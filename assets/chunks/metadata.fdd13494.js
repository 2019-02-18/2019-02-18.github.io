window.__VP_HASH_MAP__=JSON.parse("{\"00.目录页_01.前端.md\":\"kFysGWIm\",\"00.目录页_02.页面.md\":\"B3sTkOd8\",\"00.目录页_03.技术.md\":\"B1ySNC7O\",\"00.目录页_04.更多.md\":\"DEXZTK9X\",\"01.前端_25.javascript文章_01.33个非常实用的javascript一行代码.md\":\"TFEhIaui\",\"01.前端_25.javascript文章_02.new命令原理.md\":\"cTsT1xQB\",\"01.前端_25.javascript文章_03.es5面向对象.md\":\"CnsqjJh7\",\"01.前端_25.javascript文章_04.es6面向对象.md\":\"D8Z9eFs3\",\"01.前端_25.javascript文章_06.多种数组去重性能对比.md\":\"CffpZM8M\",\"01.前端_25.javascript文章_07.js随机打乱数组.md\":\"BuyqZCZD\",\"01.前端_25.javascript文章_08.判断是否为移动端浏览器.md\":\"DgArdC07\",\"01.前端_25.javascript文章_09.将一维数组按指定长度转为二维数组.md\":\"N3cnXyfF\",\"01.前端_25.javascript文章_10.防抖与节流函数.md\":\"YCi6ZE4q\",\"01.前端_25.javascript文章_11.js获取和修改url参数.md\":\"D7V9AqwO\",\"01.前端_25.javascript文章_1110.三级目录_00.四级文件.md\":\"DpFVxa2f\",\"01.前端_25.javascript文章_12.比typeof运算符更准确的类型判断.md\":\"bL_vIwgE\",\"01.前端_25.javascript文章_13.javascript常用类型数值比较图.md\":\"BW_8bAHa\",\"01.前端_25.javascript文章_14.js获取当前url_域名_端口号.md\":\"C2gTbkie\",\"01.前端_25.javascript文章_15.js实现深度优先遍历和广度优先遍历.md\":\"DeEsU_RH\",\"01.前端_40.学习笔记_00.《javascript教程》笔记.md\":\"LKU13E_g\",\"01.前端_40.学习笔记_05.《javascript高级程序设计》笔记.md\":\"DII20bZS\",\"01.前端_40.学习笔记_10.《es6 教程》笔记.md\":\"CAWgdJfS\",\"01.前端_40.学习笔记_20.《vue》笔记.md\":\"DB4JMxuO\",\"01.前端_40.学习笔记_33.《git》学习笔记.md\":\"yzi_Lee3\",\"01.前端_40.学习笔记_35.typescript笔记.md\":\"Du4-xAMc\",\"01.前端_40.学习笔记_40.小程序笔记.md\":\"BM-njk4e\",\"01.前端_40.学习笔记_50.js设计模式总结笔记.md\":\"CzAd-5Ss\",\"01.前端_40.学习笔记_60.《electron》笔记.md\":\"CVUPwNzF\",\"02.页面_10.html_10.常用meta整理.md\":\"D0CYTKjC\",\"02.页面_20.css_00.css教程和技巧收藏.md\":\"x_99B3td\",\"02.页面_20.css_01.flex布局语法.md\":\"DzLYvt2Z\",\"02.页面_20.css_02.flex布局案例-基础.md\":\"DK6D6dq3\",\"02.页面_20.css_03.flex布局案例-骰子.md\":\"D0pspLzu\",\"02.页面_20.css_04.flex布局案例-圣杯布局.md\":\"BfTPwcjn\",\"02.页面_20.css_05.flex布局案例-网格布局.md\":\"scVb0_qw\",\"02.页面_20.css_06.flex布局案例-输入框布局.md\":\"CF6DKbKy\",\"02.页面_20.css_07.css3之transition过渡.md\":\"BXM5wV9x\",\"02.页面_20.css_08.css3之animation动画.md\":\"C48Ew-Om\",\"02.页面_20.css_09.「布局技巧」图片未加载前自动撑开元素高度.md\":\"D1_yhTxN\",\"02.页面_20.css_10.文字在一行或多行时超出显示省略号.md\":\"-LzESiqM\",\"02.页面_20.css_11.从box-sizing属性入手，了解盒子模型.md\":\"BbTjCKBP\",\"02.页面_20.css_12.水平垂直居中的几种方式-案例.md\":\"BIoZJarU\",\"02.页面_20.css_13.如何根据系统主题自动响应css深色模式.md\":\"D4GVjuQM\",\"02.页面_20.css_14.css-function汇总.md\":\"J4Uxp2Iv\",\"02.页面_20.css_15.css给table的tbody添加滚动条.md\":\"DoKYWYm5\",\"02.页面_20.css_16.css calc()使用.md\":\"CGadXOHF\",\"03.技术_01.技术文档_01.git使用手册.md\":\"DqduW_Om\",\"03.技术_01.技术文档_02.markdown使用教程.md\":\"DUWY7T4K\",\"03.技术_01.技术文档_03.npm常用命令.md\":\"DPgDFrh0\",\"03.技术_01.技术文档_10.npm packagejson属性详解.md\":\"Dm5BRNhW\",\"03.技术_01.技术文档_15.yaml语言教程.md\":\"BAcb0N-_\",\"03.技术_01.技术文档_20.git修改分支名.md\":\"Cou6CIgi\",\"03.技术_02.nodejs_01.nodejs递归读取所有文件.md\":\"BPUlMI8i\",\"03.技术_03.博客搭建_01.解决百度无法收录搭建在github上的个人博客的问题.md\":\"BY-W88hP\",\"03.技术_03.博客搭建_02.使用gitalk实现静态博客无后台评论系统.md\":\"P7dC352u\",\"03.技术_03.博客搭建_03.github _ jsdelivr _ tinypng_ picgo 打造稳定快速、高效免费图床.md\":\"CXVzOPgg\",\"03.技术_03.博客搭建_10.vdoing主题效果图.md\":\"BVfIK1IP\",\"04.更多_01.学习_00.费曼学习法.md\":\"CCg08H2x\",\"04.更多_01.学习_03.提高记忆的技巧.md\":\"Bkska9IS\",\"04.更多_01.学习_10.搜索引擎使用技巧.md\":\"FeJgYexG\",\"04.更多_03.面试_01.面试问题集锦.md\":\"DBcUM1hA\",\"04.更多_05.ai随笔_01.当珍妮机学会了写代码.md\":\"CyjUE6iF\",\"04.更多_99.友情链接.md\":\"Dq-NcnUx\",\"05.关于_01.关于.md\":\"ChPCqBHY\",\"@pages_archivespage.md\":\"zTaC-XNi\",\"@pages_categoriespage.md\":\"ARsEmJzq\",\"@pages_tagspage.md\":\"DGwl8BZA\",\"index.md\":\"DAUeJbUL\",\"《electron》笔记_01.electron记录.md\":\"CC2czwc9\",\"《electron》笔记_02.electron下使用puppeteer模拟用户操作_数据获取.md\":\"Bfw06oSn\",\"《es6 教程》笔记_01.ecmascript 6 简介.md\":\"Dj9a0ZYM\",\"《es6 教程》笔记_02.let 和 const 命令.md\":\"CRUCi2Sc\",\"《es6 教程》笔记_03.变量的解构赋值.md\":\"D8YuVeSI\",\"《es6 教程》笔记_04.字符串的扩展.md\":\"D6X1izpk\",\"《es6 教程》笔记_05.字符串的新增方法.md\":\"BP_02PR8\",\"《es6 教程》笔记_06.正则的扩展.md\":\"_cXINDVT\",\"《es6 教程》笔记_07.数值的扩展.md\":\"CQ63LfPB\",\"《es6 教程》笔记_08.函数的扩展.md\":\"yp7XTogt\",\"《es6 教程》笔记_09.数组的扩展.md\":\"wPLrV_YA\",\"《es6 教程》笔记_10.对象的扩展.md\":\"CmjyBUQE\",\"《es6 教程》笔记_11.对象的新增方法.md\":\"CISVIvcF\",\"《es6 教程》笔记_12.symbol.md\":\"HA_1LTUy\",\"《es6 教程》笔记_13.set 和 map 数据结构.md\":\"BN4QW7Uk\",\"《es6 教程》笔记_14.proxy.md\":\"Bwwq-dWT\",\"《es6 教程》笔记_15.reflect.md\":\"BCnSntE-\",\"《es6 教程》笔记_16.promise 对象.md\":\"BYzUCV7c\",\"《es6 教程》笔记_17.iterator 和 for-of 循环.md\":\"Bx9tJfjg\",\"《es6 教程》笔记_18.generator 函数的语法.md\":\"DHPyJEIw\",\"《es6 教程》笔记_19.generator 函数的异步应用.md\":\"BkM71aOK\",\"《es6 教程》笔记_20.async 函数.md\":\"BI_1vPKd\",\"《es6 教程》笔记_21.class 的基本语法.md\":\"B4B_TYHW\",\"《es6 教程》笔记_22.class 的继承.md\":\"CYjckBzA\",\"《es6 教程》笔记_23.module 的语法.md\":\"DeW_xkti\",\"《es6 教程》笔记_24.module 的加载实现.md\":\"Dkkes5KL\",\"《es6 教程》笔记_25.编程风格.md\":\"B6_xDeKn\",\"《es6 教程》笔记_26.读懂 ecmascript 规格.md\":\"Dx5Hv8na\",\"《es6 教程》笔记_27.异步遍历器.md\":\"B1I4A--Z\",\"《es6 教程》笔记_28.arraybuffer.md\":\"D0l_94gT\",\"《es6 教程》笔记_29.最新提案.md\":\"rbyBf212\",\"《es6 教程》笔记_30.装饰器.md\":\"CGuebGOr\",\"《es6 教程》笔记_31.函数式编程.md\":\"D0FnQ_sC\",\"《es6 教程》笔记_32.mixin.md\":\"CG0Sxpiz\",\"《es6 教程》笔记_33.simd.md\":\"BqAz0z4s\",\"《es6 教程》笔记_34.参考链接.md\":\"C0AF3eD0\",\"《es6 教程》笔记_35.了解es6中的map和set.md\":\"CNyf6p2n\",\"《git》学习笔记_10.手册_00.常用git命令清单.md\":\"DMUvTmOS\",\"《git》学习笔记_10.手册_01.git变基合并.md\":\"CNEKiGNv\",\"《git》学习笔记_20.文档笔记_10.git基础与命令.md\":\"BtNOEKkp\",\"《git》学习笔记_20.文档笔记_100.git工具-重写历史.md\":\"Pw9ldldP\",\"《git》学习笔记_20.文档笔记_110.git工具-重置揭密.md\":\"DwTqh7_n\",\"《git》学习笔记_20.文档笔记_20.git分支-分支原理.md\":\"BFnfTMAC\",\"《git》学习笔记_20.文档笔记_30.git分支的新建与合并-分支操作.md\":\"B6cv43tR\",\"《git》学习笔记_20.文档笔记_40.git分支管理-查看分支.md\":\"m7Jl0dYX\",\"《git》学习笔记_20.文档笔记_50.git分支开发工作流.md\":\"mHNdu7Ok\",\"《git》学习笔记_20.文档笔记_60.git分支-远程分支.md\":\"D0-rJT6Q\",\"《git》学习笔记_20.文档笔记_70.git分支-变基.md\":\"OfdHAMnj\",\"《git》学习笔记_20.文档笔记_80.git工具-查看修订版本.md\":\"rw9iYJCj\",\"《git》学习笔记_20.文档笔记_90.git工具-交互式暂存.md\":\"D-Wc4yBS\",\"《git》学习笔记_git常用命令速查表.md\":\"CHP9Ex9f\",\"《javascript教程》笔记_01.基础.md\":\"BO6QS37g\",\"《javascript教程》笔记_02.内置对象.md\":\"BxFgsrlA\",\"《javascript教程》笔记_03.面向对象.md\":\"B2uy2HA2\",\"《javascript教程》笔记_04.异步操作.md\":\"Belj3UT4\",\"《javascript教程》笔记_05.dom.md\":\"BbEX1dkJ\",\"《javascript教程》笔记_06.事件.md\":\"BrHt0bVF\",\"《javascript教程》笔记_07.浏览器模型.md\":\"DPjlNZES\",\"《javascript教程》笔记_08.事件循环(evenloop).md\":\"BVmN37Qm\",\"《javascript教程》笔记_09.js 使用postmessage iframe跨域通信.md\":\"CeUF2e47\",\"《javascript教程》笔记_10.js中的？.和？？区别.md\":\"CE6bZbam\",\"《javascript教程》笔记_11._import_、_require_、_export_、_module.exports_ 的区别和使用详解.md\":\"Cg3J0GEW\",\"《javascript教程》笔记_12.console实用调试方法.md\":\"BVqr2ooN\",\"《javascript教程》笔记_13.js继承.md\":\"BHxdTBDL\",\"《javascript教程》笔记_14.js实现扫码登录.md\":\"CcYRFoIh\",\"《uniapp》笔记_使用uniapp对接蓝牙设备.md\":\"DC_7XIiF\",\"《vue》笔记_01.基础_00.mvvm模式.md\":\"CE8crOSg\",\"《vue》笔记_01.基础_10.生命周期.md\":\"yY2CGrtC\",\"《vue》笔记_01.基础_20.计算属性 vs 方法 vs 侦听属性.md\":\"N54kZs60\",\"《vue》笔记_01.基础_30.v-if vs v-show.md\":\"BkhUFh4g\",\"《vue》笔记_01.基础_35.列表渲染之数组、对象更新检测.md\":\"BYYZ_xvY\",\"《vue》笔记_02.组件_36.使用组件的细节点.md\":\"BusN5G9L\",\"《vue》笔记_02.组件_40.父组件给子组件传值.md\":\"D6PLI-IO\",\"《vue》笔记_02.组件_50.子组件派发事件和值给父组件.md\":\"3D8SC6-O\",\"《vue》笔记_02.组件_52.prop 验证 与 非 prop 的 attribute.md\":\"CEx50usW\",\"《vue》笔记_02.组件_55.自定义事件.md\":\"CtQ1WwkP\",\"《vue》笔记_02.组件_60.兄弟组件传值.md\":\"Cf5caZZz\",\"《vue》笔记_02.组件_65.非父子组件传值.md\":\"B453jzWa\",\"《vue》笔记_02.组件_70.父组件调用子组件方法并传入值.md\":\"DWbcO3Zb\",\"《vue》笔记_02.组件_75.插槽slot.md\":\"ByTPA6Du\",\"《vue》笔记_02.组件_80.动态组件与 v-once 指令.md\":\"BB0Zq3M_\",\"《vue》笔记_02.组件_90.vue父子组件的生命周期顺序.md\":\"mQKsDj2n\",\"《vue》笔记_03.过渡_动画_110.transition过渡_动画.md\":\"_XfTrRR5\",\"《vue》笔记_03.过渡_动画_112.使用animate库.md\":\"Dx3g9b9O\",\"《vue》笔记_03.过渡_动画_120.transition-group列表过渡.md\":\"CXECHp0P\",\"《vue》笔记_04.可复用性_组合_01.mixin混入.md\":\"C36VerL2\",\"《vue》笔记_05.工具_10.vue cli v3 创建项目使用记录.md\":\"C6AJZRwM\",\"《vue》笔记_06.规模化_100.vuex操作相关.md\":\"DFejrXym\",\"《vue》笔记_06.规模化_140.路由懒加载.md\":\"BzXkqWyp\",\"《vue》笔记_10.vuex_01.vuex.md\":\"Bchh0J4T\",\"《vue》笔记_99.其他_79.vue中编辑word文档以及预览word .md\":\"xw-nFzic\",\"《vue》笔记_99.其他_80.vue中的防抖函数封装和使用.md\":\"CBF8Tnti\",\"《vue》笔记_99.其他_90.操作本地缓存.md\":\"CTrLyP_9\",\"《vue》笔记_99.其他_91.vue2与vue3生命周期对照表.md\":\"BuUt6vik\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"zh-CN\",\"dir\":\"ltr\",\"title\":\"博客\",\"description\":\"web前端技术博客,专注web前端学习与总结。JavaScript,js,ES6,vue,css3,html5,git,github等技术文章。\",\"base\":\"/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"teekHome\":{\"enabled\":true,\"bannerConfig\":{\"enabled\":true,\"bgUrl\":\"/img/bg.jpeg\",\"title\":\"刘志伟\",\"titleStyle\":{\"fontSize\":\"4rem\",\"fontWeight\":\"800\",\"letterSpacing\":\"0.05em\",\"textShadow\":\"0 4px 20px rgba(0, 0, 0, 0.3)\"},\"description\":\"Web前端技术博客，个人开发记录。\",\"descStyle\":{\"fontSize\":\"1.4rem\",\"opacity\":\"0.9\",\"textShadow\":\"0 2px 10px rgba(0, 0, 0, 0.2)\"}},\"postListStyle\":\"card\"},\"blogger\":{\"avatar\":\"https://pic.imgdb.cn/item/64fc2030661c6c8e54ee27af.jpg\",\"name\":\"刘志伟\",\"slogan\":\"Web前端技术博客，个人开发记录。\"},\"docAnalysis\":{\"createTime\":true,\"wordCount\":true,\"readingTime\":true,\"author\":{\"name\":\"刘志伟\",\"url\":\"https://github.com/2019-02-18\"}},\"footerInfo\":{\"createYear\":2023,\"copyrightInfo\":\"liuzhiwei | <a href=\\\"https://github.com/2019-02-18/newBlog/blob/master/LICENSE\\\" target=\\\"_blank\\\">MIT License</a>\"},\"themeEnhance\":{\"enabled\":false},\"friendLink\":{},\"social\":[{\"icon\":\"email\",\"name\":\"发邮件\",\"url\":\"mailto:1912939243@qq.com\"},{\"icon\":\"github\",\"name\":\"GitHub\",\"url\":\"https://github.com/2019-02-18\"}],\"topArticle\":{\"enabled\":true},\"category\":{\"enabled\":true},\"tag\":{\"enabled\":true},\"archive\":{\"enabled\":true},\"logo\":\"/img/logo.png\",\"nav\":[{\"text\":\"首页\",\"link\":\"/\"},{\"text\":\"前端\",\"items\":[{\"text\":\"前端文章\",\"items\":[{\"text\":\"JavaScript\",\"link\":\"/pages/8143cc480faf9a11/\",\"activeMatch\":\"01.前端/25.JavaScript文章/02.new命令原理\"}],\"activeMatch\":\"01.前端/25.JavaScript文章\"},{\"text\":\"学习笔记\",\"items\":[{\"text\":\"《JavaScript教程》\",\"link\":\"/note/javascript/\",\"activeMatch\":\"01.前端/40.学习笔记/00.《JavaScript教程》笔记\"},{\"text\":\"《JavaScript高级程序设计》\",\"link\":\"/note/js/\",\"activeMatch\":\"01.前端/40.学习笔记/05.《JavaScript高级程序设计》笔记\"},{\"text\":\"《ES6 教程》\",\"link\":\"/note/es6/\",\"activeMatch\":\"01.前端/40.学习笔记/10.《ES6 教程》笔记\"},{\"text\":\"《Vue》\",\"link\":\"/note/vue/\",\"activeMatch\":\"01.前端/40.学习笔记/20.《Vue》笔记\"},{\"text\":\"《Git》\",\"link\":\"/note/git/\",\"activeMatch\":\"01.前端/40.学习笔记/33.《Git》学习笔记\"}],\"activeMatch\":\"01.前端/40.学习笔记\"}]},{\"text\":\"页面\",\"items\":[{\"text\":\"HTML\",\"link\":\"/pages/8309a5b876fc95e3/\",\"activeMatch\":\"02.页面/10.HTML/10.常用meta整理\"},{\"text\":\"CSS\",\"link\":\"/pages/0a83b083bdf257cb/\",\"activeMatch\":\"02.页面/20.CSS/01.flex布局语法\"}],\"activeMatch\":\"02.页面/20.CSS\"},{\"text\":\"技术\",\"items\":[{\"text\":\"技术文档\",\"link\":\"/pages/9a7ee40fc232253e/\",\"activeMatch\":\"03.技术/01.技术文档/01.Git使用手册\"},{\"text\":\"GitHub技巧\",\"link\":\"/pages/4c778760be26d8b3/\"},{\"text\":\"Nodejs\",\"link\":\"/pages/117708e0af7f0bd9/\",\"activeMatch\":\"03.技术/02.Nodejs/01.nodejs递归读取所有文件\"}],\"activeMatch\":\"03.技术/02.Nodejs\"},{\"text\":\"更多\",\"items\":[{\"text\":\"学习\",\"link\":\"/pages/f2a556/\",\"activeMatch\":\"04.更多/01.学习/00.费曼学习法\"},{\"text\":\"AI随笔\",\"link\":\"/pages/ai-coding-revolution/\",\"activeMatch\":\"04.更多/05.AI随笔/01.当珍妮机学会了写代码\"},{\"text\":\"面试\",\"link\":\"/pages/aea6571b7a8bae86/\",\"activeMatch\":\"04.更多/03.面试/01.面试问题集锦\"},{\"text\":\"实用技巧\",\"link\":\"/pages/baaa02/\"}],\"activeMatch\":\"04.更多/03.面试\"},{\"text\":\"关于\",\"link\":\"/about/\",\"activeMatch\":\"05.关于/01.关于\"},{\"text\":\"索引\",\"items\":[{\"text\":\"分类\",\"link\":\"/categories/\",\"activeMatch\":\"@pages/categoriesPage\"},{\"text\":\"标签\",\"link\":\"/tags/\",\"activeMatch\":\"@pages/tagsPage\"},{\"text\":\"归档\",\"link\":\"/archives/\",\"activeMatch\":\"@pages/archivesPage\"}],\"activeMatch\":\"@pages\"}],\"sidebar\":{\"0\":\"a\",\"1\":\"u\",\"2\":\"t\",\"3\":\"o\",\"/01.前端/\":[{\"text\":\"\",\"items\":[{\"text\":\"JavaScript文章\",\"items\":[{\"text\":\"33个非常实用的JavaScript一行代码\",\"link\":\"/01.前端/25.JavaScript文章/01.33个非常实用的JavaScript一行代码\"},{\"text\":\"new命令原理\",\"link\":\"/01.前端/25.JavaScript文章/02.new命令原理\"},{\"text\":\"ES5面向对象\",\"link\":\"/01.前端/25.JavaScript文章/03.ES5面向对象\"},{\"text\":\"ES6面向对象\",\"link\":\"/01.前端/25.JavaScript文章/04.ES6面向对象\"},{\"text\":\"多种数组去重性能对比\",\"link\":\"/01.前端/25.JavaScript文章/06.多种数组去重性能对比\"},{\"text\":\"JS随机打乱数组\",\"link\":\"/01.前端/25.JavaScript文章/07.js随机打乱数组\"},{\"text\":\"判断是否为移动端浏览器\",\"link\":\"/01.前端/25.JavaScript文章/08.判断是否为移动端浏览器\"},{\"text\":\"将一维数组按指定长度转为二维数组\",\"link\":\"/01.前端/25.JavaScript文章/09.将一维数组按指定长度转为二维数组\"},{\"text\":\"防抖与节流函数\",\"link\":\"/01.前端/25.JavaScript文章/10.防抖与节流函数\"},{\"text\":\"JS获取和修改url参数\",\"link\":\"/01.前端/25.JavaScript文章/11.JS获取和修改url参数\"},{\"text\":\"比typeof运算符更准确的类型判断\",\"link\":\"/01.前端/25.JavaScript文章/12.比typeof运算符更准确的类型判断\"},{\"text\":\"javascript常用类型数值比较图\",\"link\":\"/01.前端/25.JavaScript文章/13.javascript常用类型数值比较图\"},{\"text\":\"js获取当前URL,域名,端口号\",\"link\":\"/01.前端/25.JavaScript文章/14.js获取当前URL,域名,端口号\"},{\"text\":\"js实现深度优先遍历和广度优先遍历\",\"link\":\"/01.前端/25.JavaScript文章/15.js实现深度优先遍历和广度优先遍历\"},{\"text\":\"三级目录\",\"items\":[{\"text\":\"四级文件(测试)\",\"link\":\"/01.前端/25.JavaScript文章/1110.三级目录/00.四级文件\"}]}]},{\"text\":\"学习笔记\",\"items\":[{\"text\":\"《JavaScript教程》笔记\",\"link\":\"/01.前端/40.学习笔记/00.《JavaScript教程》笔记\"},{\"text\":\"《JavaScript高级程序设计》笔记\",\"link\":\"/01.前端/40.学习笔记/05.《JavaScript高级程序设计》笔记\"},{\"text\":\"《ES6 教程》笔记\",\"link\":\"/01.前端/40.学习笔记/10.《ES6 教程》笔记\"},{\"text\":\"《Vue》笔记\",\"link\":\"/01.前端/40.学习笔记/20.《Vue》笔记\"},{\"text\":\"《Git》学习笔记\",\"link\":\"/01.前端/40.学习笔记/33.《Git》学习笔记\"},{\"text\":\"TypeScript笔记\",\"link\":\"/01.前端/40.学习笔记/35.TypeScript笔记\"},{\"text\":\"小程序笔记\",\"link\":\"/01.前端/40.学习笔记/40.小程序笔记\"},{\"text\":\"JS设计模式总结笔记\",\"link\":\"/01.前端/40.学习笔记/50.JS设计模式总结笔记\"},{\"text\":\"《Electron》笔记\",\"link\":\"/01.前端/40.学习笔记/60.《Electron》笔记\"}]}]}],\"/02.页面/\":[{\"text\":\"\",\"items\":[{\"text\":\"HTML\",\"items\":[{\"text\":\"常用meta整理\",\"link\":\"/02.页面/10.HTML/10.常用meta整理\"}]},{\"text\":\"CSS\",\"items\":[{\"text\":\"CSS教程和技巧收藏\",\"link\":\"/02.页面/20.CSS/00.CSS教程和技巧收藏\"},{\"text\":\"flex布局语法\",\"link\":\"/02.页面/20.CSS/01.flex布局语法\"},{\"text\":\"flex布局案例-基础\",\"link\":\"/02.页面/20.CSS/02.flex布局案例-基础\"},{\"text\":\"flex布局案例-骰子\",\"link\":\"/02.页面/20.CSS/03.flex布局案例-骰子\"},{\"text\":\"flex布局案例-圣杯布局\",\"link\":\"/02.页面/20.CSS/04.flex布局案例-圣杯布局\"},{\"text\":\"flex布局案例-网格布局\",\"link\":\"/02.页面/20.CSS/05.flex布局案例-网格布局\"},{\"text\":\"flex布局案例-输入框布局\",\"link\":\"/02.页面/20.CSS/06.flex布局案例-输入框布局\"},{\"text\":\"CSS3之transition过渡\",\"link\":\"/02.页面/20.CSS/07.CSS3之transition过渡\"},{\"text\":\"CSS3之animation动画\",\"link\":\"/02.页面/20.CSS/08.CSS3之animation动画\"},{\"text\":\"「布局技巧」图片未加载前自动撑开元素高度\",\"link\":\"/02.页面/20.CSS/09.「布局技巧」图片未加载前自动撑开元素高度\"},{\"text\":\"文字在一行或多行时超出显示省略号\",\"link\":\"/02.页面/20.CSS/10.文字在一行或多行时超出显示省略号\"},{\"text\":\"从box-sizing属性入手，了解盒子模型\",\"link\":\"/02.页面/20.CSS/11.从box-sizing属性入手，了解盒子模型\"},{\"text\":\"水平垂直居中的几种方式-案例\",\"link\":\"/02.页面/20.CSS/12.水平垂直居中的几种方式-案例\"},{\"text\":\"如何根据系统主题自动响应CSS深色模式\",\"link\":\"/02.页面/20.CSS/13.如何根据系统主题自动响应CSS深色模式\"},{\"text\":\"CSS-function汇总\",\"link\":\"/02.页面/20.CSS/14.CSS-function汇总\"},{\"text\":\"CSS给table的tbody添加滚动条\",\"link\":\"/02.页面/20.CSS/15.CSS给table的tbody添加滚动条\"},{\"text\":\"css calc()使用\",\"link\":\"/02.页面/20.CSS/16.css calc()使用\"}]}]}],\"/03.技术/\":[{\"text\":\"\",\"items\":[{\"text\":\"技术文档\",\"items\":[{\"text\":\"Git使用手册\",\"link\":\"/03.技术/01.技术文档/01.Git使用手册\"},{\"text\":\"Markdown使用教程\",\"link\":\"/03.技术/01.技术文档/02.Markdown使用教程\"},{\"text\":\"npm常用命令\",\"link\":\"/03.技术/01.技术文档/03.npm常用命令\"},{\"text\":\"npm packageJson属性详解\",\"link\":\"/03.技术/01.技术文档/10.npm packageJson属性详解\"},{\"text\":\"yaml语言教程\",\"link\":\"/03.技术/01.技术文档/15.yaml语言教程\"},{\"text\":\"Git修改分支名\",\"link\":\"/03.技术/01.技术文档/20.Git修改分支名\"}]},{\"text\":\"Nodejs\",\"items\":[{\"text\":\"nodejs递归读取所有文件\",\"link\":\"/03.技术/02.Nodejs/01.nodejs递归读取所有文件\"}]},{\"text\":\"博客搭建\",\"items\":[{\"text\":\"解决百度无法收录搭建在GitHub上的个人博客的问题\",\"link\":\"/03.技术/03.博客搭建/01.解决百度无法收录搭建在GitHub上的个人博客的问题\"},{\"text\":\"使用Gitalk实现静态博客无后台评论系统\",\"link\":\"/03.技术/03.博客搭建/02.使用Gitalk实现静态博客无后台评论系统\"},{\"text\":\"GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床\",\"link\":\"/03.技术/03.博客搭建/03.GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床\"},{\"text\":\"vdoing主题效果图\",\"link\":\"/03.技术/03.博客搭建/10.vdoing主题效果图\"}]}]}],\"/04.更多/\":[{\"text\":\"\",\"items\":[{\"text\":\"学习\",\"items\":[{\"text\":\"费曼学习法\",\"link\":\"/04.更多/01.学习/00.费曼学习法\"},{\"text\":\"提高记忆的技巧\",\"link\":\"/04.更多/01.学习/03.提高记忆的技巧\"},{\"text\":\"搜索引擎使用技巧\",\"link\":\"/04.更多/01.学习/10.搜索引擎使用技巧\"}]},{\"text\":\"面试\",\"items\":[{\"text\":\"面试问题集锦\",\"link\":\"/04.更多/03.面试/01.面试问题集锦\"}]},{\"text\":\"AI随笔\",\"items\":[{\"text\":\"当珍妮机学会了写代码\",\"link\":\"/04.更多/05.AI随笔/01.当珍妮机学会了写代码\"}]},{\"text\":\"实用技巧\",\"items\":[]},{\"text\":\"友情链接\",\"link\":\"/04.更多/99.友情链接\"}]}],\"/_posts/\":[{\"text\":\"\",\"items\":[{\"text\":\"随笔\",\"items\":[]}]}],\"/《Electron》笔记/\":[{\"text\":\"\",\"items\":[{\"text\":\"electron记录\",\"link\":\"/《Electron》笔记/01.electron记录\"},{\"text\":\"electron下使用puppeteer模拟用户操作,数据获取\",\"link\":\"/《Electron》笔记/02.electron下使用puppeteer模拟用户操作,数据获取\"}]}],\"/《ES6 教程》笔记/\":[{\"text\":\"\",\"items\":[{\"text\":\"ECMAScript 6 简介\",\"link\":\"/《ES6 教程》笔记/01.ECMAScript 6 简介\"},{\"text\":\"let 和 const 命令\",\"link\":\"/《ES6 教程》笔记/02.let 和 const 命令\"},{\"text\":\"变量的解构赋值\",\"link\":\"/《ES6 教程》笔记/03.变量的解构赋值\"},{\"text\":\"字符串的扩展\",\"link\":\"/《ES6 教程》笔记/04.字符串的扩展\"},{\"text\":\"字符串的新增方法\",\"link\":\"/《ES6 教程》笔记/05.字符串的新增方法\"},{\"text\":\"正则的扩展\",\"link\":\"/《ES6 教程》笔记/06.正则的扩展\"},{\"text\":\"数值的扩展\",\"link\":\"/《ES6 教程》笔记/07.数值的扩展\"},{\"text\":\"函数的扩展\",\"link\":\"/《ES6 教程》笔记/08.函数的扩展\"},{\"text\":\"数组的扩展\",\"link\":\"/《ES6 教程》笔记/09.数组的扩展\"},{\"text\":\"对象的扩展\",\"link\":\"/《ES6 教程》笔记/10.对象的扩展\"},{\"text\":\"对象的新增方法\",\"link\":\"/《ES6 教程》笔记/11.对象的新增方法\"},{\"text\":\"Symbol\",\"link\":\"/《ES6 教程》笔记/12.Symbol\"},{\"text\":\"Set 和 Map 数据结构\",\"link\":\"/《ES6 教程》笔记/13.Set 和 Map 数据结构\"},{\"text\":\"Proxy\",\"link\":\"/《ES6 教程》笔记/14.Proxy\"},{\"text\":\"Reflect\",\"link\":\"/《ES6 教程》笔记/15.Reflect\"},{\"text\":\"Promise 对象\",\"link\":\"/《ES6 教程》笔记/16.Promise 对象\"},{\"text\":\"Iterator 和 for-of 循环\",\"link\":\"/《ES6 教程》笔记/17.Iterator 和 for-of 循环\"},{\"text\":\"Generator 函数的语法\",\"link\":\"/《ES6 教程》笔记/18.Generator 函数的语法\"},{\"text\":\"Generator 函数的异步应用\",\"link\":\"/《ES6 教程》笔记/19.Generator 函数的异步应用\"},{\"text\":\"async 函数\",\"link\":\"/《ES6 教程》笔记/20.async 函数\"},{\"text\":\"Class 的基本语法\",\"link\":\"/《ES6 教程》笔记/21.Class 的基本语法\"},{\"text\":\"Class 的继承\",\"link\":\"/《ES6 教程》笔记/22.Class 的继承\"},{\"text\":\"Module 的语法\",\"link\":\"/《ES6 教程》笔记/23.Module 的语法\"},{\"text\":\"Module 的加载实现\",\"link\":\"/《ES6 教程》笔记/24.Module 的加载实现\"},{\"text\":\"编程风格\",\"link\":\"/《ES6 教程》笔记/25.编程风格\"},{\"text\":\"读懂 ECMAScript 规格\",\"link\":\"/《ES6 教程》笔记/26.读懂 ECMAScript 规格\"},{\"text\":\"异步遍历器\",\"link\":\"/《ES6 教程》笔记/27.异步遍历器\"},{\"text\":\"ArrayBuffer\",\"link\":\"/《ES6 教程》笔记/28.ArrayBuffer\"},{\"text\":\"最新提案\",\"link\":\"/《ES6 教程》笔记/29.最新提案\"},{\"text\":\"装饰器\",\"link\":\"/《ES6 教程》笔记/30.装饰器\"},{\"text\":\"函数式编程\",\"link\":\"/《ES6 教程》笔记/31.函数式编程\"},{\"text\":\"Mixin\",\"link\":\"/《ES6 教程》笔记/32.Mixin\"},{\"text\":\"SIMD\",\"link\":\"/《ES6 教程》笔记/33.SIMD\"},{\"text\":\"参考链接\",\"link\":\"/《ES6 教程》笔记/34.参考链接\"},{\"text\":\"了解ES6中的Map和Set\",\"link\":\"/《ES6 教程》笔记/35.了解ES6中的Map和Set\"}]}],\"/《Git》学习笔记/\":[{\"text\":\"\",\"items\":[{\"text\":\"手册\",\"items\":[{\"text\":\"常用Git命令清单\",\"link\":\"/《Git》学习笔记/10.手册/00.常用Git命令清单\"},{\"text\":\"Git变基合并\",\"link\":\"/《Git》学习笔记/10.手册/01.Git变基合并\"}]},{\"text\":\"文档笔记\",\"items\":[{\"text\":\"Git基础与命令\",\"link\":\"/《Git》学习笔记/20.文档笔记/10.Git基础与命令\"},{\"text\":\"Git分支-分支原理\",\"link\":\"/《Git》学习笔记/20.文档笔记/20.Git分支-分支原理\"},{\"text\":\"Git分支的新建与合并-分支操作\",\"link\":\"/《Git》学习笔记/20.文档笔记/30.Git分支的新建与合并-分支操作\"},{\"text\":\"Git分支管理-查看分支\",\"link\":\"/《Git》学习笔记/20.文档笔记/40.Git分支管理-查看分支\"},{\"text\":\"Git分支开发工作流\",\"link\":\"/《Git》学习笔记/20.文档笔记/50.Git分支开发工作流\"},{\"text\":\"Git分支-远程分支\",\"link\":\"/《Git》学习笔记/20.文档笔记/60.Git分支-远程分支\"},{\"text\":\"Git分支-变基\",\"link\":\"/《Git》学习笔记/20.文档笔记/70.Git分支-变基\"},{\"text\":\"Git工具-查看修订版本\",\"link\":\"/《Git》学习笔记/20.文档笔记/80.Git工具-查看修订版本\"},{\"text\":\"Git工具-交互式暂存\",\"link\":\"/《Git》学习笔记/20.文档笔记/90.Git工具-交互式暂存\"},{\"text\":\"Git工具-重写历史\",\"link\":\"/《Git》学习笔记/20.文档笔记/100.Git工具-重写历史\"},{\"text\":\"Git工具-重置揭密\",\"link\":\"/《Git》学习笔记/20.文档笔记/110.Git工具-重置揭密\"}]},{\"text\":\"Git常用命令速查表\",\"link\":\"/《Git》学习笔记/Git常用命令速查表\"}]}],\"/《JavaScript教程》笔记/\":[{\"text\":\"\",\"items\":[{\"text\":\"基础\",\"link\":\"/《JavaScript教程》笔记/01.基础\"},{\"text\":\"内置对象\",\"link\":\"/《JavaScript教程》笔记/02.内置对象\"},{\"text\":\"面向对象\",\"link\":\"/《JavaScript教程》笔记/03.面向对象\"},{\"text\":\"异步操作\",\"link\":\"/《JavaScript教程》笔记/04.异步操作\"},{\"text\":\"DOM\",\"link\":\"/《JavaScript教程》笔记/05.DOM\"},{\"text\":\"事件\",\"link\":\"/《JavaScript教程》笔记/06.事件\"},{\"text\":\"浏览器模型\",\"link\":\"/《JavaScript教程》笔记/07.浏览器模型\"},{\"text\":\"事件循环(evenloop)\",\"link\":\"/《JavaScript教程》笔记/08.事件循环(evenloop)\"},{\"text\":\"js 使用postMessage iframe跨域通信\",\"link\":\"/《JavaScript教程》笔记/09.js 使用postMessage iframe跨域通信\"},{\"text\":\"和？？区别\",\"link\":\"/《JavaScript教程》笔记/10.JS中的？.和？？区别\"},{\"text\":\"exports` 的区别和使用详解\",\"link\":\"/《JavaScript教程》笔记/11.`import`、`require`、`export`、`module.exports` 的区别和使用详解\"},{\"text\":\"console实用调试方法\",\"link\":\"/《JavaScript教程》笔记/12.console实用调试方法\"},{\"text\":\"JS继承\",\"link\":\"/《JavaScript教程》笔记/13.JS继承\"},{\"text\":\"JS实现扫码登录\",\"link\":\"/《JavaScript教程》笔记/14.JS实现扫码登录\"}]}],\"/《uniapp》笔记/\":[{\"text\":\"\",\"items\":[{\"text\":\"使用uniapp对接蓝牙设备\",\"link\":\"/《uniapp》笔记/使用uniapp对接蓝牙设备\"}]}],\"/《Vue》笔记/\":[{\"text\":\"\",\"items\":[{\"text\":\"基础\",\"items\":[{\"text\":\"MVVM模式\",\"link\":\"/《Vue》笔记/01.基础/00.MVVM模式\"},{\"text\":\"生命周期\",\"link\":\"/《Vue》笔记/01.基础/10.生命周期\"},{\"text\":\"计算属性 vs 方法 vs 侦听属性\",\"link\":\"/《Vue》笔记/01.基础/20.计算属性 vs 方法 vs 侦听属性\"},{\"text\":\"v-if vs v-show\",\"link\":\"/《Vue》笔记/01.基础/30.v-if vs v-show\"},{\"text\":\"列表渲染之数组、对象更新检测\",\"link\":\"/《Vue》笔记/01.基础/35.列表渲染之数组、对象更新检测\"}]},{\"text\":\"组件\",\"items\":[{\"text\":\"使用组件的细节点\",\"link\":\"/《Vue》笔记/02.组件/36.使用组件的细节点\"},{\"text\":\"父组件给子组件传值\",\"link\":\"/《Vue》笔记/02.组件/40.父组件给子组件传值\"},{\"text\":\"子组件派发事件和值给父组件\",\"link\":\"/《Vue》笔记/02.组件/50.子组件派发事件和值给父组件\"},{\"text\":\"Prop 验证 与 非 Prop 的 Attribute\",\"link\":\"/《Vue》笔记/02.组件/52.Prop 验证 与 非 Prop 的 Attribute\"},{\"text\":\"自定义事件\",\"link\":\"/《Vue》笔记/02.组件/55.自定义事件\"},{\"text\":\"兄弟组件传值\",\"link\":\"/《Vue》笔记/02.组件/60.兄弟组件传值\"},{\"text\":\"非父子组件传值\",\"link\":\"/《Vue》笔记/02.组件/65.非父子组件传值\"},{\"text\":\"父组件调用子组件方法并传入值\",\"link\":\"/《Vue》笔记/02.组件/70.父组件调用子组件方法并传入值\"},{\"text\":\"插槽slot\",\"link\":\"/《Vue》笔记/02.组件/75.插槽slot\"},{\"text\":\"动态组件与 v-once 指令\",\"link\":\"/《Vue》笔记/02.组件/80.动态组件与 v-once 指令\"},{\"text\":\"vue父子组件的生命周期顺序\",\"link\":\"/《Vue》笔记/02.组件/90.vue父子组件的生命周期顺序\"}]},{\"text\":\"过渡&动画\",\"items\":[{\"text\":\"transition过渡&动画\",\"link\":\"/《Vue》笔记/03.过渡&动画/110.transition过渡&动画\"},{\"text\":\"使用animate库\",\"link\":\"/《Vue》笔记/03.过渡&动画/112.使用animate库\"},{\"text\":\"transition-group列表过渡\",\"link\":\"/《Vue》笔记/03.过渡&动画/120.transition-group列表过渡\"}]},{\"text\":\"可复用性&组合\",\"items\":[{\"text\":\"Mixin混入\",\"link\":\"/《Vue》笔记/04.可复用性&组合/01.Mixin混入\"}]},{\"text\":\"工具\",\"items\":[{\"text\":\"Vue CLi v3 创建项目使用记录\",\"link\":\"/《Vue》笔记/05.工具/10.Vue CLi v3 创建项目使用记录\"}]},{\"text\":\"规模化\",\"items\":[{\"text\":\"vuex操作相关\",\"link\":\"/《Vue》笔记/06.规模化/100.vuex操作相关\"},{\"text\":\"路由懒加载\",\"link\":\"/《Vue》笔记/06.规模化/140.路由懒加载\"}]},{\"text\":\"Vuex\",\"items\":[{\"text\":\"Vuex\",\"link\":\"/《Vue》笔记/10.Vuex/01.Vuex\"}]},{\"text\":\"其他\",\"items\":[{\"text\":\"Vue中编辑word文档以及预览word\",\"link\":\"/《Vue》笔记/99.其他/79.Vue中编辑word文档以及预览word \"},{\"text\":\"Vue中的防抖函数封装和使用\",\"link\":\"/《Vue》笔记/99.其他/80.Vue中的防抖函数封装和使用\"},{\"text\":\"操作本地缓存\",\"link\":\"/《Vue》笔记/99.其他/90.操作本地缓存\"},{\"text\":\"vue2与vue3生命周期对照表\",\"link\":\"/《Vue》笔记/99.其他/91.vue2与vue3生命周期对照表\"}]}]}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/2019-02-18\"}],\"editLink\":{\"pattern\":\"https://github.com/2019-02-18/newBlog/edit/master/docs/:path\",\"text\":\"编辑此页\"},\"lastUpdated\":{\"text\":\"上次更新\"},\"outline\":{\"level\":[2,6],\"label\":\"页面导航\"},\"search\":{\"provider\":\"local\",\"options\":{\"translations\":{\"button\":{\"buttonText\":\"搜索文档\",\"buttonAriaLabel\":\"搜索文档\"},\"modal\":{\"noResultsText\":\"无法找到相关结果\",\"resetButtonTitle\":\"清除查询条件\",\"footer\":{\"selectText\":\"选择\",\"navigateText\":\"切换\"}}}}},\"permalinks\":{\"map\":{\"00.目录页/01.前端\":\"/web.html\",\"00.目录页/02.页面\":\"/ui.html\",\"00.目录页/03.技术\":\"/technology.html\",\"00.目录页/04.更多\":\"/more.html\",\"01.前端/25.JavaScript文章/01.33个非常实用的JavaScript一行代码\":\"/pages/a61298.html\",\"01.前端/25.JavaScript文章/02.new命令原理\":\"/pages/8143cc480faf9a11.html\",\"01.前端/25.JavaScript文章/03.ES5面向对象\":\"/pages/b1af5cb8996363c5.html\",\"01.前端/25.JavaScript文章/04.ES6面向对象\":\"/pages/1f4123be6f45abcd.html\",\"01.前端/25.JavaScript文章/06.多种数组去重性能对比\":\"/pages/e808fba1fa8fbab2.html\",\"01.前端/25.JavaScript文章/07.js随机打乱数组\":\"/pages/40b4db2d38ba85f2.html\",\"01.前端/25.JavaScript文章/08.判断是否为移动端浏览器\":\"/pages/40f623be692cf8bc.html\",\"01.前端/25.JavaScript文章/09.将一维数组按指定长度转为二维数组\":\"/pages/f1acb712033ac8da.html\",\"01.前端/25.JavaScript文章/10.防抖与节流函数\":\"/pages/0f6a0ac99b62ede5.html\",\"01.前端/25.JavaScript文章/11.JS获取和修改url参数\":\"/pages/7a91be2d502346ce.html\",\"01.前端/25.JavaScript文章/1110.三级目录/00.四级文件\":\"/pages/8481d1.html\",\"01.前端/25.JavaScript文章/12.比typeof运算符更准确的类型判断\":\"/pages/fd4a16d56b83c1bc.html\",\"01.前端/25.JavaScript文章/13.javascript常用类型数值比较图\":\"/pages/360851.html\",\"01.前端/25.JavaScript文章/14.js获取当前URL,域名,端口号\":\"/pages/c81259.html\",\"01.前端/25.JavaScript文章/15.js实现深度优先遍历和广度优先遍历\":\"/pages/690414.html\",\"01.前端/40.学习笔记/00.《JavaScript教程》笔记\":\"/note/javascript.html\",\"01.前端/40.学习笔记/05.《JavaScript高级程序设计》笔记\":\"/note/js.html\",\"01.前端/40.学习笔记/10.《ES6 教程》笔记\":\"/note/es6.html\",\"01.前端/40.学习笔记/20.《Vue》笔记\":\"/note/vue.html\",\"01.前端/40.学习笔记/33.《Git》学习笔记\":\"/note/git.html\",\"01.前端/40.学习笔记/35.TypeScript笔记\":\"/pages/51afd6.html\",\"01.前端/40.学习笔记/40.小程序笔记\":\"/note/wx-miniprogram.html\",\"01.前端/40.学习笔记/50.JS设计模式总结笔记\":\"/pages/4643cd.html\",\"01.前端/40.学习笔记/60.《Electron》笔记\":\"/note/electron.html\",\"02.页面/10.HTML/10.常用meta整理\":\"/pages/8309a5b876fc95e3.html\",\"02.页面/20.CSS/00.CSS教程和技巧收藏\":\"/pages/c8f128.html\",\"02.页面/20.CSS/01.flex布局语法\":\"/pages/0a83b083bdf257cb.html\",\"02.页面/20.CSS/02.flex布局案例-基础\":\"/pages/ea6db1530c42ad51.html\",\"02.页面/20.CSS/03.flex布局案例-骰子\":\"/pages/eff61bc8b4f4695d.html\",\"02.页面/20.CSS/04.flex布局案例-圣杯布局\":\"/pages/df9e7c7214fa5046.html\",\"02.页面/20.CSS/05.flex布局案例-网格布局\":\"/pages/85b5a3fe218a34b7.html\",\"02.页面/20.CSS/06.flex布局案例-输入框布局\":\"/pages/05cc577fb51c7998.html\",\"02.页面/20.CSS/07.CSS3之transition过渡\":\"/pages/02d7f59d98d87409.html\",\"02.页面/20.CSS/08.CSS3之animation动画\":\"/pages/c2c0432138f6e042.html\",\"02.页面/20.CSS/09.「布局技巧」图片未加载前自动撑开元素高度\":\"/pages/3d52574260725aea.html\",\"02.页面/20.CSS/10.文字在一行或多行时超出显示省略号\":\"/pages/42b66999cc27dc25.html\",\"02.页面/20.CSS/11.从box-sizing属性入手，了解盒子模型\":\"/pages/20a978023139589d.html\",\"02.页面/20.CSS/12.水平垂直居中的几种方式-案例\":\"/pages/cb7cb251adba4bf7.html\",\"02.页面/20.CSS/13.如何根据系统主题自动响应CSS深色模式\":\"/pages/5dde351274f1e39d.html\",\"02.页面/20.CSS/14.CSS-function汇总\":\"/pages/3da0d7.html\",\"02.页面/20.CSS/15.CSS给table的tbody添加滚动条\":\"/pages/55f894.html\",\"02.页面/20.CSS/16.css calc()使用\":\"/pages/2ecc26.html\",\"03.技术/01.技术文档/01.Git使用手册\":\"/pages/9a7ee40fc232253e.html\",\"03.技术/01.技术文档/02.Markdown使用教程\":\"/pages/ad247c4332211551.html\",\"03.技术/01.技术文档/03.npm常用命令\":\"/pages/61f2f95fd7da14fd.html\",\"03.技术/01.技术文档/10.npm packageJson属性详解\":\"/pages/dec4f3f00e71a312.html\",\"03.技术/01.技术文档/15.yaml语言教程\":\"/pages/4e8444e2d534d14f.html\",\"03.技术/01.技术文档/20.Git修改分支名\":\"/pages/922650.html\",\"03.技术/02.Nodejs/01.nodejs递归读取所有文件\":\"/pages/117708e0af7f0bd9.html\",\"03.技术/03.博客搭建/01.解决百度无法收录搭建在GitHub上的个人博客的问题\":\"/pages/41f87d890d0a02af.html\",\"03.技术/03.博客搭建/02.使用Gitalk实现静态博客无后台评论系统\":\"/pages/1da0bf9a988eafe5.html\",\"03.技术/03.博客搭建/03.GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床\":\"/pages/a5f73af5185fdf0a.html\",\"03.技术/03.博客搭建/10.vdoing主题效果图\":\"/pages/d557b9a89a215d2e.html\",\"04.更多/01.学习/00.费曼学习法\":\"/pages/f2a556.html\",\"04.更多/01.学习/03.提高记忆的技巧\":\"/pages/996822b2a2ca6e3b.html\",\"04.更多/01.学习/10.搜索引擎使用技巧\":\"/pages/ce818a.html\",\"04.更多/03.面试/01.面试问题集锦\":\"/pages/aea6571b7a8bae86.html\",\"04.更多/05.AI随笔/01.当珍妮机学会了写代码\":\"/pages/ai-coding-revolution.html\",\"04.更多/99.友情链接\":\"/pages/1bf946.html\",\"05.关于/01.关于\":\"/about.html\",\"@pages/archivesPage\":\"/archives.html\",\"@pages/categoriesPage\":\"/categories.html\",\"@pages/tagsPage\":\"/tags.html\",\"《Electron》笔记/01.electron记录\":\"/pages/8e9a16.html\",\"《Electron》笔记/02.electron下使用puppeteer模拟用户操作,数据获取\":\"/pages/56ebf1.html\",\"《ES6 教程》笔记/01.ECMAScript 6 简介\":\"/pages/f344d070a1031ef7.html\",\"《ES6 教程》笔记/02.let 和 const 命令\":\"/pages/c1edd70a6b7c7872.html\",\"《ES6 教程》笔记/03.变量的解构赋值\":\"/pages/b1ab10a62f7564da.html\",\"《ES6 教程》笔记/04.字符串的扩展\":\"/pages/ca89eca8adeba5f4.html\",\"《ES6 教程》笔记/05.字符串的新增方法\":\"/pages/a650b4a0ebfc9350.html\",\"《ES6 教程》笔记/06.正则的扩展\":\"/pages/0473261a6ab0ee8c.html\",\"《ES6 教程》笔记/07.数值的扩展\":\"/pages/5dfea9a0f2d1a392.html\",\"《ES6 教程》笔记/08.函数的扩展\":\"/pages/8ed309d668b20264.html\",\"《ES6 教程》笔记/09.数组的扩展\":\"/pages/e34009d60d8bc4b2.html\",\"《ES6 教程》笔记/10.对象的扩展\":\"/pages/b5e3e0a0ff6e9c25.html\",\"《ES6 教程》笔记/11.对象的新增方法\":\"/pages/e85e68947502cf90.html\",\"《ES6 教程》笔记/12.Symbol\":\"/pages/02c86eb2792f3262.html\",\"《ES6 教程》笔记/13.Set 和 Map 数据结构\":\"/pages/0c21dae358fca16b.html\",\"《ES6 教程》笔记/14.Proxy\":\"/pages/f56ec2ab97d60483.html\",\"《ES6 教程》笔记/15.Reflect\":\"/pages/74de3e45e4491e95.html\",\"《ES6 教程》笔记/16.Promise 对象\":\"/pages/2810ae8985e9bd52.html\",\"《ES6 教程》笔记/17.Iterator 和 for-of 循环\":\"/pages/48df907ad3570f3d.html\",\"《ES6 教程》笔记/18.Generator 函数的语法\":\"/pages/718b48ed9ce0adce.html\",\"《ES6 教程》笔记/19.Generator 函数的异步应用\":\"/pages/75af7031eb66847b.html\",\"《ES6 教程》笔记/20.async 函数\":\"/pages/3777253e65bac487.html\",\"《ES6 教程》笔记/21.Class 的基本语法\":\"/pages/e831e1593c82bbe0.html\",\"《ES6 教程》笔记/22.Class 的继承\":\"/pages/83f8c3a0cd87dd83.html\",\"《ES6 教程》笔记/23.Module 的语法\":\"/pages/efe2fb04eb8ac5fb.html\",\"《ES6 教程》笔记/24.Module 的加载实现\":\"/pages/a79ca2e64ceae213.html\",\"《ES6 教程》笔记/25.编程风格\":\"/pages/984bf549204bb266.html\",\"《ES6 教程》笔记/26.读懂 ECMAScript 规格\":\"/pages/32c35f7651d6e58e.html\",\"《ES6 教程》笔记/27.异步遍历器\":\"/pages/16121351be68691b.html\",\"《ES6 教程》笔记/28.ArrayBuffer\":\"/pages/a2ba314746bfdbdd.html\",\"《ES6 教程》笔记/29.最新提案\":\"/pages/7188882b8d65af1b.html\",\"《ES6 教程》笔记/30.装饰器\":\"/pages/e97bc1e5626b082c.html\",\"《ES6 教程》笔记/31.函数式编程\":\"/pages/1cf50330655efc69.html\",\"《ES6 教程》笔记/32.Mixin\":\"/pages/6a8e2dc558da1b39.html\",\"《ES6 教程》笔记/33.SIMD\":\"/pages/8e8f80f69b775a56.html\",\"《ES6 教程》笔记/34.参考链接\":\"/pages/ea6f3b870f6dab69.html\",\"《ES6 教程》笔记/35.了解ES6中的Map和Set\":\"/pages/bfde72.html\",\"《Git》学习笔记/10.手册/00.常用Git命令清单\":\"/pages/8292d8.html\",\"《Git》学习笔记/10.手册/01.Git变基合并\":\"/pages/c10281.html\",\"《Git》学习笔记/20.文档笔记/10.Git基础与命令\":\"/pages/635088.html\",\"《Git》学习笔记/20.文档笔记/100.Git工具-重写历史\":\"/pages/1832fe.html\",\"《Git》学习笔记/20.文档笔记/110.Git工具-重置揭密\":\"/pages/d9e9c6.html\",\"《Git》学习笔记/20.文档笔记/20.Git分支-分支原理\":\"/pages/4bef1a.html\",\"《Git》学习笔记/20.文档笔记/30.Git分支的新建与合并-分支操作\":\"/pages/ea5a8c.html\",\"《Git》学习笔记/20.文档笔记/40.Git分支管理-查看分支\":\"/pages/a399b3.html\",\"《Git》学习笔记/20.文档笔记/50.Git分支开发工作流\":\"/pages/49ee30.html\",\"《Git》学习笔记/20.文档笔记/60.Git分支-远程分支\":\"/pages/574d62.html\",\"《Git》学习笔记/20.文档笔记/70.Git分支-变基\":\"/pages/3a3247.html\",\"《Git》学习笔记/20.文档笔记/80.Git工具-查看修订版本\":\"/pages/c984d1.html\",\"《Git》学习笔记/20.文档笔记/90.Git工具-交互式暂存\":\"/pages/76d859.html\",\"《Git》学习笔记/Git常用命令速查表\":\"/pages/3aa4fd.html\",\"《JavaScript教程》笔记/01.基础\":\"/pages/0796ba76b4b55368.html\",\"《JavaScript教程》笔记/02.内置对象\":\"/pages/74d2ab3fbfeaaa68.html\",\"《JavaScript教程》笔记/03.面向对象\":\"/pages/659b5af5e2e704e0.html\",\"《JavaScript教程》笔记/04.异步操作\":\"/pages/d61b1cb4cdac1f63.html\",\"《JavaScript教程》笔记/05.DOM\":\"/pages/7d961b8030c6099e.html\",\"《JavaScript教程》笔记/06.事件\":\"/pages/10b2761db5a8e089.html\",\"《JavaScript教程》笔记/07.浏览器模型\":\"/pages/bab4930124ad2c10.html\",\"《JavaScript教程》笔记/08.事件循环(evenloop)\":\"/pages/eaf565.html\",\"《JavaScript教程》笔记/09.js 使用postMessage iframe跨域通信\":\"/pages/d67bac.html\",\"《JavaScript教程》笔记/10.JS中的？.和？？区别\":\"/pages/176ae0.html\",\"《JavaScript教程》笔记/11.`import`、`require`、`export`、`module.exports` 的区别和使用详解\":\"/pages/ff5679.html\",\"《JavaScript教程》笔记/12.console实用调试方法\":\"/pages/602ffc.html\",\"《JavaScript教程》笔记/13.JS继承\":\"/pages/b17c09.html\",\"《JavaScript教程》笔记/14.JS实现扫码登录\":\"/pages/bdbdb8.html\",\"《uniapp》笔记/使用uniapp对接蓝牙设备\":\"/pages/35c361.html\",\"《Vue》笔记/01.基础/00.MVVM模式\":\"/pages/114158caa9e96df0.html\",\"《Vue》笔记/01.基础/10.生命周期\":\"/pages/176808a1b5f843b8.html\",\"《Vue》笔记/01.基础/20.计算属性 vs 方法 vs 侦听属性\":\"/pages/351f72ecd9c41129.html\",\"《Vue》笔记/01.基础/30.v-if vs v-show\":\"/pages/73e4064340277b05.html\",\"《Vue》笔记/01.基础/35.列表渲染之数组、对象更新检测\":\"/pages/04783a6691cc9d06.html\",\"《Vue》笔记/02.组件/36.使用组件的细节点\":\"/pages/83a1ab785e7fd70c.html\",\"《Vue》笔记/02.组件/40.父组件给子组件传值\":\"/pages/07b384c2e6232e07.html\",\"《Vue》笔记/02.组件/50.子组件派发事件和值给父组件\":\"/pages/0f19a1bcac14fd41.html\",\"《Vue》笔记/02.组件/52.Prop 验证 与 非 Prop 的 Attribute\":\"/pages/a3080f60f6596eb4.html\",\"《Vue》笔记/02.组件/55.自定义事件\":\"/pages/9651417d08d1779d.html\",\"《Vue》笔记/02.组件/60.兄弟组件传值\":\"/pages/809f4582d9ca9552.html\",\"《Vue》笔记/02.组件/65.非父子组件传值\":\"/pages/d408e64f666f146d.html\",\"《Vue》笔记/02.组件/70.父组件调用子组件方法并传入值\":\"/pages/2e24dab728769e0c.html\",\"《Vue》笔记/02.组件/75.插槽slot\":\"/pages/055ecee9a4325386.html\",\"《Vue》笔记/02.组件/80.动态组件与 v-once 指令\":\"/pages/636ca33122e9a64b.html\",\"《Vue》笔记/02.组件/90.vue父子组件的生命周期顺序\":\"/pages/e6cec47efa42d7f1.html\",\"《Vue》笔记/03.过渡&动画/110.transition过渡&动画\":\"/pages/184a96b493a97078.html\",\"《Vue》笔记/03.过渡&动画/112.使用animate库\":\"/pages/3b0a20e70805fcea.html\",\"《Vue》笔记/03.过渡&动画/120.transition-group列表过渡\":\"/pages/0aa92922ace6bb5e.html\",\"《Vue》笔记/04.可复用性&组合/01.Mixin混入\":\"/pages/bd36a3c1bc3e0821.html\",\"《Vue》笔记/05.工具/10.Vue CLi v3 创建项目使用记录\":\"/pages/d00311f8174119b2.html\",\"《Vue》笔记/06.规模化/100.vuex操作相关\":\"/pages/d9d62d6ab8ff99a6.html\",\"《Vue》笔记/06.规模化/140.路由懒加载\":\"/pages/38ecac9a9b92f037.html\",\"《Vue》笔记/10.Vuex/01.Vuex\":\"/pages/b30620.html\",\"《Vue》笔记/99.其他/79.Vue中编辑word文档以及预览word \":\"/pages/1ebccd.html\",\"《Vue》笔记/99.其他/80.Vue中的防抖函数封装和使用\":\"/pages/fb08e252dfd8fdfd.html\",\"《Vue》笔记/99.其他/90.操作本地缓存\":\"/pages/30a94dbe96873b33.html\",\"《Vue》笔记/99.其他/91.vue2与vue3生命周期对照表\":\"/pages/e866b9.html\"},\"inv\":{\"/web.html\":\"00.目录页/01.前端\",\"/ui.html\":\"00.目录页/02.页面\",\"/technology.html\":\"00.目录页/03.技术\",\"/more.html\":\"00.目录页/04.更多\",\"/pages/a61298.html\":\"01.前端/25.JavaScript文章/01.33个非常实用的JavaScript一行代码\",\"/pages/8143cc480faf9a11.html\":\"01.前端/25.JavaScript文章/02.new命令原理\",\"/pages/b1af5cb8996363c5.html\":\"01.前端/25.JavaScript文章/03.ES5面向对象\",\"/pages/1f4123be6f45abcd.html\":\"01.前端/25.JavaScript文章/04.ES6面向对象\",\"/pages/e808fba1fa8fbab2.html\":\"01.前端/25.JavaScript文章/06.多种数组去重性能对比\",\"/pages/40b4db2d38ba85f2.html\":\"01.前端/25.JavaScript文章/07.js随机打乱数组\",\"/pages/40f623be692cf8bc.html\":\"01.前端/25.JavaScript文章/08.判断是否为移动端浏览器\",\"/pages/f1acb712033ac8da.html\":\"01.前端/25.JavaScript文章/09.将一维数组按指定长度转为二维数组\",\"/pages/0f6a0ac99b62ede5.html\":\"01.前端/25.JavaScript文章/10.防抖与节流函数\",\"/pages/7a91be2d502346ce.html\":\"01.前端/25.JavaScript文章/11.JS获取和修改url参数\",\"/pages/8481d1.html\":\"01.前端/25.JavaScript文章/1110.三级目录/00.四级文件\",\"/pages/fd4a16d56b83c1bc.html\":\"01.前端/25.JavaScript文章/12.比typeof运算符更准确的类型判断\",\"/pages/360851.html\":\"01.前端/25.JavaScript文章/13.javascript常用类型数值比较图\",\"/pages/c81259.html\":\"01.前端/25.JavaScript文章/14.js获取当前URL,域名,端口号\",\"/pages/690414.html\":\"01.前端/25.JavaScript文章/15.js实现深度优先遍历和广度优先遍历\",\"/note/javascript.html\":\"01.前端/40.学习笔记/00.《JavaScript教程》笔记\",\"/note/js.html\":\"01.前端/40.学习笔记/05.《JavaScript高级程序设计》笔记\",\"/note/es6.html\":\"01.前端/40.学习笔记/10.《ES6 教程》笔记\",\"/note/vue.html\":\"01.前端/40.学习笔记/20.《Vue》笔记\",\"/note/git.html\":\"01.前端/40.学习笔记/33.《Git》学习笔记\",\"/pages/51afd6.html\":\"01.前端/40.学习笔记/35.TypeScript笔记\",\"/note/wx-miniprogram.html\":\"01.前端/40.学习笔记/40.小程序笔记\",\"/pages/4643cd.html\":\"01.前端/40.学习笔记/50.JS设计模式总结笔记\",\"/note/electron.html\":\"01.前端/40.学习笔记/60.《Electron》笔记\",\"/pages/8309a5b876fc95e3.html\":\"02.页面/10.HTML/10.常用meta整理\",\"/pages/c8f128.html\":\"02.页面/20.CSS/00.CSS教程和技巧收藏\",\"/pages/0a83b083bdf257cb.html\":\"02.页面/20.CSS/01.flex布局语法\",\"/pages/ea6db1530c42ad51.html\":\"02.页面/20.CSS/02.flex布局案例-基础\",\"/pages/eff61bc8b4f4695d.html\":\"02.页面/20.CSS/03.flex布局案例-骰子\",\"/pages/df9e7c7214fa5046.html\":\"02.页面/20.CSS/04.flex布局案例-圣杯布局\",\"/pages/85b5a3fe218a34b7.html\":\"02.页面/20.CSS/05.flex布局案例-网格布局\",\"/pages/05cc577fb51c7998.html\":\"02.页面/20.CSS/06.flex布局案例-输入框布局\",\"/pages/02d7f59d98d87409.html\":\"02.页面/20.CSS/07.CSS3之transition过渡\",\"/pages/c2c0432138f6e042.html\":\"02.页面/20.CSS/08.CSS3之animation动画\",\"/pages/3d52574260725aea.html\":\"02.页面/20.CSS/09.「布局技巧」图片未加载前自动撑开元素高度\",\"/pages/42b66999cc27dc25.html\":\"02.页面/20.CSS/10.文字在一行或多行时超出显示省略号\",\"/pages/20a978023139589d.html\":\"02.页面/20.CSS/11.从box-sizing属性入手，了解盒子模型\",\"/pages/cb7cb251adba4bf7.html\":\"02.页面/20.CSS/12.水平垂直居中的几种方式-案例\",\"/pages/5dde351274f1e39d.html\":\"02.页面/20.CSS/13.如何根据系统主题自动响应CSS深色模式\",\"/pages/3da0d7.html\":\"02.页面/20.CSS/14.CSS-function汇总\",\"/pages/55f894.html\":\"02.页面/20.CSS/15.CSS给table的tbody添加滚动条\",\"/pages/2ecc26.html\":\"02.页面/20.CSS/16.css calc()使用\",\"/pages/9a7ee40fc232253e.html\":\"03.技术/01.技术文档/01.Git使用手册\",\"/pages/ad247c4332211551.html\":\"03.技术/01.技术文档/02.Markdown使用教程\",\"/pages/61f2f95fd7da14fd.html\":\"03.技术/01.技术文档/03.npm常用命令\",\"/pages/dec4f3f00e71a312.html\":\"03.技术/01.技术文档/10.npm packageJson属性详解\",\"/pages/4e8444e2d534d14f.html\":\"03.技术/01.技术文档/15.yaml语言教程\",\"/pages/922650.html\":\"03.技术/01.技术文档/20.Git修改分支名\",\"/pages/117708e0af7f0bd9.html\":\"03.技术/02.Nodejs/01.nodejs递归读取所有文件\",\"/pages/41f87d890d0a02af.html\":\"03.技术/03.博客搭建/01.解决百度无法收录搭建在GitHub上的个人博客的问题\",\"/pages/1da0bf9a988eafe5.html\":\"03.技术/03.博客搭建/02.使用Gitalk实现静态博客无后台评论系统\",\"/pages/a5f73af5185fdf0a.html\":\"03.技术/03.博客搭建/03.GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床\",\"/pages/d557b9a89a215d2e.html\":\"03.技术/03.博客搭建/10.vdoing主题效果图\",\"/pages/f2a556.html\":\"04.更多/01.学习/00.费曼学习法\",\"/pages/996822b2a2ca6e3b.html\":\"04.更多/01.学习/03.提高记忆的技巧\",\"/pages/ce818a.html\":\"04.更多/01.学习/10.搜索引擎使用技巧\",\"/pages/aea6571b7a8bae86.html\":\"04.更多/03.面试/01.面试问题集锦\",\"/pages/ai-coding-revolution.html\":\"04.更多/05.AI随笔/01.当珍妮机学会了写代码\",\"/pages/1bf946.html\":\"04.更多/99.友情链接\",\"/about.html\":\"05.关于/01.关于\",\"/archives.html\":\"@pages/archivesPage\",\"/categories.html\":\"@pages/categoriesPage\",\"/tags.html\":\"@pages/tagsPage\",\"/pages/8e9a16.html\":\"《Electron》笔记/01.electron记录\",\"/pages/56ebf1.html\":\"《Electron》笔记/02.electron下使用puppeteer模拟用户操作,数据获取\",\"/pages/f344d070a1031ef7.html\":\"《ES6 教程》笔记/01.ECMAScript 6 简介\",\"/pages/c1edd70a6b7c7872.html\":\"《ES6 教程》笔记/02.let 和 const 命令\",\"/pages/b1ab10a62f7564da.html\":\"《ES6 教程》笔记/03.变量的解构赋值\",\"/pages/ca89eca8adeba5f4.html\":\"《ES6 教程》笔记/04.字符串的扩展\",\"/pages/a650b4a0ebfc9350.html\":\"《ES6 教程》笔记/05.字符串的新增方法\",\"/pages/0473261a6ab0ee8c.html\":\"《ES6 教程》笔记/06.正则的扩展\",\"/pages/5dfea9a0f2d1a392.html\":\"《ES6 教程》笔记/07.数值的扩展\",\"/pages/8ed309d668b20264.html\":\"《ES6 教程》笔记/08.函数的扩展\",\"/pages/e34009d60d8bc4b2.html\":\"《ES6 教程》笔记/09.数组的扩展\",\"/pages/b5e3e0a0ff6e9c25.html\":\"《ES6 教程》笔记/10.对象的扩展\",\"/pages/e85e68947502cf90.html\":\"《ES6 教程》笔记/11.对象的新增方法\",\"/pages/02c86eb2792f3262.html\":\"《ES6 教程》笔记/12.Symbol\",\"/pages/0c21dae358fca16b.html\":\"《ES6 教程》笔记/13.Set 和 Map 数据结构\",\"/pages/f56ec2ab97d60483.html\":\"《ES6 教程》笔记/14.Proxy\",\"/pages/74de3e45e4491e95.html\":\"《ES6 教程》笔记/15.Reflect\",\"/pages/2810ae8985e9bd52.html\":\"《ES6 教程》笔记/16.Promise 对象\",\"/pages/48df907ad3570f3d.html\":\"《ES6 教程》笔记/17.Iterator 和 for-of 循环\",\"/pages/718b48ed9ce0adce.html\":\"《ES6 教程》笔记/18.Generator 函数的语法\",\"/pages/75af7031eb66847b.html\":\"《ES6 教程》笔记/19.Generator 函数的异步应用\",\"/pages/3777253e65bac487.html\":\"《ES6 教程》笔记/20.async 函数\",\"/pages/e831e1593c82bbe0.html\":\"《ES6 教程》笔记/21.Class 的基本语法\",\"/pages/83f8c3a0cd87dd83.html\":\"《ES6 教程》笔记/22.Class 的继承\",\"/pages/efe2fb04eb8ac5fb.html\":\"《ES6 教程》笔记/23.Module 的语法\",\"/pages/a79ca2e64ceae213.html\":\"《ES6 教程》笔记/24.Module 的加载实现\",\"/pages/984bf549204bb266.html\":\"《ES6 教程》笔记/25.编程风格\",\"/pages/32c35f7651d6e58e.html\":\"《ES6 教程》笔记/26.读懂 ECMAScript 规格\",\"/pages/16121351be68691b.html\":\"《ES6 教程》笔记/27.异步遍历器\",\"/pages/a2ba314746bfdbdd.html\":\"《ES6 教程》笔记/28.ArrayBuffer\",\"/pages/7188882b8d65af1b.html\":\"《ES6 教程》笔记/29.最新提案\",\"/pages/e97bc1e5626b082c.html\":\"《ES6 教程》笔记/30.装饰器\",\"/pages/1cf50330655efc69.html\":\"《ES6 教程》笔记/31.函数式编程\",\"/pages/6a8e2dc558da1b39.html\":\"《ES6 教程》笔记/32.Mixin\",\"/pages/8e8f80f69b775a56.html\":\"《ES6 教程》笔记/33.SIMD\",\"/pages/ea6f3b870f6dab69.html\":\"《ES6 教程》笔记/34.参考链接\",\"/pages/bfde72.html\":\"《ES6 教程》笔记/35.了解ES6中的Map和Set\",\"/pages/8292d8.html\":\"《Git》学习笔记/10.手册/00.常用Git命令清单\",\"/pages/c10281.html\":\"《Git》学习笔记/10.手册/01.Git变基合并\",\"/pages/635088.html\":\"《Git》学习笔记/20.文档笔记/10.Git基础与命令\",\"/pages/1832fe.html\":\"《Git》学习笔记/20.文档笔记/100.Git工具-重写历史\",\"/pages/d9e9c6.html\":\"《Git》学习笔记/20.文档笔记/110.Git工具-重置揭密\",\"/pages/4bef1a.html\":\"《Git》学习笔记/20.文档笔记/20.Git分支-分支原理\",\"/pages/ea5a8c.html\":\"《Git》学习笔记/20.文档笔记/30.Git分支的新建与合并-分支操作\",\"/pages/a399b3.html\":\"《Git》学习笔记/20.文档笔记/40.Git分支管理-查看分支\",\"/pages/49ee30.html\":\"《Git》学习笔记/20.文档笔记/50.Git分支开发工作流\",\"/pages/574d62.html\":\"《Git》学习笔记/20.文档笔记/60.Git分支-远程分支\",\"/pages/3a3247.html\":\"《Git》学习笔记/20.文档笔记/70.Git分支-变基\",\"/pages/c984d1.html\":\"《Git》学习笔记/20.文档笔记/80.Git工具-查看修订版本\",\"/pages/76d859.html\":\"《Git》学习笔记/20.文档笔记/90.Git工具-交互式暂存\",\"/pages/3aa4fd.html\":\"《Git》学习笔记/Git常用命令速查表\",\"/pages/0796ba76b4b55368.html\":\"《JavaScript教程》笔记/01.基础\",\"/pages/74d2ab3fbfeaaa68.html\":\"《JavaScript教程》笔记/02.内置对象\",\"/pages/659b5af5e2e704e0.html\":\"《JavaScript教程》笔记/03.面向对象\",\"/pages/d61b1cb4cdac1f63.html\":\"《JavaScript教程》笔记/04.异步操作\",\"/pages/7d961b8030c6099e.html\":\"《JavaScript教程》笔记/05.DOM\",\"/pages/10b2761db5a8e089.html\":\"《JavaScript教程》笔记/06.事件\",\"/pages/bab4930124ad2c10.html\":\"《JavaScript教程》笔记/07.浏览器模型\",\"/pages/eaf565.html\":\"《JavaScript教程》笔记/08.事件循环(evenloop)\",\"/pages/d67bac.html\":\"《JavaScript教程》笔记/09.js 使用postMessage iframe跨域通信\",\"/pages/176ae0.html\":\"《JavaScript教程》笔记/10.JS中的？.和？？区别\",\"/pages/ff5679.html\":\"《JavaScript教程》笔记/11.`import`、`require`、`export`、`module.exports` 的区别和使用详解\",\"/pages/602ffc.html\":\"《JavaScript教程》笔记/12.console实用调试方法\",\"/pages/b17c09.html\":\"《JavaScript教程》笔记/13.JS继承\",\"/pages/bdbdb8.html\":\"《JavaScript教程》笔记/14.JS实现扫码登录\",\"/pages/35c361.html\":\"《uniapp》笔记/使用uniapp对接蓝牙设备\",\"/pages/114158caa9e96df0.html\":\"《Vue》笔记/01.基础/00.MVVM模式\",\"/pages/176808a1b5f843b8.html\":\"《Vue》笔记/01.基础/10.生命周期\",\"/pages/351f72ecd9c41129.html\":\"《Vue》笔记/01.基础/20.计算属性 vs 方法 vs 侦听属性\",\"/pages/73e4064340277b05.html\":\"《Vue》笔记/01.基础/30.v-if vs v-show\",\"/pages/04783a6691cc9d06.html\":\"《Vue》笔记/01.基础/35.列表渲染之数组、对象更新检测\",\"/pages/83a1ab785e7fd70c.html\":\"《Vue》笔记/02.组件/36.使用组件的细节点\",\"/pages/07b384c2e6232e07.html\":\"《Vue》笔记/02.组件/40.父组件给子组件传值\",\"/pages/0f19a1bcac14fd41.html\":\"《Vue》笔记/02.组件/50.子组件派发事件和值给父组件\",\"/pages/a3080f60f6596eb4.html\":\"《Vue》笔记/02.组件/52.Prop 验证 与 非 Prop 的 Attribute\",\"/pages/9651417d08d1779d.html\":\"《Vue》笔记/02.组件/55.自定义事件\",\"/pages/809f4582d9ca9552.html\":\"《Vue》笔记/02.组件/60.兄弟组件传值\",\"/pages/d408e64f666f146d.html\":\"《Vue》笔记/02.组件/65.非父子组件传值\",\"/pages/2e24dab728769e0c.html\":\"《Vue》笔记/02.组件/70.父组件调用子组件方法并传入值\",\"/pages/055ecee9a4325386.html\":\"《Vue》笔记/02.组件/75.插槽slot\",\"/pages/636ca33122e9a64b.html\":\"《Vue》笔记/02.组件/80.动态组件与 v-once 指令\",\"/pages/e6cec47efa42d7f1.html\":\"《Vue》笔记/02.组件/90.vue父子组件的生命周期顺序\",\"/pages/184a96b493a97078.html\":\"《Vue》笔记/03.过渡&动画/110.transition过渡&动画\",\"/pages/3b0a20e70805fcea.html\":\"《Vue》笔记/03.过渡&动画/112.使用animate库\",\"/pages/0aa92922ace6bb5e.html\":\"《Vue》笔记/03.过渡&动画/120.transition-group列表过渡\",\"/pages/bd36a3c1bc3e0821.html\":\"《Vue》笔记/04.可复用性&组合/01.Mixin混入\",\"/pages/d00311f8174119b2.html\":\"《Vue》笔记/05.工具/10.Vue CLi v3 创建项目使用记录\",\"/pages/d9d62d6ab8ff99a6.html\":\"《Vue》笔记/06.规模化/100.vuex操作相关\",\"/pages/38ecac9a9b92f037.html\":\"《Vue》笔记/06.规模化/140.路由懒加载\",\"/pages/b30620.html\":\"《Vue》笔记/10.Vuex/01.Vuex\",\"/pages/1ebccd.html\":\"《Vue》笔记/99.其他/79.Vue中编辑word文档以及预览word \",\"/pages/fb08e252dfd8fdfd.html\":\"《Vue》笔记/99.其他/80.Vue中的防抖函数封装和使用\",\"/pages/30a94dbe96873b33.html\":\"《Vue》笔记/99.其他/90.操作本地缓存\",\"/pages/e866b9.html\":\"《Vue》笔记/99.其他/91.vue2与vue3生命周期对照表\"}},\"docAnalysisInfo\":{\"fileList\":[{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\25.JavaScript文章\\\\01.33个非常实用的JavaScript一行代码.md\",\"relativePath\":\"01.前端/25.JavaScript文章/01.33个非常实用的JavaScript一行代码.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\25.JavaScript文章\\\\02.new命令原理.md\",\"relativePath\":\"01.前端/25.JavaScript文章/02.new命令原理.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\25.JavaScript文章\\\\03.ES5面向对象.md\",\"relativePath\":\"01.前端/25.JavaScript文章/03.ES5面向对象.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\25.JavaScript文章\\\\04.ES6面向对象.md\",\"relativePath\":\"01.前端/25.JavaScript文章/04.ES6面向对象.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\25.JavaScript文章\\\\06.多种数组去重性能对比.md\",\"relativePath\":\"01.前端/25.JavaScript文章/06.多种数组去重性能对比.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\25.JavaScript文章\\\\07.js随机打乱数组.md\",\"relativePath\":\"01.前端/25.JavaScript文章/07.js随机打乱数组.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\25.JavaScript文章\\\\08.判断是否为移动端浏览器.md\",\"relativePath\":\"01.前端/25.JavaScript文章/08.判断是否为移动端浏览器.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\25.JavaScript文章\\\\09.将一维数组按指定长度转为二维数组.md\",\"relativePath\":\"01.前端/25.JavaScript文章/09.将一维数组按指定长度转为二维数组.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\25.JavaScript文章\\\\10.防抖与节流函数.md\",\"relativePath\":\"01.前端/25.JavaScript文章/10.防抖与节流函数.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\25.JavaScript文章\\\\11.JS获取和修改url参数.md\",\"relativePath\":\"01.前端/25.JavaScript文章/11.JS获取和修改url参数.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\25.JavaScript文章\\\\1110.三级目录\\\\00.四级文件.md\",\"relativePath\":\"01.前端/25.JavaScript文章/1110.三级目录/00.四级文件.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\25.JavaScript文章\\\\12.比typeof运算符更准确的类型判断.md\",\"relativePath\":\"01.前端/25.JavaScript文章/12.比typeof运算符更准确的类型判断.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\25.JavaScript文章\\\\13.javascript常用类型数值比较图.md\",\"relativePath\":\"01.前端/25.JavaScript文章/13.javascript常用类型数值比较图.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\25.JavaScript文章\\\\14.js获取当前URL,域名,端口号.md\",\"relativePath\":\"01.前端/25.JavaScript文章/14.js获取当前URL,域名,端口号.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\25.JavaScript文章\\\\15.js实现深度优先遍历和广度优先遍历.md\",\"relativePath\":\"01.前端/25.JavaScript文章/15.js实现深度优先遍历和广度优先遍历.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\40.学习笔记\\\\00.《JavaScript教程》笔记.md\",\"relativePath\":\"01.前端/40.学习笔记/00.《JavaScript教程》笔记.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\40.学习笔记\\\\05.《JavaScript高级程序设计》笔记.md\",\"relativePath\":\"01.前端/40.学习笔记/05.《JavaScript高级程序设计》笔记.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\40.学习笔记\\\\10.《ES6 教程》笔记.md\",\"relativePath\":\"01.前端/40.学习笔记/10.《ES6 教程》笔记.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\40.学习笔记\\\\20.《Vue》笔记.md\",\"relativePath\":\"01.前端/40.学习笔记/20.《Vue》笔记.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\40.学习笔记\\\\33.《Git》学习笔记.md\",\"relativePath\":\"01.前端/40.学习笔记/33.《Git》学习笔记.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\40.学习笔记\\\\35.TypeScript笔记.md\",\"relativePath\":\"01.前端/40.学习笔记/35.TypeScript笔记.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\40.学习笔记\\\\40.小程序笔记.md\",\"relativePath\":\"01.前端/40.学习笔记/40.小程序笔记.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\40.学习笔记\\\\50.JS设计模式总结笔记.md\",\"relativePath\":\"01.前端/40.学习笔记/50.JS设计模式总结笔记.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\40.学习笔记\\\\60.《Electron》笔记.md\",\"relativePath\":\"01.前端/40.学习笔记/60.《Electron》笔记.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\02.页面\\\\10.HTML\\\\10.常用meta整理.md\",\"relativePath\":\"02.页面/10.HTML/10.常用meta整理.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\02.页面\\\\20.CSS\\\\00.CSS教程和技巧收藏.md\",\"relativePath\":\"02.页面/20.CSS/00.CSS教程和技巧收藏.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\02.页面\\\\20.CSS\\\\01.flex布局语法.md\",\"relativePath\":\"02.页面/20.CSS/01.flex布局语法.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\02.页面\\\\20.CSS\\\\02.flex布局案例-基础.md\",\"relativePath\":\"02.页面/20.CSS/02.flex布局案例-基础.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\02.页面\\\\20.CSS\\\\03.flex布局案例-骰子.md\",\"relativePath\":\"02.页面/20.CSS/03.flex布局案例-骰子.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\02.页面\\\\20.CSS\\\\04.flex布局案例-圣杯布局.md\",\"relativePath\":\"02.页面/20.CSS/04.flex布局案例-圣杯布局.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\02.页面\\\\20.CSS\\\\05.flex布局案例-网格布局.md\",\"relativePath\":\"02.页面/20.CSS/05.flex布局案例-网格布局.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\02.页面\\\\20.CSS\\\\06.flex布局案例-输入框布局.md\",\"relativePath\":\"02.页面/20.CSS/06.flex布局案例-输入框布局.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\02.页面\\\\20.CSS\\\\07.CSS3之transition过渡.md\",\"relativePath\":\"02.页面/20.CSS/07.CSS3之transition过渡.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\02.页面\\\\20.CSS\\\\08.CSS3之animation动画.md\",\"relativePath\":\"02.页面/20.CSS/08.CSS3之animation动画.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\02.页面\\\\20.CSS\\\\09.「布局技巧」图片未加载前自动撑开元素高度.md\",\"relativePath\":\"02.页面/20.CSS/09.「布局技巧」图片未加载前自动撑开元素高度.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\02.页面\\\\20.CSS\\\\10.文字在一行或多行时超出显示省略号.md\",\"relativePath\":\"02.页面/20.CSS/10.文字在一行或多行时超出显示省略号.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\02.页面\\\\20.CSS\\\\11.从box-sizing属性入手，了解盒子模型.md\",\"relativePath\":\"02.页面/20.CSS/11.从box-sizing属性入手，了解盒子模型.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\02.页面\\\\20.CSS\\\\12.水平垂直居中的几种方式-案例.md\",\"relativePath\":\"02.页面/20.CSS/12.水平垂直居中的几种方式-案例.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\02.页面\\\\20.CSS\\\\13.如何根据系统主题自动响应CSS深色模式.md\",\"relativePath\":\"02.页面/20.CSS/13.如何根据系统主题自动响应CSS深色模式.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\02.页面\\\\20.CSS\\\\14.CSS-function汇总.md\",\"relativePath\":\"02.页面/20.CSS/14.CSS-function汇总.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\02.页面\\\\20.CSS\\\\15.CSS给table的tbody添加滚动条.md\",\"relativePath\":\"02.页面/20.CSS/15.CSS给table的tbody添加滚动条.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\02.页面\\\\20.CSS\\\\16.css calc()使用.md\",\"relativePath\":\"02.页面/20.CSS/16.css calc()使用.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\03.技术\\\\01.技术文档\\\\01.Git使用手册.md\",\"relativePath\":\"03.技术/01.技术文档/01.Git使用手册.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\03.技术\\\\01.技术文档\\\\02.Markdown使用教程.md\",\"relativePath\":\"03.技术/01.技术文档/02.Markdown使用教程.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\03.技术\\\\01.技术文档\\\\03.npm常用命令.md\",\"relativePath\":\"03.技术/01.技术文档/03.npm常用命令.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\03.技术\\\\01.技术文档\\\\10.npm packageJson属性详解.md\",\"relativePath\":\"03.技术/01.技术文档/10.npm packageJson属性详解.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\03.技术\\\\01.技术文档\\\\15.yaml语言教程.md\",\"relativePath\":\"03.技术/01.技术文档/15.yaml语言教程.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\03.技术\\\\01.技术文档\\\\20.Git修改分支名.md\",\"relativePath\":\"03.技术/01.技术文档/20.Git修改分支名.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\03.技术\\\\02.Nodejs\\\\01.nodejs递归读取所有文件.md\",\"relativePath\":\"03.技术/02.Nodejs/01.nodejs递归读取所有文件.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\03.技术\\\\03.博客搭建\\\\01.解决百度无法收录搭建在GitHub上的个人博客的问题.md\",\"relativePath\":\"03.技术/03.博客搭建/01.解决百度无法收录搭建在GitHub上的个人博客的问题.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\03.技术\\\\03.博客搭建\\\\02.使用Gitalk实现静态博客无后台评论系统.md\",\"relativePath\":\"03.技术/03.博客搭建/02.使用Gitalk实现静态博客无后台评论系统.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\03.技术\\\\03.博客搭建\\\\03.GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床.md\",\"relativePath\":\"03.技术/03.博客搭建/03.GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\03.技术\\\\03.博客搭建\\\\10.vdoing主题效果图.md\",\"relativePath\":\"03.技术/03.博客搭建/10.vdoing主题效果图.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\04.更多\\\\01.学习\\\\00.费曼学习法.md\",\"relativePath\":\"04.更多/01.学习/00.费曼学习法.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\04.更多\\\\01.学习\\\\03.提高记忆的技巧.md\",\"relativePath\":\"04.更多/01.学习/03.提高记忆的技巧.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\04.更多\\\\01.学习\\\\10.搜索引擎使用技巧.md\",\"relativePath\":\"04.更多/01.学习/10.搜索引擎使用技巧.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\04.更多\\\\03.面试\\\\01.面试问题集锦.md\",\"relativePath\":\"04.更多/03.面试/01.面试问题集锦.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\04.更多\\\\05.AI随笔\\\\01.当珍妮机学会了写代码.md\",\"relativePath\":\"04.更多/05.AI随笔/01.当珍妮机学会了写代码.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\04.更多\\\\99.友情链接.md\",\"relativePath\":\"04.更多/99.友情链接.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\05.关于\\\\01.关于.md\",\"relativePath\":\"05.关于/01.关于.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Electron》笔记\\\\01.electron记录.md\",\"relativePath\":\"《Electron》笔记/01.electron记录.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Electron》笔记\\\\02.electron下使用puppeteer模拟用户操作,数据获取.md\",\"relativePath\":\"《Electron》笔记/02.electron下使用puppeteer模拟用户操作,数据获取.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\01.ECMAScript 6 简介.md\",\"relativePath\":\"《ES6 教程》笔记/01.ECMAScript 6 简介.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\02.let 和 const 命令.md\",\"relativePath\":\"《ES6 教程》笔记/02.let 和 const 命令.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\03.变量的解构赋值.md\",\"relativePath\":\"《ES6 教程》笔记/03.变量的解构赋值.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\04.字符串的扩展.md\",\"relativePath\":\"《ES6 教程》笔记/04.字符串的扩展.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\05.字符串的新增方法.md\",\"relativePath\":\"《ES6 教程》笔记/05.字符串的新增方法.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\06.正则的扩展.md\",\"relativePath\":\"《ES6 教程》笔记/06.正则的扩展.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\07.数值的扩展.md\",\"relativePath\":\"《ES6 教程》笔记/07.数值的扩展.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\08.函数的扩展.md\",\"relativePath\":\"《ES6 教程》笔记/08.函数的扩展.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\09.数组的扩展.md\",\"relativePath\":\"《ES6 教程》笔记/09.数组的扩展.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\10.对象的扩展.md\",\"relativePath\":\"《ES6 教程》笔记/10.对象的扩展.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\11.对象的新增方法.md\",\"relativePath\":\"《ES6 教程》笔记/11.对象的新增方法.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\12.Symbol.md\",\"relativePath\":\"《ES6 教程》笔记/12.Symbol.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\13.Set 和 Map 数据结构.md\",\"relativePath\":\"《ES6 教程》笔记/13.Set 和 Map 数据结构.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\14.Proxy.md\",\"relativePath\":\"《ES6 教程》笔记/14.Proxy.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\15.Reflect.md\",\"relativePath\":\"《ES6 教程》笔记/15.Reflect.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\16.Promise 对象.md\",\"relativePath\":\"《ES6 教程》笔记/16.Promise 对象.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\17.Iterator 和 for-of 循环.md\",\"relativePath\":\"《ES6 教程》笔记/17.Iterator 和 for-of 循环.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\18.Generator 函数的语法.md\",\"relativePath\":\"《ES6 教程》笔记/18.Generator 函数的语法.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\19.Generator 函数的异步应用.md\",\"relativePath\":\"《ES6 教程》笔记/19.Generator 函数的异步应用.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\20.async 函数.md\",\"relativePath\":\"《ES6 教程》笔记/20.async 函数.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\21.Class 的基本语法.md\",\"relativePath\":\"《ES6 教程》笔记/21.Class 的基本语法.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\22.Class 的继承.md\",\"relativePath\":\"《ES6 教程》笔记/22.Class 的继承.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\23.Module 的语法.md\",\"relativePath\":\"《ES6 教程》笔记/23.Module 的语法.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\24.Module 的加载实现.md\",\"relativePath\":\"《ES6 教程》笔记/24.Module 的加载实现.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\25.编程风格.md\",\"relativePath\":\"《ES6 教程》笔记/25.编程风格.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\26.读懂 ECMAScript 规格.md\",\"relativePath\":\"《ES6 教程》笔记/26.读懂 ECMAScript 规格.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\27.异步遍历器.md\",\"relativePath\":\"《ES6 教程》笔记/27.异步遍历器.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\28.ArrayBuffer.md\",\"relativePath\":\"《ES6 教程》笔记/28.ArrayBuffer.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\29.最新提案.md\",\"relativePath\":\"《ES6 教程》笔记/29.最新提案.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\30.装饰器.md\",\"relativePath\":\"《ES6 教程》笔记/30.装饰器.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\31.函数式编程.md\",\"relativePath\":\"《ES6 教程》笔记/31.函数式编程.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\32.Mixin.md\",\"relativePath\":\"《ES6 教程》笔记/32.Mixin.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\33.SIMD.md\",\"relativePath\":\"《ES6 教程》笔记/33.SIMD.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\34.参考链接.md\",\"relativePath\":\"《ES6 教程》笔记/34.参考链接.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\35.了解ES6中的Map和Set.md\",\"relativePath\":\"《ES6 教程》笔记/35.了解ES6中的Map和Set.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Git》学习笔记\\\\10.手册\\\\00.常用Git命令清单.md\",\"relativePath\":\"《Git》学习笔记/10.手册/00.常用Git命令清单.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Git》学习笔记\\\\10.手册\\\\01.Git变基合并.md\",\"relativePath\":\"《Git》学习笔记/10.手册/01.Git变基合并.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Git》学习笔记\\\\20.文档笔记\\\\10.Git基础与命令.md\",\"relativePath\":\"《Git》学习笔记/20.文档笔记/10.Git基础与命令.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Git》学习笔记\\\\20.文档笔记\\\\100.Git工具-重写历史.md\",\"relativePath\":\"《Git》学习笔记/20.文档笔记/100.Git工具-重写历史.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Git》学习笔记\\\\20.文档笔记\\\\110.Git工具-重置揭密.md\",\"relativePath\":\"《Git》学习笔记/20.文档笔记/110.Git工具-重置揭密.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Git》学习笔记\\\\20.文档笔记\\\\20.Git分支-分支原理.md\",\"relativePath\":\"《Git》学习笔记/20.文档笔记/20.Git分支-分支原理.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Git》学习笔记\\\\20.文档笔记\\\\30.Git分支的新建与合并-分支操作.md\",\"relativePath\":\"《Git》学习笔记/20.文档笔记/30.Git分支的新建与合并-分支操作.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Git》学习笔记\\\\20.文档笔记\\\\40.Git分支管理-查看分支.md\",\"relativePath\":\"《Git》学习笔记/20.文档笔记/40.Git分支管理-查看分支.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Git》学习笔记\\\\20.文档笔记\\\\50.Git分支开发工作流.md\",\"relativePath\":\"《Git》学习笔记/20.文档笔记/50.Git分支开发工作流.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Git》学习笔记\\\\20.文档笔记\\\\60.Git分支-远程分支.md\",\"relativePath\":\"《Git》学习笔记/20.文档笔记/60.Git分支-远程分支.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Git》学习笔记\\\\20.文档笔记\\\\70.Git分支-变基.md\",\"relativePath\":\"《Git》学习笔记/20.文档笔记/70.Git分支-变基.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Git》学习笔记\\\\20.文档笔记\\\\80.Git工具-查看修订版本.md\",\"relativePath\":\"《Git》学习笔记/20.文档笔记/80.Git工具-查看修订版本.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Git》学习笔记\\\\20.文档笔记\\\\90.Git工具-交互式暂存.md\",\"relativePath\":\"《Git》学习笔记/20.文档笔记/90.Git工具-交互式暂存.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Git》学习笔记\\\\Git常用命令速查表.md\",\"relativePath\":\"《Git》学习笔记/Git常用命令速查表.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《JavaScript教程》笔记\\\\01.基础.md\",\"relativePath\":\"《JavaScript教程》笔记/01.基础.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《JavaScript教程》笔记\\\\02.内置对象.md\",\"relativePath\":\"《JavaScript教程》笔记/02.内置对象.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《JavaScript教程》笔记\\\\03.面向对象.md\",\"relativePath\":\"《JavaScript教程》笔记/03.面向对象.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《JavaScript教程》笔记\\\\04.异步操作.md\",\"relativePath\":\"《JavaScript教程》笔记/04.异步操作.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《JavaScript教程》笔记\\\\05.DOM.md\",\"relativePath\":\"《JavaScript教程》笔记/05.DOM.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《JavaScript教程》笔记\\\\06.事件.md\",\"relativePath\":\"《JavaScript教程》笔记/06.事件.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《JavaScript教程》笔记\\\\07.浏览器模型.md\",\"relativePath\":\"《JavaScript教程》笔记/07.浏览器模型.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《JavaScript教程》笔记\\\\08.事件循环(evenloop).md\",\"relativePath\":\"《JavaScript教程》笔记/08.事件循环(evenloop).md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《JavaScript教程》笔记\\\\09.js 使用postMessage iframe跨域通信.md\",\"relativePath\":\"《JavaScript教程》笔记/09.js 使用postMessage iframe跨域通信.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《JavaScript教程》笔记\\\\10.JS中的？.和？？区别.md\",\"relativePath\":\"《JavaScript教程》笔记/10.JS中的？.和？？区别.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《JavaScript教程》笔记\\\\11.`import`、`require`、`export`、`module.exports` 的区别和使用详解.md\",\"relativePath\":\"《JavaScript教程》笔记/11.`import`、`require`、`export`、`module.exports` 的区别和使用详解.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《JavaScript教程》笔记\\\\12.console实用调试方法.md\",\"relativePath\":\"《JavaScript教程》笔记/12.console实用调试方法.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《JavaScript教程》笔记\\\\13.JS继承.md\",\"relativePath\":\"《JavaScript教程》笔记/13.JS继承.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《JavaScript教程》笔记\\\\14.JS实现扫码登录.md\",\"relativePath\":\"《JavaScript教程》笔记/14.JS实现扫码登录.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《uniapp》笔记\\\\使用uniapp对接蓝牙设备.md\",\"relativePath\":\"《uniapp》笔记/使用uniapp对接蓝牙设备.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\01.基础\\\\00.MVVM模式.md\",\"relativePath\":\"《Vue》笔记/01.基础/00.MVVM模式.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\01.基础\\\\10.生命周期.md\",\"relativePath\":\"《Vue》笔记/01.基础/10.生命周期.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\01.基础\\\\20.计算属性 vs 方法 vs 侦听属性.md\",\"relativePath\":\"《Vue》笔记/01.基础/20.计算属性 vs 方法 vs 侦听属性.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\01.基础\\\\30.v-if vs v-show.md\",\"relativePath\":\"《Vue》笔记/01.基础/30.v-if vs v-show.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\01.基础\\\\35.列表渲染之数组、对象更新检测.md\",\"relativePath\":\"《Vue》笔记/01.基础/35.列表渲染之数组、对象更新检测.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\02.组件\\\\36.使用组件的细节点.md\",\"relativePath\":\"《Vue》笔记/02.组件/36.使用组件的细节点.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\02.组件\\\\40.父组件给子组件传值.md\",\"relativePath\":\"《Vue》笔记/02.组件/40.父组件给子组件传值.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\02.组件\\\\50.子组件派发事件和值给父组件.md\",\"relativePath\":\"《Vue》笔记/02.组件/50.子组件派发事件和值给父组件.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\02.组件\\\\52.Prop 验证 与 非 Prop 的 Attribute.md\",\"relativePath\":\"《Vue》笔记/02.组件/52.Prop 验证 与 非 Prop 的 Attribute.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\02.组件\\\\55.自定义事件.md\",\"relativePath\":\"《Vue》笔记/02.组件/55.自定义事件.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\02.组件\\\\60.兄弟组件传值.md\",\"relativePath\":\"《Vue》笔记/02.组件/60.兄弟组件传值.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\02.组件\\\\65.非父子组件传值.md\",\"relativePath\":\"《Vue》笔记/02.组件/65.非父子组件传值.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\02.组件\\\\70.父组件调用子组件方法并传入值.md\",\"relativePath\":\"《Vue》笔记/02.组件/70.父组件调用子组件方法并传入值.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\02.组件\\\\75.插槽slot.md\",\"relativePath\":\"《Vue》笔记/02.组件/75.插槽slot.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\02.组件\\\\80.动态组件与 v-once 指令.md\",\"relativePath\":\"《Vue》笔记/02.组件/80.动态组件与 v-once 指令.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\02.组件\\\\90.vue父子组件的生命周期顺序.md\",\"relativePath\":\"《Vue》笔记/02.组件/90.vue父子组件的生命周期顺序.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\03.过渡&动画\\\\110.transition过渡&动画.md\",\"relativePath\":\"《Vue》笔记/03.过渡&动画/110.transition过渡&动画.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\03.过渡&动画\\\\112.使用animate库.md\",\"relativePath\":\"《Vue》笔记/03.过渡&动画/112.使用animate库.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\03.过渡&动画\\\\120.transition-group列表过渡.md\",\"relativePath\":\"《Vue》笔记/03.过渡&动画/120.transition-group列表过渡.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\04.可复用性&组合\\\\01.Mixin混入.md\",\"relativePath\":\"《Vue》笔记/04.可复用性&组合/01.Mixin混入.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\05.工具\\\\10.Vue CLi v3 创建项目使用记录.md\",\"relativePath\":\"《Vue》笔记/05.工具/10.Vue CLi v3 创建项目使用记录.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\06.规模化\\\\100.vuex操作相关.md\",\"relativePath\":\"《Vue》笔记/06.规模化/100.vuex操作相关.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\06.规模化\\\\140.路由懒加载.md\",\"relativePath\":\"《Vue》笔记/06.规模化/140.路由懒加载.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\10.Vuex\\\\01.Vuex.md\",\"relativePath\":\"《Vue》笔记/10.Vuex/01.Vuex.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\99.其他\\\\79.Vue中编辑word文档以及预览word .md\",\"relativePath\":\"《Vue》笔记/99.其他/79.Vue中编辑word文档以及预览word .md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\99.其他\\\\80.Vue中的防抖函数封装和使用.md\",\"relativePath\":\"《Vue》笔记/99.其他/80.Vue中的防抖函数封装和使用.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\99.其他\\\\90.操作本地缓存.md\",\"relativePath\":\"《Vue》笔记/99.其他/90.操作本地缓存.md\"},{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\99.其他\\\\91.vue2与vue3生命周期对照表.md\",\"relativePath\":\"《Vue》笔记/99.其他/91.vue2与vue3生命周期对照表.md\"}],\"totalFileWords\":489593,\"eachFileWords\":[{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\25.JavaScript文章\\\\01.33个非常实用的JavaScript一行代码.md\",\"relativePath\":\"01.前端/25.JavaScript文章/01.33个非常实用的JavaScript一行代码.md\"},\"wordCount\":1656,\"readingTime\":\"7.2m\",\"frontmatter\":{\"title\":\"33个非常实用的JavaScript一行代码\",\"date\":{},\"permalink\":\"/pages/a61298/\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[\"JavaScript\"],\"author\":\"CUGGZ\"}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\25.JavaScript文章\\\\02.new命令原理.md\",\"relativePath\":\"01.前端/25.JavaScript文章/02.new命令原理.md\"},\"wordCount\":451,\"readingTime\":\"1.8m\",\"frontmatter\":{\"title\":\"new命令原理\",\"date\":{},\"permalink\":\"/pages/8143cc480faf9a11\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\25.JavaScript文章\\\\03.ES5面向对象.md\",\"relativePath\":\"01.前端/25.JavaScript文章/03.ES5面向对象.md\"},\"wordCount\":370,\"readingTime\":\"1.5m\",\"frontmatter\":{\"title\":\"ES5面向对象\",\"date\":{},\"permalink\":\"/pages/b1af5cb8996363c5\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\25.JavaScript文章\\\\04.ES6面向对象.md\",\"relativePath\":\"01.前端/25.JavaScript文章/04.ES6面向对象.md\"},\"wordCount\":289,\"readingTime\":\"1.2m\",\"frontmatter\":{\"title\":\"ES6面向对象\",\"date\":{},\"permalink\":\"/pages/1f4123be6f45abcd\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\25.JavaScript文章\\\\06.多种数组去重性能对比.md\",\"relativePath\":\"01.前端/25.JavaScript文章/06.多种数组去重性能对比.md\"},\"wordCount\":596,\"readingTime\":\"2.9m\",\"frontmatter\":{\"title\":\"多种数组去重性能对比\",\"date\":{},\"permalink\":\"/pages/e808fba1fa8fbab2\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\25.JavaScript文章\\\\07.js随机打乱数组.md\",\"relativePath\":\"01.前端/25.JavaScript文章/07.js随机打乱数组.md\"},\"wordCount\":233,\"readingTime\":\"1.2m\",\"frontmatter\":{\"title\":\"JS随机打乱数组\",\"date\":{},\"permalink\":\"/pages/40b4db2d38ba85f2\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\25.JavaScript文章\\\\08.判断是否为移动端浏览器.md\",\"relativePath\":\"01.前端/25.JavaScript文章/08.判断是否为移动端浏览器.md\"},\"wordCount\":46,\"readingTime\":\"1m\",\"frontmatter\":{\"title\":\"判断是否为移动端浏览器\",\"date\":{},\"permalink\":\"/pages/40f623be692cf8bc\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\25.JavaScript文章\\\\09.将一维数组按指定长度转为二维数组.md\",\"relativePath\":\"01.前端/25.JavaScript文章/09.将一维数组按指定长度转为二维数组.md\"},\"wordCount\":284,\"readingTime\":\"1.3m\",\"frontmatter\":{\"title\":\"将一维数组按指定长度转为二维数组\",\"date\":{},\"permalink\":\"/pages/f1acb712033ac8da\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\25.JavaScript文章\\\\10.防抖与节流函数.md\",\"relativePath\":\"01.前端/25.JavaScript文章/10.防抖与节流函数.md\"},\"wordCount\":625,\"readingTime\":\"2.5m\",\"frontmatter\":{\"title\":\"防抖与节流函数\",\"date\":{},\"permalink\":\"/pages/0f6a0ac99b62ede5\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\25.JavaScript文章\\\\11.JS获取和修改url参数.md\",\"relativePath\":\"01.前端/25.JavaScript文章/11.JS获取和修改url参数.md\"},\"wordCount\":299,\"readingTime\":\"1.4m\",\"frontmatter\":{\"title\":\"JS获取和修改url参数\",\"date\":{},\"permalink\":\"/pages/7a91be2d502346ce\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\25.JavaScript文章\\\\1110.三级目录\\\\00.四级文件.md\",\"relativePath\":\"01.前端/25.JavaScript文章/1110.三级目录/00.四级文件.md\"},\"wordCount\":41,\"readingTime\":\"1m\",\"frontmatter\":{\"title\":\"四级文件(测试)\",\"date\":{},\"permalink\":\"/pages/8481d1/\",\"categories\":[\"前端\",\"JavaScript文章\",\"三级目录\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\25.JavaScript文章\\\\12.比typeof运算符更准确的类型判断.md\",\"relativePath\":\"01.前端/25.JavaScript文章/12.比typeof运算符更准确的类型判断.md\"},\"wordCount\":328,\"readingTime\":\"1.6m\",\"frontmatter\":{\"title\":\"比typeof运算符更准确的类型判断\",\"date\":{},\"permalink\":\"/pages/fd4a16d56b83c1bc\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\25.JavaScript文章\\\\13.javascript常用类型数值比较图.md\",\"relativePath\":\"01.前端/25.JavaScript文章/13.javascript常用类型数值比较图.md\"},\"wordCount\":27,\"readingTime\":\"1m\",\"frontmatter\":{\"title\":\"javascript常用类型数值比较图\",\"date\":{},\"permalink\":\"/pages/360851/\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\25.JavaScript文章\\\\14.js获取当前URL,域名,端口号.md\",\"relativePath\":\"01.前端/25.JavaScript文章/14.js获取当前URL,域名,端口号.md\"},\"wordCount\":64,\"readingTime\":\"1m\",\"frontmatter\":{\"title\":\"js获取当前URL,域名,端口号\",\"date\":{},\"permalink\":\"/pages/c81259/\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\25.JavaScript文章\\\\15.js实现深度优先遍历和广度优先遍历.md\",\"relativePath\":\"01.前端/25.JavaScript文章/15.js实现深度优先遍历和广度优先遍历.md\"},\"wordCount\":437,\"readingTime\":\"1.8m\",\"frontmatter\":{\"title\":\"js实现深度优先遍历和广度优先遍历\",\"date\":{},\"permalink\":\"/pages/690414/\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\40.学习笔记\\\\00.《JavaScript教程》笔记.md\",\"relativePath\":\"01.前端/40.学习笔记/00.《JavaScript教程》笔记.md\"},\"wordCount\":0,\"readingTime\":\"1m\",\"frontmatter\":{\"pageComponent\":{\"name\":\"Catalogue\",\"data\":{\"path\":\"《JavaScript教程》笔记\",\"imgUrl\":\"https://www.runoob.com/wp-content/uploads/2013/07/js-logo.png\",\"description\":\"本章内容为博主在原教程基础上添加学习笔记，教程版权归原作者所有。来源：<a href='https://wangdoc.com/javascript/' target='_blank'>JavaScript教程</a>\"}},\"title\":\"《JavaScript教程》笔记\",\"date\":{},\"permalink\":\"/note/javascript/\",\"article\":false,\"comment\":false,\"editLink\":false,\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\40.学习笔记\\\\05.《JavaScript高级程序设计》笔记.md\",\"relativePath\":\"01.前端/40.学习笔记/05.《JavaScript高级程序设计》笔记.md\"},\"wordCount\":3598,\"readingTime\":\"14m\",\"frontmatter\":{\"title\":\"《JavaScript高级程序设计》笔记\",\"date\":{},\"permalink\":\"/note/js/\",\"categories\":[\"笔记\"],\"tags\":[\"笔记\",\"红宝书\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\40.学习笔记\\\\10.《ES6 教程》笔记.md\",\"relativePath\":\"01.前端/40.学习笔记/10.《ES6 教程》笔记.md\"},\"wordCount\":0,\"readingTime\":\"1m\",\"frontmatter\":{\"pageComponent\":{\"name\":\"Catalogue\",\"data\":{\"path\":\"《ES6 教程》笔记\",\"imgUrl\":\"https://www.runoob.com/wp-content/uploads/2017/08/20130807-es6-e1420205362328.png\",\"description\":\"本章内容为博主在原教程基础上添加学习笔记，教程版权归原作者所有。来源：<a href='https://es6.ruanyifeng.com/' target='_blank'>ES6教程</a>\"}},\"title\":\"《ES6 教程》笔记\",\"date\":{},\"permalink\":\"/note/es6/\",\"article\":false,\"comment\":false,\"editLink\":false,\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\40.学习笔记\\\\20.《Vue》笔记.md\",\"relativePath\":\"01.前端/40.学习笔记/20.《Vue》笔记.md\"},\"wordCount\":0,\"readingTime\":\"1m\",\"frontmatter\":{\"pageComponent\":{\"name\":\"Catalogue\",\"data\":{\"path\":\"《Vue》笔记\",\"imgUrl\":\"https://v2.cn.vuejs.org/images/logo.svg\",\"description\":\"本章内容是博主的Vue学习笔记，非教程文档，请以官方文档为准。\"}},\"title\":\"《Vue》笔记\",\"date\":{},\"permalink\":\"/note/vue/\",\"article\":false,\"comment\":false,\"editLink\":false,\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\40.学习笔记\\\\33.《Git》学习笔记.md\",\"relativePath\":\"01.前端/40.学习笔记/33.《Git》学习笔记.md\"},\"wordCount\":0,\"readingTime\":\"1m\",\"frontmatter\":{\"pageComponent\":{\"name\":\"Catalogue\",\"data\":{\"path\":\"《Git》学习笔记\",\"imgUrl\":\"https://avatars3.githubusercontent.com/u/18133?s=200&v=4\",\"description\":\"<a href='https://git-scm.com/book/zh/v2' target='_blank'>Git官网文档</a>的学习笔记，以官方文档为准。\"}},\"title\":\"《Git》学习笔记\",\"date\":{},\"permalink\":\"/note/git/\",\"article\":false,\"comment\":false,\"editLink\":false,\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\40.学习笔记\\\\35.TypeScript笔记.md\",\"relativePath\":\"01.前端/40.学习笔记/35.TypeScript笔记.md\"},\"wordCount\":4433,\"readingTime\":\"19.7m\",\"frontmatter\":{\"title\":\"TypeScript笔记\",\"date\":{},\"permalink\":\"/pages/51afd6/\",\"categories\":[\"前端\",\"学习笔记\"],\"tags\":[\"TypeScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\40.学习笔记\\\\40.小程序笔记.md\",\"relativePath\":\"01.前端/40.学习笔记/40.小程序笔记.md\"},\"wordCount\":11554,\"readingTime\":\"48.7m\",\"frontmatter\":{\"title\":\"小程序笔记\",\"date\":{},\"permalink\":\"/note/wx-miniprogram/\",\"tags\":[\"小程序\"],\"categories\":[\"前端\",\"学习笔记\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\40.学习笔记\\\\50.JS设计模式总结笔记.md\",\"relativePath\":\"01.前端/40.学习笔记/50.JS设计模式总结笔记.md\"},\"wordCount\":813,\"readingTime\":\"3m\",\"frontmatter\":{\"title\":\"JS设计模式总结笔记\",\"date\":{},\"permalink\":\"/pages/4643cd/\",\"categories\":[\"前端\",\"学习笔记\"],\"tags\":[\"设计模式\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\01.前端\\\\40.学习笔记\\\\60.《Electron》笔记.md\",\"relativePath\":\"01.前端/40.学习笔记/60.《Electron》笔记.md\"},\"wordCount\":0,\"readingTime\":\"1m\",\"frontmatter\":{\"pageComponent\":{\"name\":\"Catalogue\",\"data\":{\"path\":\"《Electron》笔记\",\"imgUrl\":\"https://www.electronjs.org/assets/img/logo.svg\",\"description\":\"Electron 是一个使用 JavaScript、HTML 和 CSS 构建桌面应用程序的框架。\"}},\"title\":\"《Electron》笔记\",\"date\":{},\"permalink\":\"/note/electron/\",\"article\":false,\"comment\":false,\"editLink\":false,\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\02.页面\\\\10.HTML\\\\10.常用meta整理.md\",\"relativePath\":\"02.页面/10.HTML/10.常用meta整理.md\"},\"wordCount\":1691,\"readingTime\":\"7.2m\",\"frontmatter\":{\"title\":\"常用meta整理\",\"date\":{},\"permalink\":\"/pages/8309a5b876fc95e3\",\"categories\":[\"页面\",\"HTML\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\02.页面\\\\20.CSS\\\\00.CSS教程和技巧收藏.md\",\"relativePath\":\"02.页面/20.CSS/00.CSS教程和技巧收藏.md\"},\"wordCount\":222,\"readingTime\":\"1m\",\"frontmatter\":{\"title\":\"CSS教程和技巧收藏\",\"date\":{},\"permalink\":\"/pages/c8f128/\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\02.页面\\\\20.CSS\\\\01.flex布局语法.md\",\"relativePath\":\"02.页面/20.CSS/01.flex布局语法.md\"},\"wordCount\":1787,\"readingTime\":\"7.4m\",\"frontmatter\":{\"title\":\"flex布局语法\",\"date\":{},\"permalink\":\"/pages/0a83b083bdf257cb\",\"author\":{\"name\":\"阮一峰\"},\"categories\":[\"页面\",\"CSS\"],\"tags\":[null]}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\02.页面\\\\20.CSS\\\\02.flex布局案例-基础.md\",\"relativePath\":\"02.页面/20.CSS/02.flex布局案例-基础.md\"},\"wordCount\":1071,\"readingTime\":\"4.3m\",\"frontmatter\":{\"title\":\"flex布局案例-基础\",\"date\":{},\"permalink\":\"/pages/ea6db1530c42ad51\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\02.页面\\\\20.CSS\\\\03.flex布局案例-骰子.md\",\"relativePath\":\"02.页面/20.CSS/03.flex布局案例-骰子.md\"},\"wordCount\":518,\"readingTime\":\"2.7m\",\"frontmatter\":{\"title\":\"flex布局案例-骰子\",\"date\":{},\"permalink\":\"/pages/eff61bc8b4f4695d\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\02.页面\\\\20.CSS\\\\04.flex布局案例-圣杯布局.md\",\"relativePath\":\"02.页面/20.CSS/04.flex布局案例-圣杯布局.md\"},\"wordCount\":146,\"readingTime\":\"1m\",\"frontmatter\":{\"title\":\"flex布局案例-圣杯布局\",\"date\":{},\"permalink\":\"/pages/df9e7c7214fa5046\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\02.页面\\\\20.CSS\\\\05.flex布局案例-网格布局.md\",\"relativePath\":\"02.页面/20.CSS/05.flex布局案例-网格布局.md\"},\"wordCount\":434,\"readingTime\":\"2.2m\",\"frontmatter\":{\"title\":\"flex布局案例-网格布局\",\"date\":{},\"permalink\":\"/pages/85b5a3fe218a34b7\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\02.页面\\\\20.CSS\\\\06.flex布局案例-输入框布局.md\",\"relativePath\":\"02.页面/20.CSS/06.flex布局案例-输入框布局.md\"},\"wordCount\":279,\"readingTime\":\"1.3m\",\"frontmatter\":{\"title\":\"flex布局案例-输入框布局\",\"date\":{},\"permalink\":\"/pages/05cc577fb51c7998\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\02.页面\\\\20.CSS\\\\07.CSS3之transition过渡.md\",\"relativePath\":\"02.页面/20.CSS/07.CSS3之transition过渡.md\"},\"wordCount\":1016,\"readingTime\":\"5.5m\",\"frontmatter\":{\"title\":\"CSS3之transition过渡\",\"date\":{},\"permalink\":\"/pages/02d7f59d98d87409\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\02.页面\\\\20.CSS\\\\08.CSS3之animation动画.md\",\"relativePath\":\"02.页面/20.CSS/08.CSS3之animation动画.md\"},\"wordCount\":558,\"readingTime\":\"2.8m\",\"frontmatter\":{\"title\":\"CSS3之animation动画\",\"date\":{},\"permalink\":\"/pages/c2c0432138f6e042\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\02.页面\\\\20.CSS\\\\09.「布局技巧」图片未加载前自动撑开元素高度.md\",\"relativePath\":\"02.页面/20.CSS/09.「布局技巧」图片未加载前自动撑开元素高度.md\"},\"wordCount\":285,\"readingTime\":\"1m\",\"frontmatter\":{\"title\":\"「布局技巧」图片未加载前自动撑开元素高度\",\"date\":{},\"permalink\":\"/pages/3d52574260725aea\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\02.页面\\\\20.CSS\\\\10.文字在一行或多行时超出显示省略号.md\",\"relativePath\":\"02.页面/20.CSS/10.文字在一行或多行时超出显示省略号.md\"},\"wordCount\":474,\"readingTime\":\"1.9m\",\"frontmatter\":{\"title\":\"文字在一行或多行时超出显示省略号\",\"date\":{},\"permalink\":\"/pages/42b66999cc27dc25\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\02.页面\\\\20.CSS\\\\11.从box-sizing属性入手，了解盒子模型.md\",\"relativePath\":\"02.页面/20.CSS/11.从box-sizing属性入手，了解盒子模型.md\"},\"wordCount\":999,\"readingTime\":\"3.8m\",\"frontmatter\":{\"title\":\"从box-sizing属性入手，了解盒子模型\",\"date\":{},\"permalink\":\"/pages/20a978023139589d\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\02.页面\\\\20.CSS\\\\12.水平垂直居中的几种方式-案例.md\",\"relativePath\":\"02.页面/20.CSS/12.水平垂直居中的几种方式-案例.md\"},\"wordCount\":96,\"readingTime\":\"1m\",\"frontmatter\":{\"title\":\"水平垂直居中的几种方式-案例\",\"date\":{},\"permalink\":\"/pages/cb7cb251adba4bf7\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\02.页面\\\\20.CSS\\\\13.如何根据系统主题自动响应CSS深色模式.md\",\"relativePath\":\"02.页面/20.CSS/13.如何根据系统主题自动响应CSS深色模式.md\"},\"wordCount\":818,\"readingTime\":\"3.2m\",\"frontmatter\":{\"title\":\"如何根据系统主题自动响应CSS深色模式\",\"date\":{},\"permalink\":\"/pages/5dde351274f1e39d\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[\"css\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\02.页面\\\\20.CSS\\\\14.CSS-function汇总.md\",\"relativePath\":\"02.页面/20.CSS/14.CSS-function汇总.md\"},\"wordCount\":10,\"readingTime\":\"1m\",\"frontmatter\":{\"title\":\"CSS-function汇总\",\"date\":{},\"permalink\":\"/pages/3da0d7\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\02.页面\\\\20.CSS\\\\15.CSS给table的tbody添加滚动条.md\",\"relativePath\":\"02.页面/20.CSS/15.CSS给table的tbody添加滚动条.md\"},\"wordCount\":18,\"readingTime\":\"1m\",\"frontmatter\":{\"title\":\"CSS给table的tbody添加滚动条\",\"date\":{},\"permalink\":\"/pages/55f894/\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\02.页面\\\\20.CSS\\\\16.css calc()使用.md\",\"relativePath\":\"02.页面/20.CSS/16.css calc()使用.md\"},\"wordCount\":552,\"readingTime\":\"2m\",\"frontmatter\":{\"title\":\"css calc()使用\",\"date\":{},\"permalink\":\"/pages/2ecc26/\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\03.技术\\\\01.技术文档\\\\01.Git使用手册.md\",\"relativePath\":\"03.技术/01.技术文档/01.Git使用手册.md\"},\"wordCount\":2394,\"readingTime\":\"9.9m\",\"frontmatter\":{\"title\":\"Git使用手册\",\"date\":{},\"permalink\":\"/pages/9a7ee40fc232253e\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\03.技术\\\\01.技术文档\\\\02.Markdown使用教程.md\",\"relativePath\":\"03.技术/01.技术文档/02.Markdown使用教程.md\"},\"wordCount\":4182,\"readingTime\":\"18.3m\",\"frontmatter\":{\"title\":\"Markdown使用教程\",\"date\":{},\"permalink\":\"/pages/ad247c4332211551\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\03.技术\\\\01.技术文档\\\\03.npm常用命令.md\",\"relativePath\":\"03.技术/01.技术文档/03.npm常用命令.md\"},\"wordCount\":980,\"readingTime\":\"3.8m\",\"frontmatter\":{\"title\":\"npm常用命令\",\"date\":{},\"permalink\":\"/pages/61f2f95fd7da14fd\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\03.技术\\\\01.技术文档\\\\10.npm packageJson属性详解.md\",\"relativePath\":\"03.技术/01.技术文档/10.npm packageJson属性详解.md\"},\"wordCount\":4259,\"readingTime\":\"16.9m\",\"frontmatter\":{\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"npm packageJson属性详解\",\"date\":{},\"permalink\":\"/pages/dec4f3f00e71a312\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null]}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\03.技术\\\\01.技术文档\\\\15.yaml语言教程.md\",\"relativePath\":\"03.技术/01.技术文档/15.yaml语言教程.md\"},\"wordCount\":1239,\"readingTime\":\"5.1m\",\"frontmatter\":{\"title\":\"yaml语言教程\",\"date\":{},\"permalink\":\"/pages/4e8444e2d534d14f\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\03.技术\\\\01.技术文档\\\\20.Git修改分支名.md\",\"relativePath\":\"03.技术/01.技术文档/20.Git修改分支名.md\"},\"wordCount\":104,\"readingTime\":\"1m\",\"frontmatter\":{\"title\":\"Git修改分支名\",\"date\":{},\"permalink\":\"/pages/922650/\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\03.技术\\\\02.Nodejs\\\\01.nodejs递归读取所有文件.md\",\"relativePath\":\"03.技术/02.Nodejs/01.nodejs递归读取所有文件.md\"},\"wordCount\":71,\"readingTime\":\"1m\",\"frontmatter\":{\"title\":\"nodejs递归读取所有文件\",\"date\":{},\"permalink\":\"/pages/117708e0af7f0bd9\",\"categories\":[\"技术\",\"Nodejs\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\03.技术\\\\03.博客搭建\\\\01.解决百度无法收录搭建在GitHub上的个人博客的问题.md\",\"relativePath\":\"03.技术/03.博客搭建/01.解决百度无法收录搭建在GitHub上的个人博客的问题.md\"},\"wordCount\":650,\"readingTime\":\"2.5m\",\"frontmatter\":{\"title\":\"解决百度无法收录搭建在GitHub上的个人博客的问题\",\"date\":{},\"permalink\":\"/pages/41f87d890d0a02af\",\"categories\":[\"技术\",\"博客搭建\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\03.技术\\\\03.博客搭建\\\\02.使用Gitalk实现静态博客无后台评论系统.md\",\"relativePath\":\"03.技术/03.博客搭建/02.使用Gitalk实现静态博客无后台评论系统.md\"},\"wordCount\":789,\"readingTime\":\"3.4m\",\"frontmatter\":{\"title\":\"使用Gitalk实现静态博客无后台评论系统\",\"date\":{},\"permalink\":\"/pages/1da0bf9a988eafe5\",\"categories\":[\"技术\",\"博客搭建\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\03.技术\\\\03.博客搭建\\\\03.GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床.md\",\"relativePath\":\"03.技术/03.博客搭建/03.GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床.md\"},\"wordCount\":710,\"readingTime\":\"2.6m\",\"frontmatter\":{\"title\":\"GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床\",\"date\":{},\"permalink\":\"/pages/a5f73af5185fdf0a\",\"categories\":[\"技术\",\"博客搭建\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\03.技术\\\\03.博客搭建\\\\10.vdoing主题效果图.md\",\"relativePath\":\"03.技术/03.博客搭建/10.vdoing主题效果图.md\"},\"wordCount\":290,\"readingTime\":\"1.6m\",\"frontmatter\":{\"title\":\"vdoing主题效果图\",\"date\":{},\"permalink\":\"/pages/d557b9a89a215d2e\",\"article\":false,\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\04.更多\\\\01.学习\\\\00.费曼学习法.md\",\"relativePath\":\"04.更多/01.学习/00.费曼学习法.md\"},\"wordCount\":256,\"readingTime\":\"1m\",\"frontmatter\":{\"title\":\"费曼学习法\",\"date\":{},\"permalink\":\"/pages/f2a556/\",\"categories\":[\"更多\",\"学习\"],\"tags\":[\"学习方法\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\04.更多\\\\01.学习\\\\03.提高记忆的技巧.md\",\"relativePath\":\"04.更多/01.学习/03.提高记忆的技巧.md\"},\"wordCount\":197,\"readingTime\":\"1m\",\"frontmatter\":{\"title\":\"提高记忆的技巧\",\"date\":{},\"permalink\":\"/pages/996822b2a2ca6e3b\",\"categories\":[\"更多\",\"学习\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\04.更多\\\\01.学习\\\\10.搜索引擎使用技巧.md\",\"relativePath\":\"04.更多/01.学习/10.搜索引擎使用技巧.md\"},\"wordCount\":484,\"readingTime\":\"1.7m\",\"frontmatter\":{\"title\":\"搜索引擎使用技巧\",\"date\":{},\"permalink\":\"/pages/ce818a\",\"categories\":[\"更多\",\"学习\"],\"tags\":[\"搜索技巧\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\04.更多\\\\03.面试\\\\01.面试问题集锦.md\",\"relativePath\":\"04.更多/03.面试/01.面试问题集锦.md\"},\"wordCount\":6797,\"readingTime\":\"22.6m\",\"frontmatter\":{\"title\":\"面试问题集锦\",\"date\":{},\"permalink\":\"/pages/aea6571b7a8bae86\",\"categories\":[\"更多\",\"面试\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\04.更多\\\\05.AI随笔\\\\01.当珍妮机学会了写代码.md\",\"relativePath\":\"04.更多/05.AI随笔/01.当珍妮机学会了写代码.md\"},\"wordCount\":2935,\"readingTime\":\"10.2m\",\"frontmatter\":{\"title\":\"当珍妮机学会了写代码\",\"date\":{},\"permalink\":\"/pages/ai-coding-revolution/\",\"categories\":[\"更多\",\"AI随笔\"],\"tags\":[\"AI\",\"思考\",\"编程\"],\"author\":{\"name\":\"刘志伟;AI\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\04.更多\\\\99.友情链接.md\",\"relativePath\":\"04.更多/99.友情链接.md\"},\"wordCount\":0,\"readingTime\":\"1m\",\"frontmatter\":{\"title\":\"友情链接\",\"date\":{},\"permalink\":\"/pages/1bf946/\",\"categories\":[\"更多\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\05.关于\\\\01.关于.md\",\"relativePath\":\"05.关于/01.关于.md\"},\"wordCount\":1,\"readingTime\":\"1m\",\"frontmatter\":{\"title\":\"关于\",\"date\":{},\"permalink\":\"/about/\",\"sidebar\":false,\"article\":false,\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Electron》笔记\\\\01.electron记录.md\",\"relativePath\":\"《Electron》笔记/01.electron记录.md\"},\"wordCount\":2417,\"readingTime\":\"9.4m\",\"frontmatter\":{\"title\":\"electron记录\",\"date\":{},\"permalink\":\"/pages/8e9a16/\",\"categories\":[\"《Electron》笔记\"],\"tags\":[\"electron\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Electron》笔记\\\\02.electron下使用puppeteer模拟用户操作,数据获取.md\",\"relativePath\":\"《Electron》笔记/02.electron下使用puppeteer模拟用户操作,数据获取.md\"},\"wordCount\":2073,\"readingTime\":\"8.7m\",\"frontmatter\":{\"title\":\"electron下使用puppeteer模拟用户操作,数据获取\",\"date\":{},\"permalink\":\"/pages/56ebf1/\",\"categories\":[\"《Electron》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\01.ECMAScript 6 简介.md\",\"relativePath\":\"《ES6 教程》笔记/01.ECMAScript 6 简介.md\"},\"wordCount\":4497,\"readingTime\":\"18.2m\",\"frontmatter\":{\"title\":\"ECMAScript 6 简介\",\"date\":{},\"permalink\":\"/pages/f344d070a1031ef7\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\02.let 和 const 命令.md\",\"relativePath\":\"《ES6 教程》笔记/02.let 和 const 命令.md\"},\"wordCount\":5285,\"readingTime\":\"20.3m\",\"frontmatter\":{\"title\":\"let 和 const 命令\",\"date\":{},\"permalink\":\"/pages/c1edd70a6b7c7872\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\03.变量的解构赋值.md\",\"relativePath\":\"《ES6 教程》笔记/03.变量的解构赋值.md\"},\"wordCount\":3970,\"readingTime\":\"16.2m\",\"frontmatter\":{\"title\":\"变量的解构赋值\",\"date\":{},\"permalink\":\"/pages/b1ab10a62f7564da\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\04.字符串的扩展.md\",\"relativePath\":\"《ES6 教程》笔记/04.字符串的扩展.md\"},\"wordCount\":4087,\"readingTime\":\"17m\",\"frontmatter\":{\"title\":\"字符串的扩展\",\"date\":{},\"permalink\":\"/pages/ca89eca8adeba5f4\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\05.字符串的新增方法.md\",\"relativePath\":\"《ES6 教程》笔记/05.字符串的新增方法.md\"},\"wordCount\":2753,\"readingTime\":\"10.9m\",\"frontmatter\":{\"title\":\"字符串的新增方法\",\"date\":{},\"permalink\":\"/pages/a650b4a0ebfc9350\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\06.正则的扩展.md\",\"relativePath\":\"《ES6 教程》笔记/06.正则的扩展.md\"},\"wordCount\":4938,\"readingTime\":\"20.1m\",\"frontmatter\":{\"title\":\"正则的扩展\",\"date\":{},\"permalink\":\"/pages/0473261a6ab0ee8c\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\07.数值的扩展.md\",\"relativePath\":\"《ES6 教程》笔记/07.数值的扩展.md\"},\"wordCount\":5975,\"readingTime\":\"25.7m\",\"frontmatter\":{\"title\":\"数值的扩展\",\"date\":{},\"permalink\":\"/pages/5dfea9a0f2d1a392\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\08.函数的扩展.md\",\"relativePath\":\"《ES6 教程》笔记/08.函数的扩展.md\"},\"wordCount\":9521,\"readingTime\":\"37.8m\",\"frontmatter\":{\"title\":\"函数的扩展\",\"date\":{},\"permalink\":\"/pages/8ed309d668b20264\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\09.数组的扩展.md\",\"relativePath\":\"《ES6 教程》笔记/09.数组的扩展.md\"},\"wordCount\":6376,\"readingTime\":\"26.5m\",\"frontmatter\":{\"title\":\"数组的扩展\",\"date\":{},\"permalink\":\"/pages/e34009d60d8bc4b2\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\10.对象的扩展.md\",\"relativePath\":\"《ES6 教程》笔记/10.对象的扩展.md\"},\"wordCount\":5524,\"readingTime\":\"22.4m\",\"frontmatter\":{\"title\":\"对象的扩展\",\"date\":{},\"permalink\":\"/pages/b5e3e0a0ff6e9c25\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\11.对象的新增方法.md\",\"relativePath\":\"《ES6 教程》笔记/11.对象的新增方法.md\"},\"wordCount\":4578,\"readingTime\":\"19.6m\",\"frontmatter\":{\"title\":\"对象的新增方法\",\"date\":{},\"permalink\":\"/pages/e85e68947502cf90\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\12.Symbol.md\",\"relativePath\":\"《ES6 教程》笔记/12.Symbol.md\"},\"wordCount\":5410,\"readingTime\":\"23m\",\"frontmatter\":{\"title\":\"Symbol\",\"date\":{},\"permalink\":\"/pages/02c86eb2792f3262\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\13.Set 和 Map 数据结构.md\",\"relativePath\":\"《ES6 教程》笔记/13.Set 和 Map 数据结构.md\"},\"wordCount\":7179,\"readingTime\":\"30.3m\",\"frontmatter\":{\"title\":\"Set 和 Map 数据结构\",\"date\":{},\"permalink\":\"/pages/0c21dae358fca16b\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\14.Proxy.md\",\"relativePath\":\"《ES6 教程》笔记/14.Proxy.md\"},\"wordCount\":6345,\"readingTime\":\"27.6m\",\"frontmatter\":{\"title\":\"Proxy\",\"date\":{},\"permalink\":\"/pages/f56ec2ab97d60483\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\15.Reflect.md\",\"relativePath\":\"《ES6 教程》笔记/15.Reflect.md\"},\"wordCount\":2812,\"readingTime\":\"12.6m\",\"frontmatter\":{\"title\":\"Reflect\",\"date\":{},\"permalink\":\"/pages/74de3e45e4491e95\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\16.Promise 对象.md\",\"relativePath\":\"《ES6 教程》笔记/16.Promise 对象.md\"},\"wordCount\":8250,\"readingTime\":\"33.9m\",\"frontmatter\":{\"title\":\"Promise 对象\",\"date\":{},\"permalink\":\"/pages/2810ae8985e9bd52\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\17.Iterator 和 for-of 循环.md\",\"relativePath\":\"《ES6 教程》笔记/17.Iterator 和 for-of 循环.md\"},\"wordCount\":5593,\"readingTime\":\"23.1m\",\"frontmatter\":{\"title\":\"Iterator 和 for-of 循环\",\"date\":{},\"permalink\":\"/pages/48df907ad3570f3d\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\18.Generator 函数的语法.md\",\"relativePath\":\"《ES6 教程》笔记/18.Generator 函数的语法.md\"},\"wordCount\":10915,\"readingTime\":\"44.8m\",\"frontmatter\":{\"title\":\"Generator 函数的语法\",\"date\":{},\"permalink\":\"/pages/718b48ed9ce0adce\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\19.Generator 函数的异步应用.md\",\"relativePath\":\"《ES6 教程》笔记/19.Generator 函数的异步应用.md\"},\"wordCount\":6023,\"readingTime\":\"23.9m\",\"frontmatter\":{\"title\":\"Generator 函数的异步应用\",\"date\":{},\"permalink\":\"/pages/75af7031eb66847b\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\20.async 函数.md\",\"relativePath\":\"《ES6 教程》笔记/20.async 函数.md\"},\"wordCount\":5150,\"readingTime\":\"21.5m\",\"frontmatter\":{\"title\":\"async 函数\",\"date\":{},\"permalink\":\"/pages/3777253e65bac487\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\21.Class 的基本语法.md\",\"relativePath\":\"《ES6 教程》笔记/21.Class 的基本语法.md\"},\"wordCount\":5370,\"readingTime\":\"21.8m\",\"frontmatter\":{\"title\":\"Class 的基本语法\",\"date\":{},\"permalink\":\"/pages/e831e1593c82bbe0\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\22.Class 的继承.md\",\"relativePath\":\"《ES6 教程》笔记/22.Class 的继承.md\"},\"wordCount\":4221,\"readingTime\":\"17.5m\",\"frontmatter\":{\"title\":\"Class 的继承\",\"date\":{},\"permalink\":\"/pages/83f8c3a0cd87dd83\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\23.Module 的语法.md\",\"relativePath\":\"《ES6 教程》笔记/23.Module 的语法.md\"},\"wordCount\":5819,\"readingTime\":\"22.8m\",\"frontmatter\":{\"title\":\"Module 的语法\",\"date\":{},\"permalink\":\"/pages/efe2fb04eb8ac5fb\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\24.Module 的加载实现.md\",\"relativePath\":\"《ES6 教程》笔记/24.Module 的加载实现.md\"},\"wordCount\":6304,\"readingTime\":\"25.5m\",\"frontmatter\":{\"title\":\"Module 的加载实现\",\"date\":{},\"permalink\":\"/pages/a79ca2e64ceae213\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\25.编程风格.md\",\"relativePath\":\"《ES6 教程》笔记/25.编程风格.md\"},\"wordCount\":2422,\"readingTime\":\"10.4m\",\"frontmatter\":{\"title\":\"编程风格\",\"date\":{},\"permalink\":\"/pages/984bf549204bb266\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\26.读懂 ECMAScript 规格.md\",\"relativePath\":\"《ES6 教程》笔记/26.读懂 ECMAScript 规格.md\"},\"wordCount\":3672,\"readingTime\":\"15.3m\",\"frontmatter\":{\"title\":\"读懂 ECMAScript 规格\",\"date\":{},\"permalink\":\"/pages/32c35f7651d6e58e\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\27.异步遍历器.md\",\"relativePath\":\"《ES6 教程》笔记/27.异步遍历器.md\"},\"wordCount\":3291,\"readingTime\":\"13.7m\",\"frontmatter\":{\"title\":\"异步遍历器\",\"date\":{},\"permalink\":\"/pages/16121351be68691b\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\28.ArrayBuffer.md\",\"relativePath\":\"《ES6 教程》笔记/28.ArrayBuffer.md\"},\"wordCount\":11752,\"readingTime\":\"47.7m\",\"frontmatter\":{\"title\":\"ArrayBuffer\",\"date\":{},\"permalink\":\"/pages/a2ba314746bfdbdd\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\29.最新提案.md\",\"relativePath\":\"《ES6 教程》笔记/29.最新提案.md\"},\"wordCount\":4160,\"readingTime\":\"16.8m\",\"frontmatter\":{\"title\":\"最新提案\",\"date\":{},\"permalink\":\"/pages/7188882b8d65af1b\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\30.装饰器.md\",\"relativePath\":\"《ES6 教程》笔记/30.装饰器.md\"},\"wordCount\":3514,\"readingTime\":\"15.4m\",\"frontmatter\":{\"title\":\"装饰器\",\"date\":{},\"permalink\":\"/pages/e97bc1e5626b082c\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\31.函数式编程.md\",\"relativePath\":\"《ES6 教程》笔记/31.函数式编程.md\"},\"wordCount\":1318,\"readingTime\":\"5.6m\",\"frontmatter\":{\"title\":\"函数式编程\",\"date\":{},\"permalink\":\"/pages/1cf50330655efc69\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\32.Mixin.md\",\"relativePath\":\"《ES6 教程》笔记/32.Mixin.md\"},\"wordCount\":884,\"readingTime\":\"3.5m\",\"frontmatter\":{\"title\":\"Mixin\",\"date\":{},\"permalink\":\"/pages/6a8e2dc558da1b39\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\33.SIMD.md\",\"relativePath\":\"《ES6 教程》笔记/33.SIMD.md\"},\"wordCount\":5573,\"readingTime\":\"24.9m\",\"frontmatter\":{\"title\":\"SIMD\",\"date\":{},\"permalink\":\"/pages/8e8f80f69b775a56\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\34.参考链接.md\",\"relativePath\":\"《ES6 教程》笔记/34.参考链接.md\"},\"wordCount\":4567,\"readingTime\":\"24.9m\",\"frontmatter\":{\"title\":\"参考链接\",\"date\":{},\"permalink\":\"/pages/ea6f3b870f6dab69\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《ES6 教程》笔记\\\\35.了解ES6中的Map和Set.md\",\"relativePath\":\"《ES6 教程》笔记/35.了解ES6中的Map和Set.md\"},\"wordCount\":897,\"readingTime\":\"3.9m\",\"frontmatter\":{\"title\":\"了解ES6中的Map和Set\",\"date\":{},\"permalink\":\"/pages/bfde72/\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Git》学习笔记\\\\10.手册\\\\00.常用Git命令清单.md\",\"relativePath\":\"《Git》学习笔记/10.手册/00.常用Git命令清单.md\"},\"wordCount\":1806,\"readingTime\":\"7.3m\",\"frontmatter\":{\"title\":\"常用Git命令清单\",\"date\":{},\"permalink\":\"/pages/8292d8/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Git》学习笔记\\\\10.手册\\\\01.Git变基合并.md\",\"relativePath\":\"《Git》学习笔记/10.手册/01.Git变基合并.md\"},\"wordCount\":1268,\"readingTime\":\"5.1m\",\"frontmatter\":{\"title\":\"Git变基合并\",\"date\":{},\"permalink\":\"/pages/c10281/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Git》学习笔记\\\\20.文档笔记\\\\10.Git基础与命令.md\",\"relativePath\":\"《Git》学习笔记/20.文档笔记/10.Git基础与命令.md\"},\"wordCount\":3925,\"readingTime\":\"15.5m\",\"frontmatter\":{\"title\":\"Git基础与命令\",\"date\":{},\"permalink\":\"/pages/635088/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Git》学习笔记\\\\20.文档笔记\\\\100.Git工具-重写历史.md\",\"relativePath\":\"《Git》学习笔记/20.文档笔记/100.Git工具-重写历史.md\"},\"wordCount\":3864,\"readingTime\":\"15.3m\",\"frontmatter\":{\"title\":\"Git工具-重写历史\",\"date\":{},\"permalink\":\"/pages/1832fe/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Git》学习笔记\\\\20.文档笔记\\\\110.Git工具-重置揭密.md\",\"relativePath\":\"《Git》学习笔记/20.文档笔记/110.Git工具-重置揭密.md\"},\"wordCount\":4074,\"readingTime\":\"15.5m\",\"frontmatter\":{\"title\":\"Git工具-重置揭密\",\"date\":{},\"permalink\":\"/pages/d9e9c6/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Git》学习笔记\\\\20.文档笔记\\\\20.Git分支-分支原理.md\",\"relativePath\":\"《Git》学习笔记/20.文档笔记/20.Git分支-分支原理.md\"},\"wordCount\":2011,\"readingTime\":\"7.7m\",\"frontmatter\":{\"title\":\"Git分支-分支原理\",\"date\":{},\"permalink\":\"/pages/4bef1a/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Git》学习笔记\\\\20.文档笔记\\\\30.Git分支的新建与合并-分支操作.md\",\"relativePath\":\"《Git》学习笔记/20.文档笔记/30.Git分支的新建与合并-分支操作.md\"},\"wordCount\":918,\"readingTime\":\"3.4m\",\"frontmatter\":{\"title\":\"Git分支的新建与合并-分支操作\",\"date\":{},\"permalink\":\"/pages/ea5a8c/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Git》学习笔记\\\\20.文档笔记\\\\40.Git分支管理-查看分支.md\",\"relativePath\":\"《Git》学习笔记/20.文档笔记/40.Git分支管理-查看分支.md\"},\"wordCount\":381,\"readingTime\":\"1.5m\",\"frontmatter\":{\"title\":\"Git分支管理-查看分支\",\"date\":{},\"permalink\":\"/pages/a399b3/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Git》学习笔记\\\\20.文档笔记\\\\50.Git分支开发工作流.md\",\"relativePath\":\"《Git》学习笔记/20.文档笔记/50.Git分支开发工作流.md\"},\"wordCount\":1260,\"readingTime\":\"4.4m\",\"frontmatter\":{\"title\":\"Git分支开发工作流\",\"date\":{},\"permalink\":\"/pages/49ee30/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Git》学习笔记\\\\20.文档笔记\\\\60.Git分支-远程分支.md\",\"relativePath\":\"《Git》学习笔记/20.文档笔记/60.Git分支-远程分支.md\"},\"wordCount\":3442,\"readingTime\":\"13.3m\",\"frontmatter\":{\"title\":\"Git分支-远程分支\",\"date\":{},\"permalink\":\"/pages/574d62/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Git》学习笔记\\\\20.文档笔记\\\\70.Git分支-变基.md\",\"relativePath\":\"《Git》学习笔记/20.文档笔记/70.Git分支-变基.md\"},\"wordCount\":4635,\"readingTime\":\"17.1m\",\"frontmatter\":{\"title\":\"Git分支-变基\",\"date\":{},\"permalink\":\"/pages/3a3247/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Git》学习笔记\\\\20.文档笔记\\\\80.Git工具-查看修订版本.md\",\"relativePath\":\"《Git》学习笔记/20.文档笔记/80.Git工具-查看修订版本.md\"},\"wordCount\":3528,\"readingTime\":\"14m\",\"frontmatter\":{\"title\":\"Git工具-查看修订版本\",\"date\":{},\"permalink\":\"/pages/c984d1/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Git》学习笔记\\\\20.文档笔记\\\\90.Git工具-交互式暂存.md\",\"relativePath\":\"《Git》学习笔记/20.文档笔记/90.Git工具-交互式暂存.md\"},\"wordCount\":1586,\"readingTime\":\"7.1m\",\"frontmatter\":{\"title\":\"Git工具-交互式暂存\",\"date\":{},\"permalink\":\"/pages/76d859/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Git》学习笔记\\\\Git常用命令速查表.md\",\"relativePath\":\"《Git》学习笔记/Git常用命令速查表.md\"},\"wordCount\":23,\"readingTime\":\"1m\",\"frontmatter\":{\"title\":\"Git常用命令速查表\",\"date\":{},\"permalink\":\"/pages/3aa4fd/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《JavaScript教程》笔记\\\\01.基础.md\",\"relativePath\":\"《JavaScript教程》笔记/01.基础.md\"},\"wordCount\":4964,\"readingTime\":\"19.5m\",\"frontmatter\":{\"title\":\"基础\",\"date\":{},\"permalink\":\"/pages/0796ba76b4b55368\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《JavaScript教程》笔记\\\\02.内置对象.md\",\"relativePath\":\"《JavaScript教程》笔记/02.内置对象.md\"},\"wordCount\":38354,\"readingTime\":\"2h36m\",\"frontmatter\":{\"title\":\"内置对象\",\"date\":{},\"permalink\":\"/pages/74d2ab3fbfeaaa68\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《JavaScript教程》笔记\\\\03.面向对象.md\",\"relativePath\":\"《JavaScript教程》笔记/03.面向对象.md\"},\"wordCount\":18921,\"readingTime\":\"1h14m\",\"frontmatter\":{\"title\":\"面向对象\",\"date\":{},\"permalink\":\"/pages/659b5af5e2e704e0\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《JavaScript教程》笔记\\\\04.异步操作.md\",\"relativePath\":\"《JavaScript教程》笔记/04.异步操作.md\"},\"wordCount\":3633,\"readingTime\":\"13.5m\",\"frontmatter\":{\"title\":\"异步操作\",\"date\":{},\"permalink\":\"/pages/d61b1cb4cdac1f63\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《JavaScript教程》笔记\\\\05.DOM.md\",\"relativePath\":\"《JavaScript教程》笔记/05.DOM.md\"},\"wordCount\":38738,\"readingTime\":\"2h35m\",\"frontmatter\":{\"title\":\"DOM\",\"date\":{},\"permalink\":\"/pages/7d961b8030c6099e\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《JavaScript教程》笔记\\\\06.事件.md\",\"relativePath\":\"《JavaScript教程》笔记/06.事件.md\"},\"wordCount\":27061,\"readingTime\":\"1h45m\",\"frontmatter\":{\"title\":\"事件\",\"date\":{},\"permalink\":\"/pages/10b2761db5a8e089\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《JavaScript教程》笔记\\\\07.浏览器模型.md\",\"relativePath\":\"《JavaScript教程》笔记/07.浏览器模型.md\"},\"wordCount\":56421,\"readingTime\":\"3h44m\",\"frontmatter\":{\"title\":\"浏览器模型\",\"date\":{},\"permalink\":\"/pages/bab4930124ad2c10\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《JavaScript教程》笔记\\\\08.事件循环(evenloop).md\",\"relativePath\":\"《JavaScript教程》笔记/08.事件循环(evenloop).md\"},\"wordCount\":531,\"readingTime\":\"2.2m\",\"frontmatter\":{\"title\":\"事件循环(evenloop)\",\"date\":{},\"permalink\":\"/pages/eaf565/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《JavaScript教程》笔记\\\\09.js 使用postMessage iframe跨域通信.md\",\"relativePath\":\"《JavaScript教程》笔记/09.js 使用postMessage iframe跨域通信.md\"},\"wordCount\":625,\"readingTime\":\"2.3m\",\"frontmatter\":{\"title\":\"js 使用postMessage iframe跨域通信\",\"date\":{},\"permalink\":\"/pages/d67bac/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《JavaScript教程》笔记\\\\10.JS中的？.和？？区别.md\",\"relativePath\":\"《JavaScript教程》笔记/10.JS中的？.和？？区别.md\"},\"wordCount\":872,\"readingTime\":\"3.4m\",\"frontmatter\":{\"title\":\"和？？区别\",\"date\":{},\"permalink\":\"/pages/176ae0/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《JavaScript教程》笔记\\\\11.`import`、`require`、`export`、`module.exports` 的区别和使用详解.md\",\"relativePath\":\"《JavaScript教程》笔记/11.`import`、`require`、`export`、`module.exports` 的区别和使用详解.md\"},\"wordCount\":900,\"readingTime\":\"3.6m\",\"frontmatter\":{\"title\":\"exports` 的区别和使用详解\",\"date\":{},\"permalink\":\"/pages/ff5679/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《JavaScript教程》笔记\\\\12.console实用调试方法.md\",\"relativePath\":\"《JavaScript教程》笔记/12.console实用调试方法.md\"},\"wordCount\":456,\"readingTime\":\"2m\",\"frontmatter\":{\"title\":\"console实用调试方法\",\"date\":{},\"permalink\":\"/pages/602ffc/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《JavaScript教程》笔记\\\\13.JS继承.md\",\"relativePath\":\"《JavaScript教程》笔记/13.JS继承.md\"},\"wordCount\":1003,\"readingTime\":\"3.9m\",\"frontmatter\":{\"title\":\"JS继承\",\"date\":{},\"permalink\":\"/pages/b17c09/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《JavaScript教程》笔记\\\\14.JS实现扫码登录.md\",\"relativePath\":\"《JavaScript教程》笔记/14.JS实现扫码登录.md\"},\"wordCount\":779,\"readingTime\":\"3m\",\"frontmatter\":{\"title\":\"JS实现扫码登录\",\"date\":{},\"permalink\":\"/pages/bdbdb8/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《uniapp》笔记\\\\使用uniapp对接蓝牙设备.md\",\"relativePath\":\"《uniapp》笔记/使用uniapp对接蓝牙设备.md\"},\"wordCount\":1736,\"readingTime\":\"7.1m\",\"frontmatter\":{\"title\":\"使用uniapp对接蓝牙设备\",\"date\":{},\"permalink\":\"/pages/35c361/\",\"categories\":[\"《uniapp》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\01.基础\\\\00.MVVM模式.md\",\"relativePath\":\"《Vue》笔记/01.基础/00.MVVM模式.md\"},\"wordCount\":210,\"readingTime\":\"1m\",\"frontmatter\":{\"title\":\"MVVM模式\",\"date\":{},\"permalink\":\"/pages/114158caa9e96df0\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\01.基础\\\\10.生命周期.md\",\"relativePath\":\"《Vue》笔记/01.基础/10.生命周期.md\"},\"wordCount\":512,\"readingTime\":\"2.6m\",\"frontmatter\":{\"title\":\"生命周期\",\"date\":{},\"permalink\":\"/pages/176808a1b5f843b8\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\01.基础\\\\20.计算属性 vs 方法 vs 侦听属性.md\",\"relativePath\":\"《Vue》笔记/01.基础/20.计算属性 vs 方法 vs 侦听属性.md\"},\"wordCount\":141,\"readingTime\":\"1m\",\"frontmatter\":{\"title\":\"计算属性 vs 方法 vs 侦听属性\",\"date\":{},\"permalink\":\"/pages/351f72ecd9c41129\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\01.基础\\\\30.v-if vs v-show.md\",\"relativePath\":\"《Vue》笔记/01.基础/30.v-if vs v-show.md\"},\"wordCount\":114,\"readingTime\":\"1m\",\"frontmatter\":{\"title\":\"v-if vs v-show\",\"date\":{},\"permalink\":\"/pages/73e4064340277b05\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\01.基础\\\\35.列表渲染之数组、对象更新检测.md\",\"relativePath\":\"《Vue》笔记/01.基础/35.列表渲染之数组、对象更新检测.md\"},\"wordCount\":1011,\"readingTime\":\"4m\",\"frontmatter\":{\"title\":\"列表渲染之数组、对象更新检测\",\"date\":{},\"permalink\":\"/pages/04783a6691cc9d06\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\02.组件\\\\36.使用组件的细节点.md\",\"relativePath\":\"《Vue》笔记/02.组件/36.使用组件的细节点.md\"},\"wordCount\":665,\"readingTime\":\"2.9m\",\"frontmatter\":{\"title\":\"使用组件的细节点\",\"date\":{},\"permalink\":\"/pages/83a1ab785e7fd70c\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\02.组件\\\\40.父组件给子组件传值.md\",\"relativePath\":\"《Vue》笔记/02.组件/40.父组件给子组件传值.md\"},\"wordCount\":456,\"readingTime\":\"1.9m\",\"frontmatter\":{\"title\":\"父组件给子组件传值\",\"date\":{},\"permalink\":\"/pages/07b384c2e6232e07\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\02.组件\\\\50.子组件派发事件和值给父组件.md\",\"relativePath\":\"《Vue》笔记/02.组件/50.子组件派发事件和值给父组件.md\"},\"wordCount\":212,\"readingTime\":\"1m\",\"frontmatter\":{\"title\":\"子组件派发事件和值给父组件\",\"date\":{},\"permalink\":\"/pages/0f19a1bcac14fd41\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\02.组件\\\\52.Prop 验证 与 非 Prop 的 Attribute.md\",\"relativePath\":\"《Vue》笔记/02.组件/52.Prop 验证 与 非 Prop 的 Attribute.md\"},\"wordCount\":332,\"readingTime\":\"1.4m\",\"frontmatter\":{\"title\":\"Prop 验证 与 非 Prop 的 Attribute\",\"date\":{},\"permalink\":\"/pages/a3080f60f6596eb4\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\02.组件\\\\55.自定义事件.md\",\"relativePath\":\"《Vue》笔记/02.组件/55.自定义事件.md\"},\"wordCount\":477,\"readingTime\":\"2m\",\"frontmatter\":{\"title\":\"自定义事件\",\"date\":{},\"permalink\":\"/pages/9651417d08d1779d\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\02.组件\\\\60.兄弟组件传值.md\",\"relativePath\":\"《Vue》笔记/02.组件/60.兄弟组件传值.md\"},\"wordCount\":114,\"readingTime\":\"1m\",\"frontmatter\":{\"title\":\"兄弟组件传值\",\"date\":{},\"permalink\":\"/pages/809f4582d9ca9552\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\02.组件\\\\65.非父子组件传值.md\",\"relativePath\":\"《Vue》笔记/02.组件/65.非父子组件传值.md\"},\"wordCount\":430,\"readingTime\":\"2m\",\"frontmatter\":{\"title\":\"非父子组件传值\",\"date\":{},\"permalink\":\"/pages/d408e64f666f146d\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\02.组件\\\\70.父组件调用子组件方法并传入值.md\",\"relativePath\":\"《Vue》笔记/02.组件/70.父组件调用子组件方法并传入值.md\"},\"wordCount\":78,\"readingTime\":\"1m\",\"frontmatter\":{\"title\":\"父组件调用子组件方法并传入值\",\"date\":{},\"permalink\":\"/pages/2e24dab728769e0c\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\02.组件\\\\75.插槽slot.md\",\"relativePath\":\"《Vue》笔记/02.组件/75.插槽slot.md\"},\"wordCount\":1331,\"readingTime\":\"6m\",\"frontmatter\":{\"title\":\"插槽slot\",\"date\":{},\"permalink\":\"/pages/055ecee9a4325386\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\02.组件\\\\80.动态组件与 v-once 指令.md\",\"relativePath\":\"《Vue》笔记/02.组件/80.动态组件与 v-once 指令.md\"},\"wordCount\":671,\"readingTime\":\"3m\",\"frontmatter\":{\"title\":\"动态组件与 v-once 指令\",\"date\":{},\"permalink\":\"/pages/636ca33122e9a64b\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\02.组件\\\\90.vue父子组件的生命周期顺序.md\",\"relativePath\":\"《Vue》笔记/02.组件/90.vue父子组件的生命周期顺序.md\"},\"wordCount\":102,\"readingTime\":\"1m\",\"frontmatter\":{\"title\":\"vue父子组件的生命周期顺序\",\"date\":{},\"permalink\":\"/pages/e6cec47efa42d7f1\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\03.过渡&动画\\\\110.transition过渡&动画.md\",\"relativePath\":\"《Vue》笔记/03.过渡&动画/110.transition过渡&动画.md\"},\"wordCount\":502,\"readingTime\":\"2.4m\",\"frontmatter\":{\"title\":\"transition过渡&动画\",\"date\":{},\"permalink\":\"/pages/184a96b493a97078\",\"categories\":[\"《Vue》笔记\",\"过渡&动画\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\03.过渡&动画\\\\112.使用animate库.md\",\"relativePath\":\"《Vue》笔记/03.过渡&动画/112.使用animate库.md\"},\"wordCount\":328,\"readingTime\":\"1.6m\",\"frontmatter\":{\"title\":\"使用animate库\",\"date\":{},\"permalink\":\"/pages/3b0a20e70805fcea\",\"categories\":[\"《Vue》笔记\",\"过渡&动画\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\03.过渡&动画\\\\120.transition-group列表过渡.md\",\"relativePath\":\"《Vue》笔记/03.过渡&动画/120.transition-group列表过渡.md\"},\"wordCount\":422,\"readingTime\":\"2.3m\",\"frontmatter\":{\"title\":\"transition-group列表过渡\",\"date\":{},\"permalink\":\"/pages/0aa92922ace6bb5e\",\"categories\":[\"《Vue》笔记\",\"过渡&动画\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\04.可复用性&组合\\\\01.Mixin混入.md\",\"relativePath\":\"《Vue》笔记/04.可复用性&组合/01.Mixin混入.md\"},\"wordCount\":703,\"readingTime\":\"2.8m\",\"frontmatter\":{\"title\":\"Mixin混入\",\"date\":{},\"permalink\":\"/pages/bd36a3c1bc3e0821\",\"categories\":[\"《Vue》笔记\",\"可复用性&组合\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\05.工具\\\\10.Vue CLi v3 创建项目使用记录.md\",\"relativePath\":\"《Vue》笔记/05.工具/10.Vue CLi v3 创建项目使用记录.md\"},\"wordCount\":977,\"readingTime\":\"4.8m\",\"frontmatter\":{\"title\":\"Vue CLi v3 创建项目使用记录\",\"date\":{},\"permalink\":\"/pages/d00311f8174119b2\",\"categories\":[\"《Vue》笔记\",\"工具\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\06.规模化\\\\100.vuex操作相关.md\",\"relativePath\":\"《Vue》笔记/06.规模化/100.vuex操作相关.md\"},\"wordCount\":121,\"readingTime\":\"1m\",\"frontmatter\":{\"title\":\"vuex操作相关\",\"date\":{},\"permalink\":\"/pages/d9d62d6ab8ff99a6\",\"categories\":[\"《Vue》笔记\",\"规模化\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\06.规模化\\\\140.路由懒加载.md\",\"relativePath\":\"《Vue》笔记/06.规模化/140.路由懒加载.md\"},\"wordCount\":159,\"readingTime\":\"1m\",\"frontmatter\":{\"title\":\"路由懒加载\",\"date\":{},\"permalink\":\"/pages/38ecac9a9b92f037\",\"categories\":[\"《Vue》笔记\",\"规模化\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\10.Vuex\\\\01.Vuex.md\",\"relativePath\":\"《Vue》笔记/10.Vuex/01.Vuex.md\"},\"wordCount\":3230,\"readingTime\":\"13.1m\",\"frontmatter\":{\"title\":\"Vuex\",\"date\":{},\"permalink\":\"/pages/b30620/\",\"categories\":[\"《Vue》笔记\",\"Vuex\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\99.其他\\\\79.Vue中编辑word文档以及预览word .md\",\"relativePath\":\"《Vue》笔记/99.其他/79.Vue中编辑word文档以及预览word .md\"},\"wordCount\":1484,\"readingTime\":\"8.2m\",\"frontmatter\":{\"title\":\"Vue中编辑word文档以及预览word\",\"date\":{},\"permalink\":\"/pages/1ebccd/\",\"categories\":[\"《Vue》笔记\",\"其他\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\99.其他\\\\80.Vue中的防抖函数封装和使用.md\",\"relativePath\":\"《Vue》笔记/99.其他/80.Vue中的防抖函数封装和使用.md\"},\"wordCount\":164,\"readingTime\":\"1m\",\"frontmatter\":{\"title\":\"Vue中的防抖函数封装和使用\",\"date\":{},\"permalink\":\"/pages/fb08e252dfd8fdfd\",\"categories\":[\"《Vue》笔记\",\"其他\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\99.其他\\\\90.操作本地缓存.md\",\"relativePath\":\"《Vue》笔记/99.其他/90.操作本地缓存.md\"},\"wordCount\":16,\"readingTime\":\"1m\",\"frontmatter\":{\"title\":\"操作本地缓存\",\"date\":{},\"permalink\":\"/pages/30a94dbe96873b33\",\"categories\":[\"《Vue》笔记\",\"其他\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}},{\"fileInfo\":{\"filePath\":\"E:\\\\project\\\\vuepress-theme-vdoing\\\\docs\\\\《Vue》笔记\\\\99.其他\\\\91.vue2与vue3生命周期对照表.md\",\"relativePath\":\"《Vue》笔记/99.其他/91.vue2与vue3生命周期对照表.md\"},\"wordCount\":25,\"readingTime\":\"1m\",\"frontmatter\":{\"title\":\"vue2与vue3生命周期对照表\",\"date\":{},\"permalink\":\"/pages/e866b9/\",\"categories\":[\"《Vue》笔记\",\"其他\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}}}],\"lastCommitTime\":\"2026-02-28 16:44:41\"},\"catalogues\":{\"arr\":[],\"map\":{},\"inv\":{}},\"posts\":{\"allPosts\":[{\"url\":\"/01.前端/25.JavaScript文章/01.33个非常实用的JavaScript一行代码.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/01.33个非常实用的JavaScript一行代码.html\",\"frontmatter\":{\"title\":\"33个非常实用的JavaScript一行代码\",\"date\":\"2021-11-02 09:51:37\",\"permalink\":\"/pages/a61298/\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[\"JavaScript\"],\"author\":\"CUGGZ\"},\"author\":\"CUGGZ\",\"title\":\"33个非常实用的JavaScript一行代码\",\"date\":\"2021-11-02 09:51:37\",\"capture\":\"一、日期处理\\n 1. 检察日期是否有效\\n该方法用于检测给出的日期是否有效：\\n```javascript\\nconst isDateValid = (...val) =\\nisDateValid(\\\"December 17, 1995 03:24:00\\\");  // true\\n复制代码\\n```\\n 2. 计算两个日期之间的间隔\\n该方法用于计算两个日期之间的间隔时间：\\n```javascript\\nconst dayDif = (date1, date2) =&gt; Math.ceil(Math.abs(date1.getTime() - date2.getTime()) / 86400000)\\ndayD\"},{\"url\":\"/01.前端/25.JavaScript文章/02.new命令原理.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/02.new命令原理.html\",\"frontmatter\":{\"title\":\"new命令原理\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/8143cc480faf9a11\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"new命令原理\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"new命令原理\\\" tabindex=\\\"-1\\\">new命令原理 <a class=\\\"header-anchor\\\" href=\\\"#new命令原理\\\" aria-label=\\\"Permalink to &quot;new命令原理&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>使用new命令时，它后面的函数依次执行下面的步骤：</p>\\n<ol>\\n<li>创建一个空对象，作为将要返回的实例对象。</li>\\n<li>将这个空对象的原型，指向构造函数的prototype属性。</li>\\n<li>将这个空对象赋值给函数内部的this关键字。</li>\\n<li>开始执行构造函数内部的代码。</li>\\n<li>如果构造函数内有返回值且为对象类型，则返回该对象，否则返回上面创建的实例对象。</li>\\n</ol>\\n\",\"capture\":\"使用new命令时，它后面的函数依次执行下面的步骤：\\n1. 创建一个空对象，作为将要返回的实例对象。\\n2. 将这个空对象的原型，指向构造函数的prototype属性。\\n3. 将这个空对象赋值给函数内部的this关键字。\\n4. 开始执行构造函数内部的代码。\\n5. 如果构造函数内有返回值且为对象类型，则返回该对象，否则返回上面创建的实例对象。\\n```js\\n// 构造函数\\nfunction Person(name,age){\\n    this.name = name\\n    this.age = age\\n}\\n// 自定义_new\\nfunction _new() {\\n  // 将 arguments 对\"},{\"url\":\"/01.前端/25.JavaScript文章/03.ES5面向对象.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/03.ES5面向对象.html\",\"frontmatter\":{\"title\":\"ES5面向对象\",\"date\":\"2020-02-22 10:35:43\",\"permalink\":\"/pages/b1af5cb8996363c5\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"ES5面向对象\",\"date\":\"2020-02-22 10:35:43\",\"capture\":\"```js\\n//面向对象封装\\nfunction Student(props){ // 构造函数 （构造函数内定于属性。尊从首字母大写的约定）\\n  this.name = props.name || '匿名';  // 默认‘匿名’\\n  this.grade = props.grade || 1;\\n}\\nStudent.prototype.hello = function(){ // 在构造函数的原型上定义方法\\n  console.log('你好,'+ this.name +'同学，你在'+ this.grade+'年级');\\n}\\n//使用\\nfunction createStudent(props\"},{\"url\":\"/01.前端/25.JavaScript文章/04.ES6面向对象.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/04.ES6面向对象.html\",\"frontmatter\":{\"title\":\"ES6面向对象\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/1f4123be6f45abcd\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"ES6面向对象\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```js\\n//面向对象封装\\nclass Student{ //定义类 (尊从首字母大写的约定)\\n    constructor(props){  // 构造函数 （构造函数内定于属性）\\n        this.name = props.name || '匿名'; // 默认'匿名'\\n      this.grade = props.grade || 1;\\n    }\\n    hello(){ // 在构造函数的原型上定义方法\\n        console.log(`你好,${this.name}同学，你在${this.grade}年级`);\\n    }\\n}\\n//使用\\nfunction c\"},{\"url\":\"/01.前端/25.JavaScript文章/06.多种数组去重性能对比.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/06.多种数组去重性能对比.html\",\"frontmatter\":{\"title\":\"多种数组去重性能对比\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/e808fba1fa8fbab2\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"多种数组去重性能对比\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"测试模板\\n```js\\n// 创建一个 1 ~ 10w 的数组，Array.from为ES6语法\\nlet arr1 = Array.from(new Array(1000000), (x, index) =\\n  return index\\n})\\nlet arr2 = Array.from(new Array(500000), (x, index) =&gt; {\\n  return index + index\\n})\\nlet start = new Date().getTime()\\nconsole.log('开始数组去重')\\n// 数组去重\\nfunction distinct(a, b) {\\n  le\"},{\"url\":\"/01.前端/25.JavaScript文章/07.js随机打乱数组.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/07.js随机打乱数组.html\",\"frontmatter\":{\"title\":\"JS随机打乱数组\",\"date\":\"2020-02-08 17:42:03\",\"permalink\":\"/pages/40b4db2d38ba85f2\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"JS随机打乱数组\",\"date\":\"2020-02-08 17:42:03\",\"capture\":\"```js\\nfunction shuffle(arr) { // 随机打乱数组\\n  let _arr = arr.slice() // 调用数组副本，不改变原数组\\n  for (let i = 0; i &lt; _arr.length; i++) {\\n    let j = getRandomInt(0, i)\\n    let t = _arr[i]\\n    _arr[i] = _arr[j]\\n    _arr[j] = t\\n  }\\n  return _arr\\n}\\nfunction getRandomInt(min, max) { // 获取min到max的一个随机数，包含min和max本身\"},{\"url\":\"/01.前端/25.JavaScript文章/08.判断是否为移动端浏览器.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/08.判断是否为移动端浏览器.html\",\"frontmatter\":{\"title\":\"判断是否为移动端浏览器\",\"date\":\"2020-01-04 15:25:11\",\"permalink\":\"/pages/40f623be692cf8bc\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"判断是否为移动端浏览器\",\"date\":\"2020-01-04 15:25:11\",\"capture\":\"```js\\nconst flag = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);\\nif(flag){\\n    // 移动端\\n} else {\\n    // PC端\\n}\\n```\"},{\"url\":\"/01.前端/25.JavaScript文章/09.将一维数组按指定长度转为二维数组.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/09.将一维数组按指定长度转为二维数组.html\",\"frontmatter\":{\"title\":\"将一维数组按指定长度转为二维数组\",\"date\":\"2020-02-23 13:49:31\",\"permalink\":\"/pages/f1acb712033ac8da\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"将一维数组按指定长度转为二维数组\",\"date\":\"2020-02-23 13:49:31\",\"capture\":\"将一维数组按指定长度转为二维数组\\n```js\\nfunction pages(arr, len) {\\n    const pages = []\\n    arr.forEach((item, index) =\\n        const page = Math.floor(index / len)\\n        if (!pages[page]) {\\n            pages[page] = []\\n        }\\n        pages[page].push(item)\\n    })\\n    return pages\\n}\\n// 使用\\nconst arr = [1, 2, 3, \"},{\"url\":\"/01.前端/25.JavaScript文章/10.防抖与节流函数.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/10.防抖与节流函数.html\",\"frontmatter\":{\"title\":\"防抖与节流函数\",\"date\":\"2020-02-29 15:07:47\",\"permalink\":\"/pages/0f6a0ac99b62ede5\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"防抖与节流函数\",\"date\":\"2020-02-29 15:07:47\",\"excerpt\":\"<h1 id=\\\"防抖与节流函数\\\" tabindex=\\\"-1\\\">防抖与节流函数 <a class=\\\"header-anchor\\\" href=\\\"#防抖与节流函数\\\" aria-label=\\\"Permalink to &quot;防抖与节流函数&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>防抖和节流的作用都是在高频事件中防止函数被多次调用，是一种性能优化的方案。</p>\\n<p>区别在于，防抖函数只会在高频事件结束后n毫秒调用一次函数，节流函数会在高频事件触发过程当中每隔n毫秒调用一次函数。</p>\\n\",\"capture\":\"防抖和节流的作用都是在高频事件中防止函数被多次调用，是一种性能优化的方案。\\n区别在于，防抖函数只会在高频事件结束后n毫秒调用一次函数，节流函数会在高频事件触发过程当中每隔n毫秒调用一次函数。\\n 防抖函数\\n触发高频事件后一段时间（wait）只会执行一次函数，如果指定时间（wait）内高频事件再次被触发，则重新计算时间。\\n 封装\\n```js\\n// 防抖函数\\nfunction debounce(func, wait) {\\n    let timeout = null;\\n    return function () {\\n        let context = this;\\n        let a\"},{\"url\":\"/01.前端/25.JavaScript文章/11.JS获取和修改url参数.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/11.JS获取和修改url参数.html\",\"frontmatter\":{\"title\":\"JS获取和修改url参数\",\"date\":\"2020-03-05 12:45:37\",\"permalink\":\"/pages/7a91be2d502346ce\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"JS获取和修改url参数\",\"date\":\"2020-03-05 12:45:37\",\"capture\":\"获取url参数\\n```js\\n/**\\n * 获取url里的参数\\n * @param arg 参数名\\n * @returns\\n */\\nfunction getURLString(arg) {\\n    var reg = new RegExp(\\\"(^|&)\\\" + arg + \\\"=([^&]*)(&|$)\\\", \\\"i\\\");\\n    var r = window.location.search.substr(1).match(reg);\\n    if (r != null)\\n        return unescape(r[2]);\\n    return null;\\n}\\n```\\n 修改url参数\\n```\"},{\"url\":\"/01.前端/25.JavaScript文章/1110.三级目录/00.四级文件.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/1110.三级目录/00.四级文件.html\",\"frontmatter\":{\"title\":\"四级文件(测试)\",\"date\":\"2020-12-11 11:15:53\",\"permalink\":\"/pages/8481d1/\",\"categories\":[\"前端\",\"JavaScript文章\",\"三级目录\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"四级文件(测试)\",\"date\":\"2020-12-11 11:15:53\",\"capture\":\"测试文件\\nTest Test\\n&lt;code-group\\n  &lt;code-block title=\\\"YARN\\\" active&gt;\\n  ```bash\\n  yarn create vuepress-site [optionalDirectoryName]\\n   OR npx create-vuepress-site [optionalDirectoryName]\\n  ```\\n  &lt;/code-block&gt;\\n  &lt;code-block title=\\\"NPM\\\"&gt;\\n  ```bash\\n  npx create-vuepress-site [optionalDirec\"},{\"url\":\"/01.前端/25.JavaScript文章/12.比typeof运算符更准确的类型判断.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/12.比typeof运算符更准确的类型判断.html\",\"frontmatter\":{\"title\":\"比typeof运算符更准确的类型判断\",\"date\":\"2020-04-13 15:56:54\",\"permalink\":\"/pages/fd4a16d56b83c1bc\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"比typeof运算符更准确的类型判断\",\"date\":\"2020-04-13 15:56:54\",\"capture\":\"不同数据类型的`Object.prototype.toString`方法返回值如下。\\n- 数值：返回`[object Number]`。\\n- 字符串：返回`[object String]`。\\n- 布尔值：返回`[object Boolean]`。\\n- undefined：返回`[object Undefined]`。\\n- null：返回`[object Null]`。\\n- 数组：返回`[object Array]`。\\n- arguments 对象：返回`[object Arguments]`。\\n- 函数：返回`[object Function]`。\\n- Error 对象：返回`[object \"},{\"url\":\"/01.前端/25.JavaScript文章/13.javascript常用类型数值比较图.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/13.javascript常用类型数值比较图.html\",\"frontmatter\":{\"title\":\"javascript常用类型数值比较图\",\"date\":\"2023-09-08 13:34:43\",\"permalink\":\"/pages/360851/\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"javascript常用类型数值比较图\",\"date\":\"2023-09-08 13:34:43\",\"capture\":\"\"},{\"url\":\"/01.前端/25.JavaScript文章/14.js获取当前URL,域名,端口号.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/14.js获取当前URL,域名,端口号.html\",\"frontmatter\":{\"title\":\"js获取当前URL,域名,端口号\",\"date\":\"2023-09-08 13:57:22\",\"permalink\":\"/pages/c81259/\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"js获取当前URL,域名,端口号\",\"date\":\"2023-09-08 13:57:22\",\"capture\":\"| href | 完整的 URL | https://www.baidu.com:200/s?wd=1 |\\n| --- | --- | --- |\\n| protocol | 协议 | https: |\\n| hostname | 主机名 | www.baidu.com |\\n| port | 端口号 | 200 |\\n| host | 主机名+端口号 | www.baidu.com:200 |\\n```javascript\\nlet protocol = window.location.protocol,host = window.location.host;\\nlet url = `${protocol\"},{\"url\":\"/01.前端/25.JavaScript文章/15.js实现深度优先遍历和广度优先遍历.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/15.js实现深度优先遍历和广度优先遍历.html\",\"frontmatter\":{\"title\":\"js实现深度优先遍历和广度优先遍历\",\"date\":\"2023-09-08 14:16:56\",\"permalink\":\"/pages/690414/\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"js实现深度优先遍历和广度优先遍历\",\"date\":\"2023-09-08 14:16:56\",\"capture\":\"什么是深度优先和广度优先\\n深度优先遍历用的是栈，而广度优先遍历要用队列来实现,深度优先就是自上而下的遍历搜索 广度优先则是逐层遍历, 如下图所示(图左深度优先遍历,图右广度)\\n 深度优先遍历\\n 广度优先遍历\\n 两者的区别\\n对于算法来说 无非就是时间换空间 空间换时间\\n1. 深度优先不需要记住所有的节点, 所以占用空间小, 而广度优先需要先记录所有的节点占用空间大\\n2. 深度优先有回溯的操作(没有路走了需要回头)所以相对而言时间会长一点\\n深度优先采用的是堆栈的形式, 即先进后出\\n广度优先则采用的是队列的形式, 即先进先出\\n```jsx\\nconst data = [\\n  {\\n      name:\"},{\"url\":\"/01.前端/40.学习笔记/00.《JavaScript教程》笔记.html\",\"relativePath\":\"/01.前端/40.学习笔记/00.《JavaScript教程》笔记.html\",\"frontmatter\":{\"pageComponent\":{\"name\":\"Catalogue\",\"data\":{\"path\":\"《JavaScript教程》笔记\",\"imgUrl\":\"https://www.runoob.com/wp-content/uploads/2013/07/js-logo.png\",\"description\":\"本章内容为博主在原教程基础上添加学习笔记，教程版权归原作者所有。来源：<a href='https://wangdoc.com/javascript/' target='_blank'>JavaScript教程</a>\"}},\"title\":\"《JavaScript教程》笔记\",\"date\":\"2020-01-12 11:51:53\",\"permalink\":\"/note/javascript/\",\"article\":false,\"comment\":false,\"editLink\":false,\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"《JavaScript教程》笔记\",\"date\":\"2020-01-12 11:51:53\",\"capture\":\"\"},{\"url\":\"/01.前端/40.学习笔记/05.《JavaScript高级程序设计》笔记.html\",\"relativePath\":\"/01.前端/40.学习笔记/05.《JavaScript高级程序设计》笔记.html\",\"frontmatter\":{\"title\":\"《JavaScript高级程序设计》笔记\",\"date\":\"2020-06-12 12:39:01\",\"permalink\":\"/note/js/\",\"categories\":[\"笔记\"],\"tags\":[\"笔记\",\"红宝书\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"《JavaScript高级程序设计》笔记\",\"date\":\"2020-06-12 12:39:01\",\"capture\":\"第1章  JavaScript简介\\n* JavaScript诞生于1995年\\n* 一个完整的JavaScript由这三部分组成：\\n  * ECMAScript (核心)\\n  * DOM (文档对象模型)\\n  * BOM (浏览器对象模型)\\n* ECMAScript的 宿主环境 包含 ：\\n  * 浏览器\\n  * Node\\n  * flash\\n* ECMAScript大致规定了下列组成部分：\\n  * 语法\\n  * 类型\\n  * 语句\\n  * 关键字\\n  * 保留字\\n  * 操作符\\n  * 对象\\n 第2章 在HTML中使用JavaScript\\n* `&lt;script\\n  * async 表示立即\"},{\"url\":\"/01.前端/40.学习笔记/10.《ES6 教程》笔记.html\",\"relativePath\":\"/01.前端/40.学习笔记/10.《ES6 教程》笔记.html\",\"frontmatter\":{\"pageComponent\":{\"name\":\"Catalogue\",\"data\":{\"path\":\"《ES6 教程》笔记\",\"imgUrl\":\"https://www.runoob.com/wp-content/uploads/2017/08/20130807-es6-e1420205362328.png\",\"description\":\"本章内容为博主在原教程基础上添加学习笔记，教程版权归原作者所有。来源：<a href='https://es6.ruanyifeng.com/' target='_blank'>ES6教程</a>\"}},\"title\":\"《ES6 教程》笔记\",\"date\":\"2020-01-12 15:49:22\",\"permalink\":\"/note/es6/\",\"article\":false,\"comment\":false,\"editLink\":false,\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"《ES6 教程》笔记\",\"date\":\"2020-01-12 15:49:22\",\"capture\":\"\"},{\"url\":\"/01.前端/40.学习笔记/20.《Vue》笔记.html\",\"relativePath\":\"/01.前端/40.学习笔记/20.《Vue》笔记.html\",\"frontmatter\":{\"pageComponent\":{\"name\":\"Catalogue\",\"data\":{\"path\":\"《Vue》笔记\",\"imgUrl\":\"https://v2.cn.vuejs.org/images/logo.svg\",\"description\":\"本章内容是博主的Vue学习笔记，非教程文档，请以官方文档为准。\"}},\"title\":\"《Vue》笔记\",\"date\":\"2020-02-04 12:16:12\",\"permalink\":\"/note/vue/\",\"article\":false,\"comment\":false,\"editLink\":false,\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"《Vue》笔记\",\"date\":\"2020-02-04 12:16:12\",\"capture\":\"\"},{\"url\":\"/01.前端/40.学习笔记/33.《Git》学习笔记.html\",\"relativePath\":\"/01.前端/40.学习笔记/33.《Git》学习笔记.html\",\"frontmatter\":{\"pageComponent\":{\"name\":\"Catalogue\",\"data\":{\"path\":\"《Git》学习笔记\",\"imgUrl\":\"https://avatars3.githubusercontent.com/u/18133?s=200&v=4\",\"description\":\"<a href='https://git-scm.com/book/zh/v2' target='_blank'>Git官网文档</a>的学习笔记，以官方文档为准。\"}},\"title\":\"《Git》学习笔记\",\"date\":\"2020-11-18 17:40:48\",\"permalink\":\"/note/git/\",\"article\":false,\"comment\":false,\"editLink\":false,\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"《Git》学习笔记\",\"date\":\"2020-11-18 17:40:48\",\"capture\":\"\"},{\"url\":\"/01.前端/40.学习笔记/35.TypeScript笔记.html\",\"relativePath\":\"/01.前端/40.学习笔记/35.TypeScript笔记.html\",\"frontmatter\":{\"title\":\"TypeScript笔记\",\"date\":\"2020-10-08 13:02:48\",\"permalink\":\"/pages/51afd6/\",\"categories\":[\"前端\",\"学习笔记\"],\"tags\":[\"TypeScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"TypeScript笔记\",\"date\":\"2020-10-08 13:02:48\",\"capture\":\"TypeScript 的类型校验是给程序员看的，在编译后不会存在TS代码。\\n 类型注解\\n```typescript\\nfunction fn(person: string):void{ // 参数类型是字符串，没有返回值\\n    ///...\\n}\\nfn('str') // 如传递参数非字符串，vscode编辑器中或在编译时将给出错误提示\\nconst test:number = 1\\n```\\n 有哪些基础类型注解？\\n```typescript\\n// 基础类型\\n:string\\n:number\\n:boolean\\n:null  // 只能是null值\\n:undefined // 只能是undefined值\"},{\"url\":\"/01.前端/40.学习笔记/40.小程序笔记.html\",\"relativePath\":\"/01.前端/40.学习笔记/40.小程序笔记.html\",\"frontmatter\":{\"title\":\"小程序笔记\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/note/wx-miniprogram/\",\"tags\":[\"小程序\"],\"categories\":[\"前端\",\"学习笔记\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"小程序笔记\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"小程序笔记\\n 基础课程部分\\n 微信公众平台\\n&lt;https://mp.weixin.qq.com/\\n注册时可选择类型：订阅号、服务号、小程序、企业微信\\n每个邮箱仅能注册一个小程序。\\n个人类型小程序：无法使用微信支付、无法使用卡包功能\\n 小程序文档API\\n小程序开发文档\\n 微信开放社区\\n微信开发社区\\n 目录说明\\n默认目录\\npages-----------------------页面相关\\n​\\tindex  ----------------- 首页文件夹\\n​\\t\\tindex.js ------------首页js\\n​\\t\\tindex.json---------首页配置\\n​\\t\\tindex.wxml--\"},{\"url\":\"/01.前端/40.学习笔记/50.JS设计模式总结笔记.html\",\"relativePath\":\"/01.前端/40.学习笔记/50.JS设计模式总结笔记.html\",\"frontmatter\":{\"title\":\"JS设计模式总结笔记\",\"date\":\"2021-02-27 20:01:18\",\"permalink\":\"/pages/4643cd/\",\"categories\":[\"前端\",\"学习笔记\"],\"tags\":[\"设计模式\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"JS设计模式总结笔记\",\"date\":\"2021-02-27 20:01:18\",\"capture\":\"开篇：前端工程师的成长论\\n能够决定一个前端工程师的本质的，不是那些瞬息万变的技术点，而是那些不变的东西。\\n所谓“不变的东西”，就是驾驭技术的能力。\\n具体来说，它分为以下三个层次：\\n- 能用健壮的代码去解决具体的问题；\\n- 能用抽象的思维去应对复杂的系统；\\n- 能用工程化的思想去规划更大规模的业务。\\n\\n 设计模式之“道”\\n- 设计模式是“拿来主义”。如使用数学公式，不会从头推导一个公式。\\n  核心思想\\n- 设计模式的核心思想——封装变化\\n- 保证可维护性、可扩展性。\\n- 将变与不变分离，确保变化的部分灵活，不变的部分稳定。——这就是所谓的“健壮”的代码。\\n 设计模式之“术”\\n即最经典的23种设计\"},{\"url\":\"/01.前端/40.学习笔记/60.《Electron》笔记.html\",\"relativePath\":\"/01.前端/40.学习笔记/60.《Electron》笔记.html\",\"frontmatter\":{\"pageComponent\":{\"name\":\"Catalogue\",\"data\":{\"path\":\"《Electron》笔记\",\"imgUrl\":\"https://www.electronjs.org/assets/img/logo.svg\",\"description\":\"Electron 是一个使用 JavaScript、HTML 和 CSS 构建桌面应用程序的框架。\"}},\"title\":\"《Electron》笔记\",\"date\":\"2023-09-09 13:48:17\",\"permalink\":\"/note/electron/\",\"article\":false,\"comment\":false,\"editLink\":false,\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"《Electron》笔记\",\"date\":\"2023-09-09 13:48:17\",\"capture\":\"\"},{\"url\":\"/02.页面/10.HTML/10.常用meta整理.html\",\"relativePath\":\"/02.页面/10.HTML/10.常用meta整理.html\",\"frontmatter\":{\"title\":\"常用meta整理\",\"date\":\"2020-02-21 12:20:10\",\"permalink\":\"/pages/8309a5b876fc95e3\",\"categories\":[\"页面\",\"HTML\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"常用meta整理\",\"date\":\"2020-02-21 12:20:10\",\"excerpt\":\"<h1 id=\\\"常用meta整理\\\" tabindex=\\\"-1\\\">常用meta整理 <a class=\\\"header-anchor\\\" href=\\\"#常用meta整理\\\" aria-label=\\\"Permalink to &quot;常用meta整理&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"meta-元素\\\" tabindex=\\\"-1\\\">&lt;meta&gt; 元素 <a class=\\\"header-anchor\\\" href=\\\"#meta-元素\\\" aria-label=\\\"Permalink to &quot;&lt;meta\\\\&gt; 元素&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"概要\\\" tabindex=\\\"-1\\\">概要 <a class=\\\"header-anchor\\\" href=\\\"#概要\\\" aria-label=\\\"Permalink to &quot;概要&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>meta标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。</p>\\n\",\"capture\":\"&lt;meta\\\\\\n 概要\\nmeta标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。\\n必要属性\\n| 属性    | 值        | 描述                                   |\\n| ------- | --------- | -------------------------------------- |\\n| content | some text | 定义与http-equiv或name属性相关的元信息 |\\n可选属性\\n| 属性     \"},{\"url\":\"/02.页面/20.CSS/00.CSS教程和技巧收藏.html\",\"relativePath\":\"/02.页面/20.CSS/00.CSS教程和技巧收藏.html\",\"frontmatter\":{\"title\":\"CSS教程和技巧收藏\",\"date\":\"2020-08-11 17:13:52\",\"permalink\":\"/pages/c8f128/\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"CSS教程和技巧收藏\",\"date\":\"2020-08-11 17:13:52\",\"capture\":\"Flex 布局教程：语法篇\\n&lt;http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\\n CSS Grid 网格布局教程\\n&lt;http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html&gt;\\n 只要一行代码，实现五种 CSS 经典布局\\n&lt;http://www.ruanyifeng.com/blog/2020/08/five-css-layouts-in-one-line.html&gt;\\n* 空间居中布局\\n  &gt; 不管容器的大小，项目总是占据中心\"},{\"url\":\"/02.页面/20.CSS/01.flex布局语法.html\",\"relativePath\":\"/02.页面/20.CSS/01.flex布局语法.html\",\"frontmatter\":{\"title\":\"flex布局语法\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/0a83b083bdf257cb\",\"author\":{\"name\":\"阮一峰\"},\"categories\":[\"页面\",\"CSS\"],\"tags\":[null]},\"author\":{\"name\":\"阮一峰\"},\"title\":\"flex布局语法\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"flex布局语法\\\" tabindex=\\\"-1\\\">flex布局语法 <a class=\\\"header-anchor\\\" href=\\\"#flex布局语法\\\" aria-label=\\\"Permalink to &quot;flex布局语法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"一、flex-布局是什么\\\" tabindex=\\\"-1\\\">一、flex 布局是什么？ <a class=\\\"header-anchor\\\" href=\\\"#一、flex-布局是什么\\\" aria-label=\\\"Permalink to &quot;一、flex 布局是什么？&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>Flex是 Flexible Box 的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性。</p>\\n<p><strong>任何一个容器</strong> 都可以指定为 Flex 布局。</p>\\n\",\"capture\":\"一、flex 布局是什么？\\nFlex是 Flexible Box 的缩写，意为\\\"弹性布局\\\"，用来为盒状模型提供最大的灵活性。\\n任何一个容器 都可以指定为 Flex 布局。\\n```css\\n.box{\\n  display: flex;\\n}\\n```\\n行内元素 也可以使用 Flex 布局。\\n```css\\n.box{\\n  display: inline-flex;\\n}\\n```\\nWebkit 内核的浏览器，必须加上`-webkit`前缀。\\n```css\\n.box{\\n  display: -webkit-flex; /* Safari */\\n  display: flex;\\n}\\n```\\n注意，设为 Flex\"},{\"url\":\"/02.页面/20.CSS/02.flex布局案例-基础.html\",\"relativePath\":\"/02.页面/20.CSS/02.flex布局案例-基础.html\",\"frontmatter\":{\"title\":\"flex布局案例-基础\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/ea6db1530c42ad51\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"flex布局案例-基础\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"``` html\\n&lt;html&gt;\\n  &lt;div class=\\\"box\\\"&gt;\\n    &lt;span&gt;1&lt;/span&gt;\\n    &lt;span&gt;2&lt;/span&gt;\\n    &lt;span&gt;3&lt;/span&gt;\\n    &lt;span&gt;4&lt;/span&gt;\\n    &lt;span&gt;5&lt;/span&gt;\\n    &lt;span&gt;6&lt;/span&gt;\\n    &lt;span&gt;7&lt;/span&gt;\\n  &lt;/div&gt;\\n&lt;/html&gt;\\n&lt;st\"},{\"url\":\"/02.页面/20.CSS/03.flex布局案例-骰子.html\",\"relativePath\":\"/02.页面/20.CSS/03.flex布局案例-骰子.html\",\"frontmatter\":{\"title\":\"flex布局案例-骰子\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/eff61bc8b4f4695d\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"flex布局案例-骰子\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```html\\n&lt;html&gt;\\n  &lt;div class=\\\"box2\\\"&gt;\\n    &lt;div class=\\\"first-face\\\"&gt;\\n      &lt;span class=\\\"pip\\\"&gt;&lt;/span&gt;\\n    &lt;/div&gt;\\n    &lt;div class=\\\"second-face\\\"&gt;\\n      &lt;span class=\\\"pip\\\"&gt;&lt;/span&gt;\\n      &lt;span class=\\\"pip\\\"&gt;&lt;/span&gt;\\n    &lt;/div&gt;\\n    &lt;div cla\"},{\"url\":\"/02.页面/20.CSS/04.flex布局案例-圣杯布局.html\",\"relativePath\":\"/02.页面/20.CSS/04.flex布局案例-圣杯布局.html\",\"frontmatter\":{\"title\":\"flex布局案例-圣杯布局\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/df9e7c7214fa5046\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"flex布局案例-圣杯布局\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```html\\n&lt;html&gt;\\n  &lt;div class=\\\"HolyGrail\\\"&gt;\\n    &lt;header&gt;header&lt;/header&gt;\\n    &lt;div class=\\\"wrap\\\"&gt;\\n      &lt;nav class=\\\"left\\\"&gt;left 宽度固定200px&lt;/nav&gt;\\n      &lt;main class=\\\"content\\\"&gt;center 宽度自适应&lt;/main&gt;\\n      &lt;aside class=\\\"right\\\"&gt;right 宽度固定200px&lt;/aside&gt\"},{\"url\":\"/02.页面/20.CSS/05.flex布局案例-网格布局.html\",\"relativePath\":\"/02.页面/20.CSS/05.flex布局案例-网格布局.html\",\"frontmatter\":{\"title\":\"flex布局案例-网格布局\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/85b5a3fe218a34b7\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"flex布局案例-网格布局\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```html\\n&lt;html&gt;\\n  &lt;div class=\\\"grid\\\"&gt;\\n    &lt;div class=\\\"grid-cell\\\"&gt;1/2&lt;/div&gt;\\n    &lt;div class=\\\"grid-cell\\\"&gt;1/2&lt;/div&gt;\\n  &lt;/div&gt;\\n  &lt;div class=\\\"grid\\\"&gt;\\n    &lt;div class=\\\"grid-cell\\\"&gt;1/3&lt;/div&gt;\\n    &lt;div class=\\\"grid-cell\\\"&gt;1/3&lt;/div&gt;\\n    &lt;div cl\"},{\"url\":\"/02.页面/20.CSS/06.flex布局案例-输入框布局.html\",\"relativePath\":\"/02.页面/20.CSS/06.flex布局案例-输入框布局.html\",\"frontmatter\":{\"title\":\"flex布局案例-输入框布局\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/05cc577fb51c7998\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"flex布局案例-输入框布局\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```html\\n&lt;html&gt;\\n  &lt;div class=\\\"InputAddOn\\\"&gt;\\n    &lt;span class=\\\"InputAddOn-item\\\"&gt;icon&lt;/span&gt;\\n    &lt;input class=\\\"InputAddOn-field\\\" placeholder=\\\"input宽度自适应\\\"&gt;\\n    &lt;button class=\\\"InputAddOn-item\\\"&gt;提交&lt;/button&gt;\\n  &lt;/div&gt;\\n  &lt;br/&gt;\\n  &lt;div class=\\\"Media\\\"&gt;\\n   \"},{\"url\":\"/02.页面/20.CSS/07.CSS3之transition过渡.html\",\"relativePath\":\"/02.页面/20.CSS/07.CSS3之transition过渡.html\",\"frontmatter\":{\"title\":\"CSS3之transition过渡\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/02d7f59d98d87409\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"CSS3之transition过渡\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"html结构\\n```html\\n&lt;div class=\\\"box1\\\"\\n  &lt;div class=\\\"div1\\\"&gt;&lt;/div&gt;\\n  &lt;div class=\\\"div2\\\"&gt;&lt;/div&gt;\\n  &lt;div class=\\\"div3\\\"&gt;&lt;/div&gt;\\n&lt;/div&gt;\\n```\\n先给元素设置transition过渡，指定样式和时间，这里设置all全部样式都采用0.3s的过渡\\n```css\\n.box1&gt;div{\\n  /* 给元素所有变化都添加过渡动画, 也可以指定唯一的过渡样式属性*/\\n  transition: all .3s;\"},{\"url\":\"/02.页面/20.CSS/08.CSS3之animation动画.html\",\"relativePath\":\"/02.页面/20.CSS/08.CSS3之animation动画.html\",\"frontmatter\":{\"title\":\"CSS3之animation动画\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/c2c0432138f6e042\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"CSS3之animation动画\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```html\\n&lt;html&gt;\\n  &lt;div class=\\\"animationBox\\\"&gt;\\n    &lt;div class=\\\"rotate\\\"&gt;旋转动画1&lt;/div&gt;\\n    &lt;div class=\\\"play\\\"&gt;\\n      &lt;div class=\\\"img\\\"&gt;旋转动画2&lt;/div&gt;\\n      &lt;span&gt;&lt;p class=\\\"p2\\\"&gt;&lt;/p&gt;&lt;/span&gt;\\n      &lt;span&gt;&lt;p&gt;&lt;/p&gt;&lt;/span&gt;\\n      &\"},{\"url\":\"/02.页面/20.CSS/09.「布局技巧」图片未加载前自动撑开元素高度.html\",\"relativePath\":\"/02.页面/20.CSS/09.「布局技巧」图片未加载前自动撑开元素高度.html\",\"frontmatter\":{\"title\":\"「布局技巧」图片未加载前自动撑开元素高度\",\"date\":\"2020-02-22 16:37:10\",\"permalink\":\"/pages/3d52574260725aea\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"「布局技巧」图片未加载前自动撑开元素高度\",\"date\":\"2020-02-22 16:37:10\",\"excerpt\":\"<h1 id=\\\"「布局技巧」图片未加载前自动撑开元素高度\\\" tabindex=\\\"-1\\\">「布局技巧」图片未加载前自动撑开元素高度 <a class=\\\"header-anchor\\\" href=\\\"#「布局技巧」图片未加载前自动撑开元素高度\\\" aria-label=\\\"Permalink to &quot;「布局技巧」图片未加载前自动撑开元素高度&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>在移动端开发中，有一些元素是根据图片高度来自动撑开的 ，高度不能写死（如轮播图的外层元素）。在网络较慢的情况下，图片加载需要一些时间，此时该元素的高度没有被撑开，在网页布局上会有一些不想看到的效果。</p>\\n\",\"capture\":\"在移动端开发中，有一些元素是根据图片高度来自动撑开的 ，高度不能写死（如轮播图的外层元素）。在网络较慢的情况下，图片加载需要一些时间，此时该元素的高度没有被撑开，在网页布局上会有一些不想看到的效果。\\n这种情况我们可以设置如下样式来设置该元素的高度：\\n```stylus\\n.wrapper\\n  overflow hidden\\n  width 100%\\n  height 0\\n  padding-bottom 26.66% // 这个数值是图片的高宽比，即 高/宽\\n  background eee\\n```\\n上面代码中，`padding-bottom` 的取值是图片的高宽比（即，高/宽），它会根据 `w\"},{\"url\":\"/02.页面/20.CSS/10.文字在一行或多行时超出显示省略号.html\",\"relativePath\":\"/02.页面/20.CSS/10.文字在一行或多行时超出显示省略号.html\",\"frontmatter\":{\"title\":\"文字在一行或多行时超出显示省略号\",\"date\":\"2020-02-23 15:07:08\",\"permalink\":\"/pages/42b66999cc27dc25\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"文字在一行或多行时超出显示省略号\",\"date\":\"2020-02-23 15:07:08\",\"excerpt\":\"<h1 id=\\\"文字在一行或多行时超出显示省略号\\\" tabindex=\\\"-1\\\">文字在一行或多行时超出显示省略号 <a class=\\\"header-anchor\\\" href=\\\"#文字在一行或多行时超出显示省略号\\\" aria-label=\\\"Permalink to &quot;文字在一行或多行时超出显示省略号&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"一行超出显示省略\\\" tabindex=\\\"-1\\\">一行超出显示省略 <a class=\\\"header-anchor\\\" href=\\\"#一行超出显示省略\\\" aria-label=\\\"Permalink to &quot;一行超出显示省略&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<div class=\\\"language-css vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">css</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">overflow: hidden;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">white-space</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">: nowrap;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">text-overflow</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">: ellipsis;</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br></div></div>\",\"capture\":\"一行超出显示省略\\n```css\\noverflow: hidden;\\nwhite-space: nowrap;\\ntext-overflow: ellipsis;\\n```\\n```html\\n&lt;html\\n   &lt;div class=\\\"box-42b6\\\"&gt;演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字&lt;/div&gt;\\n&lt;/html&gt;\\n&lt;style&gt;\\n    .box-42b6{\\n        border: 1px solid 999;\\n        width\"},{\"url\":\"/02.页面/20.CSS/11.从box-sizing属性入手，了解盒子模型.html\",\"relativePath\":\"/02.页面/20.CSS/11.从box-sizing属性入手，了解盒子模型.html\",\"frontmatter\":{\"title\":\"从box-sizing属性入手，了解盒子模型\",\"date\":\"2020-02-27 17:08:48\",\"permalink\":\"/pages/20a978023139589d\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"从box-sizing属性入手，了解盒子模型\",\"date\":\"2020-02-27 17:08:48\",\"excerpt\":\"<h1 id=\\\"从box-sizing属性入手-了解盒子模型\\\" tabindex=\\\"-1\\\">从box-sizing属性入手，了解盒子模型 <a class=\\\"header-anchor\\\" href=\\\"#从box-sizing属性入手-了解盒子模型\\\" aria-label=\\\"Permalink to &quot;从box-sizing属性入手，了解盒子模型&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"背景\\\" tabindex=\\\"-1\\\">背景 <a class=\\\"header-anchor\\\" href=\\\"#背景\\\" aria-label=\\\"Permalink to &quot;背景&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>先声明一下运用的场景，假如项目布局使用的是<strong>自适应</strong>的布局方式，div给出的宽度是<strong>百分比</strong>的形式，即占窗口宽度的100%，但边框<code>border</code>和内边距<code>padding</code>是用像素来表示的，此时就会造成一个问题是div总宽度超过窗口宽度。为了避免这种问题，可以使用属性<code>box-sizing:border-box</code>来把 <strong>标准盒模型</strong> 变成 <strong>代替(IE)盒模型</strong> ，从而使div的总宽度依然是100%</p>\\n\",\"capture\":\"背景\\n先声明一下运用的场景，假如项目布局使用的是自适应的布局方式，div给出的宽度是百分比的形式，即占窗口宽度的100%，但边框`border`和内边距`padding`是用像素来表示的，此时就会造成一个问题是div总宽度超过窗口宽度。为了避免这种问题，可以使用属性`box-sizing:border-box`来把 标准盒模型 变成 代替(IE)盒模型 ，从而使div的总宽度依然是100%\\n 什么是CSS 盒模型?\\n页面布局中，一个元素的外边距（margin）、 边框（border）、内边距（padding）、内容（content）组成一个盒模型。盒模型可分为标准盒模型 和 代替（IE）盒模型\"},{\"url\":\"/02.页面/20.CSS/12.水平垂直居中的几种方式-案例.html\",\"relativePath\":\"/02.页面/20.CSS/12.水平垂直居中的几种方式-案例.html\",\"frontmatter\":{\"title\":\"水平垂直居中的几种方式-案例\",\"date\":\"2020-03-13 16:13:43\",\"permalink\":\"/pages/cb7cb251adba4bf7\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"水平垂直居中的几种方式-案例\",\"date\":\"2020-03-13 16:13:43\",\"capture\":\"&lt;iframe height=\\\"880\\\" style=\\\"width: 100%;\\\" scrolling=\\\"no\\\" title=\\\"水平垂直居中的几种方式\\\" src=\\\"https://codepen.io/xugaoyi/embed/poJLeYv?height=880&theme-id=light&default-tab=result\\\" frameborder=\\\"no\\\" allowtransparency=\\\"true\\\" allowfullscreen=\\\"true\\\"\\n  See the Pen &lt;a href='https://codepen.io/xugaoyi/pen/poJLeY\"},{\"url\":\"/02.页面/20.CSS/13.如何根据系统主题自动响应CSS深色模式.html\",\"relativePath\":\"/02.页面/20.CSS/13.如何根据系统主题自动响应CSS深色模式.html\",\"frontmatter\":{\"title\":\"如何根据系统主题自动响应CSS深色模式\",\"date\":\"2020-03-31 14:06:26\",\"permalink\":\"/pages/5dde351274f1e39d\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[\"css\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"如何根据系统主题自动响应CSS深色模式\",\"date\":\"2020-03-31 14:06:26\",\"excerpt\":\"<h1 id=\\\"如何根据系统主题自动响应css深色模式\\\" tabindex=\\\"-1\\\">如何根据系统主题自动响应CSS深色模式 <a class=\\\"header-anchor\\\" href=\\\"#如何根据系统主题自动响应css深色模式\\\" aria-label=\\\"Permalink to &quot;如何根据系统主题自动响应CSS深色模式&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p align=\\\"center\\\">\\n  <img src=\\\"https://cdn.staticaly.com/gh/xugaoyi/image_store/blog/20200427163531.jpg\\\" width=\\\"500\\\">\\n</p>\\n<p>很多人喜欢选择APP或网站中的深色模式，也许他们更喜欢这样的外观，或者他们想让自己的眼睛免受疲劳。这篇文章将告诉你如何在网站中实现一个自动的CSS深色模式，根据访客的系统主题来自动响应。</p>\\n\",\"capture\":\"如何根据系统主题自动响应CSS深色模式\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"https://cdn.staticaly.com/gh/xugaoyi/image_store/blog/20200427163531.jpg\\\" width=\\\"500\\\"&gt;\\n&lt;/p&gt;\\n很多人喜欢选择APP或网站中的深色模式，也许他们更喜欢这样的外观，或者他们想让自己的眼睛免受疲劳。这篇文章将告诉你如何在网站中实现一个自动的CSS深色模式，根据访客的系统主题来自动响应。\\n CSS 深色模式 (Dark Mode)\\n在`:root`根元素中定义变量来设置主题的颜色。我建\"},{\"url\":\"/02.页面/20.CSS/14.CSS-function汇总.html\",\"relativePath\":\"/02.页面/20.CSS/14.CSS-function汇总.html\",\"frontmatter\":{\"title\":\"CSS-function汇总\",\"date\":\"2020-05-12 09:36:44\",\"permalink\":\"/pages/3da0d7\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"CSS-function汇总\",\"date\":\"2020-05-12 09:36:44\",\"capture\":\"\"},{\"url\":\"/02.页面/20.CSS/15.CSS给table的tbody添加滚动条.html\",\"relativePath\":\"/02.页面/20.CSS/15.CSS给table的tbody添加滚动条.html\",\"frontmatter\":{\"title\":\"CSS给table的tbody添加滚动条\",\"date\":\"2022-06-29 09:34:23\",\"permalink\":\"/pages/55f894/\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"CSS给table的tbody添加滚动条\",\"date\":\"2022-06-29 09:34:23\",\"capture\":\"```css\\ntable tbody {\\n  height: 200px;\\n  overflow-y: auto;\\n  display: block;\\n}\\ntable thead,\\ntbody tr {\\n  display: table;\\n  width: 100%;\\n}\\n```\"},{\"url\":\"/02.页面/20.CSS/16.css calc()使用.html\",\"relativePath\":\"/02.页面/20.CSS/16.css calc()使用.html\",\"frontmatter\":{\"title\":\"css calc()使用\",\"date\":\"2023-09-08 11:40:43\",\"permalink\":\"/pages/2ecc26/\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"css calc()使用\",\"date\":\"2023-09-08 11:40:43\",\"capture\":\"1.什么是 CSS calc() 函数？\\ncalc() 函数允许在指定 CSS 属性值时执行计算。它对于计算 length、 percentage、 time、 numbers、integers、frequencies 和 angles 等特别有用。 CSS calc() 函数的一个强大功能是能够组合不同的单位。这个函数可以执行预处理器不能执行的数学计算。\\nCSS 中的预处理器只能组合具有固定关系的单位，如角度单位、时间单位、频率单位、分辨率单位和特定长度单位。\\ncalc( Expression)\\ncalc() 函数接受一个表达式作为参数。然后将表达式的结果用作值。它可以采用任何形式并使用以下\"},{\"url\":\"/03.技术/01.技术文档/01.Git使用手册.html\",\"relativePath\":\"/03.技术/01.技术文档/01.Git使用手册.html\",\"frontmatter\":{\"title\":\"Git使用手册\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/9a7ee40fc232253e\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git使用手册\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"git使用手册\\\" tabindex=\\\"-1\\\">Git使用手册 <a class=\\\"header-anchor\\\" href=\\\"#git使用手册\\\" aria-label=\\\"Permalink to &quot;Git使用手册&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"安装\\\" tabindex=\\\"-1\\\">安装 <a class=\\\"header-anchor\\\" href=\\\"#安装\\\" aria-label=\\\"Permalink to &quot;安装&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>官网下载：<a href=\\\"https://git-scm.com/downloads\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">https://git-scm.com/downloads</a> 下载完成后使用默认进行安装。</p>\\n<p>安装完成后，在开始菜单里找到 <code>Git</code> -&gt; <code>Git Bash</code>，蹦出一个类似命令行窗口的东西，就说明Git安装成功！\\n还需要最后一步设置，在命令行输入：</p>\\n<div class=\\\"language-bash vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">bash</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">git</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> config</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> --global</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> user.name</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> \\\"Your Name\\\"</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">git</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> config</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> --global</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> user.email</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> \\\"email@example.com\\\"</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br></div></div><p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。</p>\\n\",\"capture\":\"Git使用手册\\n 安装\\n官网下载：&lt;https://git-scm.com/downloads\\n安装完成后，在开始菜单里找到 `Git` -&gt; `Git Bash`，蹦出一个类似命令行窗口的东西，就说明Git安装成功！\\n还需要最后一步设置，在命令行输入：\\n```bash\\ngit config --global user.name \\\"Your Name\\\"\\ngit config --global user.email \\\"email@example.com\\\"\\n```\\n因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。\\n 创建版本库（仓库）\\n```ba\"},{\"url\":\"/03.技术/01.技术文档/02.Markdown使用教程.html\",\"relativePath\":\"/03.技术/01.技术文档/02.Markdown使用教程.html\",\"frontmatter\":{\"title\":\"Markdown使用教程\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/ad247c4332211551\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Markdown使用教程\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"markdown使用教程\\\" tabindex=\\\"-1\\\">Markdown使用教程 <a class=\\\"header-anchor\\\" href=\\\"#markdown使用教程\\\" aria-label=\\\"Permalink to &quot;Markdown使用教程&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"一、markdown\\\" tabindex=\\\"-1\\\">一、Markdown <a class=\\\"header-anchor\\\" href=\\\"#一、markdown\\\" aria-label=\\\"Permalink to &quot;一、Markdown&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p><img src=\\\"https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/md_logo.png\\\" alt=\\\"logo\\\"></p>\\n<p><code>Markdown</code> 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>\\n\",\"capture\":\"一、Markdown\\n 简介\\n`Markdown` 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。\\n  应用\\n当前许多网站都广泛使用 `Markdown` 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、知乎等\\n 编辑器\\n推荐使用`Typora`，官网：&lt;https://typora.io/\\n 二、徽章\\n 什么是徽章\\n徽章是一种小巧精美的小图标，一般配有相关文字进行辅助说明，可对数据进行监控，链接跳转等，富有表现力。\\n常见于`github`项目主页，但其不仅出现于 `github` 项目主页，凡是能够表现图片的地方都可以出现徽章。\\n 徽章的使用\\n* 在\"},{\"url\":\"/03.技术/01.技术文档/03.npm常用命令.html\",\"relativePath\":\"/03.技术/01.技术文档/03.npm常用命令.html\",\"frontmatter\":{\"title\":\"npm常用命令\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/61f2f95fd7da14fd\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"npm常用命令\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"npm常用命令\\\" tabindex=\\\"-1\\\">npm常用命令 <a class=\\\"header-anchor\\\" href=\\\"#npm常用命令\\\" aria-label=\\\"Permalink to &quot;npm常用命令&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>npm是跟随node一起安装的包（模块）管理器。常见的使用场景有以下几种：</p>\\n<ul>\\n<li>允许用户从npm服务器下载别人编写的第三方包到本地使用。</li>\\n<li>允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用。</li>\\n<li>允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。</li>\\n</ul>\\n\",\"capture\":\"简介\\nnpm是跟随node一起安装的包（模块）管理器。常见的使用场景有以下几种：\\n* 允许用户从npm服务器下载别人编写的第三方包到本地使用。\\n* 允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用。\\n* 允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。\\n 常用命令\\n 检测是否安装及版本\\n```sh\\nnpm -v  显示版本号说明已经安装相应的版本\\n```\\n 生成package.json文件\\n```sh\\nnpm init\\n```\\n\\n 安装模块\\n```sh\\nnpm install  安装package.json定义好的模块，简写 npm i\\n 安装包指定模块\\nnpm \"},{\"url\":\"/03.技术/01.技术文档/10.npm packageJson属性详解.html\",\"relativePath\":\"/03.技术/01.技术文档/10.npm packageJson属性详解.html\",\"frontmatter\":{\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"npm packageJson属性详解\",\"date\":\"2020-04-08 17:16:38\",\"permalink\":\"/pages/dec4f3f00e71a312\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null]},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"npm packageJson属性详解\",\"date\":\"2020-04-08 17:16:38\",\"excerpt\":\"<h1 id=\\\"npm-package-json属性详解\\\" tabindex=\\\"-1\\\">npm package.json属性详解 <a class=\\\"header-anchor\\\" href=\\\"#npm-package-json属性详解\\\" aria-label=\\\"Permalink to &quot;npm package.json属性详解&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<blockquote>\\n<p>本文转自<a href=\\\"https://www.cnblogs.com/tzyy/p/5193811.html\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">https://www.cnblogs.com/tzyy/p/5193811.html</a>，作者：TZYY</p>\\n</blockquote>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p><code>package.json</code>必须是一个严格的json文件，而不仅仅是js里边的一个对象。其中很多属性可以通过<code>npm-config</code>来生成</p>\\n\",\"capture\":\"npm package.json属性详解\\n\\n 概述\\n`package.json`必须是一个严格的json文件，而不仅仅是js里边的一个对象。其中很多属性可以通过`npm-config`来生成\\n name\\n`package.json`中最重要的属性是`name`和`version`两个属性，这两个属性是必须要有的，否则模块就无法被安装，这两个属性一起形成了一个npm模块的唯一标识符。模块中内容变更的同时，模块版本也应该一起变化。\\n`name`属性就是你的模块名称，下面是一些命名规则:\\n- `name`必须小于等于214个字节，包括前缀名称在内（如 xxx/xxxmodule）。\\n- `name`\"},{\"url\":\"/03.技术/01.技术文档/15.yaml语言教程.html\",\"relativePath\":\"/03.技术/01.技术文档/15.yaml语言教程.html\",\"frontmatter\":{\"title\":\"yaml语言教程\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/4e8444e2d534d14f\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"yaml语言教程\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"yaml语言教程\\\" tabindex=\\\"-1\\\">yaml语言教程 <a class=\\\"header-anchor\\\" href=\\\"#yaml语言教程\\\" aria-label=\\\"Permalink to &quot;yaml语言教程&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>YAML 是 &quot;YAML Ain't a Markup Language&quot;（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：&quot;Yet Another Markup Language&quot;（仍是一种标记语言）。</p>\\n\",\"capture\":\"简介\\nYAML 是 \\\"YAML Ain't a Markup Language\\\"（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：\\\"Yet Another Markup Language\\\"（仍是一种标记语言）。\\nYAML 的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲（例如：许多电子邮件标题格式和YAML非常接近）。\\nYAML 的配置文件后缀为 .yml，如：runoob.yml 。\\n\\n 基本语法\\n- 大小写敏感\\n- 使用缩进\"},{\"url\":\"/03.技术/01.技术文档/20.Git修改分支名.html\",\"relativePath\":\"/03.技术/01.技术文档/20.Git修改分支名.html\",\"frontmatter\":{\"title\":\"Git修改分支名\",\"date\":\"2022-08-11 10:51:18\",\"permalink\":\"/pages/922650/\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git修改分支名\",\"date\":\"2022-08-11 10:51:18\",\"capture\":\"同时修改本地分支名和对应的远程分支名\\n修改前要确保本地分支的代码是最新的，并且修改后不会影响到同事的代码。\\n1. 修改本地分支名\\n```sh\\ngit branch -m oldBranchName newBranchName\\n```\\n2. 删除远程分支\\n```sh\\ngit push origin :oldBranchName\\n 或者 git push origin --delete oldBranchName\\n```\\n3. 改名后的本地分支推送到远程\\n```sh\\ngit push --set-upstream origin newBranchName\\n```\"},{\"url\":\"/03.技术/02.Nodejs/01.nodejs递归读取所有文件.html\",\"relativePath\":\"/03.技术/02.Nodejs/01.nodejs递归读取所有文件.html\",\"frontmatter\":{\"title\":\"nodejs递归读取所有文件\",\"date\":\"2019-12-26 15:57:32\",\"permalink\":\"/pages/117708e0af7f0bd9\",\"categories\":[\"技术\",\"Nodejs\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"nodejs递归读取所有文件\",\"date\":\"2019-12-26 15:57:32\",\"capture\":\"```js\\nvar fs = require('fs');\\nvar path = require('path');\\n \\nfunction readFileList(dir, filesList = []) {\\n    const files = fs.readdirSync(dir);\\n    console.log(files);\\n    files.forEach((item, index) =\\n        var fullPath = path.join(dir, item);\\n        const stat = fs.statSync(fullPath);\\n        i\"},{\"url\":\"/03.技术/03.博客搭建/01.解决百度无法收录搭建在GitHub上的个人博客的问题.html\",\"relativePath\":\"/03.技术/03.博客搭建/01.解决百度无法收录搭建在GitHub上的个人博客的问题.html\",\"frontmatter\":{\"title\":\"解决百度无法收录搭建在GitHub上的个人博客的问题\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/41f87d890d0a02af\",\"categories\":[\"技术\",\"博客搭建\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"解决百度无法收录搭建在GitHub上的个人博客的问题\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"解决百度无法收录搭建在github上的静态博客的问题\\\" tabindex=\\\"-1\\\">解决百度无法收录搭建在GitHub上的静态博客的问题 <a class=\\\"header-anchor\\\" href=\\\"#解决百度无法收录搭建在github上的静态博客的问题\\\" aria-label=\\\"Permalink to &quot;解决百度无法收录搭建在GitHub上的静态博客的问题&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<div class=\\\"warning custom-block\\\"><p class=\\\"custom-block-title\\\">WARNING</p>\\n<p>如果你正在寻找本博客的搭建文档，博主建议您查看这个仓库的<a href=\\\"https://github.com/xugaoyi/vuepress-theme-vdoing\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">README</a>。</p>\\n</div>\\n<h2 id=\\\"背景\\\" tabindex=\\\"-1\\\">背景 <a class=\\\"header-anchor\\\" href=\\\"#背景\\\" aria-label=\\\"Permalink to &quot;背景&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>由于GitHub禁止百度爬虫访问，造成托管在GitHub Pages上的博客无法被百度收录。相关问题可以通过百度站长平台的<code>抓取诊断</code>再现，每次都是403 Forbidden的错误。</p>\\n\",\"capture\":\"如果你正在寻找本博客的搭建文档，博主建议您查看这个仓库的README。\\n 背景\\n由于GitHub禁止百度爬虫访问，造成托管在GitHub Pages上的博客无法被百度收录。相关问题可以通过百度站长平台的`抓取诊断`再现，每次都是403 Forbidden的错误。\\n 解决方案\\n同时将博客同时同步托管到GitHub Pages和coding pages上，解决百度不收录问题。最后发现在国内使用coding pages打开速度特别快，而且还会被百度收录，因此我把coding pages的站点作为主站点，原本在github pages的作为分站点。\\n步骤：\\n1、注册coding账号，创建仓库，把代码推\"},{\"url\":\"/03.技术/03.博客搭建/02.使用Gitalk实现静态博客无后台评论系统.html\",\"relativePath\":\"/03.技术/03.博客搭建/02.使用Gitalk实现静态博客无后台评论系统.html\",\"frontmatter\":{\"title\":\"使用Gitalk实现静态博客无后台评论系统\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/1da0bf9a988eafe5\",\"categories\":[\"技术\",\"博客搭建\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"使用Gitalk实现静态博客无后台评论系统\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"使用gitalk实现静态博客无后台评论系统\\\" tabindex=\\\"-1\\\">使用Gitalk实现静态博客无后台评论系统 <a class=\\\"header-anchor\\\" href=\\\"#使用gitalk实现静态博客无后台评论系统\\\" aria-label=\\\"Permalink to &quot;使用Gitalk实现静态博客无后台评论系统&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"前言\\\" tabindex=\\\"-1\\\">前言 <a class=\\\"header-anchor\\\" href=\\\"#前言\\\" aria-label=\\\"Permalink to &quot;前言&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>Gitalk，一个基于 Github Issue 和 Preact 开发的评论插件。</p>\\n<p>下面我们来用它在vuepress搭建的博客中搭建评论区吧</p>\\n\",\"capture\":\"前言\\nGitalk，一个基于 Github Issue 和 Preact 开发的评论插件。\\n下面我们来用它在vuepress搭建的博客中搭建评论区吧\\n 准备\\n使用一个新的东西首先当然是要了解它\\nGitalk demo：&lt;https://gitalk.github.io/\\nGitalk github：&lt;https://github.com/gitalk/gitalk&gt;\\n 实现\\n如何实现？最好的方法我认为是看官方文档，这里我只是记录一下实现的步骤。\\n使用一个别人已经开发好的 vuepress-plugin-comment 插件来帮助我们把Gitalk应用到vuepress搭建的静\"},{\"url\":\"/03.技术/03.博客搭建/03.GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床.html\",\"relativePath\":\"/03.技术/03.博客搭建/03.GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床.html\",\"frontmatter\":{\"title\":\"GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床\",\"date\":\"2020-01-03 12:55:43\",\"permalink\":\"/pages/a5f73af5185fdf0a\",\"categories\":[\"技术\",\"博客搭建\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床\",\"date\":\"2020-01-03 12:55:43\",\"excerpt\":\"<h1 id=\\\"github-jsdelivr-tinypng-picgo-打造稳定快速、高效免费图床\\\" tabindex=\\\"-1\\\">GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床 <a class=\\\"header-anchor\\\" href=\\\"#github-jsdelivr-tinypng-picgo-打造稳定快速、高效免费图床\\\" aria-label=\\\"Permalink to &quot;GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"前言\\\" tabindex=\\\"-1\\\">前言 <a class=\\\"header-anchor\\\" href=\\\"#前言\\\" aria-label=\\\"Permalink to &quot;前言&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p><strong>Q：为什么要使用图床呢？什么是图床？</strong></p>\\n<p>A：写博客文章时，图片的上传和存放是一个问题，有的朋友可能会把图片放到和博客同一个仓库当中，使用相对路径来引用，这样后期维护起来会比较麻烦。还有的朋友会在不同的平台发布同一篇文章，这样一来每个平台都要上传图片，为了解决这些问题，比较推荐的做法是把图片统一上传到一个在线的第三方静态资源库中，我们把这个资源库称为图床，其返回一个图片的URL，使用<code>markdown+图片url</code>的方式写作文章，一次编写，到处使用~</p>\\n\",\"capture\":\"前言\\nQ：为什么要使用图床呢？什么是图床？\\nA：写博客文章时，图片的上传和存放是一个问题，有的朋友可能会把图片放到和博客同一个仓库当中，使用相对路径来引用，这样后期维护起来会比较麻烦。还有的朋友会在不同的平台发布同一篇文章，这样一来每个平台都要上传图片，为了解决这些问题，比较推荐的做法是把图片统一上传到一个在线的第三方静态资源库中，我们把这个资源库称为图床，其返回一个图片的URL，使用`markdown+图片url`的方式写作文章，一次编写，到处使用~\\n以下内容是比较旧的，现在我发现一个更好用，配置更方便的图床工具：&lt;https://picx.xpoet.cn/\\n使用方法看一下他网站的使\"},{\"url\":\"/03.技术/03.博客搭建/10.vdoing主题效果图.html\",\"relativePath\":\"/03.技术/03.博客搭建/10.vdoing主题效果图.html\",\"frontmatter\":{\"title\":\"vdoing主题效果图\",\"date\":\"2020-04-08 11:27:22\",\"permalink\":\"/pages/d557b9a89a215d2e\",\"article\":false,\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"vdoing主题效果图\",\"date\":\"2020-04-08 11:27:22\",\"capture\":\"vdoing主题效果图\\n PC端\\n&lt;br/\\n&lt;img src=\\\"https://cdn.staticaly.com/gh/xugaoyi/image_store/blog/20200408125410.png\\\" style=\\\"width:48%;\\\"/&gt;\\n&lt;img src=\\\"https://cdn.staticaly.com/gh/xugaoyi/image_store/blog/20200408120138.png\\\"  style=\\\"width:48%;\\\" /&gt;\\n&lt;p align=\\\"center\\\"&gt;首页 & 目录页△&lt;/p&gt;\\n&lt;img\"},{\"url\":\"/04.更多/01.学习/00.费曼学习法.html\",\"relativePath\":\"/04.更多/01.学习/00.费曼学习法.html\",\"frontmatter\":{\"title\":\"费曼学习法\",\"date\":\"2020-07-16 10:04:14\",\"permalink\":\"/pages/f2a556/\",\"categories\":[\"更多\",\"学习\"],\"tags\":[\"学习方法\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"费曼学习法\",\"date\":\"2020-07-16 10:04:14\",\"capture\":\"步骤\\n费曼学习法分为4个步骤:\\n1. 确定学习目标\\n你想学习的概念、内容、主题是什么。\\n2. 模拟教学学习法\\n你要模拟自己是一位老师，面对完全不懂这个领域的人，用自己的话，尽可能具体形象地讲诉。这样的讲诉有助于你活学活用，触类旁通，联系生活具体情境。\\n3. 回顾\\n反思第2步遇到的问题，哪些地方卡壳了，哪些地方对方没有真正听懂。找出问题的要害，把握关键环节。\\n4. 简化\\n把这些遇到问题的地方，重新梳理理解，尽可能了解更多背景和相关知识，再用尽可能简化的方式重新表达，设法看穿本质。然后，返回第2步。\\n\\n&gt; \\n&gt; 《费曼学习法：为何被称为史上最牛的学习法，它的本质究竟是什么？》\\n&gt;\"},{\"url\":\"/04.更多/01.学习/03.提高记忆的技巧.html\",\"relativePath\":\"/04.更多/01.学习/03.提高记忆的技巧.html\",\"frontmatter\":{\"title\":\"提高记忆的技巧\",\"date\":\"2020-01-03 14:34:48\",\"permalink\":\"/pages/996822b2a2ca6e3b\",\"categories\":[\"更多\",\"学习\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"提高记忆的技巧\",\"date\":\"2020-01-03 14:34:48\",\"excerpt\":\"<h1 id=\\\"提高记忆的技巧\\\" tabindex=\\\"-1\\\">提高记忆的技巧 <a class=\\\"header-anchor\\\" href=\\\"#提高记忆的技巧\\\" aria-label=\\\"Permalink to &quot;提高记忆的技巧&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<ol>\\n<li><strong>多个感官并用</strong>\\n记忆时调用一切感官。没人的话可以大声阅读，有人的话可以默念，轻微摇晃手指等，有助于保持专注。</li>\\n</ol>\\n\",\"capture\":\"1. 多个感官并用\\n   记忆时调用一切感官。没人的话可以大声阅读，有人的话可以默念，轻微摇晃手指等，有助于保持专注。\\n   \\n2. 重复记忆\\n   每天留出半个到一个小时，梳理总结今天所学的内容。每一章复习完成后做系统的知识整理。\\n   \\n3. 建立关联\\n   把你所学的新知识与已有的认知建立联系，对于记忆事半功倍。\\n   \\n4. 场景记忆\\n   把知识具象化为一个场景，想象自己在何时何地能用这些知识，与自身发生联系。\\n   \\n5. 提出问题\\n   每学习一个知识点，试着提问，然后给出答案。用了就记住了。\"},{\"url\":\"/04.更多/01.学习/10.搜索引擎使用技巧.html\",\"relativePath\":\"/04.更多/01.学习/10.搜索引擎使用技巧.html\",\"frontmatter\":{\"title\":\"搜索引擎使用技巧\",\"date\":\"2020-05-24 11:44:19\",\"permalink\":\"/pages/ce818a\",\"categories\":[\"更多\",\"学习\"],\"tags\":[\"搜索技巧\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"搜索引擎使用技巧\",\"date\":\"2020-05-24 11:44:19\",\"capture\":\"搜索引擎相信大家经常在使用，但是有时候想搜某个信息时却搜出来一大堆不相关的（百度：你们都在看我干什么？）。下面我们来介绍几种搜索技巧，可以提升搜索效率，助你快速查资料，妈妈再也不担心我的学习了（'妈~我真的是在找学习资料'）\\n 技巧1：排除干扰项\\n方式：关键词1+空格+减号+关键词2，即 `关键词1 -关键词2`\\n功能：排除一些不想要的关键词\\n示例：\\n```\\n锤子 -锤子手机\\n```\\n示例中将在搜索结果排除与`锤子手机`相关的，只显示`锤子`本来的样子。\\n\\n 技巧2：精确搜索\\n方式：给关键词加双引号，`\\\"关键词\\\"`\\n功能：只搜索引号里的字，少一个字或者把字拆开都不行\\n示例：\\n```\\n\\\"达拉不崩\"},{\"url\":\"/04.更多/03.面试/01.面试问题集锦.html\",\"relativePath\":\"/04.更多/03.面试/01.面试问题集锦.html\",\"frontmatter\":{\"title\":\"面试问题集锦\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/aea6571b7a8bae86\",\"categories\":[\"更多\",\"面试\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"面试问题集锦\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"请做一下自我介绍\\n回答提示： 一般人回答这个问题过于平常，只说姓名、年龄、工作经验，这些在简历上都有。其实，企业最希望知道的是求职者能否胜任工作，包括：最强的技能、最深入研究的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，要突出积极的个性和做事的能力，说的合情合理企业才会相信。\\n 你最大的优点是什么？\\n回答提示： 沉着冷静、条理清楚、立场坚定、乐于助人等，加上例子如：我在XX经过一到两年的培训及项目实战，加上实习工作，我想我适合这份工作。\\n 说说你最大的缺点？\\n回答提示： 这个问题企业问的概率很大，通常不希望听到直接回答的缺点是什么等，如果求职者说自己小心眼、非常懒、工作效率低\"},{\"url\":\"/04.更多/05.AI随笔/01.当珍妮机学会了写代码.html\",\"relativePath\":\"/04.更多/05.AI随笔/01.当珍妮机学会了写代码.html\",\"frontmatter\":{\"title\":\"当珍妮机学会了写代码\",\"date\":\"2026-02-26 20:00:00\",\"permalink\":\"/pages/ai-coding-revolution/\",\"categories\":[\"更多\",\"AI随笔\"],\"tags\":[\"AI\",\"思考\",\"编程\"],\"author\":{\"name\":\"刘志伟;AI\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟;AI\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"当珍妮机学会了写代码\",\"date\":\"2026-02-26 20:00:00\",\"capture\":\"当珍妮机学会了写代码\\n\\n 一、从一台纺纱机说起\\n1764 年的某个夜晚，英国兰开夏郡的织工詹姆斯·哈格里夫斯看着妻子的纺车被踢倒后仍在旋转，灵光一闪——如果把纱锭竖起来，一个轮子就能同时驱动八个纱锭。\\n珍妮纺纱机就这样诞生了。一个人能干八个人的活，效率提升 800%。\\n262 年后的 2026 年，我坐在屏幕前，让一个叫 Claude 的 AI 帮我重构整个博客系统。它用 Three.js 写了一个极光 Shader 背景，用 Vue 3 搭了全屏滚动首页，让它设计了五套可切换的艺术风格主题——赛博朋克、梵高、水墨、古典雕塑、现代。它还帮我写了一篇博客，就是现在你正在看的这篇。\\n如果哈格里夫斯\"},{\"url\":\"/04.更多/99.友情链接.html\",\"relativePath\":\"/04.更多/99.友情链接.html\",\"frontmatter\":{\"title\":\"友情链接\",\"date\":\"2023-08-29 15:43:33\",\"permalink\":\"/pages/1bf946/\",\"categories\":[\"更多\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"友情链接\",\"date\":\"2023-08-29 15:43:33\",\"capture\":\"\"},{\"url\":\"/05.关于/01.关于.html\",\"relativePath\":\"/05.关于/01.关于.html\",\"frontmatter\":{\"title\":\"关于\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/about/\",\"sidebar\":false,\"article\":false,\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"关于\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"📚Blog\"},{\"url\":\"/@pages/archivesPage.html\",\"relativePath\":\"/@pages/archivesPage.html\",\"frontmatter\":{\"archivesPage\":true,\"title\":\"归档\",\"permalink\":\"/archives/\",\"article\":false},\"title\":\"归档\",\"date\":\"2023-09-08 07:05:12\",\"capture\":\"\"},{\"url\":\"/@pages/categoriesPage.html\",\"relativePath\":\"/@pages/categoriesPage.html\",\"frontmatter\":{\"categoriesPage\":true,\"title\":\"分类\",\"permalink\":\"/categories/\",\"article\":false},\"title\":\"分类\",\"date\":\"2023-09-08 07:05:12\",\"capture\":\"\"},{\"url\":\"/@pages/tagsPage.html\",\"relativePath\":\"/@pages/tagsPage.html\",\"frontmatter\":{\"tagsPage\":true,\"title\":\"标签\",\"permalink\":\"/tags/\",\"article\":false},\"title\":\"标签\",\"date\":\"2023-09-08 07:05:12\",\"capture\":\"\"},{\"url\":\"/\",\"relativePath\":\"/\",\"frontmatter\":{\"layout\":\"page\",\"title\":\"首页\"},\"title\":\"首页\",\"date\":\"2023-08-29 07:43:33\",\"capture\":\"&lt;HomePage /\"},{\"url\":\"/《ES6 教程》笔记/01.ECMAScript 6 简介.html\",\"relativePath\":\"/《ES6 教程》笔记/01.ECMAScript 6 简介.html\",\"frontmatter\":{\"title\":\"ECMAScript 6 简介\",\"date\":\"2020-01-12 15:45:35\",\"permalink\":\"/pages/f344d070a1031ef7\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"ECMAScript 6 简介\",\"date\":\"2020-01-12 15:45:35\",\"excerpt\":\"<blockquote>\\n<p>说明：本章内容为博主在原教程基础上添加自己的学习笔记，来源<a href=\\\"http://es6.ruanyifeng.com/\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">http://es6.ruanyifeng.com/</a>，教程版权归原作者所有。</p>\\n</blockquote>\\n<h1 id=\\\"ecmascript-6-简介\\\" tabindex=\\\"-1\\\">ECMAScript 6 简介 <a class=\\\"header-anchor\\\" href=\\\"#ecmascript-6-简介\\\" aria-label=\\\"Permalink to &quot;ECMAScript 6 简介&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p>\\n\",\"capture\":\"ECMAScript 6 简介\\nECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。\\n ECMAScript 和 JavaScript 的关系\\n一个常见的问题是，ECMAScript 和 JavaScript 到底是什么关系？\\n要讲清楚这个问题，需要回顾历史。1996 年 11 月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给标准化组织 ECMA，希望这种语言能够成为国际标\"},{\"url\":\"/《ES6 教程》笔记/02.let 和 const 命令.html\",\"relativePath\":\"/《ES6 教程》笔记/02.let 和 const 命令.html\",\"frontmatter\":{\"title\":\"let 和 const 命令\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/c1edd70a6b7c7872\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"let 和 const 命令\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"let-和-const-命令\\\" tabindex=\\\"-1\\\">let 和 const 命令 <a class=\\\"header-anchor\\\" href=\\\"#let-和-const-命令\\\" aria-label=\\\"Permalink to &quot;let 和 const 命令&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"let-命令\\\" tabindex=\\\"-1\\\">let 命令 <a class=\\\"header-anchor\\\" href=\\\"#let-命令\\\" aria-label=\\\"Permalink to &quot;let 命令&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"基本用法\\\" tabindex=\\\"-1\\\">基本用法 <a class=\\\"header-anchor\\\" href=\\\"#基本用法\\\" aria-label=\\\"Permalink to &quot;基本用法&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>ES6 新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code>，但是所声明的变量，<strong>只在<code>let</code>命令所在的代码块内有效(块级作用域)</strong>。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">{</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">  let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> a </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 10</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">  var</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> b </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">a </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// ReferenceError: a is not defined.</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">b </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// 1</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br></div></div>\",\"capture\":\"let 命令\\n 基本用法\\nES6 新增了`let`命令，用来声明变量。它的用法类似于`var`，但是所声明的变量，只在`let`命令所在的代码块内有效(块级作用域)。\\n```javascript\\n{\\n  let a = 10;\\n  var b = 1;\\n}\\na // ReferenceError: a is not defined.\\nb // 1\\n```\\n上面代码在代码块之中，分别用`let`和`var`声明了两个变量。然后在代码块之外调用这两个变量，结果`let`声明的变量报错，`var`声明的变量返回了正确的值。这表明，`let`声明的变量只在它所在的代码块有效。\\n`for`循环的计数器，\"},{\"url\":\"/《ES6 教程》笔记/03.变量的解构赋值.html\",\"relativePath\":\"/《ES6 教程》笔记/03.变量的解构赋值.html\",\"frontmatter\":{\"title\":\"变量的解构赋值\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/b1ab10a62f7564da\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"变量的解构赋值\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"变量的解构赋值\\\" tabindex=\\\"-1\\\">变量的解构赋值 <a class=\\\"header-anchor\\\" href=\\\"#变量的解构赋值\\\" aria-label=\\\"Permalink to &quot;变量的解构赋值&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"数组的解构赋值\\\" tabindex=\\\"-1\\\">数组的解构赋值 <a class=\\\"header-anchor\\\" href=\\\"#数组的解构赋值\\\" aria-label=\\\"Permalink to &quot;数组的解构赋值&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"基本用法\\\" tabindex=\\\"-1\\\">基本用法 <a class=\\\"header-anchor\\\" href=\\\"#基本用法\\\" aria-label=\\\"Permalink to &quot;基本用法&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>ES6 允许按照一定模式，<strong>从数组和对象中提取值，对变量进行赋值，这被称为解构</strong>（Destructuring）。</p>\\n<p>以前，为变量赋值，只能直接指定值。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> a </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> b </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> c </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 3</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br></div></div>\",\"capture\":\"数组的解构赋值\\n 基本用法\\nES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。\\n以前，为变量赋值，只能直接指定值。\\n```javascript\\nlet a = 1;\\nlet b = 2;\\nlet c = 3;\\n```\\nES6 允许写成下面这样。\\n```javascript\\nlet [a, b, c] = [1, 2, 3];\\n```\\n上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。\\n本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。\\n```javas\"},{\"url\":\"/《ES6 教程》笔记/04.字符串的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/04.字符串的扩展.html\",\"frontmatter\":{\"title\":\"字符串的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/ca89eca8adeba5f4\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"字符串的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"字符串的扩展\\\" tabindex=\\\"-1\\\">字符串的扩展 <a class=\\\"header-anchor\\\" href=\\\"#字符串的扩展\\\" aria-label=\\\"Permalink to &quot;字符串的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>本章介绍 ES6 对字符串的改造和增强，下一章介绍字符串对象的新增方法。</p>\\n<h2 id=\\\"字符的-unicode-表示法\\\" tabindex=\\\"-1\\\">字符的 Unicode 表示法 <a class=\\\"header-anchor\\\" href=\\\"#字符的-unicode-表示法\\\" aria-label=\\\"Permalink to &quot;字符的 Unicode 表示法&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES6 加强了对 Unicode 的支持，允许采用<code>\\\\uxxxx</code>形式表示一个字符，其中<code>xxxx</code>表示字符的 Unicode 码点。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">\\\\u0061</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// \\\"a\\\"</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br></div></div>\",\"capture\":\"本章介绍 ES6 对字符串的改造和增强，下一章介绍字符串对象的新增方法。\\n 字符的 Unicode 表示法\\nES6 加强了对 Unicode 的支持，允许采用`\\\\uxxxx`形式表示一个字符，其中`xxxx`表示字符的 Unicode 码点。\\n```javascript\\n\\\"\\\\u0061\\\"\\n// \\\"a\\\"\\n```\\n但是，这种表示法只限于码点在`\\\\u0000`~`\\\\uFFFF`之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。\\n```javascript\\n\\\"\\\\uD842\\\\uDFB7\\\"\\n// \\\"𠮷\\\"\\n\\\"\\\\u20BB7\\\"\\n// \\\" 7\\\"\\n```\\n上面代码表示，如果直接在`\\\\u`后面跟上超过`\"},{\"url\":\"/《ES6 教程》笔记/05.字符串的新增方法.html\",\"relativePath\":\"/《ES6 教程》笔记/05.字符串的新增方法.html\",\"frontmatter\":{\"title\":\"字符串的新增方法\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/a650b4a0ebfc9350\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"字符串的新增方法\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"字符串的新增方法\\\" tabindex=\\\"-1\\\">字符串的新增方法 <a class=\\\"header-anchor\\\" href=\\\"#字符串的新增方法\\\" aria-label=\\\"Permalink to &quot;字符串的新增方法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>本章介绍字符串对象的新增方法。</p>\\n<h2 id=\\\"string-fromcodepoint\\\" tabindex=\\\"-1\\\">String.fromCodePoint() <a class=\\\"header-anchor\\\" href=\\\"#string-fromcodepoint\\\" aria-label=\\\"Permalink to &quot;String.fromCodePoint()&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES5 提供<code>String.fromCharCode()</code>方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于<code>0xFFFF</code>的字符。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">String.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">fromCharCode</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">0x20BB7</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">)</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// \\\"ஷ\\\"</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br></div></div>\",\"capture\":\"本章介绍字符串对象的新增方法。\\n String.fromCodePoint()\\nES5 提供`String.fromCharCode()`方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于`0xFFFF`的字符。\\n```javascript\\nString.fromCharCode(0x20BB7)\\n// \\\"ஷ\\\"\\n```\\n上面代码中，`String.fromCharCode()`不能识别大于`0xFFFF`的码点，所以`0x20BB7`就发生了溢出，最高位`2`被舍弃了，最后返回码点`U+0BB7`对应的字符，而不是码点`U+20BB7`对应的字符。\\nES6 提供了`S\"},{\"url\":\"/《ES6 教程》笔记/06.正则的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/06.正则的扩展.html\",\"frontmatter\":{\"title\":\"正则的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/0473261a6ab0ee8c\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"正则的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"正则的扩展\\\" tabindex=\\\"-1\\\">正则的扩展 <a class=\\\"header-anchor\\\" href=\\\"#正则的扩展\\\" aria-label=\\\"Permalink to &quot;正则的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"regexp-构造函数\\\" tabindex=\\\"-1\\\">RegExp 构造函数 <a class=\\\"header-anchor\\\" href=\\\"#regexp-构造函数\\\" aria-label=\\\"Permalink to &quot;RegExp 构造函数&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>在 ES5 中，<code>RegExp</code>构造函数的参数有两种情况。</p>\\n<p>第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">var</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> regex </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> new</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> RegExp</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'xyz'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'i'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">);</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// 等价于</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">var</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> regex </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> /</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#DBEDFF\\\">xyz</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">/</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">i</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br></div></div>\",\"capture\":\"RegExp 构造函数\\n在 ES5 中，`RegExp`构造函数的参数有两种情况。\\n第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。\\n```javascript\\nvar regex = new RegExp('xyz', 'i');\\n// 等价于\\nvar regex = /xyz/i;\\n```\\n第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。\\n```javascript\\nvar regex = new RegExp(/xyz/i);\\n// 等价于\\nvar regex = /xyz/i;\\n```\\n但是，ES5 不允许此时使用第二个参数添加修饰\"},{\"url\":\"/《ES6 教程》笔记/07.数值的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/07.数值的扩展.html\",\"frontmatter\":{\"title\":\"数值的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/5dfea9a0f2d1a392\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"数值的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"数值的扩展\\\" tabindex=\\\"-1\\\">数值的扩展 <a class=\\\"header-anchor\\\" href=\\\"#数值的扩展\\\" aria-label=\\\"Permalink to &quot;数值的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"二进制和八进制表示法\\\" tabindex=\\\"-1\\\">二进制和八进制表示法 <a class=\\\"header-anchor\\\" href=\\\"#二进制和八进制表示法\\\" aria-label=\\\"Permalink to &quot;二进制和八进制表示法&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES6 提供了二进制和八进制数值的新的写法，分别用前缀<code>0b</code>（或<code>0B</code>）和<code>0o</code>（或<code>0O</code>）表示。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">0b111110111</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> ===</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 503</span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\"> // true</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">0o767</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> ===</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 503</span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\"> // true</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br></div></div>\",\"capture\":\"二进制和八进制表示法\\nES6 提供了二进制和八进制数值的新的写法，分别用前缀`0b`（或`0B`）和`0o`（或`0O`）表示。\\n```javascript\\n0b111110111 === 503 // true\\n0o767 === 503 // true\\n```\\n从 ES5 开始，在严格模式之中，八进制就不再允许使用前缀`0`表示，ES6 进一步明确，要使用前缀`0o`表示。\\n```javascript\\n// 非严格模式\\n(function(){\\n  console.log(0o11 === 011);\\n})() // true\\n// 严格模式\\n(function(){\\n  'use str\"},{\"url\":\"/《ES6 教程》笔记/08.函数的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/08.函数的扩展.html\",\"frontmatter\":{\"title\":\"函数的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/8ed309d668b20264\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"函数的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"函数的扩展\\\" tabindex=\\\"-1\\\">函数的扩展 <a class=\\\"header-anchor\\\" href=\\\"#函数的扩展\\\" aria-label=\\\"Permalink to &quot;函数的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"函数参数的默认值\\\" tabindex=\\\"-1\\\">函数参数的默认值 <a class=\\\"header-anchor\\\" href=\\\"#函数参数的默认值\\\" aria-label=\\\"Permalink to &quot;函数参数的默认值&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"基本用法\\\" tabindex=\\\"-1\\\">基本用法 <a class=\\\"header-anchor\\\" href=\\\"#基本用法\\\" aria-label=\\\"Permalink to &quot;基本用法&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">function</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#E36209;--shiki-dark:#FFAB70\\\">x</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#E36209;--shiki-dark:#FFAB70\\\">y</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">) {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">  y </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> y </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">||</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> 'World'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">  console.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(x, y);</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'Hello'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">) </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// Hello World</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'Hello'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'China'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">) </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// Hello China</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'Hello'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">''</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">) </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// Hello World</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br><span class=\\\"line-number\\\">8</span><br></div></div>\",\"capture\":\"函数参数的默认值\\n 基本用法\\nES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。\\n```javascript\\nfunction log(x, y) {\\n  y = y || 'World';\\n  console.log(x, y);\\n}\\nlog('Hello') // Hello World\\nlog('Hello', 'China') // Hello China\\nlog('Hello', '') // Hello World\\n```\\n上面代码检查函数`log`的参数`y`有没有赋值，如果没有，则指定默认值为`World`。这种写法的缺点在于，如果参数`y`赋值了，但是对应的布\"},{\"url\":\"/《ES6 教程》笔记/09.数组的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/09.数组的扩展.html\",\"frontmatter\":{\"title\":\"数组的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/e34009d60d8bc4b2\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"数组的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"数组的扩展\\\" tabindex=\\\"-1\\\">数组的扩展 <a class=\\\"header-anchor\\\" href=\\\"#数组的扩展\\\" aria-label=\\\"Permalink to &quot;数组的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"扩展运算符\\\" tabindex=\\\"-1\\\">扩展运算符 <a class=\\\"header-anchor\\\" href=\\\"#扩展运算符\\\" aria-label=\\\"Permalink to &quot;扩展运算符&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"含义\\\" tabindex=\\\"-1\\\">含义 <a class=\\\"header-anchor\\\" href=\\\"#含义\\\" aria-label=\\\"Permalink to &quot;含义&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>扩展运算符（spread）是三个点（<code>...</code>）。它好比 rest 参数的逆运算，<strong>将一个数组转为用逗号分隔的参数序列</strong>。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">console.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">...</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">[</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">3</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">])</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// 1 2 3</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">console.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">...</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">[</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">3</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">4</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">], </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">5</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">)</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// 1 2 3 4 5</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">[</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">...</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">document.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">querySelectorAll</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'div'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">)]</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// [&#x3C;div>, &#x3C;div>, &#x3C;div>]</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br><span class=\\\"line-number\\\">8</span><br></div></div>\",\"capture\":\"扩展运算符\\n 含义\\n扩展运算符（spread）是三个点（`...`）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。\\n```javascript\\nconsole.log(...[1, 2, 3])\\n// 1 2 3\\nconsole.log(1, ...[2, 3, 4], 5)\\n// 1 2 3 4 5\\n[...document.querySelectorAll('div')]\\n// [&lt;div\\n```\\n该运算符主要用于函数调用。\\n```javascript\\nfunction push(array, ...items) {\\n  array.push(...items\"},{\"url\":\"/《ES6 教程》笔记/10.对象的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/10.对象的扩展.html\",\"frontmatter\":{\"title\":\"对象的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/b5e3e0a0ff6e9c25\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"对象的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"对象的扩展\\\" tabindex=\\\"-1\\\">对象的扩展 <a class=\\\"header-anchor\\\" href=\\\"#对象的扩展\\\" aria-label=\\\"Permalink to &quot;对象的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>对象（object）是 JavaScript 最重要的数据结构。ES6 对它进行了重大升级，本章介绍数据结构本身的改变，下一章介绍<code>Object</code>对象的新增方法。</p>\\n\",\"capture\":\"对象（object）是 JavaScript 最重要的数据结构。ES6 对它进行了重大升级，本章介绍数据结构本身的改变，下一章介绍`Object`对象的新增方法。\\n 属性的简洁表示法\\nES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。\\n```javascript\\nconst foo = 'bar';\\nconst baz = {foo};\\nbaz // {foo: \\\"bar\\\"}\\n// 等同于\\nconst baz = {foo: foo};\\n```\\n上面代码中，变量`foo`直接写在大括号里面。这时，属性名就是变量名, 属性值就是变量值。下面是另一个例子。\\n`\"},{\"url\":\"/《ES6 教程》笔记/11.对象的新增方法.html\",\"relativePath\":\"/《ES6 教程》笔记/11.对象的新增方法.html\",\"frontmatter\":{\"title\":\"对象的新增方法\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/e85e68947502cf90\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"对象的新增方法\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"对象的新增方法\\\" tabindex=\\\"-1\\\">对象的新增方法 <a class=\\\"header-anchor\\\" href=\\\"#对象的新增方法\\\" aria-label=\\\"Permalink to &quot;对象的新增方法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>本章介绍 Object 对象的新增方法。</p>\\n<h2 id=\\\"object-is\\\" tabindex=\\\"-1\\\">Object.is() <a class=\\\"header-anchor\\\" href=\\\"#object-is\\\" aria-label=\\\"Permalink to &quot;Object.is()&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES5 比较两个值是否相等，只有两个运算符：相等运算符（<code>==</code>）和严格相等运算符（<code>===</code>）。它们都有缺点，前者会自动转换数据类型，后者的<code>NaN</code>不等于自身，以及<code>+0</code>等于<code>-0</code>。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</p>\\n<p>ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。<code>Object.is</code>就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</p>\\n\",\"capture\":\"本章介绍 Object 对象的新增方法。\\n Object.is()\\nES5 比较两个值是否相等，只有两个运算符：相等运算符（`==`）和严格相等运算符（`===`）。它们都有缺点，前者会自动转换数据类型，后者的`NaN`不等于自身，以及`+0`等于`-0`。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。\\nES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。`Object.is`就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。\\n```javascript\\nObject.\"},{\"url\":\"/《ES6 教程》笔记/12.Symbol.html\",\"relativePath\":\"/《ES6 教程》笔记/12.Symbol.html\",\"frontmatter\":{\"title\":\"Symbol\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/02c86eb2792f3262\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Symbol\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"symbol\\\" tabindex=\\\"-1\\\">Symbol <a class=\\\"header-anchor\\\" href=\\\"#symbol\\\" aria-label=\\\"Permalink to &quot;Symbol&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，<strong>保证每个属性的名字都是独一无二</strong>的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入<code>Symbol</code>的原因。</p>\\n\",\"capture\":\"概述\\nES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入`Symbol`的原因。\\nES6 引入了一种新的原始数据类型`Symbol`，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：`undefined`、`null`、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。\\nSymbol 值\"},{\"url\":\"/《ES6 教程》笔记/13.Set 和 Map 数据结构.html\",\"relativePath\":\"/《ES6 教程》笔记/13.Set 和 Map 数据结构.html\",\"frontmatter\":{\"title\":\"Set 和 Map 数据结构\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/0c21dae358fca16b\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Set 和 Map 数据结构\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"set-和-map-数据结构\\\" tabindex=\\\"-1\\\">Set 和 Map 数据结构 <a class=\\\"header-anchor\\\" href=\\\"#set-和-map-数据结构\\\" aria-label=\\\"Permalink to &quot;Set 和 Map 数据结构&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"set\\\" tabindex=\\\"-1\\\">Set <a class=\\\"header-anchor\\\" href=\\\"#set\\\" aria-label=\\\"Permalink to &quot;Set&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"基本用法\\\" tabindex=\\\"-1\\\">基本用法 <a class=\\\"header-anchor\\\" href=\\\"#基本用法\\\" aria-label=\\\"Permalink to &quot;基本用法&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>ES6 提供了新的数据结构 Set。它<strong>类似于数组，但是成员的值都是唯一的，没有重复的值</strong>。</p>\\n<p><strong><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构</strong>。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">const</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> s</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> =</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> new</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> Set</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">();</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">[</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">3</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">5</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">4</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">5</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">].</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">forEach</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#E36209;--shiki-dark:#FFAB70\\\">x</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> =></span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> s.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">add</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(x));</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">for</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> (</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> i </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">of</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> s) {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">  console.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(i);</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// 2 3 5 4</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br><span class=\\\"line-number\\\">8</span><br></div></div>\",\"capture\":\"Set\\n 基本用法\\nES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。\\n`Set`本身是一个构造函数，用来生成 Set 数据结构。\\n```javascript\\nconst s = new Set();\\n[2, 3, 5, 4, 5, 2, 2].forEach(x =\\nfor (let i of s) {\\n  console.log(i);\\n}\\n// 2 3 5 4\\n```\\n上面代码通过`add()`方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。\\n`Set`函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参\"},{\"url\":\"/《ES6 教程》笔记/14.Proxy.html\",\"relativePath\":\"/《ES6 教程》笔记/14.Proxy.html\",\"frontmatter\":{\"title\":\"Proxy\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/f56ec2ab97d60483\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Proxy\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"proxy\\\" tabindex=\\\"-1\\\">Proxy <a class=\\\"header-anchor\\\" href=\\\"#proxy\\\" aria-label=\\\"Permalink to &quot;Proxy&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“<strong>元编程</strong>”（meta programming），即<strong>对编程语言进行编程</strong>。</p>\\n<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，<strong>外界对该对象的访问，都必须先通过这层拦截</strong>，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>\\n\",\"capture\":\"概述\\nProxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。\\nProxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。\\n```javascript\\nvar obj = new Proxy({}, {\\n  get: function (target, propKey, receiver) {\\n    console.log(\"},{\"url\":\"/《ES6 教程》笔记/15.Reflect.html\",\"relativePath\":\"/《ES6 教程》笔记/15.Reflect.html\",\"frontmatter\":{\"title\":\"Reflect\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/74de3e45e4491e95\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Reflect\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"reflect\\\" tabindex=\\\"-1\\\">Reflect <a class=\\\"header-anchor\\\" href=\\\"#reflect\\\" aria-label=\\\"Permalink to &quot;Reflect&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p><code>Reflect</code>对象与<code>Proxy</code>对象一样，也是 ES6 为了操作对象而提供的新 API。<code>Reflect</code>对象的设计目的有这样几个。</p>\\n<p>（1） **将<code>Object</code>对象的一些明显属于语言内部的方法（比如<code>Object.defineProperty</code>），放到<code>Reflect</code>对象上。**现阶段，某些方法同时在<code>Object</code>和<code>Reflect</code>对象上部署，未来的新方法将只部署在<code>Reflect</code>对象上。也就是说，从<code>Reflect</code>对象上可以拿到语言内部的方法。</p>\\n\",\"capture\":\"概述\\n`Reflect`对象与`Proxy`对象一样，也是 ES6 为了操作对象而提供的新 API。`Reflect`对象的设计目的有这样几个。\\n（1） 将`Object`对象的一些明显属于语言内部的方法（比如`Object.defineProperty`），放到`Reflect`对象上。现阶段，某些方法同时在`Object`和`Reflect`对象上部署，未来的新方法将只部署在`Reflect`对象上。也就是说，从`Reflect`对象上可以拿到语言内部的方法。\\n（2） 修改某些`Object`方法的返回结果，让其变得更合理。比如，`Object.defineProperty(obj, na\"},{\"url\":\"/《ES6 教程》笔记/16.Promise 对象.html\",\"relativePath\":\"/《ES6 教程》笔记/16.Promise 对象.html\",\"frontmatter\":{\"title\":\"Promise 对象\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/2810ae8985e9bd52\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Promise 对象\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"promise-对象\\\" tabindex=\\\"-1\\\">Promise 对象 <a class=\\\"header-anchor\\\" href=\\\"#promise-对象\\\" aria-label=\\\"Permalink to &quot;Promise 对象&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"promise-的含义\\\" tabindex=\\\"-1\\\">Promise 的含义 <a class=\\\"header-anchor\\\" href=\\\"#promise-的含义\\\" aria-label=\\\"Permalink to &quot;Promise 的含义&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了<code>Promise</code>对象。</p>\\n\",\"capture\":\"Promise 的含义\\nPromise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了`Promise`对象。\\n所谓`Promise`，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。\\n`Promise`对象有以下两个特点。\\n（1）对象的状态不受外界影响。`Promise`对象代表一个异步操作，有三种状态：`pe\"},{\"url\":\"/《ES6 教程》笔记/17.Iterator 和 for-of 循环.html\",\"relativePath\":\"/《ES6 教程》笔记/17.Iterator 和 for-of 循环.html\",\"frontmatter\":{\"title\":\"Iterator 和 for-of 循环\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/48df907ad3570f3d\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Iterator 和 for-of 循环\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"iterator-和-for-of-循环\\\" tabindex=\\\"-1\\\">Iterator 和 for...of 循环 <a class=\\\"header-anchor\\\" href=\\\"#iterator-和-for-of-循环\\\" aria-label=\\\"Permalink to &quot;Iterator 和 for...of 循环&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"iterator-遍历器-的概念\\\" tabindex=\\\"-1\\\">Iterator（遍历器）的概念 <a class=\\\"header-anchor\\\" href=\\\"#iterator-遍历器-的概念\\\" aria-label=\\\"Permalink to &quot;Iterator（遍历器）的概念&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>JavaScript 原有的表示“集合”的数据结构，主要是数组（<code>Array</code>）和对象（<code>Object</code>），ES6 又添加了<code>Map</code>和<code>Set</code>。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是<code>Map</code>，<code>Map</code>的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。</p>\\n\",\"capture\":\"Iterator（遍历器）的概念\\nJavaScript 原有的表示“集合”的数据结构，主要是数组（`Array`）和对象（`Object`），ES6 又添加了`Map`和`Set`。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是`Map`，`Map`的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。\\n遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。\\nIterator 的作用有三个：一是为各\"},{\"url\":\"/《ES6 教程》笔记/18.Generator 函数的语法.html\",\"relativePath\":\"/《ES6 教程》笔记/18.Generator 函数的语法.html\",\"frontmatter\":{\"title\":\"Generator 函数的语法\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/718b48ed9ce0adce\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Generator 函数的语法\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"generator-函数的语法\\\" tabindex=\\\"-1\\\">Generator 函数的语法 <a class=\\\"header-anchor\\\" href=\\\"#generator-函数的语法\\\" aria-label=\\\"Permalink to &quot;Generator 函数的语法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"基本概念\\\" tabindex=\\\"-1\\\">基本概念 <a class=\\\"header-anchor\\\" href=\\\"#基本概念\\\" aria-label=\\\"Permalink to &quot;基本概念&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>Generator 函数是 ES6 提供的一种<strong>异步编程解决方案</strong>，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《Generator 函数的异步应用》一章。</p>\\n\",\"capture\":\"简介\\n 基本概念\\nGenerator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《Generator 函数的异步应用》一章。\\nGenerator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。\\n执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。\\n形式上，Generator 函数是一个\"},{\"url\":\"/《ES6 教程》笔记/19.Generator 函数的异步应用.html\",\"relativePath\":\"/《ES6 教程》笔记/19.Generator 函数的异步应用.html\",\"frontmatter\":{\"title\":\"Generator 函数的异步应用\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/75af7031eb66847b\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Generator 函数的异步应用\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"generator-函数的异步应用\\\" tabindex=\\\"-1\\\">Generator 函数的异步应用 <a class=\\\"header-anchor\\\" href=\\\"#generator-函数的异步应用\\\" aria-label=\\\"Permalink to &quot;Generator 函数的异步应用&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>异步编程对 JavaScript 语言太重要。JavaScript 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。本章主要介绍 Generator 函数如何完成异步操作。</p>\\n\",\"capture\":\"异步编程对 JavaScript 语言太重要。JavaScript 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。本章主要介绍 Generator 函数如何完成异步操作。\\n 传统方法\\nES6 诞生以前，异步编程的方法，大概有下面四种。\\n- 回调函数\\n- 事件监听\\n- 发布/订阅\\n- Promise 对象\\nGenerator 函数将 JavaScript 异步编程带入了一个全新的阶段。\\n 基本概念\\n 异步\\n所谓\\\"异步\\\"，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。\\n比如，有一个任\"},{\"url\":\"/《ES6 教程》笔记/20.async 函数.html\",\"relativePath\":\"/《ES6 教程》笔记/20.async 函数.html\",\"frontmatter\":{\"title\":\"async 函数\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/3777253e65bac487\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"async 函数\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"async-函数\\\" tabindex=\\\"-1\\\">async 函数 <a class=\\\"header-anchor\\\" href=\\\"#async-函数\\\" aria-label=\\\"Permalink to &quot;async 函数&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"含义\\\" tabindex=\\\"-1\\\">含义 <a class=\\\"header-anchor\\\" href=\\\"#含义\\\" aria-label=\\\"Permalink to &quot;含义&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p>\\n<p>async 函数是什么？一句话，它就<strong>是 Generator 函数的语法糖</strong>。</p>\\n<p>前文有一个 Generator 函数，依次读取两个文件。</p>\\n\",\"capture\":\"含义\\nES2017 标准引入了 async 函数，使得异步操作变得更加方便。\\nasync 函数是什么？一句话，它就是 Generator 函数的语法糖。\\n前文有一个 Generator 函数，依次读取两个文件。\\n```javascript\\nconst fs = require('fs');\\nconst readFile = function (fileName) {\\n  return new Promise(function (resolve, reject) {\\n    fs.readFile(fileName, function(error, data) {\\n      if (error\"},{\"url\":\"/《ES6 教程》笔记/21.Class 的基本语法.html\",\"relativePath\":\"/《ES6 教程》笔记/21.Class 的基本语法.html\",\"frontmatter\":{\"title\":\"Class 的基本语法\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/e831e1593c82bbe0\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Class 的基本语法\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"class-的基本语法\\\" tabindex=\\\"-1\\\">Class 的基本语法 <a class=\\\"header-anchor\\\" href=\\\"#class-的基本语法\\\" aria-label=\\\"Permalink to &quot;Class 的基本语法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"类的由来\\\" tabindex=\\\"-1\\\">类的由来 <a class=\\\"header-anchor\\\" href=\\\"#类的由来\\\" aria-label=\\\"Permalink to &quot;类的由来&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">function</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> Point</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#E36209;--shiki-dark:#FFAB70\\\">x</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#E36209;--shiki-dark:#FFAB70\\\">y</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">) {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">  this</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.x </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> x;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">  this</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.y </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> y;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">Point</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">prototype</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">toString</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> =</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> function</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> () {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">  return</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> '('</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> +</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> this</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.x </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">+</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> ', '</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> +</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> this</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.y </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">+</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> ')'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">};</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">var</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> p </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> new</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> Point</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">);</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br><span class=\\\"line-number\\\">8</span><br><span class=\\\"line-number\\\">9</span><br><span class=\\\"line-number\\\">10</span><br></div></div>\",\"capture\":\"简介\\n 类的由来\\nJavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。\\n```javascript\\nfunction Point(x, y) {\\n  this.x = x;\\n  this.y = y;\\n}\\nPoint.prototype.toString = function () {\\n  return '(' + this.x + ', ' + this.y + ')';\\n};\\nvar p = new Point(1, 2);\\n```\\n上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。\\nES6 提供\"},{\"url\":\"/《ES6 教程》笔记/22.Class 的继承.html\",\"relativePath\":\"/《ES6 教程》笔记/22.Class 的继承.html\",\"frontmatter\":{\"title\":\"Class 的继承\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/83f8c3a0cd87dd83\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Class 的继承\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"class-的继承\\\" tabindex=\\\"-1\\\">Class 的继承 <a class=\\\"header-anchor\\\" href=\\\"#class-的继承\\\" aria-label=\\\"Permalink to &quot;Class 的继承&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>Class 可以通过<code>extends</code>关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">class</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> Point</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">class</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> ColorPoint</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> extends</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> Point</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br></div></div>\",\"capture\":\"简介\\nClass 可以通过`extends`关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。\\n```javascript\\nclass Point {\\n}\\nclass ColorPoint extends Point {\\n}\\n```\\n上面代码定义了一个`ColorPoint`类，该类通过`extends`关键字，继承了`Point`类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个`Point`类。下面，我们在`ColorPoint`内部加上代码。\\n```javascript\\nclass ColorPoint extends Point \"},{\"url\":\"/《ES6 教程》笔记/23.Module 的语法.html\",\"relativePath\":\"/《ES6 教程》笔记/23.Module 的语法.html\",\"frontmatter\":{\"title\":\"Module 的语法\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/efe2fb04eb8ac5fb\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Module 的语法\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"module-的语法\\\" tabindex=\\\"-1\\\">Module 的语法 <a class=\\\"header-anchor\\\" href=\\\"#module-的语法\\\" aria-label=\\\"Permalink to &quot;Module 的语法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的<code>require</code>、Python 的<code>import</code>，甚至就连 CSS 都有<code>@import</code>，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p>\\n\",\"capture\":\"概述\\n历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的`require`、Python 的`import`，甚至就连 CSS 都有`@import`，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。\\n在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD \"},{\"url\":\"/《ES6 教程》笔记/24.Module 的加载实现.html\",\"relativePath\":\"/《ES6 教程》笔记/24.Module 的加载实现.html\",\"frontmatter\":{\"title\":\"Module 的加载实现\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/a79ca2e64ceae213\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Module 的加载实现\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"module-的加载实现\\\" tabindex=\\\"-1\\\">Module 的加载实现 <a class=\\\"header-anchor\\\" href=\\\"#module-的加载实现\\\" aria-label=\\\"Permalink to &quot;Module 的加载实现&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>上一章介绍了模块的语法，本章介绍如何在浏览器和 Node.js 之中加载 ES6 模块，以及实际开发中经常遇到的一些问题（比如循环加载）。</p>\\n\",\"capture\":\"上一章介绍了模块的语法，本章介绍如何在浏览器和 Node.js 之中加载 ES6 模块，以及实际开发中经常遇到的一些问题（比如循环加载）。\\n 浏览器加载\\n 传统方法\\nHTML 网页中，浏览器通过`&lt;script\\n```html\\n&lt;!-- 页面内嵌的脚本 --&gt;\\n&lt;script type=\\\"application/javascript\\\"&gt;\\n  // module code\\n&lt;/script&gt;\\n&lt;!-- 外部脚本 --&gt;\\n&lt;script type=\\\"application/javascript\\\" src=\\\"path/to/myModule\"},{\"url\":\"/《ES6 教程》笔记/25.编程风格.html\",\"relativePath\":\"/《ES6 教程》笔记/25.编程风格.html\",\"frontmatter\":{\"title\":\"编程风格\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/984bf549204bb266\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"编程风格\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"编程风格\\\" tabindex=\\\"-1\\\">编程风格 <a class=\\\"header-anchor\\\" href=\\\"#编程风格\\\" aria-label=\\\"Permalink to &quot;编程风格&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>本章探讨如何将 ES6 的新语法，运用到编码实践之中，与传统的 JavaScript 语法结合在一起，写出合理的、易于阅读和维护的代码。</p>\\n<p>多家公司和组织已经公开了它们的风格规范，下面的内容主要参考了 <a href=\\\"https://github.com/airbnb/javascript\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">Airbnb</a> 公司的 JavaScript 风格规范。</p>\\n\",\"capture\":\"本章探讨如何将 ES6 的新语法，运用到编码实践之中，与传统的 JavaScript 语法结合在一起，写出合理的、易于阅读和维护的代码。\\n多家公司和组织已经公开了它们的风格规范，下面的内容主要参考了 Airbnb 公司的 JavaScript 风格规范。\\n 块级作用域\\n（1）let 取代 var\\nES6 提出了两个新的声明变量的命令：`let`和`const`。其中，`let`完全可以取代`var`，因为两者语义相同，而且`let`没有副作用。\\n```javascript\\n'use strict';\\nif (true) {\\n  let x = 'hello';\\n}\\nfor (let i = 0\"},{\"url\":\"/《ES6 教程》笔记/26.读懂 ECMAScript 规格.html\",\"relativePath\":\"/《ES6 教程》笔记/26.读懂 ECMAScript 规格.html\",\"frontmatter\":{\"title\":\"读懂 ECMAScript 规格\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/32c35f7651d6e58e\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"读懂 ECMAScript 规格\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"读懂-ecmascript-规格\\\" tabindex=\\\"-1\\\">读懂 ECMAScript 规格 <a class=\\\"header-anchor\\\" href=\\\"#读懂-ecmascript-规格\\\" aria-label=\\\"Permalink to &quot;读懂 ECMAScript 规格&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>规格文件是计算机语言的官方标准，详细描述语法规则和实现方法。</p>\\n<p>一般来说，没有必要阅读规格，除非你要写编译器。因为规格写得非常抽象和精炼，又缺乏实例，不容易理解，而且对于解决实际的应用问题，帮助不大。但是，如果你遇到疑难的语法问题，实在找不到答案，这时可以去查看规格文件，了解语言标准是怎么说的。规格是解决问题的“最后一招”。</p>\\n\",\"capture\":\"概述\\n规格文件是计算机语言的官方标准，详细描述语法规则和实现方法。\\n一般来说，没有必要阅读规格，除非你要写编译器。因为规格写得非常抽象和精炼，又缺乏实例，不容易理解，而且对于解决实际的应用问题，帮助不大。但是，如果你遇到疑难的语法问题，实在找不到答案，这时可以去查看规格文件，了解语言标准是怎么说的。规格是解决问题的“最后一招”。\\n这对 JavaScript 语言很有必要。因为它的使用场景复杂，语法规则不统一，例外很多，各种运行环境的行为不一致，导致奇怪的语法问题层出不穷，任何语法书都不可能囊括所有情况。查看规格，不失为一种解决语法问题的最可靠、最权威的终极方法。\\n本章介绍如何读懂 ECMASc\"},{\"url\":\"/《ES6 教程》笔记/27.异步遍历器.html\",\"relativePath\":\"/《ES6 教程》笔记/27.异步遍历器.html\",\"frontmatter\":{\"title\":\"异步遍历器\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/16121351be68691b\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"异步遍历器\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"异步遍历器\\\" tabindex=\\\"-1\\\">异步遍历器 <a class=\\\"header-anchor\\\" href=\\\"#异步遍历器\\\" aria-label=\\\"Permalink to &quot;异步遍历器&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"同步遍历器的问题\\\" tabindex=\\\"-1\\\">同步遍历器的问题 <a class=\\\"header-anchor\\\" href=\\\"#同步遍历器的问题\\\" aria-label=\\\"Permalink to &quot;同步遍历器的问题&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>《遍历器》一章说过，Iterator 接口是一种数据遍历的协议，只要调用遍历器对象的<code>next</code>方法，就会得到一个对象，表示当前遍历指针所在的那个位置的信息。<code>next</code>方法返回的对象的结构是<code>{value, done}</code>，其中<code>value</code>表示当前的数据的值，<code>done</code>是一个布尔值，表示遍历是否结束。</p>\\n\",\"capture\":\"同步遍历器的问题\\n《遍历器》一章说过，Iterator 接口是一种数据遍历的协议，只要调用遍历器对象的`next`方法，就会得到一个对象，表示当前遍历指针所在的那个位置的信息。`next`方法返回的对象的结构是`{value, done}`，其中`value`表示当前的数据的值，`done`是一个布尔值，表示遍历是否结束。\\n```javascript\\nfunction idMaker() {\\n  let index = 0;\\n  return {\\n    next: function() {\\n      return { value: index++, done: false };\\n    }\"},{\"url\":\"/《ES6 教程》笔记/28.ArrayBuffer.html\",\"relativePath\":\"/《ES6 教程》笔记/28.ArrayBuffer.html\",\"frontmatter\":{\"title\":\"ArrayBuffer\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/a2ba314746bfdbdd\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"ArrayBuffer\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"arraybuffer\\\" tabindex=\\\"-1\\\">ArrayBuffer <a class=\\\"header-anchor\\\" href=\\\"#arraybuffer\\\" aria-label=\\\"Permalink to &quot;ArrayBuffer&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><code>ArrayBuffer</code>对象、<code>TypedArray</code>视图和<code>DataView</code>视图是 JavaScript 操作二进制数据的一个接口。这些对象早就存在，属于独立的规格（2011 年 2 月发布），ES6 将它们纳入了 ECMAScript 规格，并且增加了新的方法。它们都是以数组的语法处理二进制数据，所以统称为二进制数组。</p>\\n\",\"capture\":\"`ArrayBuffer`对象、`TypedArray`视图和`DataView`视图是 JavaScript 操作二进制数据的一个接口。这些对象早就存在，属于独立的规格（2011 年 2 月发布），ES6 将它们纳入了 ECMAScript 规格，并且增加了新的方法。它们都是以数组的语法处理二进制数据，所以统称为二进制数组。\\n这个接口的原始设计目的，与 WebGL 项目有关。所谓 WebGL，就是指浏览器与显卡之间的通信接口，为了满足 JavaScript 与显卡之间大量的、实时的数据交换，它们之间的数据通信必须是二进制的，而不能是传统的文本格式。文本格式传递一个 32 位整数，两端的 Ja\"},{\"url\":\"/《ES6 教程》笔记/29.最新提案.html\",\"relativePath\":\"/《ES6 教程》笔记/29.最新提案.html\",\"frontmatter\":{\"title\":\"最新提案\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/7188882b8d65af1b\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"最新提案\",\"date\":\"2020-02-09 16:00:30\",\"excerpt\":\"<h1 id=\\\"最新提案\\\" tabindex=\\\"-1\\\">最新提案 <a class=\\\"header-anchor\\\" href=\\\"#最新提案\\\" aria-label=\\\"Permalink to &quot;最新提案&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>本章介绍一些尚未进入标准、但很有希望的最新提案。</p>\\n<h2 id=\\\"do-表达式\\\" tabindex=\\\"-1\\\">do 表达式 <a class=\\\"header-anchor\\\" href=\\\"#do-表达式\\\" aria-label=\\\"Permalink to &quot;do 表达式&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">{</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">  let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> t </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> f</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">();</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">  t </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> t </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">*</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> t </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">+</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br></div></div>\",\"capture\":\"本章介绍一些尚未进入标准、但很有希望的最新提案。\\n do 表达式\\n本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。\\n```javascript\\n{\\n  let t = f();\\n  t = t * t + 1;\\n}\\n```\\n上面代码中，块级作用域将两个语句封装在一起。但是，在块级作用域以外，没有办法得到`t`的值，因为块级作用域不返回值，除非`t`是全局变量。\\n现在有一个提案，使得块级作用域可以变为表达式，也就是说可以返回值，办法就是在块级作用域之前加上`do`，使它变为`do`表达式，然后就会返回内部最后执行的表达式的值。\\n```javascript\\nlet x = do {\"},{\"url\":\"/《ES6 教程》笔记/30.装饰器.html\",\"relativePath\":\"/《ES6 教程》笔记/30.装饰器.html\",\"frontmatter\":{\"title\":\"装饰器\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/e97bc1e5626b082c\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"装饰器\",\"date\":\"2020-02-09 16:00:30\",\"excerpt\":\"<h1 id=\\\"装饰器\\\" tabindex=\\\"-1\\\">装饰器 <a class=\\\"header-anchor\\\" href=\\\"#装饰器\\\" aria-label=\\\"Permalink to &quot;装饰器&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>[说明] Decorator 提案经过了大幅修改，目前还没有定案，不知道语法会不会再变。下面的内容完全依据以前的提案，已经有点过时了。等待定案以后，需要完全重写。</p>\\n<p>装饰器（Decorator）是一种与类（class）相关的语法，用来注释或修改类和类方法。许多面向对象的语言都有这项功能，目前有一个<a href=\\\"https://github.com/tc39/proposal-decorators\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">提案</a>将其引入了 ECMAScript。</p>\\n\",\"capture\":\"[说明] Decorator 提案经过了大幅修改，目前还没有定案，不知道语法会不会再变。下面的内容完全依据以前的提案，已经有点过时了。等待定案以后，需要完全重写。\\n装饰器（Decorator）是一种与类（class）相关的语法，用来注释或修改类和类方法。许多面向对象的语言都有这项功能，目前有一个提案将其引入了 ECMAScript。\\n装饰器是一种函数，写成`@ + 函数名`。它可以放在类和类方法的定义前面。\\n```javascript\\n@frozen class Foo {\\n  @configurable(false)\\n  @enumerable(true)\\n  method() {}\\n  @\"},{\"url\":\"/《ES6 教程》笔记/31.函数式编程.html\",\"relativePath\":\"/《ES6 教程》笔记/31.函数式编程.html\",\"frontmatter\":{\"title\":\"函数式编程\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/1cf50330655efc69\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"函数式编程\",\"date\":\"2020-02-09 16:00:30\",\"excerpt\":\"<h1 id=\\\"函数式编程\\\" tabindex=\\\"-1\\\">函数式编程 <a class=\\\"header-anchor\\\" href=\\\"#函数式编程\\\" aria-label=\\\"Permalink to &quot;函数式编程&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>JavaScript 语言从一诞生，就具有函数式编程的烙印。它将函数作为一种独立的数据类型，与其他数据类型处于完全平等的地位。在 JavaScript 语言中，你可以采用面向对象编程，也可以采用函数式编程。有人甚至说，JavaScript 是有史以来第一种被大规模采用的函数式编程语言。</p>\\n\",\"capture\":\"JavaScript 语言从一诞生，就具有函数式编程的烙印。它将函数作为一种独立的数据类型，与其他数据类型处于完全平等的地位。在 JavaScript 语言中，你可以采用面向对象编程，也可以采用函数式编程。有人甚至说，JavaScript 是有史以来第一种被大规模采用的函数式编程语言。\\nES6 的种种新增功能，使得函数式编程变得更方便、更强大。本章介绍 ES6 如何进行函数式编程。\\n 柯里化\\n柯里化（currying）指的是将一个多参数的函数拆分成一系列函数，每个拆分后的函数都只接受一个参数（unary）。\\n```javascript\\nfunction add (a, b) {\\n  retur\"},{\"url\":\"/《ES6 教程》笔记/32.Mixin.html\",\"relativePath\":\"/《ES6 教程》笔记/32.Mixin.html\",\"frontmatter\":{\"title\":\"Mixin\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/6a8e2dc558da1b39\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Mixin\",\"date\":\"2020-02-09 16:00:30\",\"excerpt\":\"<h1 id=\\\"mixin\\\" tabindex=\\\"-1\\\">Mixin <a class=\\\"header-anchor\\\" href=\\\"#mixin\\\" aria-label=\\\"Permalink to &quot;Mixin&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>JavaScript 语言的设计是单一继承，即子类只能继承一个父类，不允许继承多个父类。这种设计保证了对象继承的层次结构是树状的，而不是复杂的<a href=\\\"https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">网状结构</a>。</p>\\n\",\"capture\":\"JavaScript 语言的设计是单一继承，即子类只能继承一个父类，不允许继承多个父类。这种设计保证了对象继承的层次结构是树状的，而不是复杂的网状结构。\\n但是，这大大降低了编程的灵活性。因为实际开发中，有时不可避免，子类需要继承多个父类。举例来说，“猫”可以继承“哺乳类动物”，也可以继承“宠物”。\\n各种单一继承的编程语言，有不同的多重继承解决方案。比如，Java 语言也是子类只能继承一个父类，但是还允许继承多个界面（interface），这样就间接实现了多重继承。Interface 与父类一样，也是一个类，只不过它只定义接口（method signature），不定义实现，因此又被称为“抽象类\"},{\"url\":\"/《ES6 教程》笔记/33.SIMD.html\",\"relativePath\":\"/《ES6 教程》笔记/33.SIMD.html\",\"frontmatter\":{\"title\":\"SIMD\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/8e8f80f69b775a56\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"SIMD\",\"date\":\"2020-02-09 16:00:30\",\"excerpt\":\"<h1 id=\\\"simd\\\" tabindex=\\\"-1\\\">SIMD <a class=\\\"header-anchor\\\" href=\\\"#simd\\\" aria-label=\\\"Permalink to &quot;SIMD&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>SIMD（发音<code>/sim-dee/</code>）是“Single Instruction/Multiple Data”的缩写，意为“单指令，多数据”。它是 JavaScript 操作 CPU 对应指令的接口，你可以看做这是一种不同的运算执行模式。与它相对的是 SISD（“Single Instruction/Single Data”），即“单指令，单数据”。</p>\\n\",\"capture\":\"概述\\nSIMD（发音`/sim-dee/`）是“Single Instruction/Multiple Data”的缩写，意为“单指令，多数据”。它是 JavaScript 操作 CPU 对应指令的接口，你可以看做这是一种不同的运算执行模式。与它相对的是 SISD（“Single Instruction/Single Data”），即“单指令，单数据”。\\nSIMD 的含义是使用一个指令，完成多个数据的运算；SISD 的含义是使用一个指令，完成单个数据的运算，这是 JavaScript 的默认运算模式。显而易见，SIMD 的执行效率要高于 SISD，所以被广泛用于 3D 图形运算、物理模拟等运算\"},{\"url\":\"/《ES6 教程》笔记/34.参考链接.html\",\"relativePath\":\"/《ES6 教程》笔记/34.参考链接.html\",\"frontmatter\":{\"title\":\"参考链接\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/ea6f3b870f6dab69\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"参考链接\",\"date\":\"2020-02-09 16:00:30\",\"capture\":\"官方文件\\n- ECMAScript® 2015 Language Specification: ECMAScript 2015 规格\\n- ECMAScript® 2016 Language Specification: ECMAScript 2016 规格\\n- ECMAScript® 2017 Language Specification：ECMAScript 2017 规格（草案）\\n- ECMAScript Current Proposals: ECMAScript 当前的所有提案\\n- ECMAScript Active Proposals: 已经进入正式流程的提案\\n- ECMAScript\"},{\"url\":\"/《ES6 教程》笔记/35.了解ES6中的Map和Set.html\",\"relativePath\":\"/《ES6 教程》笔记/35.了解ES6中的Map和Set.html\",\"frontmatter\":{\"title\":\"了解ES6中的Map和Set\",\"date\":\"2023-09-08 16:10:10\",\"permalink\":\"/pages/bfde72/\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"了解ES6中的Map和Set\",\"date\":\"2023-09-08 16:10:10\",\"capture\":\"Map对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。构造函数Map可以接受一个数组作为参数。\\nMap对象的方法\\nset(key, val): 向Map中添加新元素\\nget(key): 通过键值查找特定的数值并返回\\nhas(key): 判断Map对象中是否有Key所对应的值，有返回true,否则返回false\\ndelete(key): 通过键值从Map中移除对应的数据\\nclear(): 将这个Map中的所有元素删除\\n```jsx\\nconst m1 = new Map([['a', 111], ['b', 222]])\\nconsole.log(m1) // {\\\"a\\\" =\\nm1\"},{\"url\":\"/《Electron》笔记/01.electron记录.html\",\"relativePath\":\"/《Electron》笔记/01.electron记录.html\",\"frontmatter\":{\"title\":\"electron记录\",\"date\":\"2023-09-09 14:23:20\",\"permalink\":\"/pages/8e9a16/\",\"categories\":[\"《Electron》笔记\"],\"tags\":[\"electron\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"electron记录\",\"date\":\"2023-09-09 14:23:20\",\"capture\":\"事件周期\\n electron常用事件统计\\n主进程常用事件可以分为以下几类：\\n1. 应用程序生命周期事件：\\n    - `ready`: 当 Electron 应用程序初始化完成且准备好显示窗口时触发。\\n    - `window-all-closed`: 当所有窗口都关闭后触发，在 macOS 上通常不会退出应用程序。\\n    - `activate`: 在 macOS 上，当用户点击应用程序的 Dock 图标并且没有其他窗口打开时触发，用于重新创建新窗口。\\n2. 窗口相关事件：\\n    - `closed`: 窗口关闭时触发。\\n    - `dom-ready`: 窗口加载完毕并且 DOM \"},{\"url\":\"/《Electron》笔记/02.electron下使用puppeteer模拟用户操作,数据获取.html\",\"relativePath\":\"/《Electron》笔记/02.electron下使用puppeteer模拟用户操作,数据获取.html\",\"frontmatter\":{\"title\":\"electron下使用puppeteer模拟用户操作,数据获取\",\"date\":\"2023-09-09 15:15:18\",\"permalink\":\"/pages/56ebf1/\",\"categories\":[\"《Electron》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"electron下使用puppeteer模拟用户操作,数据获取\",\"date\":\"2023-09-09 15:15:18\",\"capture\":\"Puppeteer是一个由Google开发的Node.js库，它提供了一组用于控制和自动化Chrome或Chromium浏览器的API。它可以用于执行各种与浏览器相关的任务，如网页截图、生成PDF、模拟用户交互、爬取网页数据等。Puppeteer通过WebSocket连接与浏览器建立通信，并通过DevTools协议发送命令和接收浏览器的响应。\\n什么是 Chrome DevTool Protocol\\n- CDP 基于 WebSocket，利用 WebSocket 实现与浏览器内核的快速数据通道\\n- CDP 分为多个域（DOM，Debugger，Network，Profiler，Console..\"},{\"url\":\"/《Git》学习笔记/10.手册/00.常用Git命令清单.html\",\"relativePath\":\"/《Git》学习笔记/10.手册/00.常用Git命令清单.html\",\"frontmatter\":{\"title\":\"常用Git命令清单\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/8292d8/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"常用Git命令清单\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。\\n下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。\\n\\n&gt; - Index / Stage：暂存区\\n&gt; - Repository：仓库区（或本地仓库）\\n&gt; - Remote：远程仓库\\n 一、新建代码库\\n```bash\\n 在当前目录新建一个Git代码库\\n$ git init\\n 新建一个目录，将其初始化为Git代码库\\n$ git init [project-name]\\n 下载一个项目和它的整个代码历史\\n$ git clone [url]\\n```\\n 二、配置\\nGit的设置文件为\"},{\"url\":\"/《Git》学习笔记/10.手册/01.Git变基合并.html\",\"relativePath\":\"/《Git》学习笔记/10.手册/01.Git变基合并.html\",\"frontmatter\":{\"title\":\"Git变基合并\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/c10281/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git变基合并\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"说明\\n以下 `v2` 是某个需求的开发分支， `dev`是总的开发分支，`v2` 是基于`dev`分支签出的。\\n当完成`v2`的开发后，需要把代码合并到`dev`，我们可以使用`rebase`进行合并：\\n```sh\\n 首先将 v2 push到远程仓库\\ngit add .\\ngit commit -m 'xxx'\\ngit push origin v2\\n 切换到 dev 拉取最新代码\\ngit checkout dev\\ngit pull origin dev\\n 切换到 v2\\ngit checkout v2\\ngit rebase dev  将 v2 的所有[commit] 变基到(应用到) dev\\n 切\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/10.Git基础与命令.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/10.Git基础与命令.html\",\"frontmatter\":{\"title\":\"Git基础与命令\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/635088/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git基础与命令\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"官方文档（中文）：https://git-scm.com/book/zh/v2\\n\\n Git基础\\n 全局配置\\n```bash\\ngit config --global user.name 'your name'\\ngit config --global user.email 'xxx@xx.com'\\n```\\n自报家门\\n 检查配置信息\\n```sh\\ngit config --list\\n```\\n 获取帮助\\n```sh\\n 获取全局帮助手册\\ngit help\\n 获取特定命令的详细版帮助手册 (两个命令是等价的)\\ngit help &lt;某个命令&gt;\\ngit &lt;某个命令&gt; --help  两个\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/100.Git工具-重写历史.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/100.Git工具-重写历史.html\",\"frontmatter\":{\"title\":\"Git工具-重写历史\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/1832fe/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git工具-重写历史\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"许多时候，在使用 Git 时，你可能想要修订提交历史。 Git 很棒的一点是它允许你在最后时刻做决定。 你可以在将暂存区内容提交前决定哪些文件进入提交，可以通过 `git stash` 来决定不与某些内容工作， 也可以重写已经发生的提交就像它们以另一种方式发生的一样。 这可能涉及改变提交的顺序，改变提交中的信息或修改文件，将提交压缩或是拆分， 或完全地移除提交——在将你的工作成果与他人共享之前。\\n在本节中，你可以学到如何完成这些工作，这样在与他人分享你的工作成果时你的提交历史将如你所愿地展示出来。\\n| Note | 在满意之前不要推送你的工作Git 的基本原则之一是，由于克隆中有很多工作是本地\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/110.Git工具-重置揭密.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/110.Git工具-重置揭密.html\",\"frontmatter\":{\"title\":\"Git工具-重置揭密\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/d9e9c6/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git工具-重置揭密\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"在继续了解更专业的工具前，我们先探讨一下 Git 的 `reset` 和 `checkout` 命令。 在初遇的 Git 命令中，这两个是最让人困惑的。 它们能做很多事情，所以看起来我们很难真正地理解并恰当地运用它们。 针对这一点，我们先来做一个简单的比喻。\\n 三棵树\\n理解 `reset` 和 `checkout` 的最简方法，就是以 Git 的思维框架（将其作为内容管理器）来管理三棵不同的树。 “树” 在我们这里的实际意思是 “文件的集合”，而不是指特定的数据结构。 （在某些情况下索引看起来并不像一棵树，不过我们现在的目的是用简单的方式思考它。）\\nGit 作为一个系统，是以它的一般操作来管理\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/20.Git分支-分支原理.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/20.Git分支-分支原理.html\",\"frontmatter\":{\"title\":\"Git分支-分支原理\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/4bef1a/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支-分支原理\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。\\n 首次提交\\n在进行提交操作时，Git 会保存一个提交对象（commit object）。\\n假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 暂存操作会为每一个文件计算校验和（使用 SHA-1 哈希算法），然后会把当前版本的文件快照保存到 Git 仓库中 （Git 使用 *blob* 对象来保存它们），最终将校验和加入到暂存区域等待提交：\\n```sh\\n$ git\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/30.Git分支的新建与合并-分支操作.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/30.Git分支的新建与合并-分支操作.html\",\"frontmatter\":{\"title\":\"Git分支的新建与合并-分支操作\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/ea5a8c/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支的新建与合并-分支操作\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"文档：Git 分支 - 分支的新建与合并\\n 创建分支并切换\\n此时有一个需求需要在新的分支`iss53`上工作：\\n```sh\\n$ git checkout -b iss53   b表示branch\\n```\\n它是下面两条命令的简写：\\n```sh\\n$ git branch iss53\\n$ git checkout iss53\\n```\\n 切换分支\\n突然有一个紧急问题要解决，需要在原来的`master`分支进行修复：\\n```sh\\n$ git checkout master\\n```\\n在切换到`master`之前，需要`iss53`分支保持好一个干净的状态（修改都已提交）。\\n注意：切换分支Git 会重置你的\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/40.Git分支管理-查看分支.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/40.Git分支管理-查看分支.html\",\"frontmatter\":{\"title\":\"Git分支管理-查看分支\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/a399b3/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支管理-查看分支\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"查看分支\\n```sh\\n$ git branch\\n  iss53\\n* master   带星号*表示当前所在分支\\n  testing\\n```\\n`git branch` 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表。\\n 查看每个分支的最后提交\\n```sh\\n$ git branch -v\\n  iss53   93b412c fix javascript issue\\n* master  7a98805 Merge branch 'iss53'\\n  testing 782fd34 test\\n```\\n 查看已(未)合并的分支\\n`--merged` 与 `--no-m\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/50.Git分支开发工作流.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/50.Git分支开发工作流.html\",\"frontmatter\":{\"title\":\"Git分支开发工作流\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/49ee30/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支开发工作流\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"文档：Git分支开发工作流\\n 长期分支\\n因为 Git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。 也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些主题分支合并入其他分支中。\\n许多使用 Git 的开发者都喜欢使用这种方式来工作，比如只在 `master` 分支上保留完全稳定的代码，开发过程在`dev`分支，开发完成后并入`test`分支进行测试，通过测试的稳定代码才并入`master`分支中。\\n`dev`和`test`分支不需要保持绝对稳定，但在`test`通过测试达到稳定状态，就可以被合并入`mast\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/60.Git分支-远程分支.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/60.Git分支-远程分支.html\",\"frontmatter\":{\"title\":\"Git分支-远程分支\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/574d62/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支-远程分支\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"远程引用是对远程仓库的引用（指针），包括分支、标签等等。\\n\\n 查看远程引用列表与信息\\n```sh\\ngit ls-remote &lt;remote&gt;  远程引用的完整列表\\ngit remote show &lt;remote&gt;  远程分支的更多信息\\n```\\n上面两行命令比较少用，更常见的做法是利用远程跟踪分支。\\n 远程跟踪分支\\n远程跟踪分支是远程分支状态的引用。它们是你无法移动的本地引用。一旦你进行了网络通信， Git 就会为你移动它们以精确反映远程仓库的状态。请将它们看做书签， 这样可以提醒你该分支在远程仓库中的位置就是你最后一次连接到它们的位置。\\n它们以 `&lt;remote\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/70.Git分支-变基.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/70.Git分支-变基.html\",\"frontmatter\":{\"title\":\"Git分支-变基\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/3a3247/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支-变基\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"在 Git 中整合来自不同分支的修改主要有两种方法：`merge` 以及 `rebase`。 在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。\\n 变基的基本操作\\n请回顾之前在 分支的合并 中的一个例子，你会看到开发任务分叉到两个不同分支，又各自提交了更新。\\n&lt;p align=\\\"center\\\"\\n之前介绍过，整合分支最容易的方法是 `merge` 命令。 它会把两个分支的最新快照（`C3` 和 `C4`）以及二者最近的共同祖先（`C2`）进行三方合并，合并的结果是生成一个新的快照（并提交）。\\n &lt;p align=\\\"cen\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/80.Git工具-查看修订版本.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/80.Git工具-查看修订版本.html\",\"frontmatter\":{\"title\":\"Git工具-查看修订版本\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/c984d1/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git工具-查看修订版本\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"Git 能够以多种方式来指定单个提交、一组提交、或者一定范围内的提交。 了解它们并不是必需的，但是了解一下总没坏处。\\n修订版本指的是：提交\\n 单个修订版本\\n你可以通过任意一个提交的 40 个字符的完整 SHA-1 散列值来指定它， 不过还有很多更人性化的方式来做同样的事情。本节将会介绍获取单个提交的多种方法。\\n 简短的 SHA-1\\nGit 十分智能，你只需要提供 SHA-1 的前几个字符就可以获得对应的那次提交， 当然你提供的 SHA-1 字符数量不得少于 4 个，并且没有歧义——也就是说， 当前对象数据库中没有其它对象以这段 SHA-1 开头。\\n例如，要查看你知道其中添加了某个功能的提交，首\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/90.Git工具-交互式暂存.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/90.Git工具-交互式暂存.html\",\"frontmatter\":{\"title\":\"Git工具-交互式暂存\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/76d859/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git工具-交互式暂存\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"本节中的几个交互式 Git 命令可以帮助你将文件的特定部分组合成提交。 当你在修改了大量文件后，希望这些改动能拆分为若干提交而不是混杂在一起成为一个提交时，这几个工具会非常有用。 通过这种方式，可以确保提交是逻辑上独立的变更集，同时也会使其他开发者在与你工作时很容易地审核。 如果运行 `git add` 时使用 `-i` 或者 `--interactive` 选项，Git 将会进入一个交互式终端模式，显示类似下面的东西：\\n```sh\\n$ git add -i\\n           staged     unstaged path\\n  1:    unchanged        +0/-1 T\"},{\"url\":\"/《Git》学习笔记/Git常用命令速查表.html\",\"relativePath\":\"/《Git》学习笔记/Git常用命令速查表.html\",\"frontmatter\":{\"title\":\"Git常用命令速查表\",\"date\":\"2024-03-30 15:26:32\",\"permalink\":\"/pages/3aa4fd/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git常用命令速查表\",\"date\":\"2024-03-30 15:26:32\",\"capture\":\"\"},{\"url\":\"/《JavaScript教程》笔记/01.基础.html\",\"relativePath\":\"/《JavaScript教程》笔记/01.基础.html\",\"frontmatter\":{\"title\":\"基础\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/0796ba76b4b55368\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"基础\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"基础篇\\n 一、JS的一些名词概念\\n 什么是作用域？\\n变量存在的范围。\\n可分为全局作用域和函数作用域，ES6新增块级作用域。\\n 什么是闭包？\\n闭包就是能够读取其他函数内部变量的函数。\\n* 闭包的形式：函数内部定义函数\\n* 本质上闭包就是将函数内部和外部连接起来的一座桥梁\\n闭包的作用：\\n* 可以读取函数内部变量\\n* 让这些变量始终保持在内存中，即闭包可以使得它诞生的环境一直存在。\\n*  封装对象的私有属性和私有方法\\n 什么是构造函数？\\n用于构造(生成)实例的一个函数，使实例拥有构造函数内定于的属性和方法。\\n 什么是实例对象？\\n实例对象就是通过new 构造函数生成的，拥有构造函数内定于的属性和方法的\"},{\"url\":\"/《JavaScript教程》笔记/02.内置对象.html\",\"relativePath\":\"/《JavaScript教程》笔记/02.内置对象.html\",\"frontmatter\":{\"title\":\"内置对象\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/74d2ab3fbfeaaa68\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"内置对象\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"内置对象篇\\n 一、Object对象\\n 1、概述\\nJavaScript 原生提供`Object`对象（注意起首的`O`是大写），本章介绍该对象原生的各种方法。\\nJavaScript 的所有其他对象都继承自`Object`对象，即那些对象都是`Object`的实例。\\n`Object`对象的原生方法分成两类：`Object`本身的方法与`Object`的实例方法。\\n（1）Object对象本身的方法\\n所谓“本身的方法”就是直接定义在`Object`对象的方法。\\n```js\\nObject.print = function (o) { console.log(o) };\\n```\\n上面代码中，`print`\"},{\"url\":\"/《JavaScript教程》笔记/03.面向对象.html\",\"relativePath\":\"/《JavaScript教程》笔记/03.面向对象.html\",\"frontmatter\":{\"title\":\"面向对象\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/659b5af5e2e704e0\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"面向对象\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"面向对象编程\\n 一、实例对象与new命令\\n 1、对象是什么\\n面向对象编程（Object Oriented Programming，缩写为 OOP）是目前主流的编程范式。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。\\n每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务。对象可以复用，通过继承机制还可以定制。因此，面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程（procedural programming），更适合多人合作的大型软件项目。\\n那么，“对象”\"},{\"url\":\"/《JavaScript教程》笔记/04.异步操作.html\",\"relativePath\":\"/《JavaScript教程》笔记/04.异步操作.html\",\"frontmatter\":{\"title\":\"异步操作\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/d61b1cb4cdac1f63\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"异步操作\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"异步操作\\n 一、异步操作概述\\n 1、单线程模型\\n单线程模型指的是，JavaScript 只在一个线程上运行。也就是说，JavaScript 同时只能执行一个任务，其他任务都必须在后面排队等待。\\n注意，JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合。\\nJavaScript 之所以采用单线程，而不是多线程，跟历史有关系。JavaScript 从诞生起就是单线程，原因是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对\"},{\"url\":\"/《JavaScript教程》笔记/05.DOM.html\",\"relativePath\":\"/《JavaScript教程》笔记/05.DOM.html\",\"frontmatter\":{\"title\":\"DOM\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/7d961b8030c6099e\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"DOM\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"DOM\\n 一、概述\\n 1、DOM\\nDOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。\\n浏览器会根据 DOM 模型，将结构化文档（比如 HTML 和 XML）解析成一系列的节点，再由这些节点组成一个树状结构（DOM Tree）。所有的节点和最终的树状结构，都有规范的对外接口。\\nDOM 只是一个接口规范，可以用各种语言实现。所以严格地说，DOM 不是 JavaScript 语法的一部分，但是 DOM 操作是 JavaScript 最\"},{\"url\":\"/《JavaScript教程》笔记/06.事件.html\",\"relativePath\":\"/《JavaScript教程》笔记/06.事件.html\",\"frontmatter\":{\"title\":\"事件\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/10b2761db5a8e089\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"事件\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"事件\\n 一、EventTarget 接口\\n 事件的本质是程序各个组成部分之间的一种通信方式，也是异步编程的一种实现。DOM 支持大量的事件，本章开始介绍 DOM 的事件编程。\\n 1、概述\\nDOM 的事件操作（监听和触发），都定义在`EventTarget`接口。所有节点对象都部署了这个接口，其他一些需要事件通信的浏览器内置对象（比如，`XMLHttpRequest`、`AudioNode`、`AudioContext`）也部署了这个接口。\\n该接口主要提供三个实例方法。\\n- `addEventListener`：绑定事件的监听函数\\n- `removeEventListener`：移除事件的监听函\"},{\"url\":\"/《JavaScript教程》笔记/07.浏览器模型.html\",\"relativePath\":\"/《JavaScript教程》笔记/07.浏览器模型.html\",\"frontmatter\":{\"title\":\"浏览器模型\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/bab4930124ad2c10\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"浏览器模型\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"一、浏览器环境概述\\nJavaScript 是浏览器的内置脚本语言。也就是说，浏览器内置了 JavaScript 引擎，并且提供各种接口，让 JavaScript 脚本可以控制浏览器的各种功能。一旦网页内嵌了 JavaScript 脚本，浏览器加载网页，就会去执行脚本，从而达到操作浏览器的目的，实现网页的各种动态效果。\\n本章开始介绍浏览器提供的各种 JavaScript 接口。首先，介绍 JavaScript 代码嵌入网页的方法。\\n 1、代码嵌入网页的方法\\n网页中嵌入 JavaScript 代码，主要有三种方法。\\n- `  &lt;script\\n- `  &lt;script&gt;  `标签加\"},{\"url\":\"/《JavaScript教程》笔记/08.事件循环(evenloop).html\",\"relativePath\":\"/《JavaScript教程》笔记/08.事件循环(evenloop).html\",\"frontmatter\":{\"title\":\"事件循环(evenloop)\",\"date\":\"2023-09-08 16:20:58\",\"permalink\":\"/pages/eaf565/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"事件循环(evenloop)\",\"date\":\"2023-09-08 16:20:58\",\"capture\":\"JavaScript 是一门单线程的语言，它的异步和多线程的实现是通过 Event Loop 事件循环机制来实现的\\nEvent Loop 的机制\\n大体三个部分组成\\n1、调用栈 Stack\\n2、消息队列 Message Queue\\n3、微任务队列 Microtask Queue\\n Event Loop 开始的时候会从全局栈开始逐行执行，遇到函数调用，会把函数压入到调用栈中，当函数返回后，会从调用栈中弹出\\n```javascript\\nfunction func1(){\\n    console.log(1);\\n }\\n function func2(){\\n    console.log(2);\\n   \"},{\"url\":\"/《JavaScript教程》笔记/09.js 使用postMessage iframe跨域通信.html\",\"relativePath\":\"/《JavaScript教程》笔记/09.js 使用postMessage iframe跨域通信.html\",\"frontmatter\":{\"title\":\"js 使用postMessage iframe跨域通信\",\"date\":\"2024-03-30 15:21:11\",\"permalink\":\"/pages/d67bac/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"js 使用postMessage iframe跨域通信\",\"date\":\"2024-03-30 15:21:11\",\"capture\":\"在 Web 应用程序中，由于同源策略的限制，如果我们需要在一个页面中嵌入来自不同域的资源（例如图片、脚本或 iframe），那么就会出现跨域问题。在这种情况下，我们需要使用一些技术来实现跨域通信。\\r\\n\\r\\n其中一种解决方案是使用 HTML5 中引入的 postMessage API。postMessage 允许我们在不同窗口或 iframe 之间发送消息，这使得我们可以实现跨域通信，而不违反同源策略。\\r\\n\\r\\n postMessage 简介\\r\\n\\r\\npostMessage 是 HTML5 中引入的一种跨窗口通信机制。它允许我们在不同窗口之间发送消息，并且这些窗口可以来自不同的域。postMessag\"},{\"url\":\"/《JavaScript教程》笔记/10.JS中的？.和？？区别.html\",\"relativePath\":\"/《JavaScript教程》笔记/10.JS中的？.和？？区别.html\",\"frontmatter\":{\"title\":\"和？？区别\",\"date\":\"2024-03-30 15:22:03\",\"permalink\":\"/pages/176ae0/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"和？？区别\",\"date\":\"2024-03-30 15:22:03\",\"capture\":\"`??` 运算符\\r\\n\\r\\n`??` 运算符是 ES2020 中新增的空值合并运算符。它用于判断一个值是否为 `null` 或 `undefined`，如果是，则使用默认值。其语法如下：\\r\\n\\r\\n```javascript\\r\\ndefaultValue ?? value;\\r\\n```\\r\\n\\r\\n如果 `value` 不为 `null` 或 `undefined`，则 `??` 运算符返回 `value`；否则返回 `defaultValue`。\\r\\n\\r\\n```javascript\\r\\nconst a = null;\\r\\nconst b = 5;\\r\\n\\r\\nconsole.log(a ?? 10); // 10\\r\\nco\"},{\"url\":\"/《JavaScript教程》笔记/11.`import`、`require`、`export`、`module.exports` 的区别和使用详解.html\",\"relativePath\":\"/《JavaScript教程》笔记/11.`import`、`require`、`export`、`module.exports` 的区别和使用详解.html\",\"frontmatter\":{\"title\":\"exports` 的区别和使用详解\",\"date\":\"2024-03-30 15:23:12\",\"permalink\":\"/pages/ff5679/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"exports` 的区别和使用详解\",\"date\":\"2024-03-30 15:23:12\",\"capture\":\"在 Node.js 和现代的 JavaScript 中，有多种方式可以导入和导出模块。其中最常见的是使用 `import` 和 `export`，但在 Node.js 中，也可以使用 `require` 和 `module.exports`。本篇文章将介绍这些不同的方式，以及它们之间的区别。\\r\\n\\r\\n `import` 和 `export`\\r\\n\\r\\n`import` 和 `export` 是 ES6 中引入的模块系统。它们允许我们将代码拆分成多个文件，并在不同的文件中共享代码。以下是一个简单的例子：\\r\\n\\r\\n```javascript\\r\\n// math.js\\r\\nexport const add = \"},{\"url\":\"/《JavaScript教程》笔记/12.console实用调试方法.html\",\"relativePath\":\"/《JavaScript教程》笔记/12.console实用调试方法.html\",\"frontmatter\":{\"title\":\"console实用调试方法\",\"date\":\"2024-03-30 15:31:48\",\"permalink\":\"/pages/602ffc/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"console实用调试方法\",\"date\":\"2024-03-30 15:31:48\",\"capture\":\"在JavaScript中，console是一个非常有用的工具，可以帮助我们在开发和调试过程中更好地了解代码的执行情况。本文将介绍console中一些常用的方法，并提供示例代码。\\r\\n console.time() & console.timeEnd()\\r\\nconsole.time()方法用于开始计时器，console.timeEnd()方法用于结束计时器并输出所花费的时间。这对于测试代码执行时间非常有用。\\r\\n```javascript\\r\\nconsole.time('myTimer');\\r\\nfor (let i = 0; i &lt; 1000000; i++) {\\r\\n  // do someth\"},{\"url\":\"/《JavaScript教程》笔记/13.JS继承.html\",\"relativePath\":\"/《JavaScript教程》笔记/13.JS继承.html\",\"frontmatter\":{\"title\":\"JS继承\",\"date\":\"2024-03-30 15:32:05\",\"permalink\":\"/pages/b17c09/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"JS继承\",\"date\":\"2024-03-30 15:32:05\",\"capture\":\"在JavaScript中，继承是实现面向对象编程的重要方式之一。\\r\\n\\r\\n 原型继承\\r\\n\\r\\n原型继承是JavaScript中最常用的继承方式之一。在原型继承中，子类通过继承父类的原型对象来实现继承。\\r\\n\\r\\n```javascript\\r\\nfunction Parent() {\\r\\n  this.name = 'parent';\\r\\n}\\r\\n\\r\\nParent.prototype.sayHello = function() {\\r\\n  console.log('Hello from ' + this.name);\\r\\n}\\r\\n\\r\\nfunction Child() {\\r\\n  this.name = 'child';\"},{\"url\":\"/《JavaScript教程》笔记/14.JS实现扫码登录.html\",\"relativePath\":\"/《JavaScript教程》笔记/14.JS实现扫码登录.html\",\"frontmatter\":{\"title\":\"JS实现扫码登录\",\"date\":\"2024-03-30 15:32:39\",\"permalink\":\"/pages/bdbdb8/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"JS实现扫码登录\",\"date\":\"2024-03-30 15:32:39\",\"capture\":\"JS实现扫码登录\\r\\n\\r\\n扫码登录是一种方便快捷的登录方式，用户可以通过扫描二维码来登录网站或应用程序。在本文中，我们将使用JavaScript实现一个简单的扫码登录功能。\\r\\n\\r\\n 步骤一：生成二维码\\r\\n\\r\\n首先，我们需要生成一个二维码，用于展示给用户扫描。我们可以使用第三方库 qrcode.js 来生成二维码。以下是使用qrcode.js生成二维码的示例代码：\\r\\n\\r\\n```html\\r\\n&lt;!-- 在HTML中引入qrcode.js库 --\\r\\n&lt;script src=\\\"https://cdn.bootcdn.net/ajax/libs/qrcodejs/1.0.0/qrcode.min\"},{\"url\":\"/《Vue》笔记/01.基础/00.MVVM模式.html\",\"relativePath\":\"/《Vue》笔记/01.基础/00.MVVM模式.html\",\"frontmatter\":{\"title\":\"MVVM模式\",\"date\":\"2020-02-04 12:19:00\",\"permalink\":\"/pages/114158caa9e96df0\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"MVVM模式\",\"date\":\"2020-02-04 12:19:00\",\"excerpt\":\"<div class=\\\"tip custom-block\\\"><p class=\\\"custom-block-title\\\">TIP</p>\\n<p>说明：本章内容是博主的Vue学习笔记，以<a href=\\\"https://cn.vuejs.org/v2/guide/\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">官方文档</a>为准。</p>\\n</div>\\n<h1 id=\\\"mvvm模式\\\" tabindex=\\\"-1\\\">MVVM模式 <a class=\\\"header-anchor\\\" href=\\\"#mvvm模式\\\" aria-label=\\\"Permalink to &quot;MVVM模式&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>MVVM模式，<code>M</code>即 model，数据模型；<code>V</code>即 view，视图；<code>VM</code>即 view-model，视图模型。</p>\\n\",\"capture\":\"说明：本章内容是博主的Vue学习笔记，以官方文档为准。\\n MVVM模式\\nMVVM模式，`M`即 model，数据模型；`V`即 view，视图；`VM`即 view-model，视图模型。\\n理解\\n首先，数据Model通过Data Bindings把数据绑定在View视图上，\\n当View视图有交互（有改变）的时候，Dom listeners会自动监听，然后更新数据Model。\\nQ：什么是MVVM模式？\\nA：MVVM模式，第一个M代表数据模型，V代表视图，VM代表视图模型；\\n它的实际操作原理是：后台数据通过视图模型来渲染视图，就是页面。当用户在页面上进行操作的时候，\\n视图模型会自动监听到用户的操作\"},{\"url\":\"/《Vue》笔记/01.基础/10.生命周期.html\",\"relativePath\":\"/《Vue》笔记/01.基础/10.生命周期.html\",\"frontmatter\":{\"title\":\"生命周期\",\"date\":\"2020-02-04 15:06:59\",\"permalink\":\"/pages/176808a1b5f843b8\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"生命周期\",\"date\":\"2020-02-04 15:06:59\",\"excerpt\":\"<h1 id=\\\"实例生命周期钩子\\\" tabindex=\\\"-1\\\">实例生命周期钩子 <a class=\\\"header-anchor\\\" href=\\\"#实例生命周期钩子\\\" aria-label=\\\"Permalink to &quot;实例生命周期钩子&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/instance.html#%E5%AE%9E%E4%BE%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">实例生命周期钩子API</a></p>\\n<p>简单理解，生命周期钩子函数就是vue实例在某一个时间点会自动执行的函数。</p>\\n\",\"capture\":\"实例生命周期钩子API\\n简单理解，生命周期钩子函数就是vue实例在某一个时间点会自动执行的函数。\\n```html\\n&lt;div id=\\\"app\\\"\\n&lt;script src=\\\"https://cdn.bootcss.com/vue/2.4.2/vue.js\\\"&gt;&lt;/script&gt;\\n&lt;script&gt;\\n  var vm = new Vue({\\n    el: 'app',\\n    data: {\\n      msg: 'Vue的生命周期'\\n    },\\n    beforeCreate: function() {\\n      console.group('-----\"},{\"url\":\"/《Vue》笔记/01.基础/20.计算属性 vs 方法 vs 侦听属性.html\",\"relativePath\":\"/《Vue》笔记/01.基础/20.计算属性 vs 方法 vs 侦听属性.html\",\"frontmatter\":{\"title\":\"计算属性 vs 方法 vs 侦听属性\",\"date\":\"2020-02-04 16:37:51\",\"permalink\":\"/pages/351f72ecd9c41129\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"计算属性 vs 方法 vs 侦听属性\",\"date\":\"2020-02-04 16:37:51\",\"excerpt\":\"<h1 id=\\\"计算属性-vs-方法-vs-侦听属性\\\" tabindex=\\\"-1\\\">计算属性 vs 方法 vs 侦听属性 <a class=\\\"header-anchor\\\" href=\\\"#计算属性-vs-方法-vs-侦听属性\\\" aria-label=\\\"Permalink to &quot;计算属性 vs 方法 vs 侦听属性&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/computed.html#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%BC%93%E5%AD%98-vs-%E6%96%B9%E6%B3%95\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">API</a></p>\\n<p>如果一个功能同时可以使用计算属性(computed)、方法(methods)、侦听属性(watch)来实现的时候推荐使用计算属性。</p>\\n\",\"capture\":\"API\\n如果一个功能同时可以使用计算属性(computed)、方法(methods)、侦听属性(watch)来实现的时候推荐使用计算属性。\\n| 计算属性                                 | 方法                                               | 侦听属性                                     |\\n| ---------------------------------------- | --------------------------------------------------\"},{\"url\":\"/《Vue》笔记/01.基础/30.v-if vs v-show.html\",\"relativePath\":\"/《Vue》笔记/01.基础/30.v-if vs v-show.html\",\"frontmatter\":{\"title\":\"v-if vs v-show\",\"date\":\"2020-02-04 17:32:23\",\"permalink\":\"/pages/73e4064340277b05\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"v-if vs v-show\",\"date\":\"2020-02-04 17:32:23\",\"excerpt\":\"<h1 id=\\\"v-if-vs-v-show\\\" tabindex=\\\"-1\\\">v-if vs v-show <a class=\\\"header-anchor\\\" href=\\\"#v-if-vs-v-show\\\" aria-label=\\\"Permalink to &quot;v-if vs v-show&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/conditional.html#v-if-vs-v-show\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">API</a></p>\\n<p><code>v-if</code> 根据渲染条件决定是否把元素渲染到DOM页面，而<code>v-show</code>不管渲染条件是什么，都会把元素渲染到DOM页面，只是简单的切换CSS的显示隐藏。</p>\\n\",\"capture\":\"API\\n`v-if` 根据渲染条件决定是否把元素渲染到DOM页面，而`v-show`不管渲染条件是什么，都会把元素渲染到DOM页面，只是简单的切换CSS的显示隐藏。\\n如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好。\"},{\"url\":\"/《Vue》笔记/01.基础/35.列表渲染之数组、对象更新检测.html\",\"relativePath\":\"/《Vue》笔记/01.基础/35.列表渲染之数组、对象更新检测.html\",\"frontmatter\":{\"title\":\"列表渲染之数组、对象更新检测\",\"date\":\"2020-02-05 13:09:06\",\"permalink\":\"/pages/04783a6691cc9d06\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"列表渲染之数组、对象更新检测\",\"date\":\"2020-02-05 13:09:06\",\"excerpt\":\"<h1 id=\\\"列表渲染之数组、对象更新检测\\\" tabindex=\\\"-1\\\">列表渲染之数组、对象更新检测 <a class=\\\"header-anchor\\\" href=\\\"#列表渲染之数组、对象更新检测\\\" aria-label=\\\"Permalink to &quot;列表渲染之数组、对象更新检测&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/list.html#%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">数组更新检测API</a> <a href=\\\"https://cn.vuejs.org/v2/guide/list.html#%E5%AF%B9%E8%B1%A1%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">对象更新检测API</a></p>\\n<h2 id=\\\"数组更新检测\\\" tabindex=\\\"-1\\\">数组更新检测 <a class=\\\"header-anchor\\\" href=\\\"#数组更新检测\\\" aria-label=\\\"Permalink to &quot;数组更新检测&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h4 id=\\\"变异方法-mutation-method\\\" tabindex=\\\"-1\\\">变异方法 (mutation method) <a class=\\\"header-anchor\\\" href=\\\"#变异方法-mutation-method\\\" aria-label=\\\"Permalink to &quot;变异方法 (mutation method)&quot;\\\">&ZeroWidthSpace;</a></h4>\\n<p>Vue 将被侦听的数组的变异方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：</p>\\n\",\"capture\":\"数组更新检测API 对象更新检测API\\n 数组更新检测\\n 变异方法 (mutation method)\\nVue 将被侦听的数组的变异方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：\\n- `push()`末尾添加\\n- `pop()`末尾删除\\n- `shift()` 首位删除\\n- `unshift() ` 首位添加\\n- `splice()` 拼合\\n- `sort()` 排序\\n- `reverse()` 反转\\n数组实例方法\\n 替换数组\\n变异方法，顾名思义，会改变调用了这些方法的原始数组。相比之下，也有非变异 (non-mutating method) 方法，例如 `filter(\"},{\"url\":\"/《Vue》笔记/02.组件/36.使用组件的细节点.html\",\"relativePath\":\"/《Vue》笔记/02.组件/36.使用组件的细节点.html\",\"frontmatter\":{\"title\":\"使用组件的细节点\",\"date\":\"2020-02-13 13:26:20\",\"permalink\":\"/pages/83a1ab785e7fd70c\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"使用组件的细节点\",\"date\":\"2020-02-13 13:26:20\",\"capture\":\"解析 DOM 模板时的注意事项\\n```html\\n&lt;div id=\\\"root\\\"\\n    &lt;table&gt;\\n        &lt;tbody&gt;\\n            &lt;row&gt;&lt;/row&gt;\\n            &lt;row&gt;&lt;/row&gt;\\n            &lt;row&gt;&lt;/row&gt;\\n        &lt;/tbody&gt;\\n    &lt;/table&gt;\\n&lt;/div&gt;\\n&lt;script type=\\\"text/javascript\\\"&gt;\\n    Vue.component\"},{\"url\":\"/《Vue》笔记/02.组件/40.父组件给子组件传值.html\",\"relativePath\":\"/《Vue》笔记/02.组件/40.父组件给子组件传值.html\",\"frontmatter\":{\"title\":\"父组件给子组件传值\",\"date\":\"2020-02-04 12:45:30\",\"permalink\":\"/pages/07b384c2e6232e07\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"父组件给子组件传值\",\"date\":\"2020-02-04 12:45:30\",\"excerpt\":\"<h1 id=\\\"父组件给子组件传值\\\" tabindex=\\\"-1\\\">父组件给子组件传值 <a class=\\\"header-anchor\\\" href=\\\"#父组件给子组件传值\\\" aria-label=\\\"Permalink to &quot;父组件给子组件传值&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>父组件中，通过给子组件标签v-bind绑定属性的方式传入值</p>\\n<div class=\\\"language-html vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">html</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">&#x3C;</span><span style=\\\"--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic\\\">ComponentName</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> v-bind:name</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"value\\\"</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">>&#x3C;/</span><span style=\\\"--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic\\\">ComponentName</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">></span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br></div></div><blockquote>\\n<p>如果不使用v-bind传入的值为字符串，使用v-bind绑定传入的值为表达式。</p>\\n</blockquote>\\n\",\"capture\":\"父组件中，通过给子组件标签v-bind绑定属性的方式传入值\\n```html\\n&lt;ComponentName v-bind:name=\\\"value\\\"\\n```\\n&gt; 如果不使用v-bind传入的值为字符串，使用v-bind绑定传入的值为表达式。\\n子组件中，通过props对象接收值\\n```js\\n props: {\\n    name: { // 接收父组件传入值\\n        type: String || ...,\\n        default: ''\\n    }\\n }\\n```\\n 单向数据流\\n所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向\"},{\"url\":\"/《Vue》笔记/02.组件/50.子组件派发事件和值给父组件.html\",\"relativePath\":\"/《Vue》笔记/02.组件/50.子组件派发事件和值给父组件.html\",\"frontmatter\":{\"title\":\"子组件派发事件和值给父组件\",\"date\":\"2020-02-04 12:56:51\",\"permalink\":\"/pages/0f19a1bcac14fd41\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"子组件派发事件和值给父组件\",\"date\":\"2020-02-04 12:56:51\",\"excerpt\":\"<h1 id=\\\"子组件派发事件和值给父组件\\\" tabindex=\\\"-1\\\">子组件派发事件和值给父组件 <a class=\\\"header-anchor\\\" href=\\\"#子组件派发事件和值给父组件\\\" aria-label=\\\"Permalink to &quot;子组件派发事件和值给父组件&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/components.html#%E7%9B%91%E5%90%AC%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">API</a></p>\\n<p>子组件通过<code>$emit</code>派发事件和值给父组件（值可以有多个）</p>\\n<div class=\\\"language-js vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">js</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">this</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">$emit</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'fnX'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, value)</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br></div></div>\",\"capture\":\"API\\n子组件通过`$emit`派发事件和值给父组件（值可以有多个）\\n```js\\nthis.$emit('fnX', value)\\n```\\n父组件通过`v-on`绑定子组件派发的事件，并触发一个新的事件，新的事件内可以接收传来的值\\n```js\\n&lt;ComponentName @fnX=\\\"fnY\\\"\\nmethods: {\\n\\tfnY(value) {\\n\\t\\tconsole.log(value)\\n\\t}\\n}\\n```\\n 父子组件间传递数据 demo\\n&lt;p class=\\\"codepen\\\" data-height=\\\"400\\\" data-theme-id=\\\"light\\\" data-default-tab\"},{\"url\":\"/《Vue》笔记/02.组件/52.Prop 验证 与 非 Prop 的 Attribute.html\",\"relativePath\":\"/《Vue》笔记/02.组件/52.Prop 验证 与 非 Prop 的 Attribute.html\",\"frontmatter\":{\"title\":\"Prop 验证 与 非 Prop 的 Attribute\",\"date\":\"2020-02-15 10:49:04\",\"permalink\":\"/pages/a3080f60f6596eb4\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Prop 验证 与 非 Prop 的 Attribute\",\"date\":\"2020-02-15 10:49:04\",\"capture\":\"Prop 验证\\nAPI\\n子组件对父组件传递来的参数进行校验\\n```js\\nVue.component('my-component', {\\n  props: {\\n    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)\\n    propA: Number,\\n    // 多个可能的类型\\n    propB: [String, Number],\\n    // 必填的字符串\\n    propC: {\\n      type: String,\\n      required: true\\n    },\\n    // 带有默认值的数字\\n    propD: {\\n      \"},{\"url\":\"/《Vue》笔记/02.组件/55.自定义事件.html\",\"relativePath\":\"/《Vue》笔记/02.组件/55.自定义事件.html\",\"frontmatter\":{\"title\":\"自定义事件\",\"date\":\"2020-02-15 11:27:45\",\"permalink\":\"/pages/9651417d08d1779d\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"自定义事件\",\"date\":\"2020-02-15 11:27:45\",\"capture\":\"API\\n 在组件标签v-on绑定的事件是自定义事件\\n```html\\n&lt;div id=\\\"root\\\"\\n    &lt;child @click=\\\"handleClick\\\"&gt;&lt;/child&gt; &lt;!--这里click是自定义事件--&gt;\\n&lt;/div&gt;\\n&lt;script type=\\\"text/javascript\\\"&gt;\\n    Vue.component('child', {\\n        template: '&lt;button&gt;Child&lt;/button&gt;',\\n    })\\n    var vm = new Vue({\\n  \"},{\"url\":\"/《Vue》笔记/02.组件/60.兄弟组件传值.html\",\"relativePath\":\"/《Vue》笔记/02.组件/60.兄弟组件传值.html\",\"frontmatter\":{\"title\":\"兄弟组件传值\",\"date\":\"2020-02-04 13:04:32\",\"permalink\":\"/pages/809f4582d9ca9552\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"兄弟组件传值\",\"date\":\"2020-02-04 13:04:32\",\"capture\":\"子组件1中把值传到父组件,父组件获取值传入子组件2\\n父组件：\\n```js\\n&lt;子组件1 @方法名x=\\\"方法名y\\\"\\n&lt;子组件2 :值名称x=\\\"值x\\\"&gt;&lt;/子组件2 &gt;\\ndata() {\\n\\treturn {\\n\\t 值x: ''\\n\\t}\\n},\\nmethods: {\\n\\t方法名y(值) {\\n\\t\\tthis.值x = 值\\n\\t}\\n}\\n```\\n子组件1：\\n```js\\nthis.$emit('方法名x', 值) // 传出值\\n```\\n子组件2：\\n```js\\nprops: {\\n    值名称x: { // 接收父组件传入值\\n        type: String,\\n        defa\"},{\"url\":\"/《Vue》笔记/02.组件/65.非父子组件传值.html\",\"relativePath\":\"/《Vue》笔记/02.组件/65.非父子组件传值.html\",\"frontmatter\":{\"title\":\"非父子组件传值\",\"date\":\"2020-02-15 14:55:03\",\"permalink\":\"/pages/d408e64f666f146d\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"非父子组件传值\",\"date\":\"2020-02-15 14:55:03\",\"excerpt\":\"<h1 id=\\\"非父子组件间传值\\\" tabindex=\\\"-1\\\">非父子组件间传值 <a class=\\\"header-anchor\\\" href=\\\"#非父子组件间传值\\\" aria-label=\\\"Permalink to &quot;非父子组件间传值&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>当组件的嵌套多时，非父子组件间传值就显得复杂，除了使用<a href=\\\"https://vuex.vuejs.org/zh/\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">vuex</a>实现之外，还可以通过Bus（或者叫 总线/发布订阅模式/观察者模式）的方式实现非父子组件间传值。</p>\\n\",\"capture\":\"当组件的嵌套多时，非父子组件间传值就显得复杂，除了使用vuex实现之外，还可以通过Bus（或者叫 总线/发布订阅模式/观察者模式）的方式实现非父子组件间传值。\\n&lt;div id=\\\"root\\\"\\n\\t\\t&lt;child1 content=\\\"组件1：点我传出值\\\"&gt;&lt;/child1&gt;\\n\\t\\t&lt;child2 content=\\\"组件2\\\"&gt;&lt;/child2&gt;\\n\\t&lt;/div&gt;\\n```html\\n&lt;div id=\\\"root\\\"&gt;\\n    &lt;child1 content=\\\"组件1：点我传出值\\\"&gt;&lt;/child1&gt;\\n    &l\"},{\"url\":\"/《Vue》笔记/02.组件/70.父组件调用子组件方法并传入值.html\",\"relativePath\":\"/《Vue》笔记/02.组件/70.父组件调用子组件方法并传入值.html\",\"frontmatter\":{\"title\":\"父组件调用子组件方法并传入值\",\"date\":\"2020-02-04 13:06:37\",\"permalink\":\"/pages/2e24dab728769e0c\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"父组件调用子组件方法并传入值\",\"date\":\"2020-02-04 13:06:37\",\"capture\":\"通过`ref`引用调用子组件内的方法并传入参数\\n父组件：\\n```js\\n&lt;子组件标签  ref=\\\"refName\\\"\\nmethods: {\\n    fnX(x) {\\n      this.$refs.refName.fnY(x) // 调用子组件方法并传入值\\n    }\\n}\\n```\\n子组件：\\n```js\\nmethods: {\\n    fnY(x) {\\n      this.x = x\\n    }\\n  }\\n}\\n```\"},{\"url\":\"/《Vue》笔记/02.组件/75.插槽slot.html\",\"relativePath\":\"/《Vue》笔记/02.组件/75.插槽slot.html\",\"frontmatter\":{\"title\":\"插槽slot\",\"date\":\"2020-02-16 11:46:27\",\"permalink\":\"/pages/055ecee9a4325386\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"插槽slot\",\"date\":\"2020-02-16 11:46:27\",\"capture\":\"API\\n 插槽\\n```html\\n&lt;div id=\\\"root\\\"\\n    &lt;child&gt; &lt;!-- 组件标签 --&gt;\\n        &lt;h1&gt;hello&lt;/h1&gt;\\n    &lt;/child&gt;\\n&lt;/div&gt;\\n&lt;script type=\\\"text/javascript\\\"&gt;\\n    Vue.component('child', { // 子组件\\n        template: '&lt;div&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;'\\n    })\\n    var vm \"},{\"url\":\"/《Vue》笔记/02.组件/80.动态组件与 v-once 指令.html\",\"relativePath\":\"/《Vue》笔记/02.组件/80.动态组件与 v-once 指令.html\",\"frontmatter\":{\"title\":\"动态组件与 v-once 指令\",\"date\":\"2020-02-16 15:52:19\",\"permalink\":\"/pages/636ca33122e9a64b\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"动态组件与 v-once 指令\",\"date\":\"2020-02-16 15:52:19\",\"capture\":\"动态组件\\n```html\\n&lt;div id=\\\"root\\\"\\n\\t&lt;component :is=\\\"type\\\"&gt;&lt;/component&gt; &lt;!--其效果如同下面两行被注释的代码--&gt;\\n\\t&lt;!-- &lt;child-one v-if=\\\"type === 'child-one'\\\"&gt;&lt;/child-one&gt;\\n\\t    &lt;child-two v-if=\\\"type === 'child-two'\\\"&gt;&lt;/child-two&gt; --&gt;\\n\\t&lt;button @click=\\\"handleClick\\\"&gt;change&\"},{\"url\":\"/《Vue》笔记/02.组件/90.vue父子组件的生命周期顺序.html\",\"relativePath\":\"/《Vue》笔记/02.组件/90.vue父子组件的生命周期顺序.html\",\"frontmatter\":{\"title\":\"vue父子组件的生命周期顺序\",\"date\":\"2020-02-18 16:39:33\",\"permalink\":\"/pages/e6cec47efa42d7f1\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"vue父子组件的生命周期顺序\",\"date\":\"2020-02-18 16:39:33\",\"capture\":\"加载渲染过程\\n```\\n父beforeCreate -\\n```\\n父组件会先执行到beforeMount，接着会执行子组件钩子到挂载结束，再挂载父组件。\\n 子组件更新过程\\n```\\n父beforeUpdate -&gt; 子beforeUpdate -&gt; 子updated -&gt; 父updated\\n```\\n 父组件更新过程\\n```\\n父beforeUpdate -&gt; 父updated\\n```\\n 销毁过程\\n```\\n父beforeDestroy -&gt; 子beforeDestroy -&gt; 子destroyed -&gt; 父destroyed\\n```\"},{\"url\":\"/《Vue》笔记/03.过渡&动画/110.transition过渡&动画.html\",\"relativePath\":\"/《Vue》笔记/03.过渡&动画/110.transition过渡&动画.html\",\"frontmatter\":{\"title\":\"transition过渡&动画\",\"date\":\"2020-02-04 13:16:19\",\"permalink\":\"/pages/184a96b493a97078\",\"categories\":[\"《Vue》笔记\",\"过渡&动画\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"transition过渡&动画\",\"date\":\"2020-02-04 13:16:19\",\"excerpt\":\"<h1 id=\\\"transition过渡-动画\\\" tabindex=\\\"-1\\\">transition过渡&amp;动画 <a class=\\\"header-anchor\\\" href=\\\"#transition过渡-动画\\\" aria-label=\\\"Permalink to &quot;transition过渡&amp;动画&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/transitions.html\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">API</a></p>\\n<h2 id=\\\"使用\\\" tabindex=\\\"-1\\\">使用 <a class=\\\"header-anchor\\\" href=\\\"#使用\\\" aria-label=\\\"Permalink to &quot;使用&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>需要设置动画的元素或组件要在外边包裹一个<code>&lt;transition&gt;</code>标签，设置自定义的<code>name</code>，vue会根据元素的切换（进入/离开）过程添加相应的css类名，你可以<strong>自由地使用css类名来设置css过渡&amp;动画</strong>。</p>\\n\",\"capture\":\"API\\n 使用\\n需要设置动画的元素或组件要在外边包裹一个`&lt;transition\\n 过渡的类名\\n在进入/离开的过渡中，会有 6 个 class 切换。\\n各类名的生命周期\\n* 进入\\n  * `v-enter` 只存在于第一帧\\n  * `v-enter-active` 第一帧到最后一帧，结束后移除\\n  * `v-enter-to` 第二帧到最后一帧，结束后移除\\n* 离开\\n  * `v-leave` 只存在于第一帧\\n  * `v-leave-active` 第一帧到最后一帧，结束后移除\\n  * `v-leave-to` 第二帧到最后一帧，结束后移除\\n如果你使用一个没有`name`的`&lt;t\"},{\"url\":\"/《Vue》笔记/03.过渡&动画/112.使用animate库.html\",\"relativePath\":\"/《Vue》笔记/03.过渡&动画/112.使用animate库.html\",\"frontmatter\":{\"title\":\"使用animate库\",\"date\":\"2020-02-17 16:05:52\",\"permalink\":\"/pages/3b0a20e70805fcea\",\"categories\":[\"《Vue》笔记\",\"过渡&动画\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"使用animate库\",\"date\":\"2020-02-17 16:05:52\",\"excerpt\":\"<h1 id=\\\"vue中使用animate-css库\\\" tabindex=\\\"-1\\\">vue中使用Animate.css库 <a class=\\\"header-anchor\\\" href=\\\"#vue中使用animate-css库\\\" aria-label=\\\"Permalink to &quot;vue中使用Animate.css库&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"自定义过渡类名\\\" tabindex=\\\"-1\\\">自定义过渡类名 <a class=\\\"header-anchor\\\" href=\\\"#自定义过渡类名\\\" aria-label=\\\"Permalink to &quot;自定义过渡类名&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>我们可以通过以下 attribute 来自定义过渡类名：</p>\\n<ul>\\n<li><code>enter-class</code></li>\\n<li><code>enter-active-class</code></li>\\n<li><code>enter-to-class</code> (2.1.8+)</li>\\n<li><code>leave-class</code></li>\\n<li><code>leave-active-class</code></li>\\n<li><code>leave-to-class</code> (2.1.8+)</li>\\n</ul>\\n\",\"capture\":\"自定义过渡类名\\n我们可以通过以下 attribute 来自定义过渡类名：\\n- `enter-class`\\n- `enter-active-class`\\n- `enter-to-class` (2.1.8+)\\n- `leave-class`\\n- `leave-active-class`\\n- `leave-to-class` (2.1.8+)\\n他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 Animate.css结合使用十分有用。\\n 使用Animate.css库\\n```html\\n&lt;transition\\n            name=\\\"custom-\"},{\"url\":\"/《Vue》笔记/03.过渡&动画/120.transition-group列表过渡.html\",\"relativePath\":\"/《Vue》笔记/03.过渡&动画/120.transition-group列表过渡.html\",\"frontmatter\":{\"title\":\"transition-group列表过渡\",\"date\":\"2020-02-04 13:17:42\",\"permalink\":\"/pages/0aa92922ace6bb5e\",\"categories\":[\"《Vue》笔记\",\"过渡&动画\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"transition-group列表过渡\",\"date\":\"2020-02-04 13:17:42\",\"excerpt\":\"<h1 id=\\\"transition-group列表过渡\\\" tabindex=\\\"-1\\\">transition-group列表过渡 <a class=\\\"header-anchor\\\" href=\\\"#transition-group列表过渡\\\" aria-label=\\\"Permalink to &quot;transition-group列表过渡&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"列表的进入-离开过渡\\\" tabindex=\\\"-1\\\">列表的进入/离开过渡 <a class=\\\"header-anchor\\\" href=\\\"#列表的进入-离开过渡\\\" aria-label=\\\"Permalink to &quot;列表的进入/离开过渡&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<div class=\\\"language-html vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">html</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">&#x3C;</span><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">transition-group</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> tag</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"ul\\\"</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">> </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">&#x3C;!--tag转为ul--></span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">    &#x3C;</span><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">li</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> v-for</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"item in list\\\"</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> :key</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"item\\\"</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">>{{item}}&#x3C;/</span><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">li</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">> </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">&#x3C;!--子元素要有key--></span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">&#x3C;/</span><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">transition-group</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">></span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br></div></div><p><strong>注意</strong>：列表元素一定要有<code>key</code></p>\\n\",\"capture\":\"列表的进入/离开过渡\\n```html\\n&lt;transition-group tag=\\\"ul\\\"\\n    &lt;li v-for=\\\"item in list\\\" :key=\\\"item\\\"&gt;{{item}}&lt;/li&gt; &lt;!--子元素要有key--&gt;\\n&lt;/transition-group&gt;\\n```\\n注意：列表元素一定要有`key`\\n```css\\n.v-enter,.v-leave-to{\\n  opacity: 0;\\n  transform: translateX(30px);\\n}\\n.v-enter-active,.v-leave-active{\\n  tran\"},{\"url\":\"/《Vue》笔记/04.可复用性&组合/01.Mixin混入.html\",\"relativePath\":\"/《Vue》笔记/04.可复用性&组合/01.Mixin混入.html\",\"frontmatter\":{\"title\":\"Mixin混入\",\"date\":\"2020-02-19 15:22:41\",\"permalink\":\"/pages/bd36a3c1bc3e0821\",\"categories\":[\"《Vue》笔记\",\"可复用性&组合\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Mixin混入\",\"date\":\"2020-02-19 15:22:41\",\"excerpt\":\"<h1 id=\\\"mixin混入\\\" tabindex=\\\"-1\\\">Mixin混入 <a class=\\\"header-anchor\\\" href=\\\"#mixin混入\\\" aria-label=\\\"Permalink to &quot;Mixin混入&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"基础\\\" tabindex=\\\"-1\\\">基础 <a class=\\\"header-anchor\\\" href=\\\"#基础\\\" aria-label=\\\"Permalink to &quot;基础&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。</p>\\n\",\"capture\":\"基础\\n混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。\\n\\n&gt;\\n&gt; 可通过 `this.$options` 查看选项\\n例子：\\n```js\\n// 定义一个混入对象\\nvar myMixin = {\\n  created: function () {\\n    this.hello()\\n  },\\n  methods: {\\n    hello: function () {\\n      console.log('hello from mixin!')\\n  \"},{\"url\":\"/《Vue》笔记/05.工具/10.Vue CLi v3 创建项目使用记录.html\",\"relativePath\":\"/《Vue》笔记/05.工具/10.Vue CLi v3 创建项目使用记录.html\",\"frontmatter\":{\"title\":\"Vue CLi v3 创建项目使用记录\",\"date\":\"2020-02-20 17:24:29\",\"permalink\":\"/pages/d00311f8174119b2\",\"categories\":[\"《Vue》笔记\",\"工具\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Vue CLi v3 创建项目使用记录\",\"date\":\"2020-02-20 17:24:29\",\"capture\":\"官方文档\\n以下使用的CLi版本是 v3.11.0\\n vue create\\n1. 运行以下命令来创建一个新项目\\n```sh\\nvue create hello-world\\n```\\n2. 你会被提示选取一个 preset (预设)。你可以选默认的包含了基本的 Babel + ESLint 设置的 preset，也可以选“手动选择特性”来选取需要的特性。\\n```sh\\nVue CLI v3.11.0\\n? Please pick a preset: (Use arrow keys)\\n\\n  Manually select features (手动选择特性)\\n```\\n默认预设只包含Babel + ESLint\"},{\"url\":\"/《Vue》笔记/06.规模化/100.vuex操作相关.html\",\"relativePath\":\"/《Vue》笔记/06.规模化/100.vuex操作相关.html\",\"frontmatter\":{\"title\":\"vuex操作相关\",\"date\":\"2020-02-04 13:15:19\",\"permalink\":\"/pages/d9d62d6ab8ff99a6\",\"categories\":[\"《Vue》笔记\",\"规模化\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"vuex操作相关\",\"date\":\"2020-02-04 13:15:19\",\"capture\":\"```js\\nimport { mapActions, mapMutations, mapGetters } from 'vuex'\\ncomputed: {\\n    ...mapGetters([ // 获取数据，内部为数组\\n        'searchHistory' // 相当于在data插入searchHistory和获取到的数据\\n    ])\\n},\\nmethods: {\\n\\t某方法(){\\n\\t  this.saveSearchHistory(传入值)\\n\\t},\\n\\t...mapActions([ // 提交actions修改数据，内部为数组 因为actions文件已对方法进行了封装所有是数组类\"},{\"url\":\"/《Vue》笔记/06.规模化/140.路由懒加载.html\",\"relativePath\":\"/《Vue》笔记/06.规模化/140.路由懒加载.html\",\"frontmatter\":{\"title\":\"路由懒加载\",\"date\":\"2020-02-04 13:20:20\",\"permalink\":\"/pages/38ecac9a9b92f037\",\"categories\":[\"《Vue》笔记\",\"规模化\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"路由懒加载\",\"date\":\"2020-02-04 13:20:20\",\"capture\":\"```js\\n// 路由同步加载\\n// import Recommend from '@/components/recommend/recommend'\\n// import Singer from '@/components/singer/singer'\\n// import Rank from '@/components/rank/rank'\\n// import Search from '@/components/search/search'\\n// import SingerDetail from '@/components/singer-detail/singer-detail'\\n// imp\"},{\"url\":\"/《Vue》笔记/10.Vuex/01.Vuex.html\",\"relativePath\":\"/《Vue》笔记/10.Vuex/01.Vuex.html\",\"frontmatter\":{\"title\":\"Vuex\",\"date\":\"2020-08-08 10:38:33\",\"permalink\":\"/pages/b30620/\",\"categories\":[\"《Vue》笔记\",\"Vuex\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Vuex\",\"date\":\"2020-08-08 10:38:33\",\"capture\":\"Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。\\n Vuex使用过程演示\\n以`vue-cli3`新创建出来的项目为例，演示Vuex的使用过程。\\n创建项目:\\n```sh\\nvue create vuex-test\\ncd vuex-test\\nnpm run serve\\n```\\n安装`vuex`:\\n```bash\\nnpm i vuex -S\\n```\\n进入项目的`src/`下新建一个文件`store/index.js`，并写入：\\n```js\\n// store/index.js\\nimport Vue from 'vue'\\nimport Vuex from 'vuex'\\nVue.use(Vu\"},{\"url\":\"/《Vue》笔记/99.其他/79.Vue中编辑word文档以及预览word .html\",\"relativePath\":\"/《Vue》笔记/99.其他/79.Vue中编辑word文档以及预览word .html\",\"frontmatter\":{\"title\":\"Vue中编辑word文档以及预览word\",\"date\":\"2023-09-13 10:25:00\",\"permalink\":\"/pages/1ebccd/\",\"categories\":[\"《Vue》笔记\",\"其他\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Vue中编辑word文档以及预览word\",\"date\":\"2023-09-13 10:25:00\",\"capture\":\"首先通过XMLHttpRequest发送一个GET请求到指定的URL，获取Word文件的内容并将其转换为HTML格式。其中使用mammoth库的convertToHtml方法将二进制数组转换为HTML格式的文本。（mammoth我用了一个修改版本样式还原度要比官方好@shy1118/mammoth）编辑用到的是ckeditor5富文本编辑器,最后通过html-docx-js将html转换为docx在进行保存**\\n 安装主要依赖\\n```bash\\nnpm install --save @ckeditor/ckeditor5-build-decoupled-document @shy1118/mam\"},{\"url\":\"/《Vue》笔记/99.其他/80.Vue中的防抖函数封装和使用.html\",\"relativePath\":\"/《Vue》笔记/99.其他/80.Vue中的防抖函数封装和使用.html\",\"frontmatter\":{\"title\":\"Vue中的防抖函数封装和使用\",\"date\":\"2020-02-04 13:10:19\",\"permalink\":\"/pages/fb08e252dfd8fdfd\",\"categories\":[\"《Vue》笔记\",\"其他\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Vue中的防抖函数封装和使用\",\"date\":\"2020-02-04 13:10:19\",\"capture\":\"Vue中的防抖函数封装和使用\\n如搜索框中，每改变一个数值就请求一次搜索接口，当快速的改变数值时并不需要多次请求接口，这就需要一个防抖函数：\\n```js\\n// 防抖函数\\nexport function debounce(func, delay) { // func 函数 delay间隔时间\\n  let timer\\n  return function (...args) {\\n    if (timer) {\\n      clearTimeout(timer)\\n    }\\n    timer = setTimeout(() =\\n      func.apply(this, args)\\n    }, \"},{\"url\":\"/《Vue》笔记/99.其他/90.操作本地缓存.html\",\"relativePath\":\"/《Vue》笔记/99.其他/90.操作本地缓存.html\",\"frontmatter\":{\"title\":\"操作本地缓存\",\"date\":\"2020-02-04 13:14:19\",\"permalink\":\"/pages/30a94dbe96873b33\",\"categories\":[\"《Vue》笔记\",\"其他\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"操作本地缓存\",\"date\":\"2020-02-04 13:14:19\",\"capture\":\"&lt;https://github.com/ustbhuangyi/storage\\n操作 sessionStorage 和 localStorage 。\"},{\"url\":\"/《Vue》笔记/99.其他/91.vue2与vue3生命周期对照表.html\",\"relativePath\":\"/《Vue》笔记/99.其他/91.vue2与vue3生命周期对照表.html\",\"frontmatter\":{\"title\":\"vue2与vue3生命周期对照表\",\"date\":\"2023-09-08 14:57:40\",\"permalink\":\"/pages/e866b9/\",\"categories\":[\"《Vue》笔记\",\"其他\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"vue2与vue3生命周期对照表\",\"date\":\"2023-09-08 14:57:40\",\"capture\":\"\"},{\"url\":\"/《uniapp》笔记/使用uniapp对接蓝牙设备.html\",\"relativePath\":\"/《uniapp》笔记/使用uniapp对接蓝牙设备.html\",\"frontmatter\":{\"title\":\"使用uniapp对接蓝牙设备\",\"date\":\"2024-03-30 15:20:23\",\"permalink\":\"/pages/35c361/\",\"categories\":[\"《uniapp》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"使用uniapp对接蓝牙设备\",\"date\":\"2024-03-30 15:20:23\",\"capture\":\"低功耗蓝牙 API 平台差异说明\\r\\n\\r\\n| App | H5  | 微信小程序 | 支付宝小程序 | 百度小程序 | 字节跳动小程序 | 飞书小程序 | QQ 小程序 | 快手小程序 | 京东小程序 |\\r\\n| :-: | :-: | :--------: | :----------: | :--------: | :------------: | :--------: | :-------: | :--------: | :--------: |\\r\\n|  √  |  x  |     √      |      √       |     x      |       x        |  \"}],\"originPosts\":[{\"url\":\"/01.前端/25.JavaScript文章/01.33个非常实用的JavaScript一行代码.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/01.33个非常实用的JavaScript一行代码.html\",\"frontmatter\":{\"title\":\"33个非常实用的JavaScript一行代码\",\"date\":\"2021-11-02 09:51:37\",\"permalink\":\"/pages/a61298/\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[\"JavaScript\"],\"author\":\"CUGGZ\"},\"author\":\"CUGGZ\",\"title\":\"33个非常实用的JavaScript一行代码\",\"date\":\"2021-11-02 09:51:37\",\"capture\":\"一、日期处理\\n 1. 检察日期是否有效\\n该方法用于检测给出的日期是否有效：\\n```javascript\\nconst isDateValid = (...val) =\\nisDateValid(\\\"December 17, 1995 03:24:00\\\");  // true\\n复制代码\\n```\\n 2. 计算两个日期之间的间隔\\n该方法用于计算两个日期之间的间隔时间：\\n```javascript\\nconst dayDif = (date1, date2) =&gt; Math.ceil(Math.abs(date1.getTime() - date2.getTime()) / 86400000)\\ndayD\"},{\"url\":\"/01.前端/25.JavaScript文章/02.new命令原理.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/02.new命令原理.html\",\"frontmatter\":{\"title\":\"new命令原理\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/8143cc480faf9a11\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"new命令原理\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"new命令原理\\\" tabindex=\\\"-1\\\">new命令原理 <a class=\\\"header-anchor\\\" href=\\\"#new命令原理\\\" aria-label=\\\"Permalink to &quot;new命令原理&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>使用new命令时，它后面的函数依次执行下面的步骤：</p>\\n<ol>\\n<li>创建一个空对象，作为将要返回的实例对象。</li>\\n<li>将这个空对象的原型，指向构造函数的prototype属性。</li>\\n<li>将这个空对象赋值给函数内部的this关键字。</li>\\n<li>开始执行构造函数内部的代码。</li>\\n<li>如果构造函数内有返回值且为对象类型，则返回该对象，否则返回上面创建的实例对象。</li>\\n</ol>\\n\",\"capture\":\"使用new命令时，它后面的函数依次执行下面的步骤：\\n1. 创建一个空对象，作为将要返回的实例对象。\\n2. 将这个空对象的原型，指向构造函数的prototype属性。\\n3. 将这个空对象赋值给函数内部的this关键字。\\n4. 开始执行构造函数内部的代码。\\n5. 如果构造函数内有返回值且为对象类型，则返回该对象，否则返回上面创建的实例对象。\\n```js\\n// 构造函数\\nfunction Person(name,age){\\n    this.name = name\\n    this.age = age\\n}\\n// 自定义_new\\nfunction _new() {\\n  // 将 arguments 对\"},{\"url\":\"/01.前端/25.JavaScript文章/03.ES5面向对象.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/03.ES5面向对象.html\",\"frontmatter\":{\"title\":\"ES5面向对象\",\"date\":\"2020-02-22 10:35:43\",\"permalink\":\"/pages/b1af5cb8996363c5\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"ES5面向对象\",\"date\":\"2020-02-22 10:35:43\",\"capture\":\"```js\\n//面向对象封装\\nfunction Student(props){ // 构造函数 （构造函数内定于属性。尊从首字母大写的约定）\\n  this.name = props.name || '匿名';  // 默认‘匿名’\\n  this.grade = props.grade || 1;\\n}\\nStudent.prototype.hello = function(){ // 在构造函数的原型上定义方法\\n  console.log('你好,'+ this.name +'同学，你在'+ this.grade+'年级');\\n}\\n//使用\\nfunction createStudent(props\"},{\"url\":\"/01.前端/25.JavaScript文章/04.ES6面向对象.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/04.ES6面向对象.html\",\"frontmatter\":{\"title\":\"ES6面向对象\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/1f4123be6f45abcd\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"ES6面向对象\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```js\\n//面向对象封装\\nclass Student{ //定义类 (尊从首字母大写的约定)\\n    constructor(props){  // 构造函数 （构造函数内定于属性）\\n        this.name = props.name || '匿名'; // 默认'匿名'\\n      this.grade = props.grade || 1;\\n    }\\n    hello(){ // 在构造函数的原型上定义方法\\n        console.log(`你好,${this.name}同学，你在${this.grade}年级`);\\n    }\\n}\\n//使用\\nfunction c\"},{\"url\":\"/01.前端/25.JavaScript文章/06.多种数组去重性能对比.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/06.多种数组去重性能对比.html\",\"frontmatter\":{\"title\":\"多种数组去重性能对比\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/e808fba1fa8fbab2\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"多种数组去重性能对比\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"测试模板\\n```js\\n// 创建一个 1 ~ 10w 的数组，Array.from为ES6语法\\nlet arr1 = Array.from(new Array(1000000), (x, index) =\\n  return index\\n})\\nlet arr2 = Array.from(new Array(500000), (x, index) =&gt; {\\n  return index + index\\n})\\nlet start = new Date().getTime()\\nconsole.log('开始数组去重')\\n// 数组去重\\nfunction distinct(a, b) {\\n  le\"},{\"url\":\"/01.前端/25.JavaScript文章/07.js随机打乱数组.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/07.js随机打乱数组.html\",\"frontmatter\":{\"title\":\"JS随机打乱数组\",\"date\":\"2020-02-08 17:42:03\",\"permalink\":\"/pages/40b4db2d38ba85f2\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"JS随机打乱数组\",\"date\":\"2020-02-08 17:42:03\",\"capture\":\"```js\\nfunction shuffle(arr) { // 随机打乱数组\\n  let _arr = arr.slice() // 调用数组副本，不改变原数组\\n  for (let i = 0; i &lt; _arr.length; i++) {\\n    let j = getRandomInt(0, i)\\n    let t = _arr[i]\\n    _arr[i] = _arr[j]\\n    _arr[j] = t\\n  }\\n  return _arr\\n}\\nfunction getRandomInt(min, max) { // 获取min到max的一个随机数，包含min和max本身\"},{\"url\":\"/01.前端/25.JavaScript文章/08.判断是否为移动端浏览器.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/08.判断是否为移动端浏览器.html\",\"frontmatter\":{\"title\":\"判断是否为移动端浏览器\",\"date\":\"2020-01-04 15:25:11\",\"permalink\":\"/pages/40f623be692cf8bc\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"判断是否为移动端浏览器\",\"date\":\"2020-01-04 15:25:11\",\"capture\":\"```js\\nconst flag = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);\\nif(flag){\\n    // 移动端\\n} else {\\n    // PC端\\n}\\n```\"},{\"url\":\"/01.前端/25.JavaScript文章/09.将一维数组按指定长度转为二维数组.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/09.将一维数组按指定长度转为二维数组.html\",\"frontmatter\":{\"title\":\"将一维数组按指定长度转为二维数组\",\"date\":\"2020-02-23 13:49:31\",\"permalink\":\"/pages/f1acb712033ac8da\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"将一维数组按指定长度转为二维数组\",\"date\":\"2020-02-23 13:49:31\",\"capture\":\"将一维数组按指定长度转为二维数组\\n```js\\nfunction pages(arr, len) {\\n    const pages = []\\n    arr.forEach((item, index) =\\n        const page = Math.floor(index / len)\\n        if (!pages[page]) {\\n            pages[page] = []\\n        }\\n        pages[page].push(item)\\n    })\\n    return pages\\n}\\n// 使用\\nconst arr = [1, 2, 3, \"},{\"url\":\"/01.前端/25.JavaScript文章/10.防抖与节流函数.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/10.防抖与节流函数.html\",\"frontmatter\":{\"title\":\"防抖与节流函数\",\"date\":\"2020-02-29 15:07:47\",\"permalink\":\"/pages/0f6a0ac99b62ede5\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"防抖与节流函数\",\"date\":\"2020-02-29 15:07:47\",\"excerpt\":\"<h1 id=\\\"防抖与节流函数\\\" tabindex=\\\"-1\\\">防抖与节流函数 <a class=\\\"header-anchor\\\" href=\\\"#防抖与节流函数\\\" aria-label=\\\"Permalink to &quot;防抖与节流函数&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>防抖和节流的作用都是在高频事件中防止函数被多次调用，是一种性能优化的方案。</p>\\n<p>区别在于，防抖函数只会在高频事件结束后n毫秒调用一次函数，节流函数会在高频事件触发过程当中每隔n毫秒调用一次函数。</p>\\n\",\"capture\":\"防抖和节流的作用都是在高频事件中防止函数被多次调用，是一种性能优化的方案。\\n区别在于，防抖函数只会在高频事件结束后n毫秒调用一次函数，节流函数会在高频事件触发过程当中每隔n毫秒调用一次函数。\\n 防抖函数\\n触发高频事件后一段时间（wait）只会执行一次函数，如果指定时间（wait）内高频事件再次被触发，则重新计算时间。\\n 封装\\n```js\\n// 防抖函数\\nfunction debounce(func, wait) {\\n    let timeout = null;\\n    return function () {\\n        let context = this;\\n        let a\"},{\"url\":\"/01.前端/25.JavaScript文章/11.JS获取和修改url参数.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/11.JS获取和修改url参数.html\",\"frontmatter\":{\"title\":\"JS获取和修改url参数\",\"date\":\"2020-03-05 12:45:37\",\"permalink\":\"/pages/7a91be2d502346ce\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"JS获取和修改url参数\",\"date\":\"2020-03-05 12:45:37\",\"capture\":\"获取url参数\\n```js\\n/**\\n * 获取url里的参数\\n * @param arg 参数名\\n * @returns\\n */\\nfunction getURLString(arg) {\\n    var reg = new RegExp(\\\"(^|&)\\\" + arg + \\\"=([^&]*)(&|$)\\\", \\\"i\\\");\\n    var r = window.location.search.substr(1).match(reg);\\n    if (r != null)\\n        return unescape(r[2]);\\n    return null;\\n}\\n```\\n 修改url参数\\n```\"},{\"url\":\"/01.前端/25.JavaScript文章/1110.三级目录/00.四级文件.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/1110.三级目录/00.四级文件.html\",\"frontmatter\":{\"title\":\"四级文件(测试)\",\"date\":\"2020-12-11 11:15:53\",\"permalink\":\"/pages/8481d1/\",\"categories\":[\"前端\",\"JavaScript文章\",\"三级目录\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"四级文件(测试)\",\"date\":\"2020-12-11 11:15:53\",\"capture\":\"测试文件\\nTest Test\\n&lt;code-group\\n  &lt;code-block title=\\\"YARN\\\" active&gt;\\n  ```bash\\n  yarn create vuepress-site [optionalDirectoryName]\\n   OR npx create-vuepress-site [optionalDirectoryName]\\n  ```\\n  &lt;/code-block&gt;\\n  &lt;code-block title=\\\"NPM\\\"&gt;\\n  ```bash\\n  npx create-vuepress-site [optionalDirec\"},{\"url\":\"/01.前端/25.JavaScript文章/12.比typeof运算符更准确的类型判断.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/12.比typeof运算符更准确的类型判断.html\",\"frontmatter\":{\"title\":\"比typeof运算符更准确的类型判断\",\"date\":\"2020-04-13 15:56:54\",\"permalink\":\"/pages/fd4a16d56b83c1bc\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"比typeof运算符更准确的类型判断\",\"date\":\"2020-04-13 15:56:54\",\"capture\":\"不同数据类型的`Object.prototype.toString`方法返回值如下。\\n- 数值：返回`[object Number]`。\\n- 字符串：返回`[object String]`。\\n- 布尔值：返回`[object Boolean]`。\\n- undefined：返回`[object Undefined]`。\\n- null：返回`[object Null]`。\\n- 数组：返回`[object Array]`。\\n- arguments 对象：返回`[object Arguments]`。\\n- 函数：返回`[object Function]`。\\n- Error 对象：返回`[object \"},{\"url\":\"/01.前端/25.JavaScript文章/13.javascript常用类型数值比较图.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/13.javascript常用类型数值比较图.html\",\"frontmatter\":{\"title\":\"javascript常用类型数值比较图\",\"date\":\"2023-09-08 13:34:43\",\"permalink\":\"/pages/360851/\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"javascript常用类型数值比较图\",\"date\":\"2023-09-08 13:34:43\",\"capture\":\"\"},{\"url\":\"/01.前端/25.JavaScript文章/14.js获取当前URL,域名,端口号.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/14.js获取当前URL,域名,端口号.html\",\"frontmatter\":{\"title\":\"js获取当前URL,域名,端口号\",\"date\":\"2023-09-08 13:57:22\",\"permalink\":\"/pages/c81259/\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"js获取当前URL,域名,端口号\",\"date\":\"2023-09-08 13:57:22\",\"capture\":\"| href | 完整的 URL | https://www.baidu.com:200/s?wd=1 |\\n| --- | --- | --- |\\n| protocol | 协议 | https: |\\n| hostname | 主机名 | www.baidu.com |\\n| port | 端口号 | 200 |\\n| host | 主机名+端口号 | www.baidu.com:200 |\\n```javascript\\nlet protocol = window.location.protocol,host = window.location.host;\\nlet url = `${protocol\"},{\"url\":\"/01.前端/25.JavaScript文章/15.js实现深度优先遍历和广度优先遍历.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/15.js实现深度优先遍历和广度优先遍历.html\",\"frontmatter\":{\"title\":\"js实现深度优先遍历和广度优先遍历\",\"date\":\"2023-09-08 14:16:56\",\"permalink\":\"/pages/690414/\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"js实现深度优先遍历和广度优先遍历\",\"date\":\"2023-09-08 14:16:56\",\"capture\":\"什么是深度优先和广度优先\\n深度优先遍历用的是栈，而广度优先遍历要用队列来实现,深度优先就是自上而下的遍历搜索 广度优先则是逐层遍历, 如下图所示(图左深度优先遍历,图右广度)\\n 深度优先遍历\\n 广度优先遍历\\n 两者的区别\\n对于算法来说 无非就是时间换空间 空间换时间\\n1. 深度优先不需要记住所有的节点, 所以占用空间小, 而广度优先需要先记录所有的节点占用空间大\\n2. 深度优先有回溯的操作(没有路走了需要回头)所以相对而言时间会长一点\\n深度优先采用的是堆栈的形式, 即先进后出\\n广度优先则采用的是队列的形式, 即先进先出\\n```jsx\\nconst data = [\\n  {\\n      name:\"},{\"url\":\"/01.前端/40.学习笔记/05.《JavaScript高级程序设计》笔记.html\",\"relativePath\":\"/01.前端/40.学习笔记/05.《JavaScript高级程序设计》笔记.html\",\"frontmatter\":{\"title\":\"《JavaScript高级程序设计》笔记\",\"date\":\"2020-06-12 12:39:01\",\"permalink\":\"/note/js/\",\"categories\":[\"笔记\"],\"tags\":[\"笔记\",\"红宝书\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"《JavaScript高级程序设计》笔记\",\"date\":\"2020-06-12 12:39:01\",\"capture\":\"第1章  JavaScript简介\\n* JavaScript诞生于1995年\\n* 一个完整的JavaScript由这三部分组成：\\n  * ECMAScript (核心)\\n  * DOM (文档对象模型)\\n  * BOM (浏览器对象模型)\\n* ECMAScript的 宿主环境 包含 ：\\n  * 浏览器\\n  * Node\\n  * flash\\n* ECMAScript大致规定了下列组成部分：\\n  * 语法\\n  * 类型\\n  * 语句\\n  * 关键字\\n  * 保留字\\n  * 操作符\\n  * 对象\\n 第2章 在HTML中使用JavaScript\\n* `&lt;script\\n  * async 表示立即\"},{\"url\":\"/01.前端/40.学习笔记/35.TypeScript笔记.html\",\"relativePath\":\"/01.前端/40.学习笔记/35.TypeScript笔记.html\",\"frontmatter\":{\"title\":\"TypeScript笔记\",\"date\":\"2020-10-08 13:02:48\",\"permalink\":\"/pages/51afd6/\",\"categories\":[\"前端\",\"学习笔记\"],\"tags\":[\"TypeScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"TypeScript笔记\",\"date\":\"2020-10-08 13:02:48\",\"capture\":\"TypeScript 的类型校验是给程序员看的，在编译后不会存在TS代码。\\n 类型注解\\n```typescript\\nfunction fn(person: string):void{ // 参数类型是字符串，没有返回值\\n    ///...\\n}\\nfn('str') // 如传递参数非字符串，vscode编辑器中或在编译时将给出错误提示\\nconst test:number = 1\\n```\\n 有哪些基础类型注解？\\n```typescript\\n// 基础类型\\n:string\\n:number\\n:boolean\\n:null  // 只能是null值\\n:undefined // 只能是undefined值\"},{\"url\":\"/01.前端/40.学习笔记/40.小程序笔记.html\",\"relativePath\":\"/01.前端/40.学习笔记/40.小程序笔记.html\",\"frontmatter\":{\"title\":\"小程序笔记\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/note/wx-miniprogram/\",\"tags\":[\"小程序\"],\"categories\":[\"前端\",\"学习笔记\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"小程序笔记\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"小程序笔记\\n 基础课程部分\\n 微信公众平台\\n&lt;https://mp.weixin.qq.com/\\n注册时可选择类型：订阅号、服务号、小程序、企业微信\\n每个邮箱仅能注册一个小程序。\\n个人类型小程序：无法使用微信支付、无法使用卡包功能\\n 小程序文档API\\n小程序开发文档\\n 微信开放社区\\n微信开发社区\\n 目录说明\\n默认目录\\npages-----------------------页面相关\\n​\\tindex  ----------------- 首页文件夹\\n​\\t\\tindex.js ------------首页js\\n​\\t\\tindex.json---------首页配置\\n​\\t\\tindex.wxml--\"},{\"url\":\"/01.前端/40.学习笔记/50.JS设计模式总结笔记.html\",\"relativePath\":\"/01.前端/40.学习笔记/50.JS设计模式总结笔记.html\",\"frontmatter\":{\"title\":\"JS设计模式总结笔记\",\"date\":\"2021-02-27 20:01:18\",\"permalink\":\"/pages/4643cd/\",\"categories\":[\"前端\",\"学习笔记\"],\"tags\":[\"设计模式\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"JS设计模式总结笔记\",\"date\":\"2021-02-27 20:01:18\",\"capture\":\"开篇：前端工程师的成长论\\n能够决定一个前端工程师的本质的，不是那些瞬息万变的技术点，而是那些不变的东西。\\n所谓“不变的东西”，就是驾驭技术的能力。\\n具体来说，它分为以下三个层次：\\n- 能用健壮的代码去解决具体的问题；\\n- 能用抽象的思维去应对复杂的系统；\\n- 能用工程化的思想去规划更大规模的业务。\\n\\n 设计模式之“道”\\n- 设计模式是“拿来主义”。如使用数学公式，不会从头推导一个公式。\\n  核心思想\\n- 设计模式的核心思想——封装变化\\n- 保证可维护性、可扩展性。\\n- 将变与不变分离，确保变化的部分灵活，不变的部分稳定。——这就是所谓的“健壮”的代码。\\n 设计模式之“术”\\n即最经典的23种设计\"},{\"url\":\"/02.页面/10.HTML/10.常用meta整理.html\",\"relativePath\":\"/02.页面/10.HTML/10.常用meta整理.html\",\"frontmatter\":{\"title\":\"常用meta整理\",\"date\":\"2020-02-21 12:20:10\",\"permalink\":\"/pages/8309a5b876fc95e3\",\"categories\":[\"页面\",\"HTML\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"常用meta整理\",\"date\":\"2020-02-21 12:20:10\",\"excerpt\":\"<h1 id=\\\"常用meta整理\\\" tabindex=\\\"-1\\\">常用meta整理 <a class=\\\"header-anchor\\\" href=\\\"#常用meta整理\\\" aria-label=\\\"Permalink to &quot;常用meta整理&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"meta-元素\\\" tabindex=\\\"-1\\\">&lt;meta&gt; 元素 <a class=\\\"header-anchor\\\" href=\\\"#meta-元素\\\" aria-label=\\\"Permalink to &quot;&lt;meta\\\\&gt; 元素&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"概要\\\" tabindex=\\\"-1\\\">概要 <a class=\\\"header-anchor\\\" href=\\\"#概要\\\" aria-label=\\\"Permalink to &quot;概要&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>meta标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。</p>\\n\",\"capture\":\"&lt;meta\\\\\\n 概要\\nmeta标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。\\n必要属性\\n| 属性    | 值        | 描述                                   |\\n| ------- | --------- | -------------------------------------- |\\n| content | some text | 定义与http-equiv或name属性相关的元信息 |\\n可选属性\\n| 属性     \"},{\"url\":\"/02.页面/20.CSS/00.CSS教程和技巧收藏.html\",\"relativePath\":\"/02.页面/20.CSS/00.CSS教程和技巧收藏.html\",\"frontmatter\":{\"title\":\"CSS教程和技巧收藏\",\"date\":\"2020-08-11 17:13:52\",\"permalink\":\"/pages/c8f128/\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"CSS教程和技巧收藏\",\"date\":\"2020-08-11 17:13:52\",\"capture\":\"Flex 布局教程：语法篇\\n&lt;http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\\n CSS Grid 网格布局教程\\n&lt;http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html&gt;\\n 只要一行代码，实现五种 CSS 经典布局\\n&lt;http://www.ruanyifeng.com/blog/2020/08/five-css-layouts-in-one-line.html&gt;\\n* 空间居中布局\\n  &gt; 不管容器的大小，项目总是占据中心\"},{\"url\":\"/02.页面/20.CSS/01.flex布局语法.html\",\"relativePath\":\"/02.页面/20.CSS/01.flex布局语法.html\",\"frontmatter\":{\"title\":\"flex布局语法\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/0a83b083bdf257cb\",\"author\":{\"name\":\"阮一峰\"},\"categories\":[\"页面\",\"CSS\"],\"tags\":[null]},\"author\":{\"name\":\"阮一峰\"},\"title\":\"flex布局语法\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"flex布局语法\\\" tabindex=\\\"-1\\\">flex布局语法 <a class=\\\"header-anchor\\\" href=\\\"#flex布局语法\\\" aria-label=\\\"Permalink to &quot;flex布局语法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"一、flex-布局是什么\\\" tabindex=\\\"-1\\\">一、flex 布局是什么？ <a class=\\\"header-anchor\\\" href=\\\"#一、flex-布局是什么\\\" aria-label=\\\"Permalink to &quot;一、flex 布局是什么？&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>Flex是 Flexible Box 的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性。</p>\\n<p><strong>任何一个容器</strong> 都可以指定为 Flex 布局。</p>\\n\",\"capture\":\"一、flex 布局是什么？\\nFlex是 Flexible Box 的缩写，意为\\\"弹性布局\\\"，用来为盒状模型提供最大的灵活性。\\n任何一个容器 都可以指定为 Flex 布局。\\n```css\\n.box{\\n  display: flex;\\n}\\n```\\n行内元素 也可以使用 Flex 布局。\\n```css\\n.box{\\n  display: inline-flex;\\n}\\n```\\nWebkit 内核的浏览器，必须加上`-webkit`前缀。\\n```css\\n.box{\\n  display: -webkit-flex; /* Safari */\\n  display: flex;\\n}\\n```\\n注意，设为 Flex\"},{\"url\":\"/02.页面/20.CSS/02.flex布局案例-基础.html\",\"relativePath\":\"/02.页面/20.CSS/02.flex布局案例-基础.html\",\"frontmatter\":{\"title\":\"flex布局案例-基础\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/ea6db1530c42ad51\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"flex布局案例-基础\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"``` html\\n&lt;html&gt;\\n  &lt;div class=\\\"box\\\"&gt;\\n    &lt;span&gt;1&lt;/span&gt;\\n    &lt;span&gt;2&lt;/span&gt;\\n    &lt;span&gt;3&lt;/span&gt;\\n    &lt;span&gt;4&lt;/span&gt;\\n    &lt;span&gt;5&lt;/span&gt;\\n    &lt;span&gt;6&lt;/span&gt;\\n    &lt;span&gt;7&lt;/span&gt;\\n  &lt;/div&gt;\\n&lt;/html&gt;\\n&lt;st\"},{\"url\":\"/02.页面/20.CSS/03.flex布局案例-骰子.html\",\"relativePath\":\"/02.页面/20.CSS/03.flex布局案例-骰子.html\",\"frontmatter\":{\"title\":\"flex布局案例-骰子\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/eff61bc8b4f4695d\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"flex布局案例-骰子\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```html\\n&lt;html&gt;\\n  &lt;div class=\\\"box2\\\"&gt;\\n    &lt;div class=\\\"first-face\\\"&gt;\\n      &lt;span class=\\\"pip\\\"&gt;&lt;/span&gt;\\n    &lt;/div&gt;\\n    &lt;div class=\\\"second-face\\\"&gt;\\n      &lt;span class=\\\"pip\\\"&gt;&lt;/span&gt;\\n      &lt;span class=\\\"pip\\\"&gt;&lt;/span&gt;\\n    &lt;/div&gt;\\n    &lt;div cla\"},{\"url\":\"/02.页面/20.CSS/04.flex布局案例-圣杯布局.html\",\"relativePath\":\"/02.页面/20.CSS/04.flex布局案例-圣杯布局.html\",\"frontmatter\":{\"title\":\"flex布局案例-圣杯布局\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/df9e7c7214fa5046\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"flex布局案例-圣杯布局\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```html\\n&lt;html&gt;\\n  &lt;div class=\\\"HolyGrail\\\"&gt;\\n    &lt;header&gt;header&lt;/header&gt;\\n    &lt;div class=\\\"wrap\\\"&gt;\\n      &lt;nav class=\\\"left\\\"&gt;left 宽度固定200px&lt;/nav&gt;\\n      &lt;main class=\\\"content\\\"&gt;center 宽度自适应&lt;/main&gt;\\n      &lt;aside class=\\\"right\\\"&gt;right 宽度固定200px&lt;/aside&gt\"},{\"url\":\"/02.页面/20.CSS/05.flex布局案例-网格布局.html\",\"relativePath\":\"/02.页面/20.CSS/05.flex布局案例-网格布局.html\",\"frontmatter\":{\"title\":\"flex布局案例-网格布局\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/85b5a3fe218a34b7\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"flex布局案例-网格布局\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```html\\n&lt;html&gt;\\n  &lt;div class=\\\"grid\\\"&gt;\\n    &lt;div class=\\\"grid-cell\\\"&gt;1/2&lt;/div&gt;\\n    &lt;div class=\\\"grid-cell\\\"&gt;1/2&lt;/div&gt;\\n  &lt;/div&gt;\\n  &lt;div class=\\\"grid\\\"&gt;\\n    &lt;div class=\\\"grid-cell\\\"&gt;1/3&lt;/div&gt;\\n    &lt;div class=\\\"grid-cell\\\"&gt;1/3&lt;/div&gt;\\n    &lt;div cl\"},{\"url\":\"/02.页面/20.CSS/06.flex布局案例-输入框布局.html\",\"relativePath\":\"/02.页面/20.CSS/06.flex布局案例-输入框布局.html\",\"frontmatter\":{\"title\":\"flex布局案例-输入框布局\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/05cc577fb51c7998\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"flex布局案例-输入框布局\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```html\\n&lt;html&gt;\\n  &lt;div class=\\\"InputAddOn\\\"&gt;\\n    &lt;span class=\\\"InputAddOn-item\\\"&gt;icon&lt;/span&gt;\\n    &lt;input class=\\\"InputAddOn-field\\\" placeholder=\\\"input宽度自适应\\\"&gt;\\n    &lt;button class=\\\"InputAddOn-item\\\"&gt;提交&lt;/button&gt;\\n  &lt;/div&gt;\\n  &lt;br/&gt;\\n  &lt;div class=\\\"Media\\\"&gt;\\n   \"},{\"url\":\"/02.页面/20.CSS/07.CSS3之transition过渡.html\",\"relativePath\":\"/02.页面/20.CSS/07.CSS3之transition过渡.html\",\"frontmatter\":{\"title\":\"CSS3之transition过渡\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/02d7f59d98d87409\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"CSS3之transition过渡\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"html结构\\n```html\\n&lt;div class=\\\"box1\\\"\\n  &lt;div class=\\\"div1\\\"&gt;&lt;/div&gt;\\n  &lt;div class=\\\"div2\\\"&gt;&lt;/div&gt;\\n  &lt;div class=\\\"div3\\\"&gt;&lt;/div&gt;\\n&lt;/div&gt;\\n```\\n先给元素设置transition过渡，指定样式和时间，这里设置all全部样式都采用0.3s的过渡\\n```css\\n.box1&gt;div{\\n  /* 给元素所有变化都添加过渡动画, 也可以指定唯一的过渡样式属性*/\\n  transition: all .3s;\"},{\"url\":\"/02.页面/20.CSS/08.CSS3之animation动画.html\",\"relativePath\":\"/02.页面/20.CSS/08.CSS3之animation动画.html\",\"frontmatter\":{\"title\":\"CSS3之animation动画\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/c2c0432138f6e042\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"CSS3之animation动画\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```html\\n&lt;html&gt;\\n  &lt;div class=\\\"animationBox\\\"&gt;\\n    &lt;div class=\\\"rotate\\\"&gt;旋转动画1&lt;/div&gt;\\n    &lt;div class=\\\"play\\\"&gt;\\n      &lt;div class=\\\"img\\\"&gt;旋转动画2&lt;/div&gt;\\n      &lt;span&gt;&lt;p class=\\\"p2\\\"&gt;&lt;/p&gt;&lt;/span&gt;\\n      &lt;span&gt;&lt;p&gt;&lt;/p&gt;&lt;/span&gt;\\n      &\"},{\"url\":\"/02.页面/20.CSS/09.「布局技巧」图片未加载前自动撑开元素高度.html\",\"relativePath\":\"/02.页面/20.CSS/09.「布局技巧」图片未加载前自动撑开元素高度.html\",\"frontmatter\":{\"title\":\"「布局技巧」图片未加载前自动撑开元素高度\",\"date\":\"2020-02-22 16:37:10\",\"permalink\":\"/pages/3d52574260725aea\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"「布局技巧」图片未加载前自动撑开元素高度\",\"date\":\"2020-02-22 16:37:10\",\"excerpt\":\"<h1 id=\\\"「布局技巧」图片未加载前自动撑开元素高度\\\" tabindex=\\\"-1\\\">「布局技巧」图片未加载前自动撑开元素高度 <a class=\\\"header-anchor\\\" href=\\\"#「布局技巧」图片未加载前自动撑开元素高度\\\" aria-label=\\\"Permalink to &quot;「布局技巧」图片未加载前自动撑开元素高度&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>在移动端开发中，有一些元素是根据图片高度来自动撑开的 ，高度不能写死（如轮播图的外层元素）。在网络较慢的情况下，图片加载需要一些时间，此时该元素的高度没有被撑开，在网页布局上会有一些不想看到的效果。</p>\\n\",\"capture\":\"在移动端开发中，有一些元素是根据图片高度来自动撑开的 ，高度不能写死（如轮播图的外层元素）。在网络较慢的情况下，图片加载需要一些时间，此时该元素的高度没有被撑开，在网页布局上会有一些不想看到的效果。\\n这种情况我们可以设置如下样式来设置该元素的高度：\\n```stylus\\n.wrapper\\n  overflow hidden\\n  width 100%\\n  height 0\\n  padding-bottom 26.66% // 这个数值是图片的高宽比，即 高/宽\\n  background eee\\n```\\n上面代码中，`padding-bottom` 的取值是图片的高宽比（即，高/宽），它会根据 `w\"},{\"url\":\"/02.页面/20.CSS/10.文字在一行或多行时超出显示省略号.html\",\"relativePath\":\"/02.页面/20.CSS/10.文字在一行或多行时超出显示省略号.html\",\"frontmatter\":{\"title\":\"文字在一行或多行时超出显示省略号\",\"date\":\"2020-02-23 15:07:08\",\"permalink\":\"/pages/42b66999cc27dc25\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"文字在一行或多行时超出显示省略号\",\"date\":\"2020-02-23 15:07:08\",\"excerpt\":\"<h1 id=\\\"文字在一行或多行时超出显示省略号\\\" tabindex=\\\"-1\\\">文字在一行或多行时超出显示省略号 <a class=\\\"header-anchor\\\" href=\\\"#文字在一行或多行时超出显示省略号\\\" aria-label=\\\"Permalink to &quot;文字在一行或多行时超出显示省略号&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"一行超出显示省略\\\" tabindex=\\\"-1\\\">一行超出显示省略 <a class=\\\"header-anchor\\\" href=\\\"#一行超出显示省略\\\" aria-label=\\\"Permalink to &quot;一行超出显示省略&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<div class=\\\"language-css vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">css</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">overflow: hidden;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">white-space</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">: nowrap;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">text-overflow</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">: ellipsis;</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br></div></div>\",\"capture\":\"一行超出显示省略\\n```css\\noverflow: hidden;\\nwhite-space: nowrap;\\ntext-overflow: ellipsis;\\n```\\n```html\\n&lt;html\\n   &lt;div class=\\\"box-42b6\\\"&gt;演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字&lt;/div&gt;\\n&lt;/html&gt;\\n&lt;style&gt;\\n    .box-42b6{\\n        border: 1px solid 999;\\n        width\"},{\"url\":\"/02.页面/20.CSS/11.从box-sizing属性入手，了解盒子模型.html\",\"relativePath\":\"/02.页面/20.CSS/11.从box-sizing属性入手，了解盒子模型.html\",\"frontmatter\":{\"title\":\"从box-sizing属性入手，了解盒子模型\",\"date\":\"2020-02-27 17:08:48\",\"permalink\":\"/pages/20a978023139589d\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"从box-sizing属性入手，了解盒子模型\",\"date\":\"2020-02-27 17:08:48\",\"excerpt\":\"<h1 id=\\\"从box-sizing属性入手-了解盒子模型\\\" tabindex=\\\"-1\\\">从box-sizing属性入手，了解盒子模型 <a class=\\\"header-anchor\\\" href=\\\"#从box-sizing属性入手-了解盒子模型\\\" aria-label=\\\"Permalink to &quot;从box-sizing属性入手，了解盒子模型&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"背景\\\" tabindex=\\\"-1\\\">背景 <a class=\\\"header-anchor\\\" href=\\\"#背景\\\" aria-label=\\\"Permalink to &quot;背景&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>先声明一下运用的场景，假如项目布局使用的是<strong>自适应</strong>的布局方式，div给出的宽度是<strong>百分比</strong>的形式，即占窗口宽度的100%，但边框<code>border</code>和内边距<code>padding</code>是用像素来表示的，此时就会造成一个问题是div总宽度超过窗口宽度。为了避免这种问题，可以使用属性<code>box-sizing:border-box</code>来把 <strong>标准盒模型</strong> 变成 <strong>代替(IE)盒模型</strong> ，从而使div的总宽度依然是100%</p>\\n\",\"capture\":\"背景\\n先声明一下运用的场景，假如项目布局使用的是自适应的布局方式，div给出的宽度是百分比的形式，即占窗口宽度的100%，但边框`border`和内边距`padding`是用像素来表示的，此时就会造成一个问题是div总宽度超过窗口宽度。为了避免这种问题，可以使用属性`box-sizing:border-box`来把 标准盒模型 变成 代替(IE)盒模型 ，从而使div的总宽度依然是100%\\n 什么是CSS 盒模型?\\n页面布局中，一个元素的外边距（margin）、 边框（border）、内边距（padding）、内容（content）组成一个盒模型。盒模型可分为标准盒模型 和 代替（IE）盒模型\"},{\"url\":\"/02.页面/20.CSS/12.水平垂直居中的几种方式-案例.html\",\"relativePath\":\"/02.页面/20.CSS/12.水平垂直居中的几种方式-案例.html\",\"frontmatter\":{\"title\":\"水平垂直居中的几种方式-案例\",\"date\":\"2020-03-13 16:13:43\",\"permalink\":\"/pages/cb7cb251adba4bf7\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"水平垂直居中的几种方式-案例\",\"date\":\"2020-03-13 16:13:43\",\"capture\":\"&lt;iframe height=\\\"880\\\" style=\\\"width: 100%;\\\" scrolling=\\\"no\\\" title=\\\"水平垂直居中的几种方式\\\" src=\\\"https://codepen.io/xugaoyi/embed/poJLeYv?height=880&theme-id=light&default-tab=result\\\" frameborder=\\\"no\\\" allowtransparency=\\\"true\\\" allowfullscreen=\\\"true\\\"\\n  See the Pen &lt;a href='https://codepen.io/xugaoyi/pen/poJLeY\"},{\"url\":\"/02.页面/20.CSS/13.如何根据系统主题自动响应CSS深色模式.html\",\"relativePath\":\"/02.页面/20.CSS/13.如何根据系统主题自动响应CSS深色模式.html\",\"frontmatter\":{\"title\":\"如何根据系统主题自动响应CSS深色模式\",\"date\":\"2020-03-31 14:06:26\",\"permalink\":\"/pages/5dde351274f1e39d\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[\"css\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"如何根据系统主题自动响应CSS深色模式\",\"date\":\"2020-03-31 14:06:26\",\"excerpt\":\"<h1 id=\\\"如何根据系统主题自动响应css深色模式\\\" tabindex=\\\"-1\\\">如何根据系统主题自动响应CSS深色模式 <a class=\\\"header-anchor\\\" href=\\\"#如何根据系统主题自动响应css深色模式\\\" aria-label=\\\"Permalink to &quot;如何根据系统主题自动响应CSS深色模式&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p align=\\\"center\\\">\\n  <img src=\\\"https://cdn.staticaly.com/gh/xugaoyi/image_store/blog/20200427163531.jpg\\\" width=\\\"500\\\">\\n</p>\\n<p>很多人喜欢选择APP或网站中的深色模式，也许他们更喜欢这样的外观，或者他们想让自己的眼睛免受疲劳。这篇文章将告诉你如何在网站中实现一个自动的CSS深色模式，根据访客的系统主题来自动响应。</p>\\n\",\"capture\":\"如何根据系统主题自动响应CSS深色模式\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"https://cdn.staticaly.com/gh/xugaoyi/image_store/blog/20200427163531.jpg\\\" width=\\\"500\\\"&gt;\\n&lt;/p&gt;\\n很多人喜欢选择APP或网站中的深色模式，也许他们更喜欢这样的外观，或者他们想让自己的眼睛免受疲劳。这篇文章将告诉你如何在网站中实现一个自动的CSS深色模式，根据访客的系统主题来自动响应。\\n CSS 深色模式 (Dark Mode)\\n在`:root`根元素中定义变量来设置主题的颜色。我建\"},{\"url\":\"/02.页面/20.CSS/14.CSS-function汇总.html\",\"relativePath\":\"/02.页面/20.CSS/14.CSS-function汇总.html\",\"frontmatter\":{\"title\":\"CSS-function汇总\",\"date\":\"2020-05-12 09:36:44\",\"permalink\":\"/pages/3da0d7\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"CSS-function汇总\",\"date\":\"2020-05-12 09:36:44\",\"capture\":\"\"},{\"url\":\"/02.页面/20.CSS/15.CSS给table的tbody添加滚动条.html\",\"relativePath\":\"/02.页面/20.CSS/15.CSS给table的tbody添加滚动条.html\",\"frontmatter\":{\"title\":\"CSS给table的tbody添加滚动条\",\"date\":\"2022-06-29 09:34:23\",\"permalink\":\"/pages/55f894/\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"CSS给table的tbody添加滚动条\",\"date\":\"2022-06-29 09:34:23\",\"capture\":\"```css\\ntable tbody {\\n  height: 200px;\\n  overflow-y: auto;\\n  display: block;\\n}\\ntable thead,\\ntbody tr {\\n  display: table;\\n  width: 100%;\\n}\\n```\"},{\"url\":\"/02.页面/20.CSS/16.css calc()使用.html\",\"relativePath\":\"/02.页面/20.CSS/16.css calc()使用.html\",\"frontmatter\":{\"title\":\"css calc()使用\",\"date\":\"2023-09-08 11:40:43\",\"permalink\":\"/pages/2ecc26/\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"css calc()使用\",\"date\":\"2023-09-08 11:40:43\",\"capture\":\"1.什么是 CSS calc() 函数？\\ncalc() 函数允许在指定 CSS 属性值时执行计算。它对于计算 length、 percentage、 time、 numbers、integers、frequencies 和 angles 等特别有用。 CSS calc() 函数的一个强大功能是能够组合不同的单位。这个函数可以执行预处理器不能执行的数学计算。\\nCSS 中的预处理器只能组合具有固定关系的单位，如角度单位、时间单位、频率单位、分辨率单位和特定长度单位。\\ncalc( Expression)\\ncalc() 函数接受一个表达式作为参数。然后将表达式的结果用作值。它可以采用任何形式并使用以下\"},{\"url\":\"/03.技术/01.技术文档/01.Git使用手册.html\",\"relativePath\":\"/03.技术/01.技术文档/01.Git使用手册.html\",\"frontmatter\":{\"title\":\"Git使用手册\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/9a7ee40fc232253e\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git使用手册\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"git使用手册\\\" tabindex=\\\"-1\\\">Git使用手册 <a class=\\\"header-anchor\\\" href=\\\"#git使用手册\\\" aria-label=\\\"Permalink to &quot;Git使用手册&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"安装\\\" tabindex=\\\"-1\\\">安装 <a class=\\\"header-anchor\\\" href=\\\"#安装\\\" aria-label=\\\"Permalink to &quot;安装&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>官网下载：<a href=\\\"https://git-scm.com/downloads\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">https://git-scm.com/downloads</a> 下载完成后使用默认进行安装。</p>\\n<p>安装完成后，在开始菜单里找到 <code>Git</code> -&gt; <code>Git Bash</code>，蹦出一个类似命令行窗口的东西，就说明Git安装成功！\\n还需要最后一步设置，在命令行输入：</p>\\n<div class=\\\"language-bash vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">bash</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">git</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> config</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> --global</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> user.name</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> \\\"Your Name\\\"</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">git</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> config</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> --global</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> user.email</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> \\\"email@example.com\\\"</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br></div></div><p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。</p>\\n\",\"capture\":\"Git使用手册\\n 安装\\n官网下载：&lt;https://git-scm.com/downloads\\n安装完成后，在开始菜单里找到 `Git` -&gt; `Git Bash`，蹦出一个类似命令行窗口的东西，就说明Git安装成功！\\n还需要最后一步设置，在命令行输入：\\n```bash\\ngit config --global user.name \\\"Your Name\\\"\\ngit config --global user.email \\\"email@example.com\\\"\\n```\\n因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。\\n 创建版本库（仓库）\\n```ba\"},{\"url\":\"/03.技术/01.技术文档/02.Markdown使用教程.html\",\"relativePath\":\"/03.技术/01.技术文档/02.Markdown使用教程.html\",\"frontmatter\":{\"title\":\"Markdown使用教程\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/ad247c4332211551\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Markdown使用教程\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"markdown使用教程\\\" tabindex=\\\"-1\\\">Markdown使用教程 <a class=\\\"header-anchor\\\" href=\\\"#markdown使用教程\\\" aria-label=\\\"Permalink to &quot;Markdown使用教程&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"一、markdown\\\" tabindex=\\\"-1\\\">一、Markdown <a class=\\\"header-anchor\\\" href=\\\"#一、markdown\\\" aria-label=\\\"Permalink to &quot;一、Markdown&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p><img src=\\\"https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/md_logo.png\\\" alt=\\\"logo\\\"></p>\\n<p><code>Markdown</code> 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>\\n\",\"capture\":\"一、Markdown\\n 简介\\n`Markdown` 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。\\n  应用\\n当前许多网站都广泛使用 `Markdown` 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、知乎等\\n 编辑器\\n推荐使用`Typora`，官网：&lt;https://typora.io/\\n 二、徽章\\n 什么是徽章\\n徽章是一种小巧精美的小图标，一般配有相关文字进行辅助说明，可对数据进行监控，链接跳转等，富有表现力。\\n常见于`github`项目主页，但其不仅出现于 `github` 项目主页，凡是能够表现图片的地方都可以出现徽章。\\n 徽章的使用\\n* 在\"},{\"url\":\"/03.技术/01.技术文档/03.npm常用命令.html\",\"relativePath\":\"/03.技术/01.技术文档/03.npm常用命令.html\",\"frontmatter\":{\"title\":\"npm常用命令\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/61f2f95fd7da14fd\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"npm常用命令\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"npm常用命令\\\" tabindex=\\\"-1\\\">npm常用命令 <a class=\\\"header-anchor\\\" href=\\\"#npm常用命令\\\" aria-label=\\\"Permalink to &quot;npm常用命令&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>npm是跟随node一起安装的包（模块）管理器。常见的使用场景有以下几种：</p>\\n<ul>\\n<li>允许用户从npm服务器下载别人编写的第三方包到本地使用。</li>\\n<li>允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用。</li>\\n<li>允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。</li>\\n</ul>\\n\",\"capture\":\"简介\\nnpm是跟随node一起安装的包（模块）管理器。常见的使用场景有以下几种：\\n* 允许用户从npm服务器下载别人编写的第三方包到本地使用。\\n* 允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用。\\n* 允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。\\n 常用命令\\n 检测是否安装及版本\\n```sh\\nnpm -v  显示版本号说明已经安装相应的版本\\n```\\n 生成package.json文件\\n```sh\\nnpm init\\n```\\n\\n 安装模块\\n```sh\\nnpm install  安装package.json定义好的模块，简写 npm i\\n 安装包指定模块\\nnpm \"},{\"url\":\"/03.技术/01.技术文档/10.npm packageJson属性详解.html\",\"relativePath\":\"/03.技术/01.技术文档/10.npm packageJson属性详解.html\",\"frontmatter\":{\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"npm packageJson属性详解\",\"date\":\"2020-04-08 17:16:38\",\"permalink\":\"/pages/dec4f3f00e71a312\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null]},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"npm packageJson属性详解\",\"date\":\"2020-04-08 17:16:38\",\"excerpt\":\"<h1 id=\\\"npm-package-json属性详解\\\" tabindex=\\\"-1\\\">npm package.json属性详解 <a class=\\\"header-anchor\\\" href=\\\"#npm-package-json属性详解\\\" aria-label=\\\"Permalink to &quot;npm package.json属性详解&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<blockquote>\\n<p>本文转自<a href=\\\"https://www.cnblogs.com/tzyy/p/5193811.html\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">https://www.cnblogs.com/tzyy/p/5193811.html</a>，作者：TZYY</p>\\n</blockquote>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p><code>package.json</code>必须是一个严格的json文件，而不仅仅是js里边的一个对象。其中很多属性可以通过<code>npm-config</code>来生成</p>\\n\",\"capture\":\"npm package.json属性详解\\n\\n 概述\\n`package.json`必须是一个严格的json文件，而不仅仅是js里边的一个对象。其中很多属性可以通过`npm-config`来生成\\n name\\n`package.json`中最重要的属性是`name`和`version`两个属性，这两个属性是必须要有的，否则模块就无法被安装，这两个属性一起形成了一个npm模块的唯一标识符。模块中内容变更的同时，模块版本也应该一起变化。\\n`name`属性就是你的模块名称，下面是一些命名规则:\\n- `name`必须小于等于214个字节，包括前缀名称在内（如 xxx/xxxmodule）。\\n- `name`\"},{\"url\":\"/03.技术/01.技术文档/15.yaml语言教程.html\",\"relativePath\":\"/03.技术/01.技术文档/15.yaml语言教程.html\",\"frontmatter\":{\"title\":\"yaml语言教程\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/4e8444e2d534d14f\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"yaml语言教程\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"yaml语言教程\\\" tabindex=\\\"-1\\\">yaml语言教程 <a class=\\\"header-anchor\\\" href=\\\"#yaml语言教程\\\" aria-label=\\\"Permalink to &quot;yaml语言教程&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>YAML 是 &quot;YAML Ain't a Markup Language&quot;（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：&quot;Yet Another Markup Language&quot;（仍是一种标记语言）。</p>\\n\",\"capture\":\"简介\\nYAML 是 \\\"YAML Ain't a Markup Language\\\"（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：\\\"Yet Another Markup Language\\\"（仍是一种标记语言）。\\nYAML 的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲（例如：许多电子邮件标题格式和YAML非常接近）。\\nYAML 的配置文件后缀为 .yml，如：runoob.yml 。\\n\\n 基本语法\\n- 大小写敏感\\n- 使用缩进\"},{\"url\":\"/03.技术/01.技术文档/20.Git修改分支名.html\",\"relativePath\":\"/03.技术/01.技术文档/20.Git修改分支名.html\",\"frontmatter\":{\"title\":\"Git修改分支名\",\"date\":\"2022-08-11 10:51:18\",\"permalink\":\"/pages/922650/\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git修改分支名\",\"date\":\"2022-08-11 10:51:18\",\"capture\":\"同时修改本地分支名和对应的远程分支名\\n修改前要确保本地分支的代码是最新的，并且修改后不会影响到同事的代码。\\n1. 修改本地分支名\\n```sh\\ngit branch -m oldBranchName newBranchName\\n```\\n2. 删除远程分支\\n```sh\\ngit push origin :oldBranchName\\n 或者 git push origin --delete oldBranchName\\n```\\n3. 改名后的本地分支推送到远程\\n```sh\\ngit push --set-upstream origin newBranchName\\n```\"},{\"url\":\"/03.技术/02.Nodejs/01.nodejs递归读取所有文件.html\",\"relativePath\":\"/03.技术/02.Nodejs/01.nodejs递归读取所有文件.html\",\"frontmatter\":{\"title\":\"nodejs递归读取所有文件\",\"date\":\"2019-12-26 15:57:32\",\"permalink\":\"/pages/117708e0af7f0bd9\",\"categories\":[\"技术\",\"Nodejs\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"nodejs递归读取所有文件\",\"date\":\"2019-12-26 15:57:32\",\"capture\":\"```js\\nvar fs = require('fs');\\nvar path = require('path');\\n \\nfunction readFileList(dir, filesList = []) {\\n    const files = fs.readdirSync(dir);\\n    console.log(files);\\n    files.forEach((item, index) =\\n        var fullPath = path.join(dir, item);\\n        const stat = fs.statSync(fullPath);\\n        i\"},{\"url\":\"/03.技术/03.博客搭建/01.解决百度无法收录搭建在GitHub上的个人博客的问题.html\",\"relativePath\":\"/03.技术/03.博客搭建/01.解决百度无法收录搭建在GitHub上的个人博客的问题.html\",\"frontmatter\":{\"title\":\"解决百度无法收录搭建在GitHub上的个人博客的问题\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/41f87d890d0a02af\",\"categories\":[\"技术\",\"博客搭建\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"解决百度无法收录搭建在GitHub上的个人博客的问题\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"解决百度无法收录搭建在github上的静态博客的问题\\\" tabindex=\\\"-1\\\">解决百度无法收录搭建在GitHub上的静态博客的问题 <a class=\\\"header-anchor\\\" href=\\\"#解决百度无法收录搭建在github上的静态博客的问题\\\" aria-label=\\\"Permalink to &quot;解决百度无法收录搭建在GitHub上的静态博客的问题&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<div class=\\\"warning custom-block\\\"><p class=\\\"custom-block-title\\\">WARNING</p>\\n<p>如果你正在寻找本博客的搭建文档，博主建议您查看这个仓库的<a href=\\\"https://github.com/xugaoyi/vuepress-theme-vdoing\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">README</a>。</p>\\n</div>\\n<h2 id=\\\"背景\\\" tabindex=\\\"-1\\\">背景 <a class=\\\"header-anchor\\\" href=\\\"#背景\\\" aria-label=\\\"Permalink to &quot;背景&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>由于GitHub禁止百度爬虫访问，造成托管在GitHub Pages上的博客无法被百度收录。相关问题可以通过百度站长平台的<code>抓取诊断</code>再现，每次都是403 Forbidden的错误。</p>\\n\",\"capture\":\"如果你正在寻找本博客的搭建文档，博主建议您查看这个仓库的README。\\n 背景\\n由于GitHub禁止百度爬虫访问，造成托管在GitHub Pages上的博客无法被百度收录。相关问题可以通过百度站长平台的`抓取诊断`再现，每次都是403 Forbidden的错误。\\n 解决方案\\n同时将博客同时同步托管到GitHub Pages和coding pages上，解决百度不收录问题。最后发现在国内使用coding pages打开速度特别快，而且还会被百度收录，因此我把coding pages的站点作为主站点，原本在github pages的作为分站点。\\n步骤：\\n1、注册coding账号，创建仓库，把代码推\"},{\"url\":\"/03.技术/03.博客搭建/02.使用Gitalk实现静态博客无后台评论系统.html\",\"relativePath\":\"/03.技术/03.博客搭建/02.使用Gitalk实现静态博客无后台评论系统.html\",\"frontmatter\":{\"title\":\"使用Gitalk实现静态博客无后台评论系统\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/1da0bf9a988eafe5\",\"categories\":[\"技术\",\"博客搭建\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"使用Gitalk实现静态博客无后台评论系统\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"使用gitalk实现静态博客无后台评论系统\\\" tabindex=\\\"-1\\\">使用Gitalk实现静态博客无后台评论系统 <a class=\\\"header-anchor\\\" href=\\\"#使用gitalk实现静态博客无后台评论系统\\\" aria-label=\\\"Permalink to &quot;使用Gitalk实现静态博客无后台评论系统&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"前言\\\" tabindex=\\\"-1\\\">前言 <a class=\\\"header-anchor\\\" href=\\\"#前言\\\" aria-label=\\\"Permalink to &quot;前言&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>Gitalk，一个基于 Github Issue 和 Preact 开发的评论插件。</p>\\n<p>下面我们来用它在vuepress搭建的博客中搭建评论区吧</p>\\n\",\"capture\":\"前言\\nGitalk，一个基于 Github Issue 和 Preact 开发的评论插件。\\n下面我们来用它在vuepress搭建的博客中搭建评论区吧\\n 准备\\n使用一个新的东西首先当然是要了解它\\nGitalk demo：&lt;https://gitalk.github.io/\\nGitalk github：&lt;https://github.com/gitalk/gitalk&gt;\\n 实现\\n如何实现？最好的方法我认为是看官方文档，这里我只是记录一下实现的步骤。\\n使用一个别人已经开发好的 vuepress-plugin-comment 插件来帮助我们把Gitalk应用到vuepress搭建的静\"},{\"url\":\"/03.技术/03.博客搭建/03.GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床.html\",\"relativePath\":\"/03.技术/03.博客搭建/03.GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床.html\",\"frontmatter\":{\"title\":\"GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床\",\"date\":\"2020-01-03 12:55:43\",\"permalink\":\"/pages/a5f73af5185fdf0a\",\"categories\":[\"技术\",\"博客搭建\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床\",\"date\":\"2020-01-03 12:55:43\",\"excerpt\":\"<h1 id=\\\"github-jsdelivr-tinypng-picgo-打造稳定快速、高效免费图床\\\" tabindex=\\\"-1\\\">GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床 <a class=\\\"header-anchor\\\" href=\\\"#github-jsdelivr-tinypng-picgo-打造稳定快速、高效免费图床\\\" aria-label=\\\"Permalink to &quot;GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"前言\\\" tabindex=\\\"-1\\\">前言 <a class=\\\"header-anchor\\\" href=\\\"#前言\\\" aria-label=\\\"Permalink to &quot;前言&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p><strong>Q：为什么要使用图床呢？什么是图床？</strong></p>\\n<p>A：写博客文章时，图片的上传和存放是一个问题，有的朋友可能会把图片放到和博客同一个仓库当中，使用相对路径来引用，这样后期维护起来会比较麻烦。还有的朋友会在不同的平台发布同一篇文章，这样一来每个平台都要上传图片，为了解决这些问题，比较推荐的做法是把图片统一上传到一个在线的第三方静态资源库中，我们把这个资源库称为图床，其返回一个图片的URL，使用<code>markdown+图片url</code>的方式写作文章，一次编写，到处使用~</p>\\n\",\"capture\":\"前言\\nQ：为什么要使用图床呢？什么是图床？\\nA：写博客文章时，图片的上传和存放是一个问题，有的朋友可能会把图片放到和博客同一个仓库当中，使用相对路径来引用，这样后期维护起来会比较麻烦。还有的朋友会在不同的平台发布同一篇文章，这样一来每个平台都要上传图片，为了解决这些问题，比较推荐的做法是把图片统一上传到一个在线的第三方静态资源库中，我们把这个资源库称为图床，其返回一个图片的URL，使用`markdown+图片url`的方式写作文章，一次编写，到处使用~\\n以下内容是比较旧的，现在我发现一个更好用，配置更方便的图床工具：&lt;https://picx.xpoet.cn/\\n使用方法看一下他网站的使\"},{\"url\":\"/04.更多/01.学习/00.费曼学习法.html\",\"relativePath\":\"/04.更多/01.学习/00.费曼学习法.html\",\"frontmatter\":{\"title\":\"费曼学习法\",\"date\":\"2020-07-16 10:04:14\",\"permalink\":\"/pages/f2a556/\",\"categories\":[\"更多\",\"学习\"],\"tags\":[\"学习方法\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"费曼学习法\",\"date\":\"2020-07-16 10:04:14\",\"capture\":\"步骤\\n费曼学习法分为4个步骤:\\n1. 确定学习目标\\n你想学习的概念、内容、主题是什么。\\n2. 模拟教学学习法\\n你要模拟自己是一位老师，面对完全不懂这个领域的人，用自己的话，尽可能具体形象地讲诉。这样的讲诉有助于你活学活用，触类旁通，联系生活具体情境。\\n3. 回顾\\n反思第2步遇到的问题，哪些地方卡壳了，哪些地方对方没有真正听懂。找出问题的要害，把握关键环节。\\n4. 简化\\n把这些遇到问题的地方，重新梳理理解，尽可能了解更多背景和相关知识，再用尽可能简化的方式重新表达，设法看穿本质。然后，返回第2步。\\n\\n&gt; \\n&gt; 《费曼学习法：为何被称为史上最牛的学习法，它的本质究竟是什么？》\\n&gt;\"},{\"url\":\"/04.更多/01.学习/03.提高记忆的技巧.html\",\"relativePath\":\"/04.更多/01.学习/03.提高记忆的技巧.html\",\"frontmatter\":{\"title\":\"提高记忆的技巧\",\"date\":\"2020-01-03 14:34:48\",\"permalink\":\"/pages/996822b2a2ca6e3b\",\"categories\":[\"更多\",\"学习\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"提高记忆的技巧\",\"date\":\"2020-01-03 14:34:48\",\"excerpt\":\"<h1 id=\\\"提高记忆的技巧\\\" tabindex=\\\"-1\\\">提高记忆的技巧 <a class=\\\"header-anchor\\\" href=\\\"#提高记忆的技巧\\\" aria-label=\\\"Permalink to &quot;提高记忆的技巧&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<ol>\\n<li><strong>多个感官并用</strong>\\n记忆时调用一切感官。没人的话可以大声阅读，有人的话可以默念，轻微摇晃手指等，有助于保持专注。</li>\\n</ol>\\n\",\"capture\":\"1. 多个感官并用\\n   记忆时调用一切感官。没人的话可以大声阅读，有人的话可以默念，轻微摇晃手指等，有助于保持专注。\\n   \\n2. 重复记忆\\n   每天留出半个到一个小时，梳理总结今天所学的内容。每一章复习完成后做系统的知识整理。\\n   \\n3. 建立关联\\n   把你所学的新知识与已有的认知建立联系，对于记忆事半功倍。\\n   \\n4. 场景记忆\\n   把知识具象化为一个场景，想象自己在何时何地能用这些知识，与自身发生联系。\\n   \\n5. 提出问题\\n   每学习一个知识点，试着提问，然后给出答案。用了就记住了。\"},{\"url\":\"/04.更多/01.学习/10.搜索引擎使用技巧.html\",\"relativePath\":\"/04.更多/01.学习/10.搜索引擎使用技巧.html\",\"frontmatter\":{\"title\":\"搜索引擎使用技巧\",\"date\":\"2020-05-24 11:44:19\",\"permalink\":\"/pages/ce818a\",\"categories\":[\"更多\",\"学习\"],\"tags\":[\"搜索技巧\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"搜索引擎使用技巧\",\"date\":\"2020-05-24 11:44:19\",\"capture\":\"搜索引擎相信大家经常在使用，但是有时候想搜某个信息时却搜出来一大堆不相关的（百度：你们都在看我干什么？）。下面我们来介绍几种搜索技巧，可以提升搜索效率，助你快速查资料，妈妈再也不担心我的学习了（'妈~我真的是在找学习资料'）\\n 技巧1：排除干扰项\\n方式：关键词1+空格+减号+关键词2，即 `关键词1 -关键词2`\\n功能：排除一些不想要的关键词\\n示例：\\n```\\n锤子 -锤子手机\\n```\\n示例中将在搜索结果排除与`锤子手机`相关的，只显示`锤子`本来的样子。\\n\\n 技巧2：精确搜索\\n方式：给关键词加双引号，`\\\"关键词\\\"`\\n功能：只搜索引号里的字，少一个字或者把字拆开都不行\\n示例：\\n```\\n\\\"达拉不崩\"},{\"url\":\"/04.更多/03.面试/01.面试问题集锦.html\",\"relativePath\":\"/04.更多/03.面试/01.面试问题集锦.html\",\"frontmatter\":{\"title\":\"面试问题集锦\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/aea6571b7a8bae86\",\"categories\":[\"更多\",\"面试\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"面试问题集锦\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"请做一下自我介绍\\n回答提示： 一般人回答这个问题过于平常，只说姓名、年龄、工作经验，这些在简历上都有。其实，企业最希望知道的是求职者能否胜任工作，包括：最强的技能、最深入研究的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，要突出积极的个性和做事的能力，说的合情合理企业才会相信。\\n 你最大的优点是什么？\\n回答提示： 沉着冷静、条理清楚、立场坚定、乐于助人等，加上例子如：我在XX经过一到两年的培训及项目实战，加上实习工作，我想我适合这份工作。\\n 说说你最大的缺点？\\n回答提示： 这个问题企业问的概率很大，通常不希望听到直接回答的缺点是什么等，如果求职者说自己小心眼、非常懒、工作效率低\"},{\"url\":\"/04.更多/05.AI随笔/01.当珍妮机学会了写代码.html\",\"relativePath\":\"/04.更多/05.AI随笔/01.当珍妮机学会了写代码.html\",\"frontmatter\":{\"title\":\"当珍妮机学会了写代码\",\"date\":\"2026-02-26 20:00:00\",\"permalink\":\"/pages/ai-coding-revolution/\",\"categories\":[\"更多\",\"AI随笔\"],\"tags\":[\"AI\",\"思考\",\"编程\"],\"author\":{\"name\":\"刘志伟;AI\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟;AI\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"当珍妮机学会了写代码\",\"date\":\"2026-02-26 20:00:00\",\"capture\":\"当珍妮机学会了写代码\\n\\n 一、从一台纺纱机说起\\n1764 年的某个夜晚，英国兰开夏郡的织工詹姆斯·哈格里夫斯看着妻子的纺车被踢倒后仍在旋转，灵光一闪——如果把纱锭竖起来，一个轮子就能同时驱动八个纱锭。\\n珍妮纺纱机就这样诞生了。一个人能干八个人的活，效率提升 800%。\\n262 年后的 2026 年，我坐在屏幕前，让一个叫 Claude 的 AI 帮我重构整个博客系统。它用 Three.js 写了一个极光 Shader 背景，用 Vue 3 搭了全屏滚动首页，让它设计了五套可切换的艺术风格主题——赛博朋克、梵高、水墨、古典雕塑、现代。它还帮我写了一篇博客，就是现在你正在看的这篇。\\n如果哈格里夫斯\"},{\"url\":\"/04.更多/99.友情链接.html\",\"relativePath\":\"/04.更多/99.友情链接.html\",\"frontmatter\":{\"title\":\"友情链接\",\"date\":\"2023-08-29 15:43:33\",\"permalink\":\"/pages/1bf946/\",\"categories\":[\"更多\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"友情链接\",\"date\":\"2023-08-29 15:43:33\",\"capture\":\"\"},{\"url\":\"/\",\"relativePath\":\"/\",\"frontmatter\":{\"layout\":\"page\",\"title\":\"首页\"},\"title\":\"首页\",\"date\":\"2023-08-29 07:43:33\",\"capture\":\"&lt;HomePage /\"},{\"url\":\"/《ES6 教程》笔记/01.ECMAScript 6 简介.html\",\"relativePath\":\"/《ES6 教程》笔记/01.ECMAScript 6 简介.html\",\"frontmatter\":{\"title\":\"ECMAScript 6 简介\",\"date\":\"2020-01-12 15:45:35\",\"permalink\":\"/pages/f344d070a1031ef7\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"ECMAScript 6 简介\",\"date\":\"2020-01-12 15:45:35\",\"excerpt\":\"<blockquote>\\n<p>说明：本章内容为博主在原教程基础上添加自己的学习笔记，来源<a href=\\\"http://es6.ruanyifeng.com/\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">http://es6.ruanyifeng.com/</a>，教程版权归原作者所有。</p>\\n</blockquote>\\n<h1 id=\\\"ecmascript-6-简介\\\" tabindex=\\\"-1\\\">ECMAScript 6 简介 <a class=\\\"header-anchor\\\" href=\\\"#ecmascript-6-简介\\\" aria-label=\\\"Permalink to &quot;ECMAScript 6 简介&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p>\\n\",\"capture\":\"ECMAScript 6 简介\\nECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。\\n ECMAScript 和 JavaScript 的关系\\n一个常见的问题是，ECMAScript 和 JavaScript 到底是什么关系？\\n要讲清楚这个问题，需要回顾历史。1996 年 11 月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给标准化组织 ECMA，希望这种语言能够成为国际标\"},{\"url\":\"/《ES6 教程》笔记/02.let 和 const 命令.html\",\"relativePath\":\"/《ES6 教程》笔记/02.let 和 const 命令.html\",\"frontmatter\":{\"title\":\"let 和 const 命令\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/c1edd70a6b7c7872\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"let 和 const 命令\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"let-和-const-命令\\\" tabindex=\\\"-1\\\">let 和 const 命令 <a class=\\\"header-anchor\\\" href=\\\"#let-和-const-命令\\\" aria-label=\\\"Permalink to &quot;let 和 const 命令&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"let-命令\\\" tabindex=\\\"-1\\\">let 命令 <a class=\\\"header-anchor\\\" href=\\\"#let-命令\\\" aria-label=\\\"Permalink to &quot;let 命令&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"基本用法\\\" tabindex=\\\"-1\\\">基本用法 <a class=\\\"header-anchor\\\" href=\\\"#基本用法\\\" aria-label=\\\"Permalink to &quot;基本用法&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>ES6 新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code>，但是所声明的变量，<strong>只在<code>let</code>命令所在的代码块内有效(块级作用域)</strong>。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">{</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">  let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> a </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 10</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">  var</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> b </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">a </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// ReferenceError: a is not defined.</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">b </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// 1</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br></div></div>\",\"capture\":\"let 命令\\n 基本用法\\nES6 新增了`let`命令，用来声明变量。它的用法类似于`var`，但是所声明的变量，只在`let`命令所在的代码块内有效(块级作用域)。\\n```javascript\\n{\\n  let a = 10;\\n  var b = 1;\\n}\\na // ReferenceError: a is not defined.\\nb // 1\\n```\\n上面代码在代码块之中，分别用`let`和`var`声明了两个变量。然后在代码块之外调用这两个变量，结果`let`声明的变量报错，`var`声明的变量返回了正确的值。这表明，`let`声明的变量只在它所在的代码块有效。\\n`for`循环的计数器，\"},{\"url\":\"/《ES6 教程》笔记/03.变量的解构赋值.html\",\"relativePath\":\"/《ES6 教程》笔记/03.变量的解构赋值.html\",\"frontmatter\":{\"title\":\"变量的解构赋值\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/b1ab10a62f7564da\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"变量的解构赋值\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"变量的解构赋值\\\" tabindex=\\\"-1\\\">变量的解构赋值 <a class=\\\"header-anchor\\\" href=\\\"#变量的解构赋值\\\" aria-label=\\\"Permalink to &quot;变量的解构赋值&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"数组的解构赋值\\\" tabindex=\\\"-1\\\">数组的解构赋值 <a class=\\\"header-anchor\\\" href=\\\"#数组的解构赋值\\\" aria-label=\\\"Permalink to &quot;数组的解构赋值&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"基本用法\\\" tabindex=\\\"-1\\\">基本用法 <a class=\\\"header-anchor\\\" href=\\\"#基本用法\\\" aria-label=\\\"Permalink to &quot;基本用法&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>ES6 允许按照一定模式，<strong>从数组和对象中提取值，对变量进行赋值，这被称为解构</strong>（Destructuring）。</p>\\n<p>以前，为变量赋值，只能直接指定值。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> a </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> b </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> c </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 3</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br></div></div>\",\"capture\":\"数组的解构赋值\\n 基本用法\\nES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。\\n以前，为变量赋值，只能直接指定值。\\n```javascript\\nlet a = 1;\\nlet b = 2;\\nlet c = 3;\\n```\\nES6 允许写成下面这样。\\n```javascript\\nlet [a, b, c] = [1, 2, 3];\\n```\\n上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。\\n本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。\\n```javas\"},{\"url\":\"/《ES6 教程》笔记/04.字符串的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/04.字符串的扩展.html\",\"frontmatter\":{\"title\":\"字符串的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/ca89eca8adeba5f4\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"字符串的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"字符串的扩展\\\" tabindex=\\\"-1\\\">字符串的扩展 <a class=\\\"header-anchor\\\" href=\\\"#字符串的扩展\\\" aria-label=\\\"Permalink to &quot;字符串的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>本章介绍 ES6 对字符串的改造和增强，下一章介绍字符串对象的新增方法。</p>\\n<h2 id=\\\"字符的-unicode-表示法\\\" tabindex=\\\"-1\\\">字符的 Unicode 表示法 <a class=\\\"header-anchor\\\" href=\\\"#字符的-unicode-表示法\\\" aria-label=\\\"Permalink to &quot;字符的 Unicode 表示法&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES6 加强了对 Unicode 的支持，允许采用<code>\\\\uxxxx</code>形式表示一个字符，其中<code>xxxx</code>表示字符的 Unicode 码点。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">\\\\u0061</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// \\\"a\\\"</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br></div></div>\",\"capture\":\"本章介绍 ES6 对字符串的改造和增强，下一章介绍字符串对象的新增方法。\\n 字符的 Unicode 表示法\\nES6 加强了对 Unicode 的支持，允许采用`\\\\uxxxx`形式表示一个字符，其中`xxxx`表示字符的 Unicode 码点。\\n```javascript\\n\\\"\\\\u0061\\\"\\n// \\\"a\\\"\\n```\\n但是，这种表示法只限于码点在`\\\\u0000`~`\\\\uFFFF`之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。\\n```javascript\\n\\\"\\\\uD842\\\\uDFB7\\\"\\n// \\\"𠮷\\\"\\n\\\"\\\\u20BB7\\\"\\n// \\\" 7\\\"\\n```\\n上面代码表示，如果直接在`\\\\u`后面跟上超过`\"},{\"url\":\"/《ES6 教程》笔记/05.字符串的新增方法.html\",\"relativePath\":\"/《ES6 教程》笔记/05.字符串的新增方法.html\",\"frontmatter\":{\"title\":\"字符串的新增方法\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/a650b4a0ebfc9350\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"字符串的新增方法\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"字符串的新增方法\\\" tabindex=\\\"-1\\\">字符串的新增方法 <a class=\\\"header-anchor\\\" href=\\\"#字符串的新增方法\\\" aria-label=\\\"Permalink to &quot;字符串的新增方法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>本章介绍字符串对象的新增方法。</p>\\n<h2 id=\\\"string-fromcodepoint\\\" tabindex=\\\"-1\\\">String.fromCodePoint() <a class=\\\"header-anchor\\\" href=\\\"#string-fromcodepoint\\\" aria-label=\\\"Permalink to &quot;String.fromCodePoint()&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES5 提供<code>String.fromCharCode()</code>方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于<code>0xFFFF</code>的字符。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">String.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">fromCharCode</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">0x20BB7</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">)</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// \\\"ஷ\\\"</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br></div></div>\",\"capture\":\"本章介绍字符串对象的新增方法。\\n String.fromCodePoint()\\nES5 提供`String.fromCharCode()`方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于`0xFFFF`的字符。\\n```javascript\\nString.fromCharCode(0x20BB7)\\n// \\\"ஷ\\\"\\n```\\n上面代码中，`String.fromCharCode()`不能识别大于`0xFFFF`的码点，所以`0x20BB7`就发生了溢出，最高位`2`被舍弃了，最后返回码点`U+0BB7`对应的字符，而不是码点`U+20BB7`对应的字符。\\nES6 提供了`S\"},{\"url\":\"/《ES6 教程》笔记/06.正则的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/06.正则的扩展.html\",\"frontmatter\":{\"title\":\"正则的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/0473261a6ab0ee8c\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"正则的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"正则的扩展\\\" tabindex=\\\"-1\\\">正则的扩展 <a class=\\\"header-anchor\\\" href=\\\"#正则的扩展\\\" aria-label=\\\"Permalink to &quot;正则的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"regexp-构造函数\\\" tabindex=\\\"-1\\\">RegExp 构造函数 <a class=\\\"header-anchor\\\" href=\\\"#regexp-构造函数\\\" aria-label=\\\"Permalink to &quot;RegExp 构造函数&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>在 ES5 中，<code>RegExp</code>构造函数的参数有两种情况。</p>\\n<p>第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">var</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> regex </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> new</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> RegExp</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'xyz'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'i'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">);</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// 等价于</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">var</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> regex </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> /</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#DBEDFF\\\">xyz</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">/</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">i</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br></div></div>\",\"capture\":\"RegExp 构造函数\\n在 ES5 中，`RegExp`构造函数的参数有两种情况。\\n第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。\\n```javascript\\nvar regex = new RegExp('xyz', 'i');\\n// 等价于\\nvar regex = /xyz/i;\\n```\\n第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。\\n```javascript\\nvar regex = new RegExp(/xyz/i);\\n// 等价于\\nvar regex = /xyz/i;\\n```\\n但是，ES5 不允许此时使用第二个参数添加修饰\"},{\"url\":\"/《ES6 教程》笔记/07.数值的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/07.数值的扩展.html\",\"frontmatter\":{\"title\":\"数值的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/5dfea9a0f2d1a392\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"数值的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"数值的扩展\\\" tabindex=\\\"-1\\\">数值的扩展 <a class=\\\"header-anchor\\\" href=\\\"#数值的扩展\\\" aria-label=\\\"Permalink to &quot;数值的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"二进制和八进制表示法\\\" tabindex=\\\"-1\\\">二进制和八进制表示法 <a class=\\\"header-anchor\\\" href=\\\"#二进制和八进制表示法\\\" aria-label=\\\"Permalink to &quot;二进制和八进制表示法&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES6 提供了二进制和八进制数值的新的写法，分别用前缀<code>0b</code>（或<code>0B</code>）和<code>0o</code>（或<code>0O</code>）表示。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">0b111110111</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> ===</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 503</span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\"> // true</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">0o767</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> ===</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 503</span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\"> // true</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br></div></div>\",\"capture\":\"二进制和八进制表示法\\nES6 提供了二进制和八进制数值的新的写法，分别用前缀`0b`（或`0B`）和`0o`（或`0O`）表示。\\n```javascript\\n0b111110111 === 503 // true\\n0o767 === 503 // true\\n```\\n从 ES5 开始，在严格模式之中，八进制就不再允许使用前缀`0`表示，ES6 进一步明确，要使用前缀`0o`表示。\\n```javascript\\n// 非严格模式\\n(function(){\\n  console.log(0o11 === 011);\\n})() // true\\n// 严格模式\\n(function(){\\n  'use str\"},{\"url\":\"/《ES6 教程》笔记/08.函数的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/08.函数的扩展.html\",\"frontmatter\":{\"title\":\"函数的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/8ed309d668b20264\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"函数的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"函数的扩展\\\" tabindex=\\\"-1\\\">函数的扩展 <a class=\\\"header-anchor\\\" href=\\\"#函数的扩展\\\" aria-label=\\\"Permalink to &quot;函数的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"函数参数的默认值\\\" tabindex=\\\"-1\\\">函数参数的默认值 <a class=\\\"header-anchor\\\" href=\\\"#函数参数的默认值\\\" aria-label=\\\"Permalink to &quot;函数参数的默认值&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"基本用法\\\" tabindex=\\\"-1\\\">基本用法 <a class=\\\"header-anchor\\\" href=\\\"#基本用法\\\" aria-label=\\\"Permalink to &quot;基本用法&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">function</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#E36209;--shiki-dark:#FFAB70\\\">x</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#E36209;--shiki-dark:#FFAB70\\\">y</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">) {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">  y </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> y </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">||</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> 'World'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">  console.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(x, y);</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'Hello'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">) </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// Hello World</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'Hello'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'China'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">) </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// Hello China</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'Hello'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">''</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">) </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// Hello World</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br><span class=\\\"line-number\\\">8</span><br></div></div>\",\"capture\":\"函数参数的默认值\\n 基本用法\\nES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。\\n```javascript\\nfunction log(x, y) {\\n  y = y || 'World';\\n  console.log(x, y);\\n}\\nlog('Hello') // Hello World\\nlog('Hello', 'China') // Hello China\\nlog('Hello', '') // Hello World\\n```\\n上面代码检查函数`log`的参数`y`有没有赋值，如果没有，则指定默认值为`World`。这种写法的缺点在于，如果参数`y`赋值了，但是对应的布\"},{\"url\":\"/《ES6 教程》笔记/09.数组的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/09.数组的扩展.html\",\"frontmatter\":{\"title\":\"数组的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/e34009d60d8bc4b2\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"数组的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"数组的扩展\\\" tabindex=\\\"-1\\\">数组的扩展 <a class=\\\"header-anchor\\\" href=\\\"#数组的扩展\\\" aria-label=\\\"Permalink to &quot;数组的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"扩展运算符\\\" tabindex=\\\"-1\\\">扩展运算符 <a class=\\\"header-anchor\\\" href=\\\"#扩展运算符\\\" aria-label=\\\"Permalink to &quot;扩展运算符&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"含义\\\" tabindex=\\\"-1\\\">含义 <a class=\\\"header-anchor\\\" href=\\\"#含义\\\" aria-label=\\\"Permalink to &quot;含义&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>扩展运算符（spread）是三个点（<code>...</code>）。它好比 rest 参数的逆运算，<strong>将一个数组转为用逗号分隔的参数序列</strong>。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">console.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">...</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">[</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">3</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">])</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// 1 2 3</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">console.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">...</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">[</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">3</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">4</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">], </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">5</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">)</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// 1 2 3 4 5</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">[</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">...</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">document.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">querySelectorAll</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'div'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">)]</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// [&#x3C;div>, &#x3C;div>, &#x3C;div>]</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br><span class=\\\"line-number\\\">8</span><br></div></div>\",\"capture\":\"扩展运算符\\n 含义\\n扩展运算符（spread）是三个点（`...`）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。\\n```javascript\\nconsole.log(...[1, 2, 3])\\n// 1 2 3\\nconsole.log(1, ...[2, 3, 4], 5)\\n// 1 2 3 4 5\\n[...document.querySelectorAll('div')]\\n// [&lt;div\\n```\\n该运算符主要用于函数调用。\\n```javascript\\nfunction push(array, ...items) {\\n  array.push(...items\"},{\"url\":\"/《ES6 教程》笔记/10.对象的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/10.对象的扩展.html\",\"frontmatter\":{\"title\":\"对象的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/b5e3e0a0ff6e9c25\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"对象的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"对象的扩展\\\" tabindex=\\\"-1\\\">对象的扩展 <a class=\\\"header-anchor\\\" href=\\\"#对象的扩展\\\" aria-label=\\\"Permalink to &quot;对象的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>对象（object）是 JavaScript 最重要的数据结构。ES6 对它进行了重大升级，本章介绍数据结构本身的改变，下一章介绍<code>Object</code>对象的新增方法。</p>\\n\",\"capture\":\"对象（object）是 JavaScript 最重要的数据结构。ES6 对它进行了重大升级，本章介绍数据结构本身的改变，下一章介绍`Object`对象的新增方法。\\n 属性的简洁表示法\\nES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。\\n```javascript\\nconst foo = 'bar';\\nconst baz = {foo};\\nbaz // {foo: \\\"bar\\\"}\\n// 等同于\\nconst baz = {foo: foo};\\n```\\n上面代码中，变量`foo`直接写在大括号里面。这时，属性名就是变量名, 属性值就是变量值。下面是另一个例子。\\n`\"},{\"url\":\"/《ES6 教程》笔记/11.对象的新增方法.html\",\"relativePath\":\"/《ES6 教程》笔记/11.对象的新增方法.html\",\"frontmatter\":{\"title\":\"对象的新增方法\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/e85e68947502cf90\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"对象的新增方法\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"对象的新增方法\\\" tabindex=\\\"-1\\\">对象的新增方法 <a class=\\\"header-anchor\\\" href=\\\"#对象的新增方法\\\" aria-label=\\\"Permalink to &quot;对象的新增方法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>本章介绍 Object 对象的新增方法。</p>\\n<h2 id=\\\"object-is\\\" tabindex=\\\"-1\\\">Object.is() <a class=\\\"header-anchor\\\" href=\\\"#object-is\\\" aria-label=\\\"Permalink to &quot;Object.is()&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES5 比较两个值是否相等，只有两个运算符：相等运算符（<code>==</code>）和严格相等运算符（<code>===</code>）。它们都有缺点，前者会自动转换数据类型，后者的<code>NaN</code>不等于自身，以及<code>+0</code>等于<code>-0</code>。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</p>\\n<p>ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。<code>Object.is</code>就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</p>\\n\",\"capture\":\"本章介绍 Object 对象的新增方法。\\n Object.is()\\nES5 比较两个值是否相等，只有两个运算符：相等运算符（`==`）和严格相等运算符（`===`）。它们都有缺点，前者会自动转换数据类型，后者的`NaN`不等于自身，以及`+0`等于`-0`。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。\\nES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。`Object.is`就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。\\n```javascript\\nObject.\"},{\"url\":\"/《ES6 教程》笔记/12.Symbol.html\",\"relativePath\":\"/《ES6 教程》笔记/12.Symbol.html\",\"frontmatter\":{\"title\":\"Symbol\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/02c86eb2792f3262\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Symbol\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"symbol\\\" tabindex=\\\"-1\\\">Symbol <a class=\\\"header-anchor\\\" href=\\\"#symbol\\\" aria-label=\\\"Permalink to &quot;Symbol&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，<strong>保证每个属性的名字都是独一无二</strong>的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入<code>Symbol</code>的原因。</p>\\n\",\"capture\":\"概述\\nES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入`Symbol`的原因。\\nES6 引入了一种新的原始数据类型`Symbol`，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：`undefined`、`null`、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。\\nSymbol 值\"},{\"url\":\"/《ES6 教程》笔记/13.Set 和 Map 数据结构.html\",\"relativePath\":\"/《ES6 教程》笔记/13.Set 和 Map 数据结构.html\",\"frontmatter\":{\"title\":\"Set 和 Map 数据结构\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/0c21dae358fca16b\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Set 和 Map 数据结构\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"set-和-map-数据结构\\\" tabindex=\\\"-1\\\">Set 和 Map 数据结构 <a class=\\\"header-anchor\\\" href=\\\"#set-和-map-数据结构\\\" aria-label=\\\"Permalink to &quot;Set 和 Map 数据结构&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"set\\\" tabindex=\\\"-1\\\">Set <a class=\\\"header-anchor\\\" href=\\\"#set\\\" aria-label=\\\"Permalink to &quot;Set&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"基本用法\\\" tabindex=\\\"-1\\\">基本用法 <a class=\\\"header-anchor\\\" href=\\\"#基本用法\\\" aria-label=\\\"Permalink to &quot;基本用法&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>ES6 提供了新的数据结构 Set。它<strong>类似于数组，但是成员的值都是唯一的，没有重复的值</strong>。</p>\\n<p><strong><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构</strong>。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">const</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> s</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> =</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> new</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> Set</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">();</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">[</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">3</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">5</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">4</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">5</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">].</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">forEach</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#E36209;--shiki-dark:#FFAB70\\\">x</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> =></span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> s.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">add</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(x));</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">for</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> (</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> i </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">of</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> s) {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">  console.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(i);</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// 2 3 5 4</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br><span class=\\\"line-number\\\">8</span><br></div></div>\",\"capture\":\"Set\\n 基本用法\\nES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。\\n`Set`本身是一个构造函数，用来生成 Set 数据结构。\\n```javascript\\nconst s = new Set();\\n[2, 3, 5, 4, 5, 2, 2].forEach(x =\\nfor (let i of s) {\\n  console.log(i);\\n}\\n// 2 3 5 4\\n```\\n上面代码通过`add()`方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。\\n`Set`函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参\"},{\"url\":\"/《ES6 教程》笔记/14.Proxy.html\",\"relativePath\":\"/《ES6 教程》笔记/14.Proxy.html\",\"frontmatter\":{\"title\":\"Proxy\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/f56ec2ab97d60483\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Proxy\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"proxy\\\" tabindex=\\\"-1\\\">Proxy <a class=\\\"header-anchor\\\" href=\\\"#proxy\\\" aria-label=\\\"Permalink to &quot;Proxy&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“<strong>元编程</strong>”（meta programming），即<strong>对编程语言进行编程</strong>。</p>\\n<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，<strong>外界对该对象的访问，都必须先通过这层拦截</strong>，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>\\n\",\"capture\":\"概述\\nProxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。\\nProxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。\\n```javascript\\nvar obj = new Proxy({}, {\\n  get: function (target, propKey, receiver) {\\n    console.log(\"},{\"url\":\"/《ES6 教程》笔记/15.Reflect.html\",\"relativePath\":\"/《ES6 教程》笔记/15.Reflect.html\",\"frontmatter\":{\"title\":\"Reflect\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/74de3e45e4491e95\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Reflect\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"reflect\\\" tabindex=\\\"-1\\\">Reflect <a class=\\\"header-anchor\\\" href=\\\"#reflect\\\" aria-label=\\\"Permalink to &quot;Reflect&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p><code>Reflect</code>对象与<code>Proxy</code>对象一样，也是 ES6 为了操作对象而提供的新 API。<code>Reflect</code>对象的设计目的有这样几个。</p>\\n<p>（1） **将<code>Object</code>对象的一些明显属于语言内部的方法（比如<code>Object.defineProperty</code>），放到<code>Reflect</code>对象上。**现阶段，某些方法同时在<code>Object</code>和<code>Reflect</code>对象上部署，未来的新方法将只部署在<code>Reflect</code>对象上。也就是说，从<code>Reflect</code>对象上可以拿到语言内部的方法。</p>\\n\",\"capture\":\"概述\\n`Reflect`对象与`Proxy`对象一样，也是 ES6 为了操作对象而提供的新 API。`Reflect`对象的设计目的有这样几个。\\n（1） 将`Object`对象的一些明显属于语言内部的方法（比如`Object.defineProperty`），放到`Reflect`对象上。现阶段，某些方法同时在`Object`和`Reflect`对象上部署，未来的新方法将只部署在`Reflect`对象上。也就是说，从`Reflect`对象上可以拿到语言内部的方法。\\n（2） 修改某些`Object`方法的返回结果，让其变得更合理。比如，`Object.defineProperty(obj, na\"},{\"url\":\"/《ES6 教程》笔记/16.Promise 对象.html\",\"relativePath\":\"/《ES6 教程》笔记/16.Promise 对象.html\",\"frontmatter\":{\"title\":\"Promise 对象\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/2810ae8985e9bd52\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Promise 对象\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"promise-对象\\\" tabindex=\\\"-1\\\">Promise 对象 <a class=\\\"header-anchor\\\" href=\\\"#promise-对象\\\" aria-label=\\\"Permalink to &quot;Promise 对象&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"promise-的含义\\\" tabindex=\\\"-1\\\">Promise 的含义 <a class=\\\"header-anchor\\\" href=\\\"#promise-的含义\\\" aria-label=\\\"Permalink to &quot;Promise 的含义&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了<code>Promise</code>对象。</p>\\n\",\"capture\":\"Promise 的含义\\nPromise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了`Promise`对象。\\n所谓`Promise`，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。\\n`Promise`对象有以下两个特点。\\n（1）对象的状态不受外界影响。`Promise`对象代表一个异步操作，有三种状态：`pe\"},{\"url\":\"/《ES6 教程》笔记/17.Iterator 和 for-of 循环.html\",\"relativePath\":\"/《ES6 教程》笔记/17.Iterator 和 for-of 循环.html\",\"frontmatter\":{\"title\":\"Iterator 和 for-of 循环\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/48df907ad3570f3d\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Iterator 和 for-of 循环\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"iterator-和-for-of-循环\\\" tabindex=\\\"-1\\\">Iterator 和 for...of 循环 <a class=\\\"header-anchor\\\" href=\\\"#iterator-和-for-of-循环\\\" aria-label=\\\"Permalink to &quot;Iterator 和 for...of 循环&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"iterator-遍历器-的概念\\\" tabindex=\\\"-1\\\">Iterator（遍历器）的概念 <a class=\\\"header-anchor\\\" href=\\\"#iterator-遍历器-的概念\\\" aria-label=\\\"Permalink to &quot;Iterator（遍历器）的概念&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>JavaScript 原有的表示“集合”的数据结构，主要是数组（<code>Array</code>）和对象（<code>Object</code>），ES6 又添加了<code>Map</code>和<code>Set</code>。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是<code>Map</code>，<code>Map</code>的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。</p>\\n\",\"capture\":\"Iterator（遍历器）的概念\\nJavaScript 原有的表示“集合”的数据结构，主要是数组（`Array`）和对象（`Object`），ES6 又添加了`Map`和`Set`。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是`Map`，`Map`的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。\\n遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。\\nIterator 的作用有三个：一是为各\"},{\"url\":\"/《ES6 教程》笔记/18.Generator 函数的语法.html\",\"relativePath\":\"/《ES6 教程》笔记/18.Generator 函数的语法.html\",\"frontmatter\":{\"title\":\"Generator 函数的语法\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/718b48ed9ce0adce\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Generator 函数的语法\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"generator-函数的语法\\\" tabindex=\\\"-1\\\">Generator 函数的语法 <a class=\\\"header-anchor\\\" href=\\\"#generator-函数的语法\\\" aria-label=\\\"Permalink to &quot;Generator 函数的语法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"基本概念\\\" tabindex=\\\"-1\\\">基本概念 <a class=\\\"header-anchor\\\" href=\\\"#基本概念\\\" aria-label=\\\"Permalink to &quot;基本概念&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>Generator 函数是 ES6 提供的一种<strong>异步编程解决方案</strong>，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《Generator 函数的异步应用》一章。</p>\\n\",\"capture\":\"简介\\n 基本概念\\nGenerator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《Generator 函数的异步应用》一章。\\nGenerator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。\\n执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。\\n形式上，Generator 函数是一个\"},{\"url\":\"/《ES6 教程》笔记/19.Generator 函数的异步应用.html\",\"relativePath\":\"/《ES6 教程》笔记/19.Generator 函数的异步应用.html\",\"frontmatter\":{\"title\":\"Generator 函数的异步应用\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/75af7031eb66847b\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Generator 函数的异步应用\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"generator-函数的异步应用\\\" tabindex=\\\"-1\\\">Generator 函数的异步应用 <a class=\\\"header-anchor\\\" href=\\\"#generator-函数的异步应用\\\" aria-label=\\\"Permalink to &quot;Generator 函数的异步应用&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>异步编程对 JavaScript 语言太重要。JavaScript 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。本章主要介绍 Generator 函数如何完成异步操作。</p>\\n\",\"capture\":\"异步编程对 JavaScript 语言太重要。JavaScript 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。本章主要介绍 Generator 函数如何完成异步操作。\\n 传统方法\\nES6 诞生以前，异步编程的方法，大概有下面四种。\\n- 回调函数\\n- 事件监听\\n- 发布/订阅\\n- Promise 对象\\nGenerator 函数将 JavaScript 异步编程带入了一个全新的阶段。\\n 基本概念\\n 异步\\n所谓\\\"异步\\\"，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。\\n比如，有一个任\"},{\"url\":\"/《ES6 教程》笔记/20.async 函数.html\",\"relativePath\":\"/《ES6 教程》笔记/20.async 函数.html\",\"frontmatter\":{\"title\":\"async 函数\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/3777253e65bac487\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"async 函数\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"async-函数\\\" tabindex=\\\"-1\\\">async 函数 <a class=\\\"header-anchor\\\" href=\\\"#async-函数\\\" aria-label=\\\"Permalink to &quot;async 函数&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"含义\\\" tabindex=\\\"-1\\\">含义 <a class=\\\"header-anchor\\\" href=\\\"#含义\\\" aria-label=\\\"Permalink to &quot;含义&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p>\\n<p>async 函数是什么？一句话，它就<strong>是 Generator 函数的语法糖</strong>。</p>\\n<p>前文有一个 Generator 函数，依次读取两个文件。</p>\\n\",\"capture\":\"含义\\nES2017 标准引入了 async 函数，使得异步操作变得更加方便。\\nasync 函数是什么？一句话，它就是 Generator 函数的语法糖。\\n前文有一个 Generator 函数，依次读取两个文件。\\n```javascript\\nconst fs = require('fs');\\nconst readFile = function (fileName) {\\n  return new Promise(function (resolve, reject) {\\n    fs.readFile(fileName, function(error, data) {\\n      if (error\"},{\"url\":\"/《ES6 教程》笔记/21.Class 的基本语法.html\",\"relativePath\":\"/《ES6 教程》笔记/21.Class 的基本语法.html\",\"frontmatter\":{\"title\":\"Class 的基本语法\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/e831e1593c82bbe0\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Class 的基本语法\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"class-的基本语法\\\" tabindex=\\\"-1\\\">Class 的基本语法 <a class=\\\"header-anchor\\\" href=\\\"#class-的基本语法\\\" aria-label=\\\"Permalink to &quot;Class 的基本语法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"类的由来\\\" tabindex=\\\"-1\\\">类的由来 <a class=\\\"header-anchor\\\" href=\\\"#类的由来\\\" aria-label=\\\"Permalink to &quot;类的由来&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">function</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> Point</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#E36209;--shiki-dark:#FFAB70\\\">x</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#E36209;--shiki-dark:#FFAB70\\\">y</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">) {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">  this</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.x </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> x;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">  this</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.y </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> y;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">Point</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">prototype</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">toString</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> =</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> function</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> () {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">  return</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> '('</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> +</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> this</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.x </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">+</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> ', '</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> +</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> this</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.y </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">+</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> ')'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">};</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">var</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> p </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> new</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> Point</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">);</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br><span class=\\\"line-number\\\">8</span><br><span class=\\\"line-number\\\">9</span><br><span class=\\\"line-number\\\">10</span><br></div></div>\",\"capture\":\"简介\\n 类的由来\\nJavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。\\n```javascript\\nfunction Point(x, y) {\\n  this.x = x;\\n  this.y = y;\\n}\\nPoint.prototype.toString = function () {\\n  return '(' + this.x + ', ' + this.y + ')';\\n};\\nvar p = new Point(1, 2);\\n```\\n上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。\\nES6 提供\"},{\"url\":\"/《ES6 教程》笔记/22.Class 的继承.html\",\"relativePath\":\"/《ES6 教程》笔记/22.Class 的继承.html\",\"frontmatter\":{\"title\":\"Class 的继承\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/83f8c3a0cd87dd83\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Class 的继承\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"class-的继承\\\" tabindex=\\\"-1\\\">Class 的继承 <a class=\\\"header-anchor\\\" href=\\\"#class-的继承\\\" aria-label=\\\"Permalink to &quot;Class 的继承&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>Class 可以通过<code>extends</code>关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">class</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> Point</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">class</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> ColorPoint</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> extends</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> Point</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br></div></div>\",\"capture\":\"简介\\nClass 可以通过`extends`关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。\\n```javascript\\nclass Point {\\n}\\nclass ColorPoint extends Point {\\n}\\n```\\n上面代码定义了一个`ColorPoint`类，该类通过`extends`关键字，继承了`Point`类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个`Point`类。下面，我们在`ColorPoint`内部加上代码。\\n```javascript\\nclass ColorPoint extends Point \"},{\"url\":\"/《ES6 教程》笔记/23.Module 的语法.html\",\"relativePath\":\"/《ES6 教程》笔记/23.Module 的语法.html\",\"frontmatter\":{\"title\":\"Module 的语法\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/efe2fb04eb8ac5fb\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Module 的语法\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"module-的语法\\\" tabindex=\\\"-1\\\">Module 的语法 <a class=\\\"header-anchor\\\" href=\\\"#module-的语法\\\" aria-label=\\\"Permalink to &quot;Module 的语法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的<code>require</code>、Python 的<code>import</code>，甚至就连 CSS 都有<code>@import</code>，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p>\\n\",\"capture\":\"概述\\n历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的`require`、Python 的`import`，甚至就连 CSS 都有`@import`，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。\\n在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD \"},{\"url\":\"/《ES6 教程》笔记/24.Module 的加载实现.html\",\"relativePath\":\"/《ES6 教程》笔记/24.Module 的加载实现.html\",\"frontmatter\":{\"title\":\"Module 的加载实现\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/a79ca2e64ceae213\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Module 的加载实现\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"module-的加载实现\\\" tabindex=\\\"-1\\\">Module 的加载实现 <a class=\\\"header-anchor\\\" href=\\\"#module-的加载实现\\\" aria-label=\\\"Permalink to &quot;Module 的加载实现&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>上一章介绍了模块的语法，本章介绍如何在浏览器和 Node.js 之中加载 ES6 模块，以及实际开发中经常遇到的一些问题（比如循环加载）。</p>\\n\",\"capture\":\"上一章介绍了模块的语法，本章介绍如何在浏览器和 Node.js 之中加载 ES6 模块，以及实际开发中经常遇到的一些问题（比如循环加载）。\\n 浏览器加载\\n 传统方法\\nHTML 网页中，浏览器通过`&lt;script\\n```html\\n&lt;!-- 页面内嵌的脚本 --&gt;\\n&lt;script type=\\\"application/javascript\\\"&gt;\\n  // module code\\n&lt;/script&gt;\\n&lt;!-- 外部脚本 --&gt;\\n&lt;script type=\\\"application/javascript\\\" src=\\\"path/to/myModule\"},{\"url\":\"/《ES6 教程》笔记/25.编程风格.html\",\"relativePath\":\"/《ES6 教程》笔记/25.编程风格.html\",\"frontmatter\":{\"title\":\"编程风格\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/984bf549204bb266\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"编程风格\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"编程风格\\\" tabindex=\\\"-1\\\">编程风格 <a class=\\\"header-anchor\\\" href=\\\"#编程风格\\\" aria-label=\\\"Permalink to &quot;编程风格&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>本章探讨如何将 ES6 的新语法，运用到编码实践之中，与传统的 JavaScript 语法结合在一起，写出合理的、易于阅读和维护的代码。</p>\\n<p>多家公司和组织已经公开了它们的风格规范，下面的内容主要参考了 <a href=\\\"https://github.com/airbnb/javascript\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">Airbnb</a> 公司的 JavaScript 风格规范。</p>\\n\",\"capture\":\"本章探讨如何将 ES6 的新语法，运用到编码实践之中，与传统的 JavaScript 语法结合在一起，写出合理的、易于阅读和维护的代码。\\n多家公司和组织已经公开了它们的风格规范，下面的内容主要参考了 Airbnb 公司的 JavaScript 风格规范。\\n 块级作用域\\n（1）let 取代 var\\nES6 提出了两个新的声明变量的命令：`let`和`const`。其中，`let`完全可以取代`var`，因为两者语义相同，而且`let`没有副作用。\\n```javascript\\n'use strict';\\nif (true) {\\n  let x = 'hello';\\n}\\nfor (let i = 0\"},{\"url\":\"/《ES6 教程》笔记/26.读懂 ECMAScript 规格.html\",\"relativePath\":\"/《ES6 教程》笔记/26.读懂 ECMAScript 规格.html\",\"frontmatter\":{\"title\":\"读懂 ECMAScript 规格\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/32c35f7651d6e58e\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"读懂 ECMAScript 规格\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"读懂-ecmascript-规格\\\" tabindex=\\\"-1\\\">读懂 ECMAScript 规格 <a class=\\\"header-anchor\\\" href=\\\"#读懂-ecmascript-规格\\\" aria-label=\\\"Permalink to &quot;读懂 ECMAScript 规格&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>规格文件是计算机语言的官方标准，详细描述语法规则和实现方法。</p>\\n<p>一般来说，没有必要阅读规格，除非你要写编译器。因为规格写得非常抽象和精炼，又缺乏实例，不容易理解，而且对于解决实际的应用问题，帮助不大。但是，如果你遇到疑难的语法问题，实在找不到答案，这时可以去查看规格文件，了解语言标准是怎么说的。规格是解决问题的“最后一招”。</p>\\n\",\"capture\":\"概述\\n规格文件是计算机语言的官方标准，详细描述语法规则和实现方法。\\n一般来说，没有必要阅读规格，除非你要写编译器。因为规格写得非常抽象和精炼，又缺乏实例，不容易理解，而且对于解决实际的应用问题，帮助不大。但是，如果你遇到疑难的语法问题，实在找不到答案，这时可以去查看规格文件，了解语言标准是怎么说的。规格是解决问题的“最后一招”。\\n这对 JavaScript 语言很有必要。因为它的使用场景复杂，语法规则不统一，例外很多，各种运行环境的行为不一致，导致奇怪的语法问题层出不穷，任何语法书都不可能囊括所有情况。查看规格，不失为一种解决语法问题的最可靠、最权威的终极方法。\\n本章介绍如何读懂 ECMASc\"},{\"url\":\"/《ES6 教程》笔记/27.异步遍历器.html\",\"relativePath\":\"/《ES6 教程》笔记/27.异步遍历器.html\",\"frontmatter\":{\"title\":\"异步遍历器\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/16121351be68691b\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"异步遍历器\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"异步遍历器\\\" tabindex=\\\"-1\\\">异步遍历器 <a class=\\\"header-anchor\\\" href=\\\"#异步遍历器\\\" aria-label=\\\"Permalink to &quot;异步遍历器&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"同步遍历器的问题\\\" tabindex=\\\"-1\\\">同步遍历器的问题 <a class=\\\"header-anchor\\\" href=\\\"#同步遍历器的问题\\\" aria-label=\\\"Permalink to &quot;同步遍历器的问题&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>《遍历器》一章说过，Iterator 接口是一种数据遍历的协议，只要调用遍历器对象的<code>next</code>方法，就会得到一个对象，表示当前遍历指针所在的那个位置的信息。<code>next</code>方法返回的对象的结构是<code>{value, done}</code>，其中<code>value</code>表示当前的数据的值，<code>done</code>是一个布尔值，表示遍历是否结束。</p>\\n\",\"capture\":\"同步遍历器的问题\\n《遍历器》一章说过，Iterator 接口是一种数据遍历的协议，只要调用遍历器对象的`next`方法，就会得到一个对象，表示当前遍历指针所在的那个位置的信息。`next`方法返回的对象的结构是`{value, done}`，其中`value`表示当前的数据的值，`done`是一个布尔值，表示遍历是否结束。\\n```javascript\\nfunction idMaker() {\\n  let index = 0;\\n  return {\\n    next: function() {\\n      return { value: index++, done: false };\\n    }\"},{\"url\":\"/《ES6 教程》笔记/28.ArrayBuffer.html\",\"relativePath\":\"/《ES6 教程》笔记/28.ArrayBuffer.html\",\"frontmatter\":{\"title\":\"ArrayBuffer\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/a2ba314746bfdbdd\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"ArrayBuffer\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"arraybuffer\\\" tabindex=\\\"-1\\\">ArrayBuffer <a class=\\\"header-anchor\\\" href=\\\"#arraybuffer\\\" aria-label=\\\"Permalink to &quot;ArrayBuffer&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><code>ArrayBuffer</code>对象、<code>TypedArray</code>视图和<code>DataView</code>视图是 JavaScript 操作二进制数据的一个接口。这些对象早就存在，属于独立的规格（2011 年 2 月发布），ES6 将它们纳入了 ECMAScript 规格，并且增加了新的方法。它们都是以数组的语法处理二进制数据，所以统称为二进制数组。</p>\\n\",\"capture\":\"`ArrayBuffer`对象、`TypedArray`视图和`DataView`视图是 JavaScript 操作二进制数据的一个接口。这些对象早就存在，属于独立的规格（2011 年 2 月发布），ES6 将它们纳入了 ECMAScript 规格，并且增加了新的方法。它们都是以数组的语法处理二进制数据，所以统称为二进制数组。\\n这个接口的原始设计目的，与 WebGL 项目有关。所谓 WebGL，就是指浏览器与显卡之间的通信接口，为了满足 JavaScript 与显卡之间大量的、实时的数据交换，它们之间的数据通信必须是二进制的，而不能是传统的文本格式。文本格式传递一个 32 位整数，两端的 Ja\"},{\"url\":\"/《ES6 教程》笔记/29.最新提案.html\",\"relativePath\":\"/《ES6 教程》笔记/29.最新提案.html\",\"frontmatter\":{\"title\":\"最新提案\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/7188882b8d65af1b\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"最新提案\",\"date\":\"2020-02-09 16:00:30\",\"excerpt\":\"<h1 id=\\\"最新提案\\\" tabindex=\\\"-1\\\">最新提案 <a class=\\\"header-anchor\\\" href=\\\"#最新提案\\\" aria-label=\\\"Permalink to &quot;最新提案&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>本章介绍一些尚未进入标准、但很有希望的最新提案。</p>\\n<h2 id=\\\"do-表达式\\\" tabindex=\\\"-1\\\">do 表达式 <a class=\\\"header-anchor\\\" href=\\\"#do-表达式\\\" aria-label=\\\"Permalink to &quot;do 表达式&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">{</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">  let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> t </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> f</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">();</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">  t </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> t </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">*</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> t </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">+</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br></div></div>\",\"capture\":\"本章介绍一些尚未进入标准、但很有希望的最新提案。\\n do 表达式\\n本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。\\n```javascript\\n{\\n  let t = f();\\n  t = t * t + 1;\\n}\\n```\\n上面代码中，块级作用域将两个语句封装在一起。但是，在块级作用域以外，没有办法得到`t`的值，因为块级作用域不返回值，除非`t`是全局变量。\\n现在有一个提案，使得块级作用域可以变为表达式，也就是说可以返回值，办法就是在块级作用域之前加上`do`，使它变为`do`表达式，然后就会返回内部最后执行的表达式的值。\\n```javascript\\nlet x = do {\"},{\"url\":\"/《ES6 教程》笔记/30.装饰器.html\",\"relativePath\":\"/《ES6 教程》笔记/30.装饰器.html\",\"frontmatter\":{\"title\":\"装饰器\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/e97bc1e5626b082c\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"装饰器\",\"date\":\"2020-02-09 16:00:30\",\"excerpt\":\"<h1 id=\\\"装饰器\\\" tabindex=\\\"-1\\\">装饰器 <a class=\\\"header-anchor\\\" href=\\\"#装饰器\\\" aria-label=\\\"Permalink to &quot;装饰器&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>[说明] Decorator 提案经过了大幅修改，目前还没有定案，不知道语法会不会再变。下面的内容完全依据以前的提案，已经有点过时了。等待定案以后，需要完全重写。</p>\\n<p>装饰器（Decorator）是一种与类（class）相关的语法，用来注释或修改类和类方法。许多面向对象的语言都有这项功能，目前有一个<a href=\\\"https://github.com/tc39/proposal-decorators\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">提案</a>将其引入了 ECMAScript。</p>\\n\",\"capture\":\"[说明] Decorator 提案经过了大幅修改，目前还没有定案，不知道语法会不会再变。下面的内容完全依据以前的提案，已经有点过时了。等待定案以后，需要完全重写。\\n装饰器（Decorator）是一种与类（class）相关的语法，用来注释或修改类和类方法。许多面向对象的语言都有这项功能，目前有一个提案将其引入了 ECMAScript。\\n装饰器是一种函数，写成`@ + 函数名`。它可以放在类和类方法的定义前面。\\n```javascript\\n@frozen class Foo {\\n  @configurable(false)\\n  @enumerable(true)\\n  method() {}\\n  @\"},{\"url\":\"/《ES6 教程》笔记/31.函数式编程.html\",\"relativePath\":\"/《ES6 教程》笔记/31.函数式编程.html\",\"frontmatter\":{\"title\":\"函数式编程\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/1cf50330655efc69\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"函数式编程\",\"date\":\"2020-02-09 16:00:30\",\"excerpt\":\"<h1 id=\\\"函数式编程\\\" tabindex=\\\"-1\\\">函数式编程 <a class=\\\"header-anchor\\\" href=\\\"#函数式编程\\\" aria-label=\\\"Permalink to &quot;函数式编程&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>JavaScript 语言从一诞生，就具有函数式编程的烙印。它将函数作为一种独立的数据类型，与其他数据类型处于完全平等的地位。在 JavaScript 语言中，你可以采用面向对象编程，也可以采用函数式编程。有人甚至说，JavaScript 是有史以来第一种被大规模采用的函数式编程语言。</p>\\n\",\"capture\":\"JavaScript 语言从一诞生，就具有函数式编程的烙印。它将函数作为一种独立的数据类型，与其他数据类型处于完全平等的地位。在 JavaScript 语言中，你可以采用面向对象编程，也可以采用函数式编程。有人甚至说，JavaScript 是有史以来第一种被大规模采用的函数式编程语言。\\nES6 的种种新增功能，使得函数式编程变得更方便、更强大。本章介绍 ES6 如何进行函数式编程。\\n 柯里化\\n柯里化（currying）指的是将一个多参数的函数拆分成一系列函数，每个拆分后的函数都只接受一个参数（unary）。\\n```javascript\\nfunction add (a, b) {\\n  retur\"},{\"url\":\"/《ES6 教程》笔记/32.Mixin.html\",\"relativePath\":\"/《ES6 教程》笔记/32.Mixin.html\",\"frontmatter\":{\"title\":\"Mixin\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/6a8e2dc558da1b39\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Mixin\",\"date\":\"2020-02-09 16:00:30\",\"excerpt\":\"<h1 id=\\\"mixin\\\" tabindex=\\\"-1\\\">Mixin <a class=\\\"header-anchor\\\" href=\\\"#mixin\\\" aria-label=\\\"Permalink to &quot;Mixin&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>JavaScript 语言的设计是单一继承，即子类只能继承一个父类，不允许继承多个父类。这种设计保证了对象继承的层次结构是树状的，而不是复杂的<a href=\\\"https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">网状结构</a>。</p>\\n\",\"capture\":\"JavaScript 语言的设计是单一继承，即子类只能继承一个父类，不允许继承多个父类。这种设计保证了对象继承的层次结构是树状的，而不是复杂的网状结构。\\n但是，这大大降低了编程的灵活性。因为实际开发中，有时不可避免，子类需要继承多个父类。举例来说，“猫”可以继承“哺乳类动物”，也可以继承“宠物”。\\n各种单一继承的编程语言，有不同的多重继承解决方案。比如，Java 语言也是子类只能继承一个父类，但是还允许继承多个界面（interface），这样就间接实现了多重继承。Interface 与父类一样，也是一个类，只不过它只定义接口（method signature），不定义实现，因此又被称为“抽象类\"},{\"url\":\"/《ES6 教程》笔记/33.SIMD.html\",\"relativePath\":\"/《ES6 教程》笔记/33.SIMD.html\",\"frontmatter\":{\"title\":\"SIMD\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/8e8f80f69b775a56\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"SIMD\",\"date\":\"2020-02-09 16:00:30\",\"excerpt\":\"<h1 id=\\\"simd\\\" tabindex=\\\"-1\\\">SIMD <a class=\\\"header-anchor\\\" href=\\\"#simd\\\" aria-label=\\\"Permalink to &quot;SIMD&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>SIMD（发音<code>/sim-dee/</code>）是“Single Instruction/Multiple Data”的缩写，意为“单指令，多数据”。它是 JavaScript 操作 CPU 对应指令的接口，你可以看做这是一种不同的运算执行模式。与它相对的是 SISD（“Single Instruction/Single Data”），即“单指令，单数据”。</p>\\n\",\"capture\":\"概述\\nSIMD（发音`/sim-dee/`）是“Single Instruction/Multiple Data”的缩写，意为“单指令，多数据”。它是 JavaScript 操作 CPU 对应指令的接口，你可以看做这是一种不同的运算执行模式。与它相对的是 SISD（“Single Instruction/Single Data”），即“单指令，单数据”。\\nSIMD 的含义是使用一个指令，完成多个数据的运算；SISD 的含义是使用一个指令，完成单个数据的运算，这是 JavaScript 的默认运算模式。显而易见，SIMD 的执行效率要高于 SISD，所以被广泛用于 3D 图形运算、物理模拟等运算\"},{\"url\":\"/《ES6 教程》笔记/34.参考链接.html\",\"relativePath\":\"/《ES6 教程》笔记/34.参考链接.html\",\"frontmatter\":{\"title\":\"参考链接\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/ea6f3b870f6dab69\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"参考链接\",\"date\":\"2020-02-09 16:00:30\",\"capture\":\"官方文件\\n- ECMAScript® 2015 Language Specification: ECMAScript 2015 规格\\n- ECMAScript® 2016 Language Specification: ECMAScript 2016 规格\\n- ECMAScript® 2017 Language Specification：ECMAScript 2017 规格（草案）\\n- ECMAScript Current Proposals: ECMAScript 当前的所有提案\\n- ECMAScript Active Proposals: 已经进入正式流程的提案\\n- ECMAScript\"},{\"url\":\"/《ES6 教程》笔记/35.了解ES6中的Map和Set.html\",\"relativePath\":\"/《ES6 教程》笔记/35.了解ES6中的Map和Set.html\",\"frontmatter\":{\"title\":\"了解ES6中的Map和Set\",\"date\":\"2023-09-08 16:10:10\",\"permalink\":\"/pages/bfde72/\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"了解ES6中的Map和Set\",\"date\":\"2023-09-08 16:10:10\",\"capture\":\"Map对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。构造函数Map可以接受一个数组作为参数。\\nMap对象的方法\\nset(key, val): 向Map中添加新元素\\nget(key): 通过键值查找特定的数值并返回\\nhas(key): 判断Map对象中是否有Key所对应的值，有返回true,否则返回false\\ndelete(key): 通过键值从Map中移除对应的数据\\nclear(): 将这个Map中的所有元素删除\\n```jsx\\nconst m1 = new Map([['a', 111], ['b', 222]])\\nconsole.log(m1) // {\\\"a\\\" =\\nm1\"},{\"url\":\"/《Electron》笔记/01.electron记录.html\",\"relativePath\":\"/《Electron》笔记/01.electron记录.html\",\"frontmatter\":{\"title\":\"electron记录\",\"date\":\"2023-09-09 14:23:20\",\"permalink\":\"/pages/8e9a16/\",\"categories\":[\"《Electron》笔记\"],\"tags\":[\"electron\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"electron记录\",\"date\":\"2023-09-09 14:23:20\",\"capture\":\"事件周期\\n electron常用事件统计\\n主进程常用事件可以分为以下几类：\\n1. 应用程序生命周期事件：\\n    - `ready`: 当 Electron 应用程序初始化完成且准备好显示窗口时触发。\\n    - `window-all-closed`: 当所有窗口都关闭后触发，在 macOS 上通常不会退出应用程序。\\n    - `activate`: 在 macOS 上，当用户点击应用程序的 Dock 图标并且没有其他窗口打开时触发，用于重新创建新窗口。\\n2. 窗口相关事件：\\n    - `closed`: 窗口关闭时触发。\\n    - `dom-ready`: 窗口加载完毕并且 DOM \"},{\"url\":\"/《Electron》笔记/02.electron下使用puppeteer模拟用户操作,数据获取.html\",\"relativePath\":\"/《Electron》笔记/02.electron下使用puppeteer模拟用户操作,数据获取.html\",\"frontmatter\":{\"title\":\"electron下使用puppeteer模拟用户操作,数据获取\",\"date\":\"2023-09-09 15:15:18\",\"permalink\":\"/pages/56ebf1/\",\"categories\":[\"《Electron》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"electron下使用puppeteer模拟用户操作,数据获取\",\"date\":\"2023-09-09 15:15:18\",\"capture\":\"Puppeteer是一个由Google开发的Node.js库，它提供了一组用于控制和自动化Chrome或Chromium浏览器的API。它可以用于执行各种与浏览器相关的任务，如网页截图、生成PDF、模拟用户交互、爬取网页数据等。Puppeteer通过WebSocket连接与浏览器建立通信，并通过DevTools协议发送命令和接收浏览器的响应。\\n什么是 Chrome DevTool Protocol\\n- CDP 基于 WebSocket，利用 WebSocket 实现与浏览器内核的快速数据通道\\n- CDP 分为多个域（DOM，Debugger，Network，Profiler，Console..\"},{\"url\":\"/《Git》学习笔记/10.手册/00.常用Git命令清单.html\",\"relativePath\":\"/《Git》学习笔记/10.手册/00.常用Git命令清单.html\",\"frontmatter\":{\"title\":\"常用Git命令清单\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/8292d8/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"常用Git命令清单\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。\\n下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。\\n\\n&gt; - Index / Stage：暂存区\\n&gt; - Repository：仓库区（或本地仓库）\\n&gt; - Remote：远程仓库\\n 一、新建代码库\\n```bash\\n 在当前目录新建一个Git代码库\\n$ git init\\n 新建一个目录，将其初始化为Git代码库\\n$ git init [project-name]\\n 下载一个项目和它的整个代码历史\\n$ git clone [url]\\n```\\n 二、配置\\nGit的设置文件为\"},{\"url\":\"/《Git》学习笔记/10.手册/01.Git变基合并.html\",\"relativePath\":\"/《Git》学习笔记/10.手册/01.Git变基合并.html\",\"frontmatter\":{\"title\":\"Git变基合并\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/c10281/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git变基合并\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"说明\\n以下 `v2` 是某个需求的开发分支， `dev`是总的开发分支，`v2` 是基于`dev`分支签出的。\\n当完成`v2`的开发后，需要把代码合并到`dev`，我们可以使用`rebase`进行合并：\\n```sh\\n 首先将 v2 push到远程仓库\\ngit add .\\ngit commit -m 'xxx'\\ngit push origin v2\\n 切换到 dev 拉取最新代码\\ngit checkout dev\\ngit pull origin dev\\n 切换到 v2\\ngit checkout v2\\ngit rebase dev  将 v2 的所有[commit] 变基到(应用到) dev\\n 切\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/10.Git基础与命令.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/10.Git基础与命令.html\",\"frontmatter\":{\"title\":\"Git基础与命令\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/635088/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git基础与命令\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"官方文档（中文）：https://git-scm.com/book/zh/v2\\n\\n Git基础\\n 全局配置\\n```bash\\ngit config --global user.name 'your name'\\ngit config --global user.email 'xxx@xx.com'\\n```\\n自报家门\\n 检查配置信息\\n```sh\\ngit config --list\\n```\\n 获取帮助\\n```sh\\n 获取全局帮助手册\\ngit help\\n 获取特定命令的详细版帮助手册 (两个命令是等价的)\\ngit help &lt;某个命令&gt;\\ngit &lt;某个命令&gt; --help  两个\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/100.Git工具-重写历史.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/100.Git工具-重写历史.html\",\"frontmatter\":{\"title\":\"Git工具-重写历史\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/1832fe/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git工具-重写历史\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"许多时候，在使用 Git 时，你可能想要修订提交历史。 Git 很棒的一点是它允许你在最后时刻做决定。 你可以在将暂存区内容提交前决定哪些文件进入提交，可以通过 `git stash` 来决定不与某些内容工作， 也可以重写已经发生的提交就像它们以另一种方式发生的一样。 这可能涉及改变提交的顺序，改变提交中的信息或修改文件，将提交压缩或是拆分， 或完全地移除提交——在将你的工作成果与他人共享之前。\\n在本节中，你可以学到如何完成这些工作，这样在与他人分享你的工作成果时你的提交历史将如你所愿地展示出来。\\n| Note | 在满意之前不要推送你的工作Git 的基本原则之一是，由于克隆中有很多工作是本地\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/110.Git工具-重置揭密.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/110.Git工具-重置揭密.html\",\"frontmatter\":{\"title\":\"Git工具-重置揭密\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/d9e9c6/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git工具-重置揭密\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"在继续了解更专业的工具前，我们先探讨一下 Git 的 `reset` 和 `checkout` 命令。 在初遇的 Git 命令中，这两个是最让人困惑的。 它们能做很多事情，所以看起来我们很难真正地理解并恰当地运用它们。 针对这一点，我们先来做一个简单的比喻。\\n 三棵树\\n理解 `reset` 和 `checkout` 的最简方法，就是以 Git 的思维框架（将其作为内容管理器）来管理三棵不同的树。 “树” 在我们这里的实际意思是 “文件的集合”，而不是指特定的数据结构。 （在某些情况下索引看起来并不像一棵树，不过我们现在的目的是用简单的方式思考它。）\\nGit 作为一个系统，是以它的一般操作来管理\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/20.Git分支-分支原理.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/20.Git分支-分支原理.html\",\"frontmatter\":{\"title\":\"Git分支-分支原理\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/4bef1a/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支-分支原理\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。\\n 首次提交\\n在进行提交操作时，Git 会保存一个提交对象（commit object）。\\n假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 暂存操作会为每一个文件计算校验和（使用 SHA-1 哈希算法），然后会把当前版本的文件快照保存到 Git 仓库中 （Git 使用 *blob* 对象来保存它们），最终将校验和加入到暂存区域等待提交：\\n```sh\\n$ git\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/30.Git分支的新建与合并-分支操作.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/30.Git分支的新建与合并-分支操作.html\",\"frontmatter\":{\"title\":\"Git分支的新建与合并-分支操作\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/ea5a8c/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支的新建与合并-分支操作\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"文档：Git 分支 - 分支的新建与合并\\n 创建分支并切换\\n此时有一个需求需要在新的分支`iss53`上工作：\\n```sh\\n$ git checkout -b iss53   b表示branch\\n```\\n它是下面两条命令的简写：\\n```sh\\n$ git branch iss53\\n$ git checkout iss53\\n```\\n 切换分支\\n突然有一个紧急问题要解决，需要在原来的`master`分支进行修复：\\n```sh\\n$ git checkout master\\n```\\n在切换到`master`之前，需要`iss53`分支保持好一个干净的状态（修改都已提交）。\\n注意：切换分支Git 会重置你的\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/40.Git分支管理-查看分支.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/40.Git分支管理-查看分支.html\",\"frontmatter\":{\"title\":\"Git分支管理-查看分支\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/a399b3/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支管理-查看分支\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"查看分支\\n```sh\\n$ git branch\\n  iss53\\n* master   带星号*表示当前所在分支\\n  testing\\n```\\n`git branch` 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表。\\n 查看每个分支的最后提交\\n```sh\\n$ git branch -v\\n  iss53   93b412c fix javascript issue\\n* master  7a98805 Merge branch 'iss53'\\n  testing 782fd34 test\\n```\\n 查看已(未)合并的分支\\n`--merged` 与 `--no-m\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/50.Git分支开发工作流.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/50.Git分支开发工作流.html\",\"frontmatter\":{\"title\":\"Git分支开发工作流\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/49ee30/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支开发工作流\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"文档：Git分支开发工作流\\n 长期分支\\n因为 Git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。 也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些主题分支合并入其他分支中。\\n许多使用 Git 的开发者都喜欢使用这种方式来工作，比如只在 `master` 分支上保留完全稳定的代码，开发过程在`dev`分支，开发完成后并入`test`分支进行测试，通过测试的稳定代码才并入`master`分支中。\\n`dev`和`test`分支不需要保持绝对稳定，但在`test`通过测试达到稳定状态，就可以被合并入`mast\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/60.Git分支-远程分支.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/60.Git分支-远程分支.html\",\"frontmatter\":{\"title\":\"Git分支-远程分支\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/574d62/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支-远程分支\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"远程引用是对远程仓库的引用（指针），包括分支、标签等等。\\n\\n 查看远程引用列表与信息\\n```sh\\ngit ls-remote &lt;remote&gt;  远程引用的完整列表\\ngit remote show &lt;remote&gt;  远程分支的更多信息\\n```\\n上面两行命令比较少用，更常见的做法是利用远程跟踪分支。\\n 远程跟踪分支\\n远程跟踪分支是远程分支状态的引用。它们是你无法移动的本地引用。一旦你进行了网络通信， Git 就会为你移动它们以精确反映远程仓库的状态。请将它们看做书签， 这样可以提醒你该分支在远程仓库中的位置就是你最后一次连接到它们的位置。\\n它们以 `&lt;remote\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/70.Git分支-变基.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/70.Git分支-变基.html\",\"frontmatter\":{\"title\":\"Git分支-变基\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/3a3247/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支-变基\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"在 Git 中整合来自不同分支的修改主要有两种方法：`merge` 以及 `rebase`。 在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。\\n 变基的基本操作\\n请回顾之前在 分支的合并 中的一个例子，你会看到开发任务分叉到两个不同分支，又各自提交了更新。\\n&lt;p align=\\\"center\\\"\\n之前介绍过，整合分支最容易的方法是 `merge` 命令。 它会把两个分支的最新快照（`C3` 和 `C4`）以及二者最近的共同祖先（`C2`）进行三方合并，合并的结果是生成一个新的快照（并提交）。\\n &lt;p align=\\\"cen\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/80.Git工具-查看修订版本.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/80.Git工具-查看修订版本.html\",\"frontmatter\":{\"title\":\"Git工具-查看修订版本\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/c984d1/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git工具-查看修订版本\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"Git 能够以多种方式来指定单个提交、一组提交、或者一定范围内的提交。 了解它们并不是必需的，但是了解一下总没坏处。\\n修订版本指的是：提交\\n 单个修订版本\\n你可以通过任意一个提交的 40 个字符的完整 SHA-1 散列值来指定它， 不过还有很多更人性化的方式来做同样的事情。本节将会介绍获取单个提交的多种方法。\\n 简短的 SHA-1\\nGit 十分智能，你只需要提供 SHA-1 的前几个字符就可以获得对应的那次提交， 当然你提供的 SHA-1 字符数量不得少于 4 个，并且没有歧义——也就是说， 当前对象数据库中没有其它对象以这段 SHA-1 开头。\\n例如，要查看你知道其中添加了某个功能的提交，首\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/90.Git工具-交互式暂存.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/90.Git工具-交互式暂存.html\",\"frontmatter\":{\"title\":\"Git工具-交互式暂存\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/76d859/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git工具-交互式暂存\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"本节中的几个交互式 Git 命令可以帮助你将文件的特定部分组合成提交。 当你在修改了大量文件后，希望这些改动能拆分为若干提交而不是混杂在一起成为一个提交时，这几个工具会非常有用。 通过这种方式，可以确保提交是逻辑上独立的变更集，同时也会使其他开发者在与你工作时很容易地审核。 如果运行 `git add` 时使用 `-i` 或者 `--interactive` 选项，Git 将会进入一个交互式终端模式，显示类似下面的东西：\\n```sh\\n$ git add -i\\n           staged     unstaged path\\n  1:    unchanged        +0/-1 T\"},{\"url\":\"/《Git》学习笔记/Git常用命令速查表.html\",\"relativePath\":\"/《Git》学习笔记/Git常用命令速查表.html\",\"frontmatter\":{\"title\":\"Git常用命令速查表\",\"date\":\"2024-03-30 15:26:32\",\"permalink\":\"/pages/3aa4fd/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git常用命令速查表\",\"date\":\"2024-03-30 15:26:32\",\"capture\":\"\"},{\"url\":\"/《JavaScript教程》笔记/01.基础.html\",\"relativePath\":\"/《JavaScript教程》笔记/01.基础.html\",\"frontmatter\":{\"title\":\"基础\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/0796ba76b4b55368\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"基础\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"基础篇\\n 一、JS的一些名词概念\\n 什么是作用域？\\n变量存在的范围。\\n可分为全局作用域和函数作用域，ES6新增块级作用域。\\n 什么是闭包？\\n闭包就是能够读取其他函数内部变量的函数。\\n* 闭包的形式：函数内部定义函数\\n* 本质上闭包就是将函数内部和外部连接起来的一座桥梁\\n闭包的作用：\\n* 可以读取函数内部变量\\n* 让这些变量始终保持在内存中，即闭包可以使得它诞生的环境一直存在。\\n*  封装对象的私有属性和私有方法\\n 什么是构造函数？\\n用于构造(生成)实例的一个函数，使实例拥有构造函数内定于的属性和方法。\\n 什么是实例对象？\\n实例对象就是通过new 构造函数生成的，拥有构造函数内定于的属性和方法的\"},{\"url\":\"/《JavaScript教程》笔记/02.内置对象.html\",\"relativePath\":\"/《JavaScript教程》笔记/02.内置对象.html\",\"frontmatter\":{\"title\":\"内置对象\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/74d2ab3fbfeaaa68\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"内置对象\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"内置对象篇\\n 一、Object对象\\n 1、概述\\nJavaScript 原生提供`Object`对象（注意起首的`O`是大写），本章介绍该对象原生的各种方法。\\nJavaScript 的所有其他对象都继承自`Object`对象，即那些对象都是`Object`的实例。\\n`Object`对象的原生方法分成两类：`Object`本身的方法与`Object`的实例方法。\\n（1）Object对象本身的方法\\n所谓“本身的方法”就是直接定义在`Object`对象的方法。\\n```js\\nObject.print = function (o) { console.log(o) };\\n```\\n上面代码中，`print`\"},{\"url\":\"/《JavaScript教程》笔记/03.面向对象.html\",\"relativePath\":\"/《JavaScript教程》笔记/03.面向对象.html\",\"frontmatter\":{\"title\":\"面向对象\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/659b5af5e2e704e0\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"面向对象\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"面向对象编程\\n 一、实例对象与new命令\\n 1、对象是什么\\n面向对象编程（Object Oriented Programming，缩写为 OOP）是目前主流的编程范式。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。\\n每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务。对象可以复用，通过继承机制还可以定制。因此，面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程（procedural programming），更适合多人合作的大型软件项目。\\n那么，“对象”\"},{\"url\":\"/《JavaScript教程》笔记/04.异步操作.html\",\"relativePath\":\"/《JavaScript教程》笔记/04.异步操作.html\",\"frontmatter\":{\"title\":\"异步操作\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/d61b1cb4cdac1f63\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"异步操作\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"异步操作\\n 一、异步操作概述\\n 1、单线程模型\\n单线程模型指的是，JavaScript 只在一个线程上运行。也就是说，JavaScript 同时只能执行一个任务，其他任务都必须在后面排队等待。\\n注意，JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合。\\nJavaScript 之所以采用单线程，而不是多线程，跟历史有关系。JavaScript 从诞生起就是单线程，原因是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对\"},{\"url\":\"/《JavaScript教程》笔记/05.DOM.html\",\"relativePath\":\"/《JavaScript教程》笔记/05.DOM.html\",\"frontmatter\":{\"title\":\"DOM\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/7d961b8030c6099e\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"DOM\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"DOM\\n 一、概述\\n 1、DOM\\nDOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。\\n浏览器会根据 DOM 模型，将结构化文档（比如 HTML 和 XML）解析成一系列的节点，再由这些节点组成一个树状结构（DOM Tree）。所有的节点和最终的树状结构，都有规范的对外接口。\\nDOM 只是一个接口规范，可以用各种语言实现。所以严格地说，DOM 不是 JavaScript 语法的一部分，但是 DOM 操作是 JavaScript 最\"},{\"url\":\"/《JavaScript教程》笔记/06.事件.html\",\"relativePath\":\"/《JavaScript教程》笔记/06.事件.html\",\"frontmatter\":{\"title\":\"事件\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/10b2761db5a8e089\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"事件\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"事件\\n 一、EventTarget 接口\\n 事件的本质是程序各个组成部分之间的一种通信方式，也是异步编程的一种实现。DOM 支持大量的事件，本章开始介绍 DOM 的事件编程。\\n 1、概述\\nDOM 的事件操作（监听和触发），都定义在`EventTarget`接口。所有节点对象都部署了这个接口，其他一些需要事件通信的浏览器内置对象（比如，`XMLHttpRequest`、`AudioNode`、`AudioContext`）也部署了这个接口。\\n该接口主要提供三个实例方法。\\n- `addEventListener`：绑定事件的监听函数\\n- `removeEventListener`：移除事件的监听函\"},{\"url\":\"/《JavaScript教程》笔记/07.浏览器模型.html\",\"relativePath\":\"/《JavaScript教程》笔记/07.浏览器模型.html\",\"frontmatter\":{\"title\":\"浏览器模型\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/bab4930124ad2c10\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"浏览器模型\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"一、浏览器环境概述\\nJavaScript 是浏览器的内置脚本语言。也就是说，浏览器内置了 JavaScript 引擎，并且提供各种接口，让 JavaScript 脚本可以控制浏览器的各种功能。一旦网页内嵌了 JavaScript 脚本，浏览器加载网页，就会去执行脚本，从而达到操作浏览器的目的，实现网页的各种动态效果。\\n本章开始介绍浏览器提供的各种 JavaScript 接口。首先，介绍 JavaScript 代码嵌入网页的方法。\\n 1、代码嵌入网页的方法\\n网页中嵌入 JavaScript 代码，主要有三种方法。\\n- `  &lt;script\\n- `  &lt;script&gt;  `标签加\"},{\"url\":\"/《JavaScript教程》笔记/08.事件循环(evenloop).html\",\"relativePath\":\"/《JavaScript教程》笔记/08.事件循环(evenloop).html\",\"frontmatter\":{\"title\":\"事件循环(evenloop)\",\"date\":\"2023-09-08 16:20:58\",\"permalink\":\"/pages/eaf565/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"事件循环(evenloop)\",\"date\":\"2023-09-08 16:20:58\",\"capture\":\"JavaScript 是一门单线程的语言，它的异步和多线程的实现是通过 Event Loop 事件循环机制来实现的\\nEvent Loop 的机制\\n大体三个部分组成\\n1、调用栈 Stack\\n2、消息队列 Message Queue\\n3、微任务队列 Microtask Queue\\n Event Loop 开始的时候会从全局栈开始逐行执行，遇到函数调用，会把函数压入到调用栈中，当函数返回后，会从调用栈中弹出\\n```javascript\\nfunction func1(){\\n    console.log(1);\\n }\\n function func2(){\\n    console.log(2);\\n   \"},{\"url\":\"/《JavaScript教程》笔记/09.js 使用postMessage iframe跨域通信.html\",\"relativePath\":\"/《JavaScript教程》笔记/09.js 使用postMessage iframe跨域通信.html\",\"frontmatter\":{\"title\":\"js 使用postMessage iframe跨域通信\",\"date\":\"2024-03-30 15:21:11\",\"permalink\":\"/pages/d67bac/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"js 使用postMessage iframe跨域通信\",\"date\":\"2024-03-30 15:21:11\",\"capture\":\"在 Web 应用程序中，由于同源策略的限制，如果我们需要在一个页面中嵌入来自不同域的资源（例如图片、脚本或 iframe），那么就会出现跨域问题。在这种情况下，我们需要使用一些技术来实现跨域通信。\\r\\n\\r\\n其中一种解决方案是使用 HTML5 中引入的 postMessage API。postMessage 允许我们在不同窗口或 iframe 之间发送消息，这使得我们可以实现跨域通信，而不违反同源策略。\\r\\n\\r\\n postMessage 简介\\r\\n\\r\\npostMessage 是 HTML5 中引入的一种跨窗口通信机制。它允许我们在不同窗口之间发送消息，并且这些窗口可以来自不同的域。postMessag\"},{\"url\":\"/《JavaScript教程》笔记/10.JS中的？.和？？区别.html\",\"relativePath\":\"/《JavaScript教程》笔记/10.JS中的？.和？？区别.html\",\"frontmatter\":{\"title\":\"和？？区别\",\"date\":\"2024-03-30 15:22:03\",\"permalink\":\"/pages/176ae0/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"和？？区别\",\"date\":\"2024-03-30 15:22:03\",\"capture\":\"`??` 运算符\\r\\n\\r\\n`??` 运算符是 ES2020 中新增的空值合并运算符。它用于判断一个值是否为 `null` 或 `undefined`，如果是，则使用默认值。其语法如下：\\r\\n\\r\\n```javascript\\r\\ndefaultValue ?? value;\\r\\n```\\r\\n\\r\\n如果 `value` 不为 `null` 或 `undefined`，则 `??` 运算符返回 `value`；否则返回 `defaultValue`。\\r\\n\\r\\n```javascript\\r\\nconst a = null;\\r\\nconst b = 5;\\r\\n\\r\\nconsole.log(a ?? 10); // 10\\r\\nco\"},{\"url\":\"/《JavaScript教程》笔记/11.`import`、`require`、`export`、`module.exports` 的区别和使用详解.html\",\"relativePath\":\"/《JavaScript教程》笔记/11.`import`、`require`、`export`、`module.exports` 的区别和使用详解.html\",\"frontmatter\":{\"title\":\"exports` 的区别和使用详解\",\"date\":\"2024-03-30 15:23:12\",\"permalink\":\"/pages/ff5679/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"exports` 的区别和使用详解\",\"date\":\"2024-03-30 15:23:12\",\"capture\":\"在 Node.js 和现代的 JavaScript 中，有多种方式可以导入和导出模块。其中最常见的是使用 `import` 和 `export`，但在 Node.js 中，也可以使用 `require` 和 `module.exports`。本篇文章将介绍这些不同的方式，以及它们之间的区别。\\r\\n\\r\\n `import` 和 `export`\\r\\n\\r\\n`import` 和 `export` 是 ES6 中引入的模块系统。它们允许我们将代码拆分成多个文件，并在不同的文件中共享代码。以下是一个简单的例子：\\r\\n\\r\\n```javascript\\r\\n// math.js\\r\\nexport const add = \"},{\"url\":\"/《JavaScript教程》笔记/12.console实用调试方法.html\",\"relativePath\":\"/《JavaScript教程》笔记/12.console实用调试方法.html\",\"frontmatter\":{\"title\":\"console实用调试方法\",\"date\":\"2024-03-30 15:31:48\",\"permalink\":\"/pages/602ffc/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"console实用调试方法\",\"date\":\"2024-03-30 15:31:48\",\"capture\":\"在JavaScript中，console是一个非常有用的工具，可以帮助我们在开发和调试过程中更好地了解代码的执行情况。本文将介绍console中一些常用的方法，并提供示例代码。\\r\\n console.time() & console.timeEnd()\\r\\nconsole.time()方法用于开始计时器，console.timeEnd()方法用于结束计时器并输出所花费的时间。这对于测试代码执行时间非常有用。\\r\\n```javascript\\r\\nconsole.time('myTimer');\\r\\nfor (let i = 0; i &lt; 1000000; i++) {\\r\\n  // do someth\"},{\"url\":\"/《JavaScript教程》笔记/13.JS继承.html\",\"relativePath\":\"/《JavaScript教程》笔记/13.JS继承.html\",\"frontmatter\":{\"title\":\"JS继承\",\"date\":\"2024-03-30 15:32:05\",\"permalink\":\"/pages/b17c09/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"JS继承\",\"date\":\"2024-03-30 15:32:05\",\"capture\":\"在JavaScript中，继承是实现面向对象编程的重要方式之一。\\r\\n\\r\\n 原型继承\\r\\n\\r\\n原型继承是JavaScript中最常用的继承方式之一。在原型继承中，子类通过继承父类的原型对象来实现继承。\\r\\n\\r\\n```javascript\\r\\nfunction Parent() {\\r\\n  this.name = 'parent';\\r\\n}\\r\\n\\r\\nParent.prototype.sayHello = function() {\\r\\n  console.log('Hello from ' + this.name);\\r\\n}\\r\\n\\r\\nfunction Child() {\\r\\n  this.name = 'child';\"},{\"url\":\"/《JavaScript教程》笔记/14.JS实现扫码登录.html\",\"relativePath\":\"/《JavaScript教程》笔记/14.JS实现扫码登录.html\",\"frontmatter\":{\"title\":\"JS实现扫码登录\",\"date\":\"2024-03-30 15:32:39\",\"permalink\":\"/pages/bdbdb8/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"JS实现扫码登录\",\"date\":\"2024-03-30 15:32:39\",\"capture\":\"JS实现扫码登录\\r\\n\\r\\n扫码登录是一种方便快捷的登录方式，用户可以通过扫描二维码来登录网站或应用程序。在本文中，我们将使用JavaScript实现一个简单的扫码登录功能。\\r\\n\\r\\n 步骤一：生成二维码\\r\\n\\r\\n首先，我们需要生成一个二维码，用于展示给用户扫描。我们可以使用第三方库 qrcode.js 来生成二维码。以下是使用qrcode.js生成二维码的示例代码：\\r\\n\\r\\n```html\\r\\n&lt;!-- 在HTML中引入qrcode.js库 --\\r\\n&lt;script src=\\\"https://cdn.bootcdn.net/ajax/libs/qrcodejs/1.0.0/qrcode.min\"},{\"url\":\"/《Vue》笔记/01.基础/00.MVVM模式.html\",\"relativePath\":\"/《Vue》笔记/01.基础/00.MVVM模式.html\",\"frontmatter\":{\"title\":\"MVVM模式\",\"date\":\"2020-02-04 12:19:00\",\"permalink\":\"/pages/114158caa9e96df0\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"MVVM模式\",\"date\":\"2020-02-04 12:19:00\",\"excerpt\":\"<div class=\\\"tip custom-block\\\"><p class=\\\"custom-block-title\\\">TIP</p>\\n<p>说明：本章内容是博主的Vue学习笔记，以<a href=\\\"https://cn.vuejs.org/v2/guide/\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">官方文档</a>为准。</p>\\n</div>\\n<h1 id=\\\"mvvm模式\\\" tabindex=\\\"-1\\\">MVVM模式 <a class=\\\"header-anchor\\\" href=\\\"#mvvm模式\\\" aria-label=\\\"Permalink to &quot;MVVM模式&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>MVVM模式，<code>M</code>即 model，数据模型；<code>V</code>即 view，视图；<code>VM</code>即 view-model，视图模型。</p>\\n\",\"capture\":\"说明：本章内容是博主的Vue学习笔记，以官方文档为准。\\n MVVM模式\\nMVVM模式，`M`即 model，数据模型；`V`即 view，视图；`VM`即 view-model，视图模型。\\n理解\\n首先，数据Model通过Data Bindings把数据绑定在View视图上，\\n当View视图有交互（有改变）的时候，Dom listeners会自动监听，然后更新数据Model。\\nQ：什么是MVVM模式？\\nA：MVVM模式，第一个M代表数据模型，V代表视图，VM代表视图模型；\\n它的实际操作原理是：后台数据通过视图模型来渲染视图，就是页面。当用户在页面上进行操作的时候，\\n视图模型会自动监听到用户的操作\"},{\"url\":\"/《Vue》笔记/01.基础/10.生命周期.html\",\"relativePath\":\"/《Vue》笔记/01.基础/10.生命周期.html\",\"frontmatter\":{\"title\":\"生命周期\",\"date\":\"2020-02-04 15:06:59\",\"permalink\":\"/pages/176808a1b5f843b8\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"生命周期\",\"date\":\"2020-02-04 15:06:59\",\"excerpt\":\"<h1 id=\\\"实例生命周期钩子\\\" tabindex=\\\"-1\\\">实例生命周期钩子 <a class=\\\"header-anchor\\\" href=\\\"#实例生命周期钩子\\\" aria-label=\\\"Permalink to &quot;实例生命周期钩子&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/instance.html#%E5%AE%9E%E4%BE%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">实例生命周期钩子API</a></p>\\n<p>简单理解，生命周期钩子函数就是vue实例在某一个时间点会自动执行的函数。</p>\\n\",\"capture\":\"实例生命周期钩子API\\n简单理解，生命周期钩子函数就是vue实例在某一个时间点会自动执行的函数。\\n```html\\n&lt;div id=\\\"app\\\"\\n&lt;script src=\\\"https://cdn.bootcss.com/vue/2.4.2/vue.js\\\"&gt;&lt;/script&gt;\\n&lt;script&gt;\\n  var vm = new Vue({\\n    el: 'app',\\n    data: {\\n      msg: 'Vue的生命周期'\\n    },\\n    beforeCreate: function() {\\n      console.group('-----\"},{\"url\":\"/《Vue》笔记/01.基础/20.计算属性 vs 方法 vs 侦听属性.html\",\"relativePath\":\"/《Vue》笔记/01.基础/20.计算属性 vs 方法 vs 侦听属性.html\",\"frontmatter\":{\"title\":\"计算属性 vs 方法 vs 侦听属性\",\"date\":\"2020-02-04 16:37:51\",\"permalink\":\"/pages/351f72ecd9c41129\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"计算属性 vs 方法 vs 侦听属性\",\"date\":\"2020-02-04 16:37:51\",\"excerpt\":\"<h1 id=\\\"计算属性-vs-方法-vs-侦听属性\\\" tabindex=\\\"-1\\\">计算属性 vs 方法 vs 侦听属性 <a class=\\\"header-anchor\\\" href=\\\"#计算属性-vs-方法-vs-侦听属性\\\" aria-label=\\\"Permalink to &quot;计算属性 vs 方法 vs 侦听属性&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/computed.html#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%BC%93%E5%AD%98-vs-%E6%96%B9%E6%B3%95\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">API</a></p>\\n<p>如果一个功能同时可以使用计算属性(computed)、方法(methods)、侦听属性(watch)来实现的时候推荐使用计算属性。</p>\\n\",\"capture\":\"API\\n如果一个功能同时可以使用计算属性(computed)、方法(methods)、侦听属性(watch)来实现的时候推荐使用计算属性。\\n| 计算属性                                 | 方法                                               | 侦听属性                                     |\\n| ---------------------------------------- | --------------------------------------------------\"},{\"url\":\"/《Vue》笔记/01.基础/30.v-if vs v-show.html\",\"relativePath\":\"/《Vue》笔记/01.基础/30.v-if vs v-show.html\",\"frontmatter\":{\"title\":\"v-if vs v-show\",\"date\":\"2020-02-04 17:32:23\",\"permalink\":\"/pages/73e4064340277b05\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"v-if vs v-show\",\"date\":\"2020-02-04 17:32:23\",\"excerpt\":\"<h1 id=\\\"v-if-vs-v-show\\\" tabindex=\\\"-1\\\">v-if vs v-show <a class=\\\"header-anchor\\\" href=\\\"#v-if-vs-v-show\\\" aria-label=\\\"Permalink to &quot;v-if vs v-show&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/conditional.html#v-if-vs-v-show\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">API</a></p>\\n<p><code>v-if</code> 根据渲染条件决定是否把元素渲染到DOM页面，而<code>v-show</code>不管渲染条件是什么，都会把元素渲染到DOM页面，只是简单的切换CSS的显示隐藏。</p>\\n\",\"capture\":\"API\\n`v-if` 根据渲染条件决定是否把元素渲染到DOM页面，而`v-show`不管渲染条件是什么，都会把元素渲染到DOM页面，只是简单的切换CSS的显示隐藏。\\n如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好。\"},{\"url\":\"/《Vue》笔记/01.基础/35.列表渲染之数组、对象更新检测.html\",\"relativePath\":\"/《Vue》笔记/01.基础/35.列表渲染之数组、对象更新检测.html\",\"frontmatter\":{\"title\":\"列表渲染之数组、对象更新检测\",\"date\":\"2020-02-05 13:09:06\",\"permalink\":\"/pages/04783a6691cc9d06\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"列表渲染之数组、对象更新检测\",\"date\":\"2020-02-05 13:09:06\",\"excerpt\":\"<h1 id=\\\"列表渲染之数组、对象更新检测\\\" tabindex=\\\"-1\\\">列表渲染之数组、对象更新检测 <a class=\\\"header-anchor\\\" href=\\\"#列表渲染之数组、对象更新检测\\\" aria-label=\\\"Permalink to &quot;列表渲染之数组、对象更新检测&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/list.html#%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">数组更新检测API</a> <a href=\\\"https://cn.vuejs.org/v2/guide/list.html#%E5%AF%B9%E8%B1%A1%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">对象更新检测API</a></p>\\n<h2 id=\\\"数组更新检测\\\" tabindex=\\\"-1\\\">数组更新检测 <a class=\\\"header-anchor\\\" href=\\\"#数组更新检测\\\" aria-label=\\\"Permalink to &quot;数组更新检测&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h4 id=\\\"变异方法-mutation-method\\\" tabindex=\\\"-1\\\">变异方法 (mutation method) <a class=\\\"header-anchor\\\" href=\\\"#变异方法-mutation-method\\\" aria-label=\\\"Permalink to &quot;变异方法 (mutation method)&quot;\\\">&ZeroWidthSpace;</a></h4>\\n<p>Vue 将被侦听的数组的变异方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：</p>\\n\",\"capture\":\"数组更新检测API 对象更新检测API\\n 数组更新检测\\n 变异方法 (mutation method)\\nVue 将被侦听的数组的变异方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：\\n- `push()`末尾添加\\n- `pop()`末尾删除\\n- `shift()` 首位删除\\n- `unshift() ` 首位添加\\n- `splice()` 拼合\\n- `sort()` 排序\\n- `reverse()` 反转\\n数组实例方法\\n 替换数组\\n变异方法，顾名思义，会改变调用了这些方法的原始数组。相比之下，也有非变异 (non-mutating method) 方法，例如 `filter(\"},{\"url\":\"/《Vue》笔记/02.组件/36.使用组件的细节点.html\",\"relativePath\":\"/《Vue》笔记/02.组件/36.使用组件的细节点.html\",\"frontmatter\":{\"title\":\"使用组件的细节点\",\"date\":\"2020-02-13 13:26:20\",\"permalink\":\"/pages/83a1ab785e7fd70c\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"使用组件的细节点\",\"date\":\"2020-02-13 13:26:20\",\"capture\":\"解析 DOM 模板时的注意事项\\n```html\\n&lt;div id=\\\"root\\\"\\n    &lt;table&gt;\\n        &lt;tbody&gt;\\n            &lt;row&gt;&lt;/row&gt;\\n            &lt;row&gt;&lt;/row&gt;\\n            &lt;row&gt;&lt;/row&gt;\\n        &lt;/tbody&gt;\\n    &lt;/table&gt;\\n&lt;/div&gt;\\n&lt;script type=\\\"text/javascript\\\"&gt;\\n    Vue.component\"},{\"url\":\"/《Vue》笔记/02.组件/40.父组件给子组件传值.html\",\"relativePath\":\"/《Vue》笔记/02.组件/40.父组件给子组件传值.html\",\"frontmatter\":{\"title\":\"父组件给子组件传值\",\"date\":\"2020-02-04 12:45:30\",\"permalink\":\"/pages/07b384c2e6232e07\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"父组件给子组件传值\",\"date\":\"2020-02-04 12:45:30\",\"excerpt\":\"<h1 id=\\\"父组件给子组件传值\\\" tabindex=\\\"-1\\\">父组件给子组件传值 <a class=\\\"header-anchor\\\" href=\\\"#父组件给子组件传值\\\" aria-label=\\\"Permalink to &quot;父组件给子组件传值&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>父组件中，通过给子组件标签v-bind绑定属性的方式传入值</p>\\n<div class=\\\"language-html vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">html</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">&#x3C;</span><span style=\\\"--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic\\\">ComponentName</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> v-bind:name</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"value\\\"</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">>&#x3C;/</span><span style=\\\"--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic\\\">ComponentName</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">></span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br></div></div><blockquote>\\n<p>如果不使用v-bind传入的值为字符串，使用v-bind绑定传入的值为表达式。</p>\\n</blockquote>\\n\",\"capture\":\"父组件中，通过给子组件标签v-bind绑定属性的方式传入值\\n```html\\n&lt;ComponentName v-bind:name=\\\"value\\\"\\n```\\n&gt; 如果不使用v-bind传入的值为字符串，使用v-bind绑定传入的值为表达式。\\n子组件中，通过props对象接收值\\n```js\\n props: {\\n    name: { // 接收父组件传入值\\n        type: String || ...,\\n        default: ''\\n    }\\n }\\n```\\n 单向数据流\\n所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向\"},{\"url\":\"/《Vue》笔记/02.组件/50.子组件派发事件和值给父组件.html\",\"relativePath\":\"/《Vue》笔记/02.组件/50.子组件派发事件和值给父组件.html\",\"frontmatter\":{\"title\":\"子组件派发事件和值给父组件\",\"date\":\"2020-02-04 12:56:51\",\"permalink\":\"/pages/0f19a1bcac14fd41\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"子组件派发事件和值给父组件\",\"date\":\"2020-02-04 12:56:51\",\"excerpt\":\"<h1 id=\\\"子组件派发事件和值给父组件\\\" tabindex=\\\"-1\\\">子组件派发事件和值给父组件 <a class=\\\"header-anchor\\\" href=\\\"#子组件派发事件和值给父组件\\\" aria-label=\\\"Permalink to &quot;子组件派发事件和值给父组件&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/components.html#%E7%9B%91%E5%90%AC%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">API</a></p>\\n<p>子组件通过<code>$emit</code>派发事件和值给父组件（值可以有多个）</p>\\n<div class=\\\"language-js vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">js</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">this</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">$emit</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'fnX'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, value)</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br></div></div>\",\"capture\":\"API\\n子组件通过`$emit`派发事件和值给父组件（值可以有多个）\\n```js\\nthis.$emit('fnX', value)\\n```\\n父组件通过`v-on`绑定子组件派发的事件，并触发一个新的事件，新的事件内可以接收传来的值\\n```js\\n&lt;ComponentName @fnX=\\\"fnY\\\"\\nmethods: {\\n\\tfnY(value) {\\n\\t\\tconsole.log(value)\\n\\t}\\n}\\n```\\n 父子组件间传递数据 demo\\n&lt;p class=\\\"codepen\\\" data-height=\\\"400\\\" data-theme-id=\\\"light\\\" data-default-tab\"},{\"url\":\"/《Vue》笔记/02.组件/52.Prop 验证 与 非 Prop 的 Attribute.html\",\"relativePath\":\"/《Vue》笔记/02.组件/52.Prop 验证 与 非 Prop 的 Attribute.html\",\"frontmatter\":{\"title\":\"Prop 验证 与 非 Prop 的 Attribute\",\"date\":\"2020-02-15 10:49:04\",\"permalink\":\"/pages/a3080f60f6596eb4\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Prop 验证 与 非 Prop 的 Attribute\",\"date\":\"2020-02-15 10:49:04\",\"capture\":\"Prop 验证\\nAPI\\n子组件对父组件传递来的参数进行校验\\n```js\\nVue.component('my-component', {\\n  props: {\\n    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)\\n    propA: Number,\\n    // 多个可能的类型\\n    propB: [String, Number],\\n    // 必填的字符串\\n    propC: {\\n      type: String,\\n      required: true\\n    },\\n    // 带有默认值的数字\\n    propD: {\\n      \"},{\"url\":\"/《Vue》笔记/02.组件/55.自定义事件.html\",\"relativePath\":\"/《Vue》笔记/02.组件/55.自定义事件.html\",\"frontmatter\":{\"title\":\"自定义事件\",\"date\":\"2020-02-15 11:27:45\",\"permalink\":\"/pages/9651417d08d1779d\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"自定义事件\",\"date\":\"2020-02-15 11:27:45\",\"capture\":\"API\\n 在组件标签v-on绑定的事件是自定义事件\\n```html\\n&lt;div id=\\\"root\\\"\\n    &lt;child @click=\\\"handleClick\\\"&gt;&lt;/child&gt; &lt;!--这里click是自定义事件--&gt;\\n&lt;/div&gt;\\n&lt;script type=\\\"text/javascript\\\"&gt;\\n    Vue.component('child', {\\n        template: '&lt;button&gt;Child&lt;/button&gt;',\\n    })\\n    var vm = new Vue({\\n  \"},{\"url\":\"/《Vue》笔记/02.组件/60.兄弟组件传值.html\",\"relativePath\":\"/《Vue》笔记/02.组件/60.兄弟组件传值.html\",\"frontmatter\":{\"title\":\"兄弟组件传值\",\"date\":\"2020-02-04 13:04:32\",\"permalink\":\"/pages/809f4582d9ca9552\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"兄弟组件传值\",\"date\":\"2020-02-04 13:04:32\",\"capture\":\"子组件1中把值传到父组件,父组件获取值传入子组件2\\n父组件：\\n```js\\n&lt;子组件1 @方法名x=\\\"方法名y\\\"\\n&lt;子组件2 :值名称x=\\\"值x\\\"&gt;&lt;/子组件2 &gt;\\ndata() {\\n\\treturn {\\n\\t 值x: ''\\n\\t}\\n},\\nmethods: {\\n\\t方法名y(值) {\\n\\t\\tthis.值x = 值\\n\\t}\\n}\\n```\\n子组件1：\\n```js\\nthis.$emit('方法名x', 值) // 传出值\\n```\\n子组件2：\\n```js\\nprops: {\\n    值名称x: { // 接收父组件传入值\\n        type: String,\\n        defa\"},{\"url\":\"/《Vue》笔记/02.组件/65.非父子组件传值.html\",\"relativePath\":\"/《Vue》笔记/02.组件/65.非父子组件传值.html\",\"frontmatter\":{\"title\":\"非父子组件传值\",\"date\":\"2020-02-15 14:55:03\",\"permalink\":\"/pages/d408e64f666f146d\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"非父子组件传值\",\"date\":\"2020-02-15 14:55:03\",\"excerpt\":\"<h1 id=\\\"非父子组件间传值\\\" tabindex=\\\"-1\\\">非父子组件间传值 <a class=\\\"header-anchor\\\" href=\\\"#非父子组件间传值\\\" aria-label=\\\"Permalink to &quot;非父子组件间传值&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>当组件的嵌套多时，非父子组件间传值就显得复杂，除了使用<a href=\\\"https://vuex.vuejs.org/zh/\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">vuex</a>实现之外，还可以通过Bus（或者叫 总线/发布订阅模式/观察者模式）的方式实现非父子组件间传值。</p>\\n\",\"capture\":\"当组件的嵌套多时，非父子组件间传值就显得复杂，除了使用vuex实现之外，还可以通过Bus（或者叫 总线/发布订阅模式/观察者模式）的方式实现非父子组件间传值。\\n&lt;div id=\\\"root\\\"\\n\\t\\t&lt;child1 content=\\\"组件1：点我传出值\\\"&gt;&lt;/child1&gt;\\n\\t\\t&lt;child2 content=\\\"组件2\\\"&gt;&lt;/child2&gt;\\n\\t&lt;/div&gt;\\n```html\\n&lt;div id=\\\"root\\\"&gt;\\n    &lt;child1 content=\\\"组件1：点我传出值\\\"&gt;&lt;/child1&gt;\\n    &l\"},{\"url\":\"/《Vue》笔记/02.组件/70.父组件调用子组件方法并传入值.html\",\"relativePath\":\"/《Vue》笔记/02.组件/70.父组件调用子组件方法并传入值.html\",\"frontmatter\":{\"title\":\"父组件调用子组件方法并传入值\",\"date\":\"2020-02-04 13:06:37\",\"permalink\":\"/pages/2e24dab728769e0c\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"父组件调用子组件方法并传入值\",\"date\":\"2020-02-04 13:06:37\",\"capture\":\"通过`ref`引用调用子组件内的方法并传入参数\\n父组件：\\n```js\\n&lt;子组件标签  ref=\\\"refName\\\"\\nmethods: {\\n    fnX(x) {\\n      this.$refs.refName.fnY(x) // 调用子组件方法并传入值\\n    }\\n}\\n```\\n子组件：\\n```js\\nmethods: {\\n    fnY(x) {\\n      this.x = x\\n    }\\n  }\\n}\\n```\"},{\"url\":\"/《Vue》笔记/02.组件/75.插槽slot.html\",\"relativePath\":\"/《Vue》笔记/02.组件/75.插槽slot.html\",\"frontmatter\":{\"title\":\"插槽slot\",\"date\":\"2020-02-16 11:46:27\",\"permalink\":\"/pages/055ecee9a4325386\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"插槽slot\",\"date\":\"2020-02-16 11:46:27\",\"capture\":\"API\\n 插槽\\n```html\\n&lt;div id=\\\"root\\\"\\n    &lt;child&gt; &lt;!-- 组件标签 --&gt;\\n        &lt;h1&gt;hello&lt;/h1&gt;\\n    &lt;/child&gt;\\n&lt;/div&gt;\\n&lt;script type=\\\"text/javascript\\\"&gt;\\n    Vue.component('child', { // 子组件\\n        template: '&lt;div&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;'\\n    })\\n    var vm \"},{\"url\":\"/《Vue》笔记/02.组件/80.动态组件与 v-once 指令.html\",\"relativePath\":\"/《Vue》笔记/02.组件/80.动态组件与 v-once 指令.html\",\"frontmatter\":{\"title\":\"动态组件与 v-once 指令\",\"date\":\"2020-02-16 15:52:19\",\"permalink\":\"/pages/636ca33122e9a64b\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"动态组件与 v-once 指令\",\"date\":\"2020-02-16 15:52:19\",\"capture\":\"动态组件\\n```html\\n&lt;div id=\\\"root\\\"\\n\\t&lt;component :is=\\\"type\\\"&gt;&lt;/component&gt; &lt;!--其效果如同下面两行被注释的代码--&gt;\\n\\t&lt;!-- &lt;child-one v-if=\\\"type === 'child-one'\\\"&gt;&lt;/child-one&gt;\\n\\t    &lt;child-two v-if=\\\"type === 'child-two'\\\"&gt;&lt;/child-two&gt; --&gt;\\n\\t&lt;button @click=\\\"handleClick\\\"&gt;change&\"},{\"url\":\"/《Vue》笔记/02.组件/90.vue父子组件的生命周期顺序.html\",\"relativePath\":\"/《Vue》笔记/02.组件/90.vue父子组件的生命周期顺序.html\",\"frontmatter\":{\"title\":\"vue父子组件的生命周期顺序\",\"date\":\"2020-02-18 16:39:33\",\"permalink\":\"/pages/e6cec47efa42d7f1\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"vue父子组件的生命周期顺序\",\"date\":\"2020-02-18 16:39:33\",\"capture\":\"加载渲染过程\\n```\\n父beforeCreate -\\n```\\n父组件会先执行到beforeMount，接着会执行子组件钩子到挂载结束，再挂载父组件。\\n 子组件更新过程\\n```\\n父beforeUpdate -&gt; 子beforeUpdate -&gt; 子updated -&gt; 父updated\\n```\\n 父组件更新过程\\n```\\n父beforeUpdate -&gt; 父updated\\n```\\n 销毁过程\\n```\\n父beforeDestroy -&gt; 子beforeDestroy -&gt; 子destroyed -&gt; 父destroyed\\n```\"},{\"url\":\"/《Vue》笔记/03.过渡&动画/110.transition过渡&动画.html\",\"relativePath\":\"/《Vue》笔记/03.过渡&动画/110.transition过渡&动画.html\",\"frontmatter\":{\"title\":\"transition过渡&动画\",\"date\":\"2020-02-04 13:16:19\",\"permalink\":\"/pages/184a96b493a97078\",\"categories\":[\"《Vue》笔记\",\"过渡&动画\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"transition过渡&动画\",\"date\":\"2020-02-04 13:16:19\",\"excerpt\":\"<h1 id=\\\"transition过渡-动画\\\" tabindex=\\\"-1\\\">transition过渡&amp;动画 <a class=\\\"header-anchor\\\" href=\\\"#transition过渡-动画\\\" aria-label=\\\"Permalink to &quot;transition过渡&amp;动画&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/transitions.html\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">API</a></p>\\n<h2 id=\\\"使用\\\" tabindex=\\\"-1\\\">使用 <a class=\\\"header-anchor\\\" href=\\\"#使用\\\" aria-label=\\\"Permalink to &quot;使用&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>需要设置动画的元素或组件要在外边包裹一个<code>&lt;transition&gt;</code>标签，设置自定义的<code>name</code>，vue会根据元素的切换（进入/离开）过程添加相应的css类名，你可以<strong>自由地使用css类名来设置css过渡&amp;动画</strong>。</p>\\n\",\"capture\":\"API\\n 使用\\n需要设置动画的元素或组件要在外边包裹一个`&lt;transition\\n 过渡的类名\\n在进入/离开的过渡中，会有 6 个 class 切换。\\n各类名的生命周期\\n* 进入\\n  * `v-enter` 只存在于第一帧\\n  * `v-enter-active` 第一帧到最后一帧，结束后移除\\n  * `v-enter-to` 第二帧到最后一帧，结束后移除\\n* 离开\\n  * `v-leave` 只存在于第一帧\\n  * `v-leave-active` 第一帧到最后一帧，结束后移除\\n  * `v-leave-to` 第二帧到最后一帧，结束后移除\\n如果你使用一个没有`name`的`&lt;t\"},{\"url\":\"/《Vue》笔记/03.过渡&动画/112.使用animate库.html\",\"relativePath\":\"/《Vue》笔记/03.过渡&动画/112.使用animate库.html\",\"frontmatter\":{\"title\":\"使用animate库\",\"date\":\"2020-02-17 16:05:52\",\"permalink\":\"/pages/3b0a20e70805fcea\",\"categories\":[\"《Vue》笔记\",\"过渡&动画\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"使用animate库\",\"date\":\"2020-02-17 16:05:52\",\"excerpt\":\"<h1 id=\\\"vue中使用animate-css库\\\" tabindex=\\\"-1\\\">vue中使用Animate.css库 <a class=\\\"header-anchor\\\" href=\\\"#vue中使用animate-css库\\\" aria-label=\\\"Permalink to &quot;vue中使用Animate.css库&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"自定义过渡类名\\\" tabindex=\\\"-1\\\">自定义过渡类名 <a class=\\\"header-anchor\\\" href=\\\"#自定义过渡类名\\\" aria-label=\\\"Permalink to &quot;自定义过渡类名&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>我们可以通过以下 attribute 来自定义过渡类名：</p>\\n<ul>\\n<li><code>enter-class</code></li>\\n<li><code>enter-active-class</code></li>\\n<li><code>enter-to-class</code> (2.1.8+)</li>\\n<li><code>leave-class</code></li>\\n<li><code>leave-active-class</code></li>\\n<li><code>leave-to-class</code> (2.1.8+)</li>\\n</ul>\\n\",\"capture\":\"自定义过渡类名\\n我们可以通过以下 attribute 来自定义过渡类名：\\n- `enter-class`\\n- `enter-active-class`\\n- `enter-to-class` (2.1.8+)\\n- `leave-class`\\n- `leave-active-class`\\n- `leave-to-class` (2.1.8+)\\n他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 Animate.css结合使用十分有用。\\n 使用Animate.css库\\n```html\\n&lt;transition\\n            name=\\\"custom-\"},{\"url\":\"/《Vue》笔记/03.过渡&动画/120.transition-group列表过渡.html\",\"relativePath\":\"/《Vue》笔记/03.过渡&动画/120.transition-group列表过渡.html\",\"frontmatter\":{\"title\":\"transition-group列表过渡\",\"date\":\"2020-02-04 13:17:42\",\"permalink\":\"/pages/0aa92922ace6bb5e\",\"categories\":[\"《Vue》笔记\",\"过渡&动画\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"transition-group列表过渡\",\"date\":\"2020-02-04 13:17:42\",\"excerpt\":\"<h1 id=\\\"transition-group列表过渡\\\" tabindex=\\\"-1\\\">transition-group列表过渡 <a class=\\\"header-anchor\\\" href=\\\"#transition-group列表过渡\\\" aria-label=\\\"Permalink to &quot;transition-group列表过渡&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"列表的进入-离开过渡\\\" tabindex=\\\"-1\\\">列表的进入/离开过渡 <a class=\\\"header-anchor\\\" href=\\\"#列表的进入-离开过渡\\\" aria-label=\\\"Permalink to &quot;列表的进入/离开过渡&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<div class=\\\"language-html vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">html</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">&#x3C;</span><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">transition-group</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> tag</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"ul\\\"</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">> </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">&#x3C;!--tag转为ul--></span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">    &#x3C;</span><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">li</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> v-for</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"item in list\\\"</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> :key</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"item\\\"</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">>{{item}}&#x3C;/</span><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">li</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">> </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">&#x3C;!--子元素要有key--></span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">&#x3C;/</span><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">transition-group</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">></span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br></div></div><p><strong>注意</strong>：列表元素一定要有<code>key</code></p>\\n\",\"capture\":\"列表的进入/离开过渡\\n```html\\n&lt;transition-group tag=\\\"ul\\\"\\n    &lt;li v-for=\\\"item in list\\\" :key=\\\"item\\\"&gt;{{item}}&lt;/li&gt; &lt;!--子元素要有key--&gt;\\n&lt;/transition-group&gt;\\n```\\n注意：列表元素一定要有`key`\\n```css\\n.v-enter,.v-leave-to{\\n  opacity: 0;\\n  transform: translateX(30px);\\n}\\n.v-enter-active,.v-leave-active{\\n  tran\"},{\"url\":\"/《Vue》笔记/04.可复用性&组合/01.Mixin混入.html\",\"relativePath\":\"/《Vue》笔记/04.可复用性&组合/01.Mixin混入.html\",\"frontmatter\":{\"title\":\"Mixin混入\",\"date\":\"2020-02-19 15:22:41\",\"permalink\":\"/pages/bd36a3c1bc3e0821\",\"categories\":[\"《Vue》笔记\",\"可复用性&组合\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Mixin混入\",\"date\":\"2020-02-19 15:22:41\",\"excerpt\":\"<h1 id=\\\"mixin混入\\\" tabindex=\\\"-1\\\">Mixin混入 <a class=\\\"header-anchor\\\" href=\\\"#mixin混入\\\" aria-label=\\\"Permalink to &quot;Mixin混入&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"基础\\\" tabindex=\\\"-1\\\">基础 <a class=\\\"header-anchor\\\" href=\\\"#基础\\\" aria-label=\\\"Permalink to &quot;基础&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。</p>\\n\",\"capture\":\"基础\\n混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。\\n\\n&gt;\\n&gt; 可通过 `this.$options` 查看选项\\n例子：\\n```js\\n// 定义一个混入对象\\nvar myMixin = {\\n  created: function () {\\n    this.hello()\\n  },\\n  methods: {\\n    hello: function () {\\n      console.log('hello from mixin!')\\n  \"},{\"url\":\"/《Vue》笔记/05.工具/10.Vue CLi v3 创建项目使用记录.html\",\"relativePath\":\"/《Vue》笔记/05.工具/10.Vue CLi v3 创建项目使用记录.html\",\"frontmatter\":{\"title\":\"Vue CLi v3 创建项目使用记录\",\"date\":\"2020-02-20 17:24:29\",\"permalink\":\"/pages/d00311f8174119b2\",\"categories\":[\"《Vue》笔记\",\"工具\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Vue CLi v3 创建项目使用记录\",\"date\":\"2020-02-20 17:24:29\",\"capture\":\"官方文档\\n以下使用的CLi版本是 v3.11.0\\n vue create\\n1. 运行以下命令来创建一个新项目\\n```sh\\nvue create hello-world\\n```\\n2. 你会被提示选取一个 preset (预设)。你可以选默认的包含了基本的 Babel + ESLint 设置的 preset，也可以选“手动选择特性”来选取需要的特性。\\n```sh\\nVue CLI v3.11.0\\n? Please pick a preset: (Use arrow keys)\\n\\n  Manually select features (手动选择特性)\\n```\\n默认预设只包含Babel + ESLint\"},{\"url\":\"/《Vue》笔记/06.规模化/100.vuex操作相关.html\",\"relativePath\":\"/《Vue》笔记/06.规模化/100.vuex操作相关.html\",\"frontmatter\":{\"title\":\"vuex操作相关\",\"date\":\"2020-02-04 13:15:19\",\"permalink\":\"/pages/d9d62d6ab8ff99a6\",\"categories\":[\"《Vue》笔记\",\"规模化\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"vuex操作相关\",\"date\":\"2020-02-04 13:15:19\",\"capture\":\"```js\\nimport { mapActions, mapMutations, mapGetters } from 'vuex'\\ncomputed: {\\n    ...mapGetters([ // 获取数据，内部为数组\\n        'searchHistory' // 相当于在data插入searchHistory和获取到的数据\\n    ])\\n},\\nmethods: {\\n\\t某方法(){\\n\\t  this.saveSearchHistory(传入值)\\n\\t},\\n\\t...mapActions([ // 提交actions修改数据，内部为数组 因为actions文件已对方法进行了封装所有是数组类\"},{\"url\":\"/《Vue》笔记/06.规模化/140.路由懒加载.html\",\"relativePath\":\"/《Vue》笔记/06.规模化/140.路由懒加载.html\",\"frontmatter\":{\"title\":\"路由懒加载\",\"date\":\"2020-02-04 13:20:20\",\"permalink\":\"/pages/38ecac9a9b92f037\",\"categories\":[\"《Vue》笔记\",\"规模化\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"路由懒加载\",\"date\":\"2020-02-04 13:20:20\",\"capture\":\"```js\\n// 路由同步加载\\n// import Recommend from '@/components/recommend/recommend'\\n// import Singer from '@/components/singer/singer'\\n// import Rank from '@/components/rank/rank'\\n// import Search from '@/components/search/search'\\n// import SingerDetail from '@/components/singer-detail/singer-detail'\\n// imp\"},{\"url\":\"/《Vue》笔记/10.Vuex/01.Vuex.html\",\"relativePath\":\"/《Vue》笔记/10.Vuex/01.Vuex.html\",\"frontmatter\":{\"title\":\"Vuex\",\"date\":\"2020-08-08 10:38:33\",\"permalink\":\"/pages/b30620/\",\"categories\":[\"《Vue》笔记\",\"Vuex\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Vuex\",\"date\":\"2020-08-08 10:38:33\",\"capture\":\"Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。\\n Vuex使用过程演示\\n以`vue-cli3`新创建出来的项目为例，演示Vuex的使用过程。\\n创建项目:\\n```sh\\nvue create vuex-test\\ncd vuex-test\\nnpm run serve\\n```\\n安装`vuex`:\\n```bash\\nnpm i vuex -S\\n```\\n进入项目的`src/`下新建一个文件`store/index.js`，并写入：\\n```js\\n// store/index.js\\nimport Vue from 'vue'\\nimport Vuex from 'vuex'\\nVue.use(Vu\"},{\"url\":\"/《Vue》笔记/99.其他/79.Vue中编辑word文档以及预览word .html\",\"relativePath\":\"/《Vue》笔记/99.其他/79.Vue中编辑word文档以及预览word .html\",\"frontmatter\":{\"title\":\"Vue中编辑word文档以及预览word\",\"date\":\"2023-09-13 10:25:00\",\"permalink\":\"/pages/1ebccd/\",\"categories\":[\"《Vue》笔记\",\"其他\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Vue中编辑word文档以及预览word\",\"date\":\"2023-09-13 10:25:00\",\"capture\":\"首先通过XMLHttpRequest发送一个GET请求到指定的URL，获取Word文件的内容并将其转换为HTML格式。其中使用mammoth库的convertToHtml方法将二进制数组转换为HTML格式的文本。（mammoth我用了一个修改版本样式还原度要比官方好@shy1118/mammoth）编辑用到的是ckeditor5富文本编辑器,最后通过html-docx-js将html转换为docx在进行保存**\\n 安装主要依赖\\n```bash\\nnpm install --save @ckeditor/ckeditor5-build-decoupled-document @shy1118/mam\"},{\"url\":\"/《Vue》笔记/99.其他/80.Vue中的防抖函数封装和使用.html\",\"relativePath\":\"/《Vue》笔记/99.其他/80.Vue中的防抖函数封装和使用.html\",\"frontmatter\":{\"title\":\"Vue中的防抖函数封装和使用\",\"date\":\"2020-02-04 13:10:19\",\"permalink\":\"/pages/fb08e252dfd8fdfd\",\"categories\":[\"《Vue》笔记\",\"其他\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Vue中的防抖函数封装和使用\",\"date\":\"2020-02-04 13:10:19\",\"capture\":\"Vue中的防抖函数封装和使用\\n如搜索框中，每改变一个数值就请求一次搜索接口，当快速的改变数值时并不需要多次请求接口，这就需要一个防抖函数：\\n```js\\n// 防抖函数\\nexport function debounce(func, delay) { // func 函数 delay间隔时间\\n  let timer\\n  return function (...args) {\\n    if (timer) {\\n      clearTimeout(timer)\\n    }\\n    timer = setTimeout(() =\\n      func.apply(this, args)\\n    }, \"},{\"url\":\"/《Vue》笔记/99.其他/90.操作本地缓存.html\",\"relativePath\":\"/《Vue》笔记/99.其他/90.操作本地缓存.html\",\"frontmatter\":{\"title\":\"操作本地缓存\",\"date\":\"2020-02-04 13:14:19\",\"permalink\":\"/pages/30a94dbe96873b33\",\"categories\":[\"《Vue》笔记\",\"其他\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"操作本地缓存\",\"date\":\"2020-02-04 13:14:19\",\"capture\":\"&lt;https://github.com/ustbhuangyi/storage\\n操作 sessionStorage 和 localStorage 。\"},{\"url\":\"/《Vue》笔记/99.其他/91.vue2与vue3生命周期对照表.html\",\"relativePath\":\"/《Vue》笔记/99.其他/91.vue2与vue3生命周期对照表.html\",\"frontmatter\":{\"title\":\"vue2与vue3生命周期对照表\",\"date\":\"2023-09-08 14:57:40\",\"permalink\":\"/pages/e866b9/\",\"categories\":[\"《Vue》笔记\",\"其他\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"vue2与vue3生命周期对照表\",\"date\":\"2023-09-08 14:57:40\",\"capture\":\"\"},{\"url\":\"/《uniapp》笔记/使用uniapp对接蓝牙设备.html\",\"relativePath\":\"/《uniapp》笔记/使用uniapp对接蓝牙设备.html\",\"frontmatter\":{\"title\":\"使用uniapp对接蓝牙设备\",\"date\":\"2024-03-30 15:20:23\",\"permalink\":\"/pages/35c361/\",\"categories\":[\"《uniapp》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"使用uniapp对接蓝牙设备\",\"date\":\"2024-03-30 15:20:23\",\"capture\":\"低功耗蓝牙 API 平台差异说明\\r\\n\\r\\n| App | H5  | 微信小程序 | 支付宝小程序 | 百度小程序 | 字节跳动小程序 | 飞书小程序 | QQ 小程序 | 快手小程序 | 京东小程序 |\\r\\n| :-: | :-: | :--------: | :----------: | :--------: | :------------: | :--------: | :-------: | :--------: | :--------: |\\r\\n|  √  |  x  |     √      |      √       |     x      |       x        |  \"}],\"sortPostsByDateAndSticky\":[{\"url\":\"/04.更多/05.AI随笔/01.当珍妮机学会了写代码.html\",\"relativePath\":\"/04.更多/05.AI随笔/01.当珍妮机学会了写代码.html\",\"frontmatter\":{\"title\":\"当珍妮机学会了写代码\",\"date\":\"2026-02-26 20:00:00\",\"permalink\":\"/pages/ai-coding-revolution/\",\"categories\":[\"更多\",\"AI随笔\"],\"tags\":[\"AI\",\"思考\",\"编程\"],\"author\":{\"name\":\"刘志伟;AI\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟;AI\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"当珍妮机学会了写代码\",\"date\":\"2026-02-26 20:00:00\",\"capture\":\"当珍妮机学会了写代码\\n\\n 一、从一台纺纱机说起\\n1764 年的某个夜晚，英国兰开夏郡的织工詹姆斯·哈格里夫斯看着妻子的纺车被踢倒后仍在旋转，灵光一闪——如果把纱锭竖起来，一个轮子就能同时驱动八个纱锭。\\n珍妮纺纱机就这样诞生了。一个人能干八个人的活，效率提升 800%。\\n262 年后的 2026 年，我坐在屏幕前，让一个叫 Claude 的 AI 帮我重构整个博客系统。它用 Three.js 写了一个极光 Shader 背景，用 Vue 3 搭了全屏滚动首页，让它设计了五套可切换的艺术风格主题——赛博朋克、梵高、水墨、古典雕塑、现代。它还帮我写了一篇博客，就是现在你正在看的这篇。\\n如果哈格里夫斯\"},{\"url\":\"/《JavaScript教程》笔记/14.JS实现扫码登录.html\",\"relativePath\":\"/《JavaScript教程》笔记/14.JS实现扫码登录.html\",\"frontmatter\":{\"title\":\"JS实现扫码登录\",\"date\":\"2024-03-30 15:32:39\",\"permalink\":\"/pages/bdbdb8/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"JS实现扫码登录\",\"date\":\"2024-03-30 15:32:39\",\"capture\":\"JS实现扫码登录\\r\\n\\r\\n扫码登录是一种方便快捷的登录方式，用户可以通过扫描二维码来登录网站或应用程序。在本文中，我们将使用JavaScript实现一个简单的扫码登录功能。\\r\\n\\r\\n 步骤一：生成二维码\\r\\n\\r\\n首先，我们需要生成一个二维码，用于展示给用户扫描。我们可以使用第三方库 qrcode.js 来生成二维码。以下是使用qrcode.js生成二维码的示例代码：\\r\\n\\r\\n```html\\r\\n&lt;!-- 在HTML中引入qrcode.js库 --\\r\\n&lt;script src=\\\"https://cdn.bootcdn.net/ajax/libs/qrcodejs/1.0.0/qrcode.min\"},{\"url\":\"/《JavaScript教程》笔记/13.JS继承.html\",\"relativePath\":\"/《JavaScript教程》笔记/13.JS继承.html\",\"frontmatter\":{\"title\":\"JS继承\",\"date\":\"2024-03-30 15:32:05\",\"permalink\":\"/pages/b17c09/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"JS继承\",\"date\":\"2024-03-30 15:32:05\",\"capture\":\"在JavaScript中，继承是实现面向对象编程的重要方式之一。\\r\\n\\r\\n 原型继承\\r\\n\\r\\n原型继承是JavaScript中最常用的继承方式之一。在原型继承中，子类通过继承父类的原型对象来实现继承。\\r\\n\\r\\n```javascript\\r\\nfunction Parent() {\\r\\n  this.name = 'parent';\\r\\n}\\r\\n\\r\\nParent.prototype.sayHello = function() {\\r\\n  console.log('Hello from ' + this.name);\\r\\n}\\r\\n\\r\\nfunction Child() {\\r\\n  this.name = 'child';\"},{\"url\":\"/《JavaScript教程》笔记/12.console实用调试方法.html\",\"relativePath\":\"/《JavaScript教程》笔记/12.console实用调试方法.html\",\"frontmatter\":{\"title\":\"console实用调试方法\",\"date\":\"2024-03-30 15:31:48\",\"permalink\":\"/pages/602ffc/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"console实用调试方法\",\"date\":\"2024-03-30 15:31:48\",\"capture\":\"在JavaScript中，console是一个非常有用的工具，可以帮助我们在开发和调试过程中更好地了解代码的执行情况。本文将介绍console中一些常用的方法，并提供示例代码。\\r\\n console.time() & console.timeEnd()\\r\\nconsole.time()方法用于开始计时器，console.timeEnd()方法用于结束计时器并输出所花费的时间。这对于测试代码执行时间非常有用。\\r\\n```javascript\\r\\nconsole.time('myTimer');\\r\\nfor (let i = 0; i &lt; 1000000; i++) {\\r\\n  // do someth\"},{\"url\":\"/《Git》学习笔记/Git常用命令速查表.html\",\"relativePath\":\"/《Git》学习笔记/Git常用命令速查表.html\",\"frontmatter\":{\"title\":\"Git常用命令速查表\",\"date\":\"2024-03-30 15:26:32\",\"permalink\":\"/pages/3aa4fd/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git常用命令速查表\",\"date\":\"2024-03-30 15:26:32\",\"capture\":\"\"},{\"url\":\"/《JavaScript教程》笔记/11.`import`、`require`、`export`、`module.exports` 的区别和使用详解.html\",\"relativePath\":\"/《JavaScript教程》笔记/11.`import`、`require`、`export`、`module.exports` 的区别和使用详解.html\",\"frontmatter\":{\"title\":\"exports` 的区别和使用详解\",\"date\":\"2024-03-30 15:23:12\",\"permalink\":\"/pages/ff5679/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"exports` 的区别和使用详解\",\"date\":\"2024-03-30 15:23:12\",\"capture\":\"在 Node.js 和现代的 JavaScript 中，有多种方式可以导入和导出模块。其中最常见的是使用 `import` 和 `export`，但在 Node.js 中，也可以使用 `require` 和 `module.exports`。本篇文章将介绍这些不同的方式，以及它们之间的区别。\\r\\n\\r\\n `import` 和 `export`\\r\\n\\r\\n`import` 和 `export` 是 ES6 中引入的模块系统。它们允许我们将代码拆分成多个文件，并在不同的文件中共享代码。以下是一个简单的例子：\\r\\n\\r\\n```javascript\\r\\n// math.js\\r\\nexport const add = \"},{\"url\":\"/《JavaScript教程》笔记/10.JS中的？.和？？区别.html\",\"relativePath\":\"/《JavaScript教程》笔记/10.JS中的？.和？？区别.html\",\"frontmatter\":{\"title\":\"和？？区别\",\"date\":\"2024-03-30 15:22:03\",\"permalink\":\"/pages/176ae0/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"和？？区别\",\"date\":\"2024-03-30 15:22:03\",\"capture\":\"`??` 运算符\\r\\n\\r\\n`??` 运算符是 ES2020 中新增的空值合并运算符。它用于判断一个值是否为 `null` 或 `undefined`，如果是，则使用默认值。其语法如下：\\r\\n\\r\\n```javascript\\r\\ndefaultValue ?? value;\\r\\n```\\r\\n\\r\\n如果 `value` 不为 `null` 或 `undefined`，则 `??` 运算符返回 `value`；否则返回 `defaultValue`。\\r\\n\\r\\n```javascript\\r\\nconst a = null;\\r\\nconst b = 5;\\r\\n\\r\\nconsole.log(a ?? 10); // 10\\r\\nco\"},{\"url\":\"/《JavaScript教程》笔记/09.js 使用postMessage iframe跨域通信.html\",\"relativePath\":\"/《JavaScript教程》笔记/09.js 使用postMessage iframe跨域通信.html\",\"frontmatter\":{\"title\":\"js 使用postMessage iframe跨域通信\",\"date\":\"2024-03-30 15:21:11\",\"permalink\":\"/pages/d67bac/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"js 使用postMessage iframe跨域通信\",\"date\":\"2024-03-30 15:21:11\",\"capture\":\"在 Web 应用程序中，由于同源策略的限制，如果我们需要在一个页面中嵌入来自不同域的资源（例如图片、脚本或 iframe），那么就会出现跨域问题。在这种情况下，我们需要使用一些技术来实现跨域通信。\\r\\n\\r\\n其中一种解决方案是使用 HTML5 中引入的 postMessage API。postMessage 允许我们在不同窗口或 iframe 之间发送消息，这使得我们可以实现跨域通信，而不违反同源策略。\\r\\n\\r\\n postMessage 简介\\r\\n\\r\\npostMessage 是 HTML5 中引入的一种跨窗口通信机制。它允许我们在不同窗口之间发送消息，并且这些窗口可以来自不同的域。postMessag\"},{\"url\":\"/《uniapp》笔记/使用uniapp对接蓝牙设备.html\",\"relativePath\":\"/《uniapp》笔记/使用uniapp对接蓝牙设备.html\",\"frontmatter\":{\"title\":\"使用uniapp对接蓝牙设备\",\"date\":\"2024-03-30 15:20:23\",\"permalink\":\"/pages/35c361/\",\"categories\":[\"《uniapp》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"使用uniapp对接蓝牙设备\",\"date\":\"2024-03-30 15:20:23\",\"capture\":\"低功耗蓝牙 API 平台差异说明\\r\\n\\r\\n| App | H5  | 微信小程序 | 支付宝小程序 | 百度小程序 | 字节跳动小程序 | 飞书小程序 | QQ 小程序 | 快手小程序 | 京东小程序 |\\r\\n| :-: | :-: | :--------: | :----------: | :--------: | :------------: | :--------: | :-------: | :--------: | :--------: |\\r\\n|  √  |  x  |     √      |      √       |     x      |       x        |  \"},{\"url\":\"/《Vue》笔记/99.其他/79.Vue中编辑word文档以及预览word .html\",\"relativePath\":\"/《Vue》笔记/99.其他/79.Vue中编辑word文档以及预览word .html\",\"frontmatter\":{\"title\":\"Vue中编辑word文档以及预览word\",\"date\":\"2023-09-13 10:25:00\",\"permalink\":\"/pages/1ebccd/\",\"categories\":[\"《Vue》笔记\",\"其他\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Vue中编辑word文档以及预览word\",\"date\":\"2023-09-13 10:25:00\",\"capture\":\"首先通过XMLHttpRequest发送一个GET请求到指定的URL，获取Word文件的内容并将其转换为HTML格式。其中使用mammoth库的convertToHtml方法将二进制数组转换为HTML格式的文本。（mammoth我用了一个修改版本样式还原度要比官方好@shy1118/mammoth）编辑用到的是ckeditor5富文本编辑器,最后通过html-docx-js将html转换为docx在进行保存**\\n 安装主要依赖\\n```bash\\nnpm install --save @ckeditor/ckeditor5-build-decoupled-document @shy1118/mam\"},{\"url\":\"/《Electron》笔记/02.electron下使用puppeteer模拟用户操作,数据获取.html\",\"relativePath\":\"/《Electron》笔记/02.electron下使用puppeteer模拟用户操作,数据获取.html\",\"frontmatter\":{\"title\":\"electron下使用puppeteer模拟用户操作,数据获取\",\"date\":\"2023-09-09 15:15:18\",\"permalink\":\"/pages/56ebf1/\",\"categories\":[\"《Electron》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"electron下使用puppeteer模拟用户操作,数据获取\",\"date\":\"2023-09-09 15:15:18\",\"capture\":\"Puppeteer是一个由Google开发的Node.js库，它提供了一组用于控制和自动化Chrome或Chromium浏览器的API。它可以用于执行各种与浏览器相关的任务，如网页截图、生成PDF、模拟用户交互、爬取网页数据等。Puppeteer通过WebSocket连接与浏览器建立通信，并通过DevTools协议发送命令和接收浏览器的响应。\\n什么是 Chrome DevTool Protocol\\n- CDP 基于 WebSocket，利用 WebSocket 实现与浏览器内核的快速数据通道\\n- CDP 分为多个域（DOM，Debugger，Network，Profiler，Console..\"},{\"url\":\"/《Electron》笔记/01.electron记录.html\",\"relativePath\":\"/《Electron》笔记/01.electron记录.html\",\"frontmatter\":{\"title\":\"electron记录\",\"date\":\"2023-09-09 14:23:20\",\"permalink\":\"/pages/8e9a16/\",\"categories\":[\"《Electron》笔记\"],\"tags\":[\"electron\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"electron记录\",\"date\":\"2023-09-09 14:23:20\",\"capture\":\"事件周期\\n electron常用事件统计\\n主进程常用事件可以分为以下几类：\\n1. 应用程序生命周期事件：\\n    - `ready`: 当 Electron 应用程序初始化完成且准备好显示窗口时触发。\\n    - `window-all-closed`: 当所有窗口都关闭后触发，在 macOS 上通常不会退出应用程序。\\n    - `activate`: 在 macOS 上，当用户点击应用程序的 Dock 图标并且没有其他窗口打开时触发，用于重新创建新窗口。\\n2. 窗口相关事件：\\n    - `closed`: 窗口关闭时触发。\\n    - `dom-ready`: 窗口加载完毕并且 DOM \"},{\"url\":\"/《JavaScript教程》笔记/08.事件循环(evenloop).html\",\"relativePath\":\"/《JavaScript教程》笔记/08.事件循环(evenloop).html\",\"frontmatter\":{\"title\":\"事件循环(evenloop)\",\"date\":\"2023-09-08 16:20:58\",\"permalink\":\"/pages/eaf565/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"事件循环(evenloop)\",\"date\":\"2023-09-08 16:20:58\",\"capture\":\"JavaScript 是一门单线程的语言，它的异步和多线程的实现是通过 Event Loop 事件循环机制来实现的\\nEvent Loop 的机制\\n大体三个部分组成\\n1、调用栈 Stack\\n2、消息队列 Message Queue\\n3、微任务队列 Microtask Queue\\n Event Loop 开始的时候会从全局栈开始逐行执行，遇到函数调用，会把函数压入到调用栈中，当函数返回后，会从调用栈中弹出\\n```javascript\\nfunction func1(){\\n    console.log(1);\\n }\\n function func2(){\\n    console.log(2);\\n   \"},{\"url\":\"/《ES6 教程》笔记/35.了解ES6中的Map和Set.html\",\"relativePath\":\"/《ES6 教程》笔记/35.了解ES6中的Map和Set.html\",\"frontmatter\":{\"title\":\"了解ES6中的Map和Set\",\"date\":\"2023-09-08 16:10:10\",\"permalink\":\"/pages/bfde72/\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"了解ES6中的Map和Set\",\"date\":\"2023-09-08 16:10:10\",\"capture\":\"Map对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。构造函数Map可以接受一个数组作为参数。\\nMap对象的方法\\nset(key, val): 向Map中添加新元素\\nget(key): 通过键值查找特定的数值并返回\\nhas(key): 判断Map对象中是否有Key所对应的值，有返回true,否则返回false\\ndelete(key): 通过键值从Map中移除对应的数据\\nclear(): 将这个Map中的所有元素删除\\n```jsx\\nconst m1 = new Map([['a', 111], ['b', 222]])\\nconsole.log(m1) // {\\\"a\\\" =\\nm1\"},{\"url\":\"/《Vue》笔记/99.其他/91.vue2与vue3生命周期对照表.html\",\"relativePath\":\"/《Vue》笔记/99.其他/91.vue2与vue3生命周期对照表.html\",\"frontmatter\":{\"title\":\"vue2与vue3生命周期对照表\",\"date\":\"2023-09-08 14:57:40\",\"permalink\":\"/pages/e866b9/\",\"categories\":[\"《Vue》笔记\",\"其他\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"vue2与vue3生命周期对照表\",\"date\":\"2023-09-08 14:57:40\",\"capture\":\"\"},{\"url\":\"/01.前端/25.JavaScript文章/15.js实现深度优先遍历和广度优先遍历.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/15.js实现深度优先遍历和广度优先遍历.html\",\"frontmatter\":{\"title\":\"js实现深度优先遍历和广度优先遍历\",\"date\":\"2023-09-08 14:16:56\",\"permalink\":\"/pages/690414/\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"js实现深度优先遍历和广度优先遍历\",\"date\":\"2023-09-08 14:16:56\",\"capture\":\"什么是深度优先和广度优先\\n深度优先遍历用的是栈，而广度优先遍历要用队列来实现,深度优先就是自上而下的遍历搜索 广度优先则是逐层遍历, 如下图所示(图左深度优先遍历,图右广度)\\n 深度优先遍历\\n 广度优先遍历\\n 两者的区别\\n对于算法来说 无非就是时间换空间 空间换时间\\n1. 深度优先不需要记住所有的节点, 所以占用空间小, 而广度优先需要先记录所有的节点占用空间大\\n2. 深度优先有回溯的操作(没有路走了需要回头)所以相对而言时间会长一点\\n深度优先采用的是堆栈的形式, 即先进后出\\n广度优先则采用的是队列的形式, 即先进先出\\n```jsx\\nconst data = [\\n  {\\n      name:\"},{\"url\":\"/01.前端/25.JavaScript文章/14.js获取当前URL,域名,端口号.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/14.js获取当前URL,域名,端口号.html\",\"frontmatter\":{\"title\":\"js获取当前URL,域名,端口号\",\"date\":\"2023-09-08 13:57:22\",\"permalink\":\"/pages/c81259/\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"js获取当前URL,域名,端口号\",\"date\":\"2023-09-08 13:57:22\",\"capture\":\"| href | 完整的 URL | https://www.baidu.com:200/s?wd=1 |\\n| --- | --- | --- |\\n| protocol | 协议 | https: |\\n| hostname | 主机名 | www.baidu.com |\\n| port | 端口号 | 200 |\\n| host | 主机名+端口号 | www.baidu.com:200 |\\n```javascript\\nlet protocol = window.location.protocol,host = window.location.host;\\nlet url = `${protocol\"},{\"url\":\"/01.前端/25.JavaScript文章/13.javascript常用类型数值比较图.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/13.javascript常用类型数值比较图.html\",\"frontmatter\":{\"title\":\"javascript常用类型数值比较图\",\"date\":\"2023-09-08 13:34:43\",\"permalink\":\"/pages/360851/\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"javascript常用类型数值比较图\",\"date\":\"2023-09-08 13:34:43\",\"capture\":\"\"},{\"url\":\"/02.页面/20.CSS/16.css calc()使用.html\",\"relativePath\":\"/02.页面/20.CSS/16.css calc()使用.html\",\"frontmatter\":{\"title\":\"css calc()使用\",\"date\":\"2023-09-08 11:40:43\",\"permalink\":\"/pages/2ecc26/\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"css calc()使用\",\"date\":\"2023-09-08 11:40:43\",\"capture\":\"1.什么是 CSS calc() 函数？\\ncalc() 函数允许在指定 CSS 属性值时执行计算。它对于计算 length、 percentage、 time、 numbers、integers、frequencies 和 angles 等特别有用。 CSS calc() 函数的一个强大功能是能够组合不同的单位。这个函数可以执行预处理器不能执行的数学计算。\\nCSS 中的预处理器只能组合具有固定关系的单位，如角度单位、时间单位、频率单位、分辨率单位和特定长度单位。\\ncalc( Expression)\\ncalc() 函数接受一个表达式作为参数。然后将表达式的结果用作值。它可以采用任何形式并使用以下\"},{\"url\":\"/04.更多/99.友情链接.html\",\"relativePath\":\"/04.更多/99.友情链接.html\",\"frontmatter\":{\"title\":\"友情链接\",\"date\":\"2023-08-29 15:43:33\",\"permalink\":\"/pages/1bf946/\",\"categories\":[\"更多\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"友情链接\",\"date\":\"2023-08-29 15:43:33\",\"capture\":\"\"},{\"url\":\"/\",\"relativePath\":\"/\",\"frontmatter\":{\"layout\":\"page\",\"title\":\"首页\"},\"title\":\"首页\",\"date\":\"2023-08-29 07:43:33\",\"capture\":\"&lt;HomePage /\"},{\"url\":\"/03.技术/01.技术文档/20.Git修改分支名.html\",\"relativePath\":\"/03.技术/01.技术文档/20.Git修改分支名.html\",\"frontmatter\":{\"title\":\"Git修改分支名\",\"date\":\"2022-08-11 10:51:18\",\"permalink\":\"/pages/922650/\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git修改分支名\",\"date\":\"2022-08-11 10:51:18\",\"capture\":\"同时修改本地分支名和对应的远程分支名\\n修改前要确保本地分支的代码是最新的，并且修改后不会影响到同事的代码。\\n1. 修改本地分支名\\n```sh\\ngit branch -m oldBranchName newBranchName\\n```\\n2. 删除远程分支\\n```sh\\ngit push origin :oldBranchName\\n 或者 git push origin --delete oldBranchName\\n```\\n3. 改名后的本地分支推送到远程\\n```sh\\ngit push --set-upstream origin newBranchName\\n```\"},{\"url\":\"/02.页面/20.CSS/15.CSS给table的tbody添加滚动条.html\",\"relativePath\":\"/02.页面/20.CSS/15.CSS给table的tbody添加滚动条.html\",\"frontmatter\":{\"title\":\"CSS给table的tbody添加滚动条\",\"date\":\"2022-06-29 09:34:23\",\"permalink\":\"/pages/55f894/\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"CSS给table的tbody添加滚动条\",\"date\":\"2022-06-29 09:34:23\",\"capture\":\"```css\\ntable tbody {\\n  height: 200px;\\n  overflow-y: auto;\\n  display: block;\\n}\\ntable thead,\\ntbody tr {\\n  display: table;\\n  width: 100%;\\n}\\n```\"},{\"url\":\"/01.前端/25.JavaScript文章/01.33个非常实用的JavaScript一行代码.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/01.33个非常实用的JavaScript一行代码.html\",\"frontmatter\":{\"title\":\"33个非常实用的JavaScript一行代码\",\"date\":\"2021-11-02 09:51:37\",\"permalink\":\"/pages/a61298/\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[\"JavaScript\"],\"author\":\"CUGGZ\"},\"author\":\"CUGGZ\",\"title\":\"33个非常实用的JavaScript一行代码\",\"date\":\"2021-11-02 09:51:37\",\"capture\":\"一、日期处理\\n 1. 检察日期是否有效\\n该方法用于检测给出的日期是否有效：\\n```javascript\\nconst isDateValid = (...val) =\\nisDateValid(\\\"December 17, 1995 03:24:00\\\");  // true\\n复制代码\\n```\\n 2. 计算两个日期之间的间隔\\n该方法用于计算两个日期之间的间隔时间：\\n```javascript\\nconst dayDif = (date1, date2) =&gt; Math.ceil(Math.abs(date1.getTime() - date2.getTime()) / 86400000)\\ndayD\"},{\"url\":\"/01.前端/40.学习笔记/50.JS设计模式总结笔记.html\",\"relativePath\":\"/01.前端/40.学习笔记/50.JS设计模式总结笔记.html\",\"frontmatter\":{\"title\":\"JS设计模式总结笔记\",\"date\":\"2021-02-27 20:01:18\",\"permalink\":\"/pages/4643cd/\",\"categories\":[\"前端\",\"学习笔记\"],\"tags\":[\"设计模式\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"JS设计模式总结笔记\",\"date\":\"2021-02-27 20:01:18\",\"capture\":\"开篇：前端工程师的成长论\\n能够决定一个前端工程师的本质的，不是那些瞬息万变的技术点，而是那些不变的东西。\\n所谓“不变的东西”，就是驾驭技术的能力。\\n具体来说，它分为以下三个层次：\\n- 能用健壮的代码去解决具体的问题；\\n- 能用抽象的思维去应对复杂的系统；\\n- 能用工程化的思想去规划更大规模的业务。\\n\\n 设计模式之“道”\\n- 设计模式是“拿来主义”。如使用数学公式，不会从头推导一个公式。\\n  核心思想\\n- 设计模式的核心思想——封装变化\\n- 保证可维护性、可扩展性。\\n- 将变与不变分离，确保变化的部分灵活，不变的部分稳定。——这就是所谓的“健壮”的代码。\\n 设计模式之“术”\\n即最经典的23种设计\"},{\"url\":\"/01.前端/25.JavaScript文章/1110.三级目录/00.四级文件.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/1110.三级目录/00.四级文件.html\",\"frontmatter\":{\"title\":\"四级文件(测试)\",\"date\":\"2020-12-11 11:15:53\",\"permalink\":\"/pages/8481d1/\",\"categories\":[\"前端\",\"JavaScript文章\",\"三级目录\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"四级文件(测试)\",\"date\":\"2020-12-11 11:15:53\",\"capture\":\"测试文件\\nTest Test\\n&lt;code-group\\n  &lt;code-block title=\\\"YARN\\\" active&gt;\\n  ```bash\\n  yarn create vuepress-site [optionalDirectoryName]\\n   OR npx create-vuepress-site [optionalDirectoryName]\\n  ```\\n  &lt;/code-block&gt;\\n  &lt;code-block title=\\\"NPM\\\"&gt;\\n  ```bash\\n  npx create-vuepress-site [optionalDirec\"},{\"url\":\"/《Git》学习笔记/10.手册/00.常用Git命令清单.html\",\"relativePath\":\"/《Git》学习笔记/10.手册/00.常用Git命令清单.html\",\"frontmatter\":{\"title\":\"常用Git命令清单\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/8292d8/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"常用Git命令清单\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。\\n下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。\\n\\n&gt; - Index / Stage：暂存区\\n&gt; - Repository：仓库区（或本地仓库）\\n&gt; - Remote：远程仓库\\n 一、新建代码库\\n```bash\\n 在当前目录新建一个Git代码库\\n$ git init\\n 新建一个目录，将其初始化为Git代码库\\n$ git init [project-name]\\n 下载一个项目和它的整个代码历史\\n$ git clone [url]\\n```\\n 二、配置\\nGit的设置文件为\"},{\"url\":\"/《Git》学习笔记/10.手册/01.Git变基合并.html\",\"relativePath\":\"/《Git》学习笔记/10.手册/01.Git变基合并.html\",\"frontmatter\":{\"title\":\"Git变基合并\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/c10281/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git变基合并\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"说明\\n以下 `v2` 是某个需求的开发分支， `dev`是总的开发分支，`v2` 是基于`dev`分支签出的。\\n当完成`v2`的开发后，需要把代码合并到`dev`，我们可以使用`rebase`进行合并：\\n```sh\\n 首先将 v2 push到远程仓库\\ngit add .\\ngit commit -m 'xxx'\\ngit push origin v2\\n 切换到 dev 拉取最新代码\\ngit checkout dev\\ngit pull origin dev\\n 切换到 v2\\ngit checkout v2\\ngit rebase dev  将 v2 的所有[commit] 变基到(应用到) dev\\n 切\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/10.Git基础与命令.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/10.Git基础与命令.html\",\"frontmatter\":{\"title\":\"Git基础与命令\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/635088/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git基础与命令\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"官方文档（中文）：https://git-scm.com/book/zh/v2\\n\\n Git基础\\n 全局配置\\n```bash\\ngit config --global user.name 'your name'\\ngit config --global user.email 'xxx@xx.com'\\n```\\n自报家门\\n 检查配置信息\\n```sh\\ngit config --list\\n```\\n 获取帮助\\n```sh\\n 获取全局帮助手册\\ngit help\\n 获取特定命令的详细版帮助手册 (两个命令是等价的)\\ngit help &lt;某个命令&gt;\\ngit &lt;某个命令&gt; --help  两个\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/100.Git工具-重写历史.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/100.Git工具-重写历史.html\",\"frontmatter\":{\"title\":\"Git工具-重写历史\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/1832fe/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git工具-重写历史\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"许多时候，在使用 Git 时，你可能想要修订提交历史。 Git 很棒的一点是它允许你在最后时刻做决定。 你可以在将暂存区内容提交前决定哪些文件进入提交，可以通过 `git stash` 来决定不与某些内容工作， 也可以重写已经发生的提交就像它们以另一种方式发生的一样。 这可能涉及改变提交的顺序，改变提交中的信息或修改文件，将提交压缩或是拆分， 或完全地移除提交——在将你的工作成果与他人共享之前。\\n在本节中，你可以学到如何完成这些工作，这样在与他人分享你的工作成果时你的提交历史将如你所愿地展示出来。\\n| Note | 在满意之前不要推送你的工作Git 的基本原则之一是，由于克隆中有很多工作是本地\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/110.Git工具-重置揭密.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/110.Git工具-重置揭密.html\",\"frontmatter\":{\"title\":\"Git工具-重置揭密\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/d9e9c6/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git工具-重置揭密\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"在继续了解更专业的工具前，我们先探讨一下 Git 的 `reset` 和 `checkout` 命令。 在初遇的 Git 命令中，这两个是最让人困惑的。 它们能做很多事情，所以看起来我们很难真正地理解并恰当地运用它们。 针对这一点，我们先来做一个简单的比喻。\\n 三棵树\\n理解 `reset` 和 `checkout` 的最简方法，就是以 Git 的思维框架（将其作为内容管理器）来管理三棵不同的树。 “树” 在我们这里的实际意思是 “文件的集合”，而不是指特定的数据结构。 （在某些情况下索引看起来并不像一棵树，不过我们现在的目的是用简单的方式思考它。）\\nGit 作为一个系统，是以它的一般操作来管理\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/20.Git分支-分支原理.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/20.Git分支-分支原理.html\",\"frontmatter\":{\"title\":\"Git分支-分支原理\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/4bef1a/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支-分支原理\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。\\n 首次提交\\n在进行提交操作时，Git 会保存一个提交对象（commit object）。\\n假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 暂存操作会为每一个文件计算校验和（使用 SHA-1 哈希算法），然后会把当前版本的文件快照保存到 Git 仓库中 （Git 使用 *blob* 对象来保存它们），最终将校验和加入到暂存区域等待提交：\\n```sh\\n$ git\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/30.Git分支的新建与合并-分支操作.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/30.Git分支的新建与合并-分支操作.html\",\"frontmatter\":{\"title\":\"Git分支的新建与合并-分支操作\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/ea5a8c/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支的新建与合并-分支操作\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"文档：Git 分支 - 分支的新建与合并\\n 创建分支并切换\\n此时有一个需求需要在新的分支`iss53`上工作：\\n```sh\\n$ git checkout -b iss53   b表示branch\\n```\\n它是下面两条命令的简写：\\n```sh\\n$ git branch iss53\\n$ git checkout iss53\\n```\\n 切换分支\\n突然有一个紧急问题要解决，需要在原来的`master`分支进行修复：\\n```sh\\n$ git checkout master\\n```\\n在切换到`master`之前，需要`iss53`分支保持好一个干净的状态（修改都已提交）。\\n注意：切换分支Git 会重置你的\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/40.Git分支管理-查看分支.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/40.Git分支管理-查看分支.html\",\"frontmatter\":{\"title\":\"Git分支管理-查看分支\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/a399b3/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支管理-查看分支\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"查看分支\\n```sh\\n$ git branch\\n  iss53\\n* master   带星号*表示当前所在分支\\n  testing\\n```\\n`git branch` 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表。\\n 查看每个分支的最后提交\\n```sh\\n$ git branch -v\\n  iss53   93b412c fix javascript issue\\n* master  7a98805 Merge branch 'iss53'\\n  testing 782fd34 test\\n```\\n 查看已(未)合并的分支\\n`--merged` 与 `--no-m\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/50.Git分支开发工作流.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/50.Git分支开发工作流.html\",\"frontmatter\":{\"title\":\"Git分支开发工作流\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/49ee30/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支开发工作流\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"文档：Git分支开发工作流\\n 长期分支\\n因为 Git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。 也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些主题分支合并入其他分支中。\\n许多使用 Git 的开发者都喜欢使用这种方式来工作，比如只在 `master` 分支上保留完全稳定的代码，开发过程在`dev`分支，开发完成后并入`test`分支进行测试，通过测试的稳定代码才并入`master`分支中。\\n`dev`和`test`分支不需要保持绝对稳定，但在`test`通过测试达到稳定状态，就可以被合并入`mast\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/60.Git分支-远程分支.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/60.Git分支-远程分支.html\",\"frontmatter\":{\"title\":\"Git分支-远程分支\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/574d62/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支-远程分支\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"远程引用是对远程仓库的引用（指针），包括分支、标签等等。\\n\\n 查看远程引用列表与信息\\n```sh\\ngit ls-remote &lt;remote&gt;  远程引用的完整列表\\ngit remote show &lt;remote&gt;  远程分支的更多信息\\n```\\n上面两行命令比较少用，更常见的做法是利用远程跟踪分支。\\n 远程跟踪分支\\n远程跟踪分支是远程分支状态的引用。它们是你无法移动的本地引用。一旦你进行了网络通信， Git 就会为你移动它们以精确反映远程仓库的状态。请将它们看做书签， 这样可以提醒你该分支在远程仓库中的位置就是你最后一次连接到它们的位置。\\n它们以 `&lt;remote\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/70.Git分支-变基.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/70.Git分支-变基.html\",\"frontmatter\":{\"title\":\"Git分支-变基\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/3a3247/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支-变基\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"在 Git 中整合来自不同分支的修改主要有两种方法：`merge` 以及 `rebase`。 在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。\\n 变基的基本操作\\n请回顾之前在 分支的合并 中的一个例子，你会看到开发任务分叉到两个不同分支，又各自提交了更新。\\n&lt;p align=\\\"center\\\"\\n之前介绍过，整合分支最容易的方法是 `merge` 命令。 它会把两个分支的最新快照（`C3` 和 `C4`）以及二者最近的共同祖先（`C2`）进行三方合并，合并的结果是生成一个新的快照（并提交）。\\n &lt;p align=\\\"cen\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/80.Git工具-查看修订版本.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/80.Git工具-查看修订版本.html\",\"frontmatter\":{\"title\":\"Git工具-查看修订版本\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/c984d1/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git工具-查看修订版本\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"Git 能够以多种方式来指定单个提交、一组提交、或者一定范围内的提交。 了解它们并不是必需的，但是了解一下总没坏处。\\n修订版本指的是：提交\\n 单个修订版本\\n你可以通过任意一个提交的 40 个字符的完整 SHA-1 散列值来指定它， 不过还有很多更人性化的方式来做同样的事情。本节将会介绍获取单个提交的多种方法。\\n 简短的 SHA-1\\nGit 十分智能，你只需要提供 SHA-1 的前几个字符就可以获得对应的那次提交， 当然你提供的 SHA-1 字符数量不得少于 4 个，并且没有歧义——也就是说， 当前对象数据库中没有其它对象以这段 SHA-1 开头。\\n例如，要查看你知道其中添加了某个功能的提交，首\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/90.Git工具-交互式暂存.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/90.Git工具-交互式暂存.html\",\"frontmatter\":{\"title\":\"Git工具-交互式暂存\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/76d859/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git工具-交互式暂存\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"本节中的几个交互式 Git 命令可以帮助你将文件的特定部分组合成提交。 当你在修改了大量文件后，希望这些改动能拆分为若干提交而不是混杂在一起成为一个提交时，这几个工具会非常有用。 通过这种方式，可以确保提交是逻辑上独立的变更集，同时也会使其他开发者在与你工作时很容易地审核。 如果运行 `git add` 时使用 `-i` 或者 `--interactive` 选项，Git 将会进入一个交互式终端模式，显示类似下面的东西：\\n```sh\\n$ git add -i\\n           staged     unstaged path\\n  1:    unchanged        +0/-1 T\"},{\"url\":\"/01.前端/40.学习笔记/35.TypeScript笔记.html\",\"relativePath\":\"/01.前端/40.学习笔记/35.TypeScript笔记.html\",\"frontmatter\":{\"title\":\"TypeScript笔记\",\"date\":\"2020-10-08 13:02:48\",\"permalink\":\"/pages/51afd6/\",\"categories\":[\"前端\",\"学习笔记\"],\"tags\":[\"TypeScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"TypeScript笔记\",\"date\":\"2020-10-08 13:02:48\",\"capture\":\"TypeScript 的类型校验是给程序员看的，在编译后不会存在TS代码。\\n 类型注解\\n```typescript\\nfunction fn(person: string):void{ // 参数类型是字符串，没有返回值\\n    ///...\\n}\\nfn('str') // 如传递参数非字符串，vscode编辑器中或在编译时将给出错误提示\\nconst test:number = 1\\n```\\n 有哪些基础类型注解？\\n```typescript\\n// 基础类型\\n:string\\n:number\\n:boolean\\n:null  // 只能是null值\\n:undefined // 只能是undefined值\"},{\"url\":\"/02.页面/20.CSS/00.CSS教程和技巧收藏.html\",\"relativePath\":\"/02.页面/20.CSS/00.CSS教程和技巧收藏.html\",\"frontmatter\":{\"title\":\"CSS教程和技巧收藏\",\"date\":\"2020-08-11 17:13:52\",\"permalink\":\"/pages/c8f128/\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"CSS教程和技巧收藏\",\"date\":\"2020-08-11 17:13:52\",\"capture\":\"Flex 布局教程：语法篇\\n&lt;http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\\n CSS Grid 网格布局教程\\n&lt;http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html&gt;\\n 只要一行代码，实现五种 CSS 经典布局\\n&lt;http://www.ruanyifeng.com/blog/2020/08/five-css-layouts-in-one-line.html&gt;\\n* 空间居中布局\\n  &gt; 不管容器的大小，项目总是占据中心\"},{\"url\":\"/《Vue》笔记/10.Vuex/01.Vuex.html\",\"relativePath\":\"/《Vue》笔记/10.Vuex/01.Vuex.html\",\"frontmatter\":{\"title\":\"Vuex\",\"date\":\"2020-08-08 10:38:33\",\"permalink\":\"/pages/b30620/\",\"categories\":[\"《Vue》笔记\",\"Vuex\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Vuex\",\"date\":\"2020-08-08 10:38:33\",\"capture\":\"Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。\\n Vuex使用过程演示\\n以`vue-cli3`新创建出来的项目为例，演示Vuex的使用过程。\\n创建项目:\\n```sh\\nvue create vuex-test\\ncd vuex-test\\nnpm run serve\\n```\\n安装`vuex`:\\n```bash\\nnpm i vuex -S\\n```\\n进入项目的`src/`下新建一个文件`store/index.js`，并写入：\\n```js\\n// store/index.js\\nimport Vue from 'vue'\\nimport Vuex from 'vuex'\\nVue.use(Vu\"},{\"url\":\"/04.更多/01.学习/00.费曼学习法.html\",\"relativePath\":\"/04.更多/01.学习/00.费曼学习法.html\",\"frontmatter\":{\"title\":\"费曼学习法\",\"date\":\"2020-07-16 10:04:14\",\"permalink\":\"/pages/f2a556/\",\"categories\":[\"更多\",\"学习\"],\"tags\":[\"学习方法\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"费曼学习法\",\"date\":\"2020-07-16 10:04:14\",\"capture\":\"步骤\\n费曼学习法分为4个步骤:\\n1. 确定学习目标\\n你想学习的概念、内容、主题是什么。\\n2. 模拟教学学习法\\n你要模拟自己是一位老师，面对完全不懂这个领域的人，用自己的话，尽可能具体形象地讲诉。这样的讲诉有助于你活学活用，触类旁通，联系生活具体情境。\\n3. 回顾\\n反思第2步遇到的问题，哪些地方卡壳了，哪些地方对方没有真正听懂。找出问题的要害，把握关键环节。\\n4. 简化\\n把这些遇到问题的地方，重新梳理理解，尽可能了解更多背景和相关知识，再用尽可能简化的方式重新表达，设法看穿本质。然后，返回第2步。\\n\\n&gt; \\n&gt; 《费曼学习法：为何被称为史上最牛的学习法，它的本质究竟是什么？》\\n&gt;\"},{\"url\":\"/01.前端/40.学习笔记/05.《JavaScript高级程序设计》笔记.html\",\"relativePath\":\"/01.前端/40.学习笔记/05.《JavaScript高级程序设计》笔记.html\",\"frontmatter\":{\"title\":\"《JavaScript高级程序设计》笔记\",\"date\":\"2020-06-12 12:39:01\",\"permalink\":\"/note/js/\",\"categories\":[\"笔记\"],\"tags\":[\"笔记\",\"红宝书\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"《JavaScript高级程序设计》笔记\",\"date\":\"2020-06-12 12:39:01\",\"capture\":\"第1章  JavaScript简介\\n* JavaScript诞生于1995年\\n* 一个完整的JavaScript由这三部分组成：\\n  * ECMAScript (核心)\\n  * DOM (文档对象模型)\\n  * BOM (浏览器对象模型)\\n* ECMAScript的 宿主环境 包含 ：\\n  * 浏览器\\n  * Node\\n  * flash\\n* ECMAScript大致规定了下列组成部分：\\n  * 语法\\n  * 类型\\n  * 语句\\n  * 关键字\\n  * 保留字\\n  * 操作符\\n  * 对象\\n 第2章 在HTML中使用JavaScript\\n* `&lt;script\\n  * async 表示立即\"},{\"url\":\"/04.更多/01.学习/10.搜索引擎使用技巧.html\",\"relativePath\":\"/04.更多/01.学习/10.搜索引擎使用技巧.html\",\"frontmatter\":{\"title\":\"搜索引擎使用技巧\",\"date\":\"2020-05-24 11:44:19\",\"permalink\":\"/pages/ce818a\",\"categories\":[\"更多\",\"学习\"],\"tags\":[\"搜索技巧\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"搜索引擎使用技巧\",\"date\":\"2020-05-24 11:44:19\",\"capture\":\"搜索引擎相信大家经常在使用，但是有时候想搜某个信息时却搜出来一大堆不相关的（百度：你们都在看我干什么？）。下面我们来介绍几种搜索技巧，可以提升搜索效率，助你快速查资料，妈妈再也不担心我的学习了（'妈~我真的是在找学习资料'）\\n 技巧1：排除干扰项\\n方式：关键词1+空格+减号+关键词2，即 `关键词1 -关键词2`\\n功能：排除一些不想要的关键词\\n示例：\\n```\\n锤子 -锤子手机\\n```\\n示例中将在搜索结果排除与`锤子手机`相关的，只显示`锤子`本来的样子。\\n\\n 技巧2：精确搜索\\n方式：给关键词加双引号，`\\\"关键词\\\"`\\n功能：只搜索引号里的字，少一个字或者把字拆开都不行\\n示例：\\n```\\n\\\"达拉不崩\"},{\"url\":\"/02.页面/20.CSS/14.CSS-function汇总.html\",\"relativePath\":\"/02.页面/20.CSS/14.CSS-function汇总.html\",\"frontmatter\":{\"title\":\"CSS-function汇总\",\"date\":\"2020-05-12 09:36:44\",\"permalink\":\"/pages/3da0d7\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"CSS-function汇总\",\"date\":\"2020-05-12 09:36:44\",\"capture\":\"\"},{\"url\":\"/01.前端/25.JavaScript文章/12.比typeof运算符更准确的类型判断.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/12.比typeof运算符更准确的类型判断.html\",\"frontmatter\":{\"title\":\"比typeof运算符更准确的类型判断\",\"date\":\"2020-04-13 15:56:54\",\"permalink\":\"/pages/fd4a16d56b83c1bc\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"比typeof运算符更准确的类型判断\",\"date\":\"2020-04-13 15:56:54\",\"capture\":\"不同数据类型的`Object.prototype.toString`方法返回值如下。\\n- 数值：返回`[object Number]`。\\n- 字符串：返回`[object String]`。\\n- 布尔值：返回`[object Boolean]`。\\n- undefined：返回`[object Undefined]`。\\n- null：返回`[object Null]`。\\n- 数组：返回`[object Array]`。\\n- arguments 对象：返回`[object Arguments]`。\\n- 函数：返回`[object Function]`。\\n- Error 对象：返回`[object \"},{\"url\":\"/03.技术/01.技术文档/10.npm packageJson属性详解.html\",\"relativePath\":\"/03.技术/01.技术文档/10.npm packageJson属性详解.html\",\"frontmatter\":{\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"npm packageJson属性详解\",\"date\":\"2020-04-08 17:16:38\",\"permalink\":\"/pages/dec4f3f00e71a312\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null]},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"npm packageJson属性详解\",\"date\":\"2020-04-08 17:16:38\",\"excerpt\":\"<h1 id=\\\"npm-package-json属性详解\\\" tabindex=\\\"-1\\\">npm package.json属性详解 <a class=\\\"header-anchor\\\" href=\\\"#npm-package-json属性详解\\\" aria-label=\\\"Permalink to &quot;npm package.json属性详解&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<blockquote>\\n<p>本文转自<a href=\\\"https://www.cnblogs.com/tzyy/p/5193811.html\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">https://www.cnblogs.com/tzyy/p/5193811.html</a>，作者：TZYY</p>\\n</blockquote>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p><code>package.json</code>必须是一个严格的json文件，而不仅仅是js里边的一个对象。其中很多属性可以通过<code>npm-config</code>来生成</p>\\n\",\"capture\":\"npm package.json属性详解\\n\\n 概述\\n`package.json`必须是一个严格的json文件，而不仅仅是js里边的一个对象。其中很多属性可以通过`npm-config`来生成\\n name\\n`package.json`中最重要的属性是`name`和`version`两个属性，这两个属性是必须要有的，否则模块就无法被安装，这两个属性一起形成了一个npm模块的唯一标识符。模块中内容变更的同时，模块版本也应该一起变化。\\n`name`属性就是你的模块名称，下面是一些命名规则:\\n- `name`必须小于等于214个字节，包括前缀名称在内（如 xxx/xxxmodule）。\\n- `name`\"},{\"url\":\"/02.页面/20.CSS/13.如何根据系统主题自动响应CSS深色模式.html\",\"relativePath\":\"/02.页面/20.CSS/13.如何根据系统主题自动响应CSS深色模式.html\",\"frontmatter\":{\"title\":\"如何根据系统主题自动响应CSS深色模式\",\"date\":\"2020-03-31 14:06:26\",\"permalink\":\"/pages/5dde351274f1e39d\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[\"css\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"如何根据系统主题自动响应CSS深色模式\",\"date\":\"2020-03-31 14:06:26\",\"excerpt\":\"<h1 id=\\\"如何根据系统主题自动响应css深色模式\\\" tabindex=\\\"-1\\\">如何根据系统主题自动响应CSS深色模式 <a class=\\\"header-anchor\\\" href=\\\"#如何根据系统主题自动响应css深色模式\\\" aria-label=\\\"Permalink to &quot;如何根据系统主题自动响应CSS深色模式&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p align=\\\"center\\\">\\n  <img src=\\\"https://cdn.staticaly.com/gh/xugaoyi/image_store/blog/20200427163531.jpg\\\" width=\\\"500\\\">\\n</p>\\n<p>很多人喜欢选择APP或网站中的深色模式，也许他们更喜欢这样的外观，或者他们想让自己的眼睛免受疲劳。这篇文章将告诉你如何在网站中实现一个自动的CSS深色模式，根据访客的系统主题来自动响应。</p>\\n\",\"capture\":\"如何根据系统主题自动响应CSS深色模式\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"https://cdn.staticaly.com/gh/xugaoyi/image_store/blog/20200427163531.jpg\\\" width=\\\"500\\\"&gt;\\n&lt;/p&gt;\\n很多人喜欢选择APP或网站中的深色模式，也许他们更喜欢这样的外观，或者他们想让自己的眼睛免受疲劳。这篇文章将告诉你如何在网站中实现一个自动的CSS深色模式，根据访客的系统主题来自动响应。\\n CSS 深色模式 (Dark Mode)\\n在`:root`根元素中定义变量来设置主题的颜色。我建\"},{\"url\":\"/02.页面/20.CSS/12.水平垂直居中的几种方式-案例.html\",\"relativePath\":\"/02.页面/20.CSS/12.水平垂直居中的几种方式-案例.html\",\"frontmatter\":{\"title\":\"水平垂直居中的几种方式-案例\",\"date\":\"2020-03-13 16:13:43\",\"permalink\":\"/pages/cb7cb251adba4bf7\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"水平垂直居中的几种方式-案例\",\"date\":\"2020-03-13 16:13:43\",\"capture\":\"&lt;iframe height=\\\"880\\\" style=\\\"width: 100%;\\\" scrolling=\\\"no\\\" title=\\\"水平垂直居中的几种方式\\\" src=\\\"https://codepen.io/xugaoyi/embed/poJLeYv?height=880&theme-id=light&default-tab=result\\\" frameborder=\\\"no\\\" allowtransparency=\\\"true\\\" allowfullscreen=\\\"true\\\"\\n  See the Pen &lt;a href='https://codepen.io/xugaoyi/pen/poJLeY\"},{\"url\":\"/01.前端/25.JavaScript文章/11.JS获取和修改url参数.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/11.JS获取和修改url参数.html\",\"frontmatter\":{\"title\":\"JS获取和修改url参数\",\"date\":\"2020-03-05 12:45:37\",\"permalink\":\"/pages/7a91be2d502346ce\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"JS获取和修改url参数\",\"date\":\"2020-03-05 12:45:37\",\"capture\":\"获取url参数\\n```js\\n/**\\n * 获取url里的参数\\n * @param arg 参数名\\n * @returns\\n */\\nfunction getURLString(arg) {\\n    var reg = new RegExp(\\\"(^|&)\\\" + arg + \\\"=([^&]*)(&|$)\\\", \\\"i\\\");\\n    var r = window.location.search.substr(1).match(reg);\\n    if (r != null)\\n        return unescape(r[2]);\\n    return null;\\n}\\n```\\n 修改url参数\\n```\"},{\"url\":\"/01.前端/25.JavaScript文章/10.防抖与节流函数.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/10.防抖与节流函数.html\",\"frontmatter\":{\"title\":\"防抖与节流函数\",\"date\":\"2020-02-29 15:07:47\",\"permalink\":\"/pages/0f6a0ac99b62ede5\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"防抖与节流函数\",\"date\":\"2020-02-29 15:07:47\",\"excerpt\":\"<h1 id=\\\"防抖与节流函数\\\" tabindex=\\\"-1\\\">防抖与节流函数 <a class=\\\"header-anchor\\\" href=\\\"#防抖与节流函数\\\" aria-label=\\\"Permalink to &quot;防抖与节流函数&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>防抖和节流的作用都是在高频事件中防止函数被多次调用，是一种性能优化的方案。</p>\\n<p>区别在于，防抖函数只会在高频事件结束后n毫秒调用一次函数，节流函数会在高频事件触发过程当中每隔n毫秒调用一次函数。</p>\\n\",\"capture\":\"防抖和节流的作用都是在高频事件中防止函数被多次调用，是一种性能优化的方案。\\n区别在于，防抖函数只会在高频事件结束后n毫秒调用一次函数，节流函数会在高频事件触发过程当中每隔n毫秒调用一次函数。\\n 防抖函数\\n触发高频事件后一段时间（wait）只会执行一次函数，如果指定时间（wait）内高频事件再次被触发，则重新计算时间。\\n 封装\\n```js\\n// 防抖函数\\nfunction debounce(func, wait) {\\n    let timeout = null;\\n    return function () {\\n        let context = this;\\n        let a\"},{\"url\":\"/02.页面/20.CSS/11.从box-sizing属性入手，了解盒子模型.html\",\"relativePath\":\"/02.页面/20.CSS/11.从box-sizing属性入手，了解盒子模型.html\",\"frontmatter\":{\"title\":\"从box-sizing属性入手，了解盒子模型\",\"date\":\"2020-02-27 17:08:48\",\"permalink\":\"/pages/20a978023139589d\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"从box-sizing属性入手，了解盒子模型\",\"date\":\"2020-02-27 17:08:48\",\"excerpt\":\"<h1 id=\\\"从box-sizing属性入手-了解盒子模型\\\" tabindex=\\\"-1\\\">从box-sizing属性入手，了解盒子模型 <a class=\\\"header-anchor\\\" href=\\\"#从box-sizing属性入手-了解盒子模型\\\" aria-label=\\\"Permalink to &quot;从box-sizing属性入手，了解盒子模型&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"背景\\\" tabindex=\\\"-1\\\">背景 <a class=\\\"header-anchor\\\" href=\\\"#背景\\\" aria-label=\\\"Permalink to &quot;背景&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>先声明一下运用的场景，假如项目布局使用的是<strong>自适应</strong>的布局方式，div给出的宽度是<strong>百分比</strong>的形式，即占窗口宽度的100%，但边框<code>border</code>和内边距<code>padding</code>是用像素来表示的，此时就会造成一个问题是div总宽度超过窗口宽度。为了避免这种问题，可以使用属性<code>box-sizing:border-box</code>来把 <strong>标准盒模型</strong> 变成 <strong>代替(IE)盒模型</strong> ，从而使div的总宽度依然是100%</p>\\n\",\"capture\":\"背景\\n先声明一下运用的场景，假如项目布局使用的是自适应的布局方式，div给出的宽度是百分比的形式，即占窗口宽度的100%，但边框`border`和内边距`padding`是用像素来表示的，此时就会造成一个问题是div总宽度超过窗口宽度。为了避免这种问题，可以使用属性`box-sizing:border-box`来把 标准盒模型 变成 代替(IE)盒模型 ，从而使div的总宽度依然是100%\\n 什么是CSS 盒模型?\\n页面布局中，一个元素的外边距（margin）、 边框（border）、内边距（padding）、内容（content）组成一个盒模型。盒模型可分为标准盒模型 和 代替（IE）盒模型\"},{\"url\":\"/02.页面/20.CSS/10.文字在一行或多行时超出显示省略号.html\",\"relativePath\":\"/02.页面/20.CSS/10.文字在一行或多行时超出显示省略号.html\",\"frontmatter\":{\"title\":\"文字在一行或多行时超出显示省略号\",\"date\":\"2020-02-23 15:07:08\",\"permalink\":\"/pages/42b66999cc27dc25\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"文字在一行或多行时超出显示省略号\",\"date\":\"2020-02-23 15:07:08\",\"excerpt\":\"<h1 id=\\\"文字在一行或多行时超出显示省略号\\\" tabindex=\\\"-1\\\">文字在一行或多行时超出显示省略号 <a class=\\\"header-anchor\\\" href=\\\"#文字在一行或多行时超出显示省略号\\\" aria-label=\\\"Permalink to &quot;文字在一行或多行时超出显示省略号&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"一行超出显示省略\\\" tabindex=\\\"-1\\\">一行超出显示省略 <a class=\\\"header-anchor\\\" href=\\\"#一行超出显示省略\\\" aria-label=\\\"Permalink to &quot;一行超出显示省略&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<div class=\\\"language-css vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">css</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">overflow: hidden;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">white-space</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">: nowrap;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">text-overflow</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">: ellipsis;</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br></div></div>\",\"capture\":\"一行超出显示省略\\n```css\\noverflow: hidden;\\nwhite-space: nowrap;\\ntext-overflow: ellipsis;\\n```\\n```html\\n&lt;html\\n   &lt;div class=\\\"box-42b6\\\"&gt;演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字&lt;/div&gt;\\n&lt;/html&gt;\\n&lt;style&gt;\\n    .box-42b6{\\n        border: 1px solid 999;\\n        width\"},{\"url\":\"/01.前端/25.JavaScript文章/09.将一维数组按指定长度转为二维数组.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/09.将一维数组按指定长度转为二维数组.html\",\"frontmatter\":{\"title\":\"将一维数组按指定长度转为二维数组\",\"date\":\"2020-02-23 13:49:31\",\"permalink\":\"/pages/f1acb712033ac8da\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"将一维数组按指定长度转为二维数组\",\"date\":\"2020-02-23 13:49:31\",\"capture\":\"将一维数组按指定长度转为二维数组\\n```js\\nfunction pages(arr, len) {\\n    const pages = []\\n    arr.forEach((item, index) =\\n        const page = Math.floor(index / len)\\n        if (!pages[page]) {\\n            pages[page] = []\\n        }\\n        pages[page].push(item)\\n    })\\n    return pages\\n}\\n// 使用\\nconst arr = [1, 2, 3, \"},{\"url\":\"/02.页面/20.CSS/09.「布局技巧」图片未加载前自动撑开元素高度.html\",\"relativePath\":\"/02.页面/20.CSS/09.「布局技巧」图片未加载前自动撑开元素高度.html\",\"frontmatter\":{\"title\":\"「布局技巧」图片未加载前自动撑开元素高度\",\"date\":\"2020-02-22 16:37:10\",\"permalink\":\"/pages/3d52574260725aea\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"「布局技巧」图片未加载前自动撑开元素高度\",\"date\":\"2020-02-22 16:37:10\",\"excerpt\":\"<h1 id=\\\"「布局技巧」图片未加载前自动撑开元素高度\\\" tabindex=\\\"-1\\\">「布局技巧」图片未加载前自动撑开元素高度 <a class=\\\"header-anchor\\\" href=\\\"#「布局技巧」图片未加载前自动撑开元素高度\\\" aria-label=\\\"Permalink to &quot;「布局技巧」图片未加载前自动撑开元素高度&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>在移动端开发中，有一些元素是根据图片高度来自动撑开的 ，高度不能写死（如轮播图的外层元素）。在网络较慢的情况下，图片加载需要一些时间，此时该元素的高度没有被撑开，在网页布局上会有一些不想看到的效果。</p>\\n\",\"capture\":\"在移动端开发中，有一些元素是根据图片高度来自动撑开的 ，高度不能写死（如轮播图的外层元素）。在网络较慢的情况下，图片加载需要一些时间，此时该元素的高度没有被撑开，在网页布局上会有一些不想看到的效果。\\n这种情况我们可以设置如下样式来设置该元素的高度：\\n```stylus\\n.wrapper\\n  overflow hidden\\n  width 100%\\n  height 0\\n  padding-bottom 26.66% // 这个数值是图片的高宽比，即 高/宽\\n  background eee\\n```\\n上面代码中，`padding-bottom` 的取值是图片的高宽比（即，高/宽），它会根据 `w\"},{\"url\":\"/01.前端/25.JavaScript文章/03.ES5面向对象.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/03.ES5面向对象.html\",\"frontmatter\":{\"title\":\"ES5面向对象\",\"date\":\"2020-02-22 10:35:43\",\"permalink\":\"/pages/b1af5cb8996363c5\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"ES5面向对象\",\"date\":\"2020-02-22 10:35:43\",\"capture\":\"```js\\n//面向对象封装\\nfunction Student(props){ // 构造函数 （构造函数内定于属性。尊从首字母大写的约定）\\n  this.name = props.name || '匿名';  // 默认‘匿名’\\n  this.grade = props.grade || 1;\\n}\\nStudent.prototype.hello = function(){ // 在构造函数的原型上定义方法\\n  console.log('你好,'+ this.name +'同学，你在'+ this.grade+'年级');\\n}\\n//使用\\nfunction createStudent(props\"},{\"url\":\"/02.页面/10.HTML/10.常用meta整理.html\",\"relativePath\":\"/02.页面/10.HTML/10.常用meta整理.html\",\"frontmatter\":{\"title\":\"常用meta整理\",\"date\":\"2020-02-21 12:20:10\",\"permalink\":\"/pages/8309a5b876fc95e3\",\"categories\":[\"页面\",\"HTML\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"常用meta整理\",\"date\":\"2020-02-21 12:20:10\",\"excerpt\":\"<h1 id=\\\"常用meta整理\\\" tabindex=\\\"-1\\\">常用meta整理 <a class=\\\"header-anchor\\\" href=\\\"#常用meta整理\\\" aria-label=\\\"Permalink to &quot;常用meta整理&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"meta-元素\\\" tabindex=\\\"-1\\\">&lt;meta&gt; 元素 <a class=\\\"header-anchor\\\" href=\\\"#meta-元素\\\" aria-label=\\\"Permalink to &quot;&lt;meta\\\\&gt; 元素&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"概要\\\" tabindex=\\\"-1\\\">概要 <a class=\\\"header-anchor\\\" href=\\\"#概要\\\" aria-label=\\\"Permalink to &quot;概要&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>meta标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。</p>\\n\",\"capture\":\"&lt;meta\\\\\\n 概要\\nmeta标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。\\n必要属性\\n| 属性    | 值        | 描述                                   |\\n| ------- | --------- | -------------------------------------- |\\n| content | some text | 定义与http-equiv或name属性相关的元信息 |\\n可选属性\\n| 属性     \"},{\"url\":\"/《Vue》笔记/05.工具/10.Vue CLi v3 创建项目使用记录.html\",\"relativePath\":\"/《Vue》笔记/05.工具/10.Vue CLi v3 创建项目使用记录.html\",\"frontmatter\":{\"title\":\"Vue CLi v3 创建项目使用记录\",\"date\":\"2020-02-20 17:24:29\",\"permalink\":\"/pages/d00311f8174119b2\",\"categories\":[\"《Vue》笔记\",\"工具\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Vue CLi v3 创建项目使用记录\",\"date\":\"2020-02-20 17:24:29\",\"capture\":\"官方文档\\n以下使用的CLi版本是 v3.11.0\\n vue create\\n1. 运行以下命令来创建一个新项目\\n```sh\\nvue create hello-world\\n```\\n2. 你会被提示选取一个 preset (预设)。你可以选默认的包含了基本的 Babel + ESLint 设置的 preset，也可以选“手动选择特性”来选取需要的特性。\\n```sh\\nVue CLI v3.11.0\\n? Please pick a preset: (Use arrow keys)\\n\\n  Manually select features (手动选择特性)\\n```\\n默认预设只包含Babel + ESLint\"},{\"url\":\"/《Vue》笔记/04.可复用性&组合/01.Mixin混入.html\",\"relativePath\":\"/《Vue》笔记/04.可复用性&组合/01.Mixin混入.html\",\"frontmatter\":{\"title\":\"Mixin混入\",\"date\":\"2020-02-19 15:22:41\",\"permalink\":\"/pages/bd36a3c1bc3e0821\",\"categories\":[\"《Vue》笔记\",\"可复用性&组合\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Mixin混入\",\"date\":\"2020-02-19 15:22:41\",\"excerpt\":\"<h1 id=\\\"mixin混入\\\" tabindex=\\\"-1\\\">Mixin混入 <a class=\\\"header-anchor\\\" href=\\\"#mixin混入\\\" aria-label=\\\"Permalink to &quot;Mixin混入&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"基础\\\" tabindex=\\\"-1\\\">基础 <a class=\\\"header-anchor\\\" href=\\\"#基础\\\" aria-label=\\\"Permalink to &quot;基础&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。</p>\\n\",\"capture\":\"基础\\n混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。\\n\\n&gt;\\n&gt; 可通过 `this.$options` 查看选项\\n例子：\\n```js\\n// 定义一个混入对象\\nvar myMixin = {\\n  created: function () {\\n    this.hello()\\n  },\\n  methods: {\\n    hello: function () {\\n      console.log('hello from mixin!')\\n  \"},{\"url\":\"/《Vue》笔记/02.组件/90.vue父子组件的生命周期顺序.html\",\"relativePath\":\"/《Vue》笔记/02.组件/90.vue父子组件的生命周期顺序.html\",\"frontmatter\":{\"title\":\"vue父子组件的生命周期顺序\",\"date\":\"2020-02-18 16:39:33\",\"permalink\":\"/pages/e6cec47efa42d7f1\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"vue父子组件的生命周期顺序\",\"date\":\"2020-02-18 16:39:33\",\"capture\":\"加载渲染过程\\n```\\n父beforeCreate -\\n```\\n父组件会先执行到beforeMount，接着会执行子组件钩子到挂载结束，再挂载父组件。\\n 子组件更新过程\\n```\\n父beforeUpdate -&gt; 子beforeUpdate -&gt; 子updated -&gt; 父updated\\n```\\n 父组件更新过程\\n```\\n父beforeUpdate -&gt; 父updated\\n```\\n 销毁过程\\n```\\n父beforeDestroy -&gt; 子beforeDestroy -&gt; 子destroyed -&gt; 父destroyed\\n```\"},{\"url\":\"/《Vue》笔记/03.过渡&动画/112.使用animate库.html\",\"relativePath\":\"/《Vue》笔记/03.过渡&动画/112.使用animate库.html\",\"frontmatter\":{\"title\":\"使用animate库\",\"date\":\"2020-02-17 16:05:52\",\"permalink\":\"/pages/3b0a20e70805fcea\",\"categories\":[\"《Vue》笔记\",\"过渡&动画\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"使用animate库\",\"date\":\"2020-02-17 16:05:52\",\"excerpt\":\"<h1 id=\\\"vue中使用animate-css库\\\" tabindex=\\\"-1\\\">vue中使用Animate.css库 <a class=\\\"header-anchor\\\" href=\\\"#vue中使用animate-css库\\\" aria-label=\\\"Permalink to &quot;vue中使用Animate.css库&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"自定义过渡类名\\\" tabindex=\\\"-1\\\">自定义过渡类名 <a class=\\\"header-anchor\\\" href=\\\"#自定义过渡类名\\\" aria-label=\\\"Permalink to &quot;自定义过渡类名&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>我们可以通过以下 attribute 来自定义过渡类名：</p>\\n<ul>\\n<li><code>enter-class</code></li>\\n<li><code>enter-active-class</code></li>\\n<li><code>enter-to-class</code> (2.1.8+)</li>\\n<li><code>leave-class</code></li>\\n<li><code>leave-active-class</code></li>\\n<li><code>leave-to-class</code> (2.1.8+)</li>\\n</ul>\\n\",\"capture\":\"自定义过渡类名\\n我们可以通过以下 attribute 来自定义过渡类名：\\n- `enter-class`\\n- `enter-active-class`\\n- `enter-to-class` (2.1.8+)\\n- `leave-class`\\n- `leave-active-class`\\n- `leave-to-class` (2.1.8+)\\n他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 Animate.css结合使用十分有用。\\n 使用Animate.css库\\n```html\\n&lt;transition\\n            name=\\\"custom-\"},{\"url\":\"/《Vue》笔记/02.组件/80.动态组件与 v-once 指令.html\",\"relativePath\":\"/《Vue》笔记/02.组件/80.动态组件与 v-once 指令.html\",\"frontmatter\":{\"title\":\"动态组件与 v-once 指令\",\"date\":\"2020-02-16 15:52:19\",\"permalink\":\"/pages/636ca33122e9a64b\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"动态组件与 v-once 指令\",\"date\":\"2020-02-16 15:52:19\",\"capture\":\"动态组件\\n```html\\n&lt;div id=\\\"root\\\"\\n\\t&lt;component :is=\\\"type\\\"&gt;&lt;/component&gt; &lt;!--其效果如同下面两行被注释的代码--&gt;\\n\\t&lt;!-- &lt;child-one v-if=\\\"type === 'child-one'\\\"&gt;&lt;/child-one&gt;\\n\\t    &lt;child-two v-if=\\\"type === 'child-two'\\\"&gt;&lt;/child-two&gt; --&gt;\\n\\t&lt;button @click=\\\"handleClick\\\"&gt;change&\"},{\"url\":\"/《Vue》笔记/02.组件/75.插槽slot.html\",\"relativePath\":\"/《Vue》笔记/02.组件/75.插槽slot.html\",\"frontmatter\":{\"title\":\"插槽slot\",\"date\":\"2020-02-16 11:46:27\",\"permalink\":\"/pages/055ecee9a4325386\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"插槽slot\",\"date\":\"2020-02-16 11:46:27\",\"capture\":\"API\\n 插槽\\n```html\\n&lt;div id=\\\"root\\\"\\n    &lt;child&gt; &lt;!-- 组件标签 --&gt;\\n        &lt;h1&gt;hello&lt;/h1&gt;\\n    &lt;/child&gt;\\n&lt;/div&gt;\\n&lt;script type=\\\"text/javascript\\\"&gt;\\n    Vue.component('child', { // 子组件\\n        template: '&lt;div&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;'\\n    })\\n    var vm \"},{\"url\":\"/《Vue》笔记/02.组件/65.非父子组件传值.html\",\"relativePath\":\"/《Vue》笔记/02.组件/65.非父子组件传值.html\",\"frontmatter\":{\"title\":\"非父子组件传值\",\"date\":\"2020-02-15 14:55:03\",\"permalink\":\"/pages/d408e64f666f146d\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"非父子组件传值\",\"date\":\"2020-02-15 14:55:03\",\"excerpt\":\"<h1 id=\\\"非父子组件间传值\\\" tabindex=\\\"-1\\\">非父子组件间传值 <a class=\\\"header-anchor\\\" href=\\\"#非父子组件间传值\\\" aria-label=\\\"Permalink to &quot;非父子组件间传值&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>当组件的嵌套多时，非父子组件间传值就显得复杂，除了使用<a href=\\\"https://vuex.vuejs.org/zh/\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">vuex</a>实现之外，还可以通过Bus（或者叫 总线/发布订阅模式/观察者模式）的方式实现非父子组件间传值。</p>\\n\",\"capture\":\"当组件的嵌套多时，非父子组件间传值就显得复杂，除了使用vuex实现之外，还可以通过Bus（或者叫 总线/发布订阅模式/观察者模式）的方式实现非父子组件间传值。\\n&lt;div id=\\\"root\\\"\\n\\t\\t&lt;child1 content=\\\"组件1：点我传出值\\\"&gt;&lt;/child1&gt;\\n\\t\\t&lt;child2 content=\\\"组件2\\\"&gt;&lt;/child2&gt;\\n\\t&lt;/div&gt;\\n```html\\n&lt;div id=\\\"root\\\"&gt;\\n    &lt;child1 content=\\\"组件1：点我传出值\\\"&gt;&lt;/child1&gt;\\n    &l\"},{\"url\":\"/《Vue》笔记/02.组件/55.自定义事件.html\",\"relativePath\":\"/《Vue》笔记/02.组件/55.自定义事件.html\",\"frontmatter\":{\"title\":\"自定义事件\",\"date\":\"2020-02-15 11:27:45\",\"permalink\":\"/pages/9651417d08d1779d\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"自定义事件\",\"date\":\"2020-02-15 11:27:45\",\"capture\":\"API\\n 在组件标签v-on绑定的事件是自定义事件\\n```html\\n&lt;div id=\\\"root\\\"\\n    &lt;child @click=\\\"handleClick\\\"&gt;&lt;/child&gt; &lt;!--这里click是自定义事件--&gt;\\n&lt;/div&gt;\\n&lt;script type=\\\"text/javascript\\\"&gt;\\n    Vue.component('child', {\\n        template: '&lt;button&gt;Child&lt;/button&gt;',\\n    })\\n    var vm = new Vue({\\n  \"},{\"url\":\"/《Vue》笔记/02.组件/52.Prop 验证 与 非 Prop 的 Attribute.html\",\"relativePath\":\"/《Vue》笔记/02.组件/52.Prop 验证 与 非 Prop 的 Attribute.html\",\"frontmatter\":{\"title\":\"Prop 验证 与 非 Prop 的 Attribute\",\"date\":\"2020-02-15 10:49:04\",\"permalink\":\"/pages/a3080f60f6596eb4\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Prop 验证 与 非 Prop 的 Attribute\",\"date\":\"2020-02-15 10:49:04\",\"capture\":\"Prop 验证\\nAPI\\n子组件对父组件传递来的参数进行校验\\n```js\\nVue.component('my-component', {\\n  props: {\\n    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)\\n    propA: Number,\\n    // 多个可能的类型\\n    propB: [String, Number],\\n    // 必填的字符串\\n    propC: {\\n      type: String,\\n      required: true\\n    },\\n    // 带有默认值的数字\\n    propD: {\\n      \"},{\"url\":\"/《Vue》笔记/02.组件/36.使用组件的细节点.html\",\"relativePath\":\"/《Vue》笔记/02.组件/36.使用组件的细节点.html\",\"frontmatter\":{\"title\":\"使用组件的细节点\",\"date\":\"2020-02-13 13:26:20\",\"permalink\":\"/pages/83a1ab785e7fd70c\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"使用组件的细节点\",\"date\":\"2020-02-13 13:26:20\",\"capture\":\"解析 DOM 模板时的注意事项\\n```html\\n&lt;div id=\\\"root\\\"\\n    &lt;table&gt;\\n        &lt;tbody&gt;\\n            &lt;row&gt;&lt;/row&gt;\\n            &lt;row&gt;&lt;/row&gt;\\n            &lt;row&gt;&lt;/row&gt;\\n        &lt;/tbody&gt;\\n    &lt;/table&gt;\\n&lt;/div&gt;\\n&lt;script type=\\\"text/javascript\\\"&gt;\\n    Vue.component\"},{\"url\":\"/《ES6 教程》笔记/29.最新提案.html\",\"relativePath\":\"/《ES6 教程》笔记/29.最新提案.html\",\"frontmatter\":{\"title\":\"最新提案\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/7188882b8d65af1b\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"最新提案\",\"date\":\"2020-02-09 16:00:30\",\"excerpt\":\"<h1 id=\\\"最新提案\\\" tabindex=\\\"-1\\\">最新提案 <a class=\\\"header-anchor\\\" href=\\\"#最新提案\\\" aria-label=\\\"Permalink to &quot;最新提案&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>本章介绍一些尚未进入标准、但很有希望的最新提案。</p>\\n<h2 id=\\\"do-表达式\\\" tabindex=\\\"-1\\\">do 表达式 <a class=\\\"header-anchor\\\" href=\\\"#do-表达式\\\" aria-label=\\\"Permalink to &quot;do 表达式&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">{</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">  let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> t </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> f</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">();</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">  t </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> t </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">*</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> t </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">+</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br></div></div>\",\"capture\":\"本章介绍一些尚未进入标准、但很有希望的最新提案。\\n do 表达式\\n本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。\\n```javascript\\n{\\n  let t = f();\\n  t = t * t + 1;\\n}\\n```\\n上面代码中，块级作用域将两个语句封装在一起。但是，在块级作用域以外，没有办法得到`t`的值，因为块级作用域不返回值，除非`t`是全局变量。\\n现在有一个提案，使得块级作用域可以变为表达式，也就是说可以返回值，办法就是在块级作用域之前加上`do`，使它变为`do`表达式，然后就会返回内部最后执行的表达式的值。\\n```javascript\\nlet x = do {\"},{\"url\":\"/《ES6 教程》笔记/30.装饰器.html\",\"relativePath\":\"/《ES6 教程》笔记/30.装饰器.html\",\"frontmatter\":{\"title\":\"装饰器\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/e97bc1e5626b082c\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"装饰器\",\"date\":\"2020-02-09 16:00:30\",\"excerpt\":\"<h1 id=\\\"装饰器\\\" tabindex=\\\"-1\\\">装饰器 <a class=\\\"header-anchor\\\" href=\\\"#装饰器\\\" aria-label=\\\"Permalink to &quot;装饰器&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>[说明] Decorator 提案经过了大幅修改，目前还没有定案，不知道语法会不会再变。下面的内容完全依据以前的提案，已经有点过时了。等待定案以后，需要完全重写。</p>\\n<p>装饰器（Decorator）是一种与类（class）相关的语法，用来注释或修改类和类方法。许多面向对象的语言都有这项功能，目前有一个<a href=\\\"https://github.com/tc39/proposal-decorators\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">提案</a>将其引入了 ECMAScript。</p>\\n\",\"capture\":\"[说明] Decorator 提案经过了大幅修改，目前还没有定案，不知道语法会不会再变。下面的内容完全依据以前的提案，已经有点过时了。等待定案以后，需要完全重写。\\n装饰器（Decorator）是一种与类（class）相关的语法，用来注释或修改类和类方法。许多面向对象的语言都有这项功能，目前有一个提案将其引入了 ECMAScript。\\n装饰器是一种函数，写成`@ + 函数名`。它可以放在类和类方法的定义前面。\\n```javascript\\n@frozen class Foo {\\n  @configurable(false)\\n  @enumerable(true)\\n  method() {}\\n  @\"},{\"url\":\"/《ES6 教程》笔记/31.函数式编程.html\",\"relativePath\":\"/《ES6 教程》笔记/31.函数式编程.html\",\"frontmatter\":{\"title\":\"函数式编程\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/1cf50330655efc69\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"函数式编程\",\"date\":\"2020-02-09 16:00:30\",\"excerpt\":\"<h1 id=\\\"函数式编程\\\" tabindex=\\\"-1\\\">函数式编程 <a class=\\\"header-anchor\\\" href=\\\"#函数式编程\\\" aria-label=\\\"Permalink to &quot;函数式编程&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>JavaScript 语言从一诞生，就具有函数式编程的烙印。它将函数作为一种独立的数据类型，与其他数据类型处于完全平等的地位。在 JavaScript 语言中，你可以采用面向对象编程，也可以采用函数式编程。有人甚至说，JavaScript 是有史以来第一种被大规模采用的函数式编程语言。</p>\\n\",\"capture\":\"JavaScript 语言从一诞生，就具有函数式编程的烙印。它将函数作为一种独立的数据类型，与其他数据类型处于完全平等的地位。在 JavaScript 语言中，你可以采用面向对象编程，也可以采用函数式编程。有人甚至说，JavaScript 是有史以来第一种被大规模采用的函数式编程语言。\\nES6 的种种新增功能，使得函数式编程变得更方便、更强大。本章介绍 ES6 如何进行函数式编程。\\n 柯里化\\n柯里化（currying）指的是将一个多参数的函数拆分成一系列函数，每个拆分后的函数都只接受一个参数（unary）。\\n```javascript\\nfunction add (a, b) {\\n  retur\"},{\"url\":\"/《ES6 教程》笔记/32.Mixin.html\",\"relativePath\":\"/《ES6 教程》笔记/32.Mixin.html\",\"frontmatter\":{\"title\":\"Mixin\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/6a8e2dc558da1b39\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Mixin\",\"date\":\"2020-02-09 16:00:30\",\"excerpt\":\"<h1 id=\\\"mixin\\\" tabindex=\\\"-1\\\">Mixin <a class=\\\"header-anchor\\\" href=\\\"#mixin\\\" aria-label=\\\"Permalink to &quot;Mixin&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>JavaScript 语言的设计是单一继承，即子类只能继承一个父类，不允许继承多个父类。这种设计保证了对象继承的层次结构是树状的，而不是复杂的<a href=\\\"https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">网状结构</a>。</p>\\n\",\"capture\":\"JavaScript 语言的设计是单一继承，即子类只能继承一个父类，不允许继承多个父类。这种设计保证了对象继承的层次结构是树状的，而不是复杂的网状结构。\\n但是，这大大降低了编程的灵活性。因为实际开发中，有时不可避免，子类需要继承多个父类。举例来说，“猫”可以继承“哺乳类动物”，也可以继承“宠物”。\\n各种单一继承的编程语言，有不同的多重继承解决方案。比如，Java 语言也是子类只能继承一个父类，但是还允许继承多个界面（interface），这样就间接实现了多重继承。Interface 与父类一样，也是一个类，只不过它只定义接口（method signature），不定义实现，因此又被称为“抽象类\"},{\"url\":\"/《ES6 教程》笔记/33.SIMD.html\",\"relativePath\":\"/《ES6 教程》笔记/33.SIMD.html\",\"frontmatter\":{\"title\":\"SIMD\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/8e8f80f69b775a56\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"SIMD\",\"date\":\"2020-02-09 16:00:30\",\"excerpt\":\"<h1 id=\\\"simd\\\" tabindex=\\\"-1\\\">SIMD <a class=\\\"header-anchor\\\" href=\\\"#simd\\\" aria-label=\\\"Permalink to &quot;SIMD&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>SIMD（发音<code>/sim-dee/</code>）是“Single Instruction/Multiple Data”的缩写，意为“单指令，多数据”。它是 JavaScript 操作 CPU 对应指令的接口，你可以看做这是一种不同的运算执行模式。与它相对的是 SISD（“Single Instruction/Single Data”），即“单指令，单数据”。</p>\\n\",\"capture\":\"概述\\nSIMD（发音`/sim-dee/`）是“Single Instruction/Multiple Data”的缩写，意为“单指令，多数据”。它是 JavaScript 操作 CPU 对应指令的接口，你可以看做这是一种不同的运算执行模式。与它相对的是 SISD（“Single Instruction/Single Data”），即“单指令，单数据”。\\nSIMD 的含义是使用一个指令，完成多个数据的运算；SISD 的含义是使用一个指令，完成单个数据的运算，这是 JavaScript 的默认运算模式。显而易见，SIMD 的执行效率要高于 SISD，所以被广泛用于 3D 图形运算、物理模拟等运算\"},{\"url\":\"/《ES6 教程》笔记/34.参考链接.html\",\"relativePath\":\"/《ES6 教程》笔记/34.参考链接.html\",\"frontmatter\":{\"title\":\"参考链接\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/ea6f3b870f6dab69\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"参考链接\",\"date\":\"2020-02-09 16:00:30\",\"capture\":\"官方文件\\n- ECMAScript® 2015 Language Specification: ECMAScript 2015 规格\\n- ECMAScript® 2016 Language Specification: ECMAScript 2016 规格\\n- ECMAScript® 2017 Language Specification：ECMAScript 2017 规格（草案）\\n- ECMAScript Current Proposals: ECMAScript 当前的所有提案\\n- ECMAScript Active Proposals: 已经进入正式流程的提案\\n- ECMAScript\"},{\"url\":\"/《ES6 教程》笔记/02.let 和 const 命令.html\",\"relativePath\":\"/《ES6 教程》笔记/02.let 和 const 命令.html\",\"frontmatter\":{\"title\":\"let 和 const 命令\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/c1edd70a6b7c7872\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"let 和 const 命令\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"let-和-const-命令\\\" tabindex=\\\"-1\\\">let 和 const 命令 <a class=\\\"header-anchor\\\" href=\\\"#let-和-const-命令\\\" aria-label=\\\"Permalink to &quot;let 和 const 命令&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"let-命令\\\" tabindex=\\\"-1\\\">let 命令 <a class=\\\"header-anchor\\\" href=\\\"#let-命令\\\" aria-label=\\\"Permalink to &quot;let 命令&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"基本用法\\\" tabindex=\\\"-1\\\">基本用法 <a class=\\\"header-anchor\\\" href=\\\"#基本用法\\\" aria-label=\\\"Permalink to &quot;基本用法&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>ES6 新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code>，但是所声明的变量，<strong>只在<code>let</code>命令所在的代码块内有效(块级作用域)</strong>。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">{</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">  let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> a </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 10</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">  var</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> b </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">a </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// ReferenceError: a is not defined.</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">b </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// 1</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br></div></div>\",\"capture\":\"let 命令\\n 基本用法\\nES6 新增了`let`命令，用来声明变量。它的用法类似于`var`，但是所声明的变量，只在`let`命令所在的代码块内有效(块级作用域)。\\n```javascript\\n{\\n  let a = 10;\\n  var b = 1;\\n}\\na // ReferenceError: a is not defined.\\nb // 1\\n```\\n上面代码在代码块之中，分别用`let`和`var`声明了两个变量。然后在代码块之外调用这两个变量，结果`let`声明的变量报错，`var`声明的变量返回了正确的值。这表明，`let`声明的变量只在它所在的代码块有效。\\n`for`循环的计数器，\"},{\"url\":\"/《ES6 教程》笔记/03.变量的解构赋值.html\",\"relativePath\":\"/《ES6 教程》笔记/03.变量的解构赋值.html\",\"frontmatter\":{\"title\":\"变量的解构赋值\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/b1ab10a62f7564da\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"变量的解构赋值\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"变量的解构赋值\\\" tabindex=\\\"-1\\\">变量的解构赋值 <a class=\\\"header-anchor\\\" href=\\\"#变量的解构赋值\\\" aria-label=\\\"Permalink to &quot;变量的解构赋值&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"数组的解构赋值\\\" tabindex=\\\"-1\\\">数组的解构赋值 <a class=\\\"header-anchor\\\" href=\\\"#数组的解构赋值\\\" aria-label=\\\"Permalink to &quot;数组的解构赋值&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"基本用法\\\" tabindex=\\\"-1\\\">基本用法 <a class=\\\"header-anchor\\\" href=\\\"#基本用法\\\" aria-label=\\\"Permalink to &quot;基本用法&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>ES6 允许按照一定模式，<strong>从数组和对象中提取值，对变量进行赋值，这被称为解构</strong>（Destructuring）。</p>\\n<p>以前，为变量赋值，只能直接指定值。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> a </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> b </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> c </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 3</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br></div></div>\",\"capture\":\"数组的解构赋值\\n 基本用法\\nES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。\\n以前，为变量赋值，只能直接指定值。\\n```javascript\\nlet a = 1;\\nlet b = 2;\\nlet c = 3;\\n```\\nES6 允许写成下面这样。\\n```javascript\\nlet [a, b, c] = [1, 2, 3];\\n```\\n上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。\\n本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。\\n```javas\"},{\"url\":\"/《ES6 教程》笔记/04.字符串的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/04.字符串的扩展.html\",\"frontmatter\":{\"title\":\"字符串的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/ca89eca8adeba5f4\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"字符串的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"字符串的扩展\\\" tabindex=\\\"-1\\\">字符串的扩展 <a class=\\\"header-anchor\\\" href=\\\"#字符串的扩展\\\" aria-label=\\\"Permalink to &quot;字符串的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>本章介绍 ES6 对字符串的改造和增强，下一章介绍字符串对象的新增方法。</p>\\n<h2 id=\\\"字符的-unicode-表示法\\\" tabindex=\\\"-1\\\">字符的 Unicode 表示法 <a class=\\\"header-anchor\\\" href=\\\"#字符的-unicode-表示法\\\" aria-label=\\\"Permalink to &quot;字符的 Unicode 表示法&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES6 加强了对 Unicode 的支持，允许采用<code>\\\\uxxxx</code>形式表示一个字符，其中<code>xxxx</code>表示字符的 Unicode 码点。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">\\\\u0061</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// \\\"a\\\"</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br></div></div>\",\"capture\":\"本章介绍 ES6 对字符串的改造和增强，下一章介绍字符串对象的新增方法。\\n 字符的 Unicode 表示法\\nES6 加强了对 Unicode 的支持，允许采用`\\\\uxxxx`形式表示一个字符，其中`xxxx`表示字符的 Unicode 码点。\\n```javascript\\n\\\"\\\\u0061\\\"\\n// \\\"a\\\"\\n```\\n但是，这种表示法只限于码点在`\\\\u0000`~`\\\\uFFFF`之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。\\n```javascript\\n\\\"\\\\uD842\\\\uDFB7\\\"\\n// \\\"𠮷\\\"\\n\\\"\\\\u20BB7\\\"\\n// \\\" 7\\\"\\n```\\n上面代码表示，如果直接在`\\\\u`后面跟上超过`\"},{\"url\":\"/《ES6 教程》笔记/05.字符串的新增方法.html\",\"relativePath\":\"/《ES6 教程》笔记/05.字符串的新增方法.html\",\"frontmatter\":{\"title\":\"字符串的新增方法\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/a650b4a0ebfc9350\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"字符串的新增方法\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"字符串的新增方法\\\" tabindex=\\\"-1\\\">字符串的新增方法 <a class=\\\"header-anchor\\\" href=\\\"#字符串的新增方法\\\" aria-label=\\\"Permalink to &quot;字符串的新增方法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>本章介绍字符串对象的新增方法。</p>\\n<h2 id=\\\"string-fromcodepoint\\\" tabindex=\\\"-1\\\">String.fromCodePoint() <a class=\\\"header-anchor\\\" href=\\\"#string-fromcodepoint\\\" aria-label=\\\"Permalink to &quot;String.fromCodePoint()&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES5 提供<code>String.fromCharCode()</code>方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于<code>0xFFFF</code>的字符。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">String.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">fromCharCode</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">0x20BB7</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">)</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// \\\"ஷ\\\"</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br></div></div>\",\"capture\":\"本章介绍字符串对象的新增方法。\\n String.fromCodePoint()\\nES5 提供`String.fromCharCode()`方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于`0xFFFF`的字符。\\n```javascript\\nString.fromCharCode(0x20BB7)\\n// \\\"ஷ\\\"\\n```\\n上面代码中，`String.fromCharCode()`不能识别大于`0xFFFF`的码点，所以`0x20BB7`就发生了溢出，最高位`2`被舍弃了，最后返回码点`U+0BB7`对应的字符，而不是码点`U+20BB7`对应的字符。\\nES6 提供了`S\"},{\"url\":\"/《ES6 教程》笔记/06.正则的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/06.正则的扩展.html\",\"frontmatter\":{\"title\":\"正则的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/0473261a6ab0ee8c\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"正则的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"正则的扩展\\\" tabindex=\\\"-1\\\">正则的扩展 <a class=\\\"header-anchor\\\" href=\\\"#正则的扩展\\\" aria-label=\\\"Permalink to &quot;正则的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"regexp-构造函数\\\" tabindex=\\\"-1\\\">RegExp 构造函数 <a class=\\\"header-anchor\\\" href=\\\"#regexp-构造函数\\\" aria-label=\\\"Permalink to &quot;RegExp 构造函数&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>在 ES5 中，<code>RegExp</code>构造函数的参数有两种情况。</p>\\n<p>第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">var</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> regex </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> new</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> RegExp</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'xyz'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'i'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">);</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// 等价于</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">var</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> regex </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> /</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#DBEDFF\\\">xyz</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">/</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">i</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br></div></div>\",\"capture\":\"RegExp 构造函数\\n在 ES5 中，`RegExp`构造函数的参数有两种情况。\\n第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。\\n```javascript\\nvar regex = new RegExp('xyz', 'i');\\n// 等价于\\nvar regex = /xyz/i;\\n```\\n第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。\\n```javascript\\nvar regex = new RegExp(/xyz/i);\\n// 等价于\\nvar regex = /xyz/i;\\n```\\n但是，ES5 不允许此时使用第二个参数添加修饰\"},{\"url\":\"/《ES6 教程》笔记/07.数值的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/07.数值的扩展.html\",\"frontmatter\":{\"title\":\"数值的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/5dfea9a0f2d1a392\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"数值的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"数值的扩展\\\" tabindex=\\\"-1\\\">数值的扩展 <a class=\\\"header-anchor\\\" href=\\\"#数值的扩展\\\" aria-label=\\\"Permalink to &quot;数值的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"二进制和八进制表示法\\\" tabindex=\\\"-1\\\">二进制和八进制表示法 <a class=\\\"header-anchor\\\" href=\\\"#二进制和八进制表示法\\\" aria-label=\\\"Permalink to &quot;二进制和八进制表示法&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES6 提供了二进制和八进制数值的新的写法，分别用前缀<code>0b</code>（或<code>0B</code>）和<code>0o</code>（或<code>0O</code>）表示。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">0b111110111</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> ===</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 503</span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\"> // true</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">0o767</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> ===</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 503</span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\"> // true</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br></div></div>\",\"capture\":\"二进制和八进制表示法\\nES6 提供了二进制和八进制数值的新的写法，分别用前缀`0b`（或`0B`）和`0o`（或`0O`）表示。\\n```javascript\\n0b111110111 === 503 // true\\n0o767 === 503 // true\\n```\\n从 ES5 开始，在严格模式之中，八进制就不再允许使用前缀`0`表示，ES6 进一步明确，要使用前缀`0o`表示。\\n```javascript\\n// 非严格模式\\n(function(){\\n  console.log(0o11 === 011);\\n})() // true\\n// 严格模式\\n(function(){\\n  'use str\"},{\"url\":\"/《ES6 教程》笔记/08.函数的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/08.函数的扩展.html\",\"frontmatter\":{\"title\":\"函数的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/8ed309d668b20264\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"函数的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"函数的扩展\\\" tabindex=\\\"-1\\\">函数的扩展 <a class=\\\"header-anchor\\\" href=\\\"#函数的扩展\\\" aria-label=\\\"Permalink to &quot;函数的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"函数参数的默认值\\\" tabindex=\\\"-1\\\">函数参数的默认值 <a class=\\\"header-anchor\\\" href=\\\"#函数参数的默认值\\\" aria-label=\\\"Permalink to &quot;函数参数的默认值&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"基本用法\\\" tabindex=\\\"-1\\\">基本用法 <a class=\\\"header-anchor\\\" href=\\\"#基本用法\\\" aria-label=\\\"Permalink to &quot;基本用法&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">function</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#E36209;--shiki-dark:#FFAB70\\\">x</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#E36209;--shiki-dark:#FFAB70\\\">y</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">) {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">  y </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> y </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">||</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> 'World'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">  console.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(x, y);</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'Hello'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">) </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// Hello World</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'Hello'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'China'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">) </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// Hello China</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'Hello'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">''</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">) </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// Hello World</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br><span class=\\\"line-number\\\">8</span><br></div></div>\",\"capture\":\"函数参数的默认值\\n 基本用法\\nES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。\\n```javascript\\nfunction log(x, y) {\\n  y = y || 'World';\\n  console.log(x, y);\\n}\\nlog('Hello') // Hello World\\nlog('Hello', 'China') // Hello China\\nlog('Hello', '') // Hello World\\n```\\n上面代码检查函数`log`的参数`y`有没有赋值，如果没有，则指定默认值为`World`。这种写法的缺点在于，如果参数`y`赋值了，但是对应的布\"},{\"url\":\"/《ES6 教程》笔记/09.数组的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/09.数组的扩展.html\",\"frontmatter\":{\"title\":\"数组的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/e34009d60d8bc4b2\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"数组的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"数组的扩展\\\" tabindex=\\\"-1\\\">数组的扩展 <a class=\\\"header-anchor\\\" href=\\\"#数组的扩展\\\" aria-label=\\\"Permalink to &quot;数组的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"扩展运算符\\\" tabindex=\\\"-1\\\">扩展运算符 <a class=\\\"header-anchor\\\" href=\\\"#扩展运算符\\\" aria-label=\\\"Permalink to &quot;扩展运算符&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"含义\\\" tabindex=\\\"-1\\\">含义 <a class=\\\"header-anchor\\\" href=\\\"#含义\\\" aria-label=\\\"Permalink to &quot;含义&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>扩展运算符（spread）是三个点（<code>...</code>）。它好比 rest 参数的逆运算，<strong>将一个数组转为用逗号分隔的参数序列</strong>。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">console.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">...</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">[</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">3</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">])</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// 1 2 3</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">console.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">...</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">[</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">3</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">4</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">], </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">5</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">)</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// 1 2 3 4 5</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">[</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">...</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">document.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">querySelectorAll</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'div'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">)]</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// [&#x3C;div>, &#x3C;div>, &#x3C;div>]</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br><span class=\\\"line-number\\\">8</span><br></div></div>\",\"capture\":\"扩展运算符\\n 含义\\n扩展运算符（spread）是三个点（`...`）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。\\n```javascript\\nconsole.log(...[1, 2, 3])\\n// 1 2 3\\nconsole.log(1, ...[2, 3, 4], 5)\\n// 1 2 3 4 5\\n[...document.querySelectorAll('div')]\\n// [&lt;div\\n```\\n该运算符主要用于函数调用。\\n```javascript\\nfunction push(array, ...items) {\\n  array.push(...items\"},{\"url\":\"/《ES6 教程》笔记/10.对象的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/10.对象的扩展.html\",\"frontmatter\":{\"title\":\"对象的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/b5e3e0a0ff6e9c25\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"对象的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"对象的扩展\\\" tabindex=\\\"-1\\\">对象的扩展 <a class=\\\"header-anchor\\\" href=\\\"#对象的扩展\\\" aria-label=\\\"Permalink to &quot;对象的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>对象（object）是 JavaScript 最重要的数据结构。ES6 对它进行了重大升级，本章介绍数据结构本身的改变，下一章介绍<code>Object</code>对象的新增方法。</p>\\n\",\"capture\":\"对象（object）是 JavaScript 最重要的数据结构。ES6 对它进行了重大升级，本章介绍数据结构本身的改变，下一章介绍`Object`对象的新增方法。\\n 属性的简洁表示法\\nES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。\\n```javascript\\nconst foo = 'bar';\\nconst baz = {foo};\\nbaz // {foo: \\\"bar\\\"}\\n// 等同于\\nconst baz = {foo: foo};\\n```\\n上面代码中，变量`foo`直接写在大括号里面。这时，属性名就是变量名, 属性值就是变量值。下面是另一个例子。\\n`\"},{\"url\":\"/《ES6 教程》笔记/11.对象的新增方法.html\",\"relativePath\":\"/《ES6 教程》笔记/11.对象的新增方法.html\",\"frontmatter\":{\"title\":\"对象的新增方法\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/e85e68947502cf90\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"对象的新增方法\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"对象的新增方法\\\" tabindex=\\\"-1\\\">对象的新增方法 <a class=\\\"header-anchor\\\" href=\\\"#对象的新增方法\\\" aria-label=\\\"Permalink to &quot;对象的新增方法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>本章介绍 Object 对象的新增方法。</p>\\n<h2 id=\\\"object-is\\\" tabindex=\\\"-1\\\">Object.is() <a class=\\\"header-anchor\\\" href=\\\"#object-is\\\" aria-label=\\\"Permalink to &quot;Object.is()&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES5 比较两个值是否相等，只有两个运算符：相等运算符（<code>==</code>）和严格相等运算符（<code>===</code>）。它们都有缺点，前者会自动转换数据类型，后者的<code>NaN</code>不等于自身，以及<code>+0</code>等于<code>-0</code>。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</p>\\n<p>ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。<code>Object.is</code>就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</p>\\n\",\"capture\":\"本章介绍 Object 对象的新增方法。\\n Object.is()\\nES5 比较两个值是否相等，只有两个运算符：相等运算符（`==`）和严格相等运算符（`===`）。它们都有缺点，前者会自动转换数据类型，后者的`NaN`不等于自身，以及`+0`等于`-0`。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。\\nES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。`Object.is`就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。\\n```javascript\\nObject.\"},{\"url\":\"/《ES6 教程》笔记/12.Symbol.html\",\"relativePath\":\"/《ES6 教程》笔记/12.Symbol.html\",\"frontmatter\":{\"title\":\"Symbol\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/02c86eb2792f3262\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Symbol\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"symbol\\\" tabindex=\\\"-1\\\">Symbol <a class=\\\"header-anchor\\\" href=\\\"#symbol\\\" aria-label=\\\"Permalink to &quot;Symbol&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，<strong>保证每个属性的名字都是独一无二</strong>的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入<code>Symbol</code>的原因。</p>\\n\",\"capture\":\"概述\\nES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入`Symbol`的原因。\\nES6 引入了一种新的原始数据类型`Symbol`，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：`undefined`、`null`、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。\\nSymbol 值\"},{\"url\":\"/《ES6 教程》笔记/13.Set 和 Map 数据结构.html\",\"relativePath\":\"/《ES6 教程》笔记/13.Set 和 Map 数据结构.html\",\"frontmatter\":{\"title\":\"Set 和 Map 数据结构\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/0c21dae358fca16b\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Set 和 Map 数据结构\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"set-和-map-数据结构\\\" tabindex=\\\"-1\\\">Set 和 Map 数据结构 <a class=\\\"header-anchor\\\" href=\\\"#set-和-map-数据结构\\\" aria-label=\\\"Permalink to &quot;Set 和 Map 数据结构&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"set\\\" tabindex=\\\"-1\\\">Set <a class=\\\"header-anchor\\\" href=\\\"#set\\\" aria-label=\\\"Permalink to &quot;Set&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"基本用法\\\" tabindex=\\\"-1\\\">基本用法 <a class=\\\"header-anchor\\\" href=\\\"#基本用法\\\" aria-label=\\\"Permalink to &quot;基本用法&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>ES6 提供了新的数据结构 Set。它<strong>类似于数组，但是成员的值都是唯一的，没有重复的值</strong>。</p>\\n<p><strong><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构</strong>。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">const</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> s</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> =</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> new</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> Set</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">();</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">[</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">3</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">5</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">4</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">5</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">].</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">forEach</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#E36209;--shiki-dark:#FFAB70\\\">x</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> =></span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> s.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">add</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(x));</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">for</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> (</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> i </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">of</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> s) {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">  console.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(i);</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// 2 3 5 4</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br><span class=\\\"line-number\\\">8</span><br></div></div>\",\"capture\":\"Set\\n 基本用法\\nES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。\\n`Set`本身是一个构造函数，用来生成 Set 数据结构。\\n```javascript\\nconst s = new Set();\\n[2, 3, 5, 4, 5, 2, 2].forEach(x =\\nfor (let i of s) {\\n  console.log(i);\\n}\\n// 2 3 5 4\\n```\\n上面代码通过`add()`方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。\\n`Set`函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参\"},{\"url\":\"/《ES6 教程》笔记/14.Proxy.html\",\"relativePath\":\"/《ES6 教程》笔记/14.Proxy.html\",\"frontmatter\":{\"title\":\"Proxy\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/f56ec2ab97d60483\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Proxy\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"proxy\\\" tabindex=\\\"-1\\\">Proxy <a class=\\\"header-anchor\\\" href=\\\"#proxy\\\" aria-label=\\\"Permalink to &quot;Proxy&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“<strong>元编程</strong>”（meta programming），即<strong>对编程语言进行编程</strong>。</p>\\n<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，<strong>外界对该对象的访问，都必须先通过这层拦截</strong>，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>\\n\",\"capture\":\"概述\\nProxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。\\nProxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。\\n```javascript\\nvar obj = new Proxy({}, {\\n  get: function (target, propKey, receiver) {\\n    console.log(\"},{\"url\":\"/《ES6 教程》笔记/15.Reflect.html\",\"relativePath\":\"/《ES6 教程》笔记/15.Reflect.html\",\"frontmatter\":{\"title\":\"Reflect\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/74de3e45e4491e95\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Reflect\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"reflect\\\" tabindex=\\\"-1\\\">Reflect <a class=\\\"header-anchor\\\" href=\\\"#reflect\\\" aria-label=\\\"Permalink to &quot;Reflect&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p><code>Reflect</code>对象与<code>Proxy</code>对象一样，也是 ES6 为了操作对象而提供的新 API。<code>Reflect</code>对象的设计目的有这样几个。</p>\\n<p>（1） **将<code>Object</code>对象的一些明显属于语言内部的方法（比如<code>Object.defineProperty</code>），放到<code>Reflect</code>对象上。**现阶段，某些方法同时在<code>Object</code>和<code>Reflect</code>对象上部署，未来的新方法将只部署在<code>Reflect</code>对象上。也就是说，从<code>Reflect</code>对象上可以拿到语言内部的方法。</p>\\n\",\"capture\":\"概述\\n`Reflect`对象与`Proxy`对象一样，也是 ES6 为了操作对象而提供的新 API。`Reflect`对象的设计目的有这样几个。\\n（1） 将`Object`对象的一些明显属于语言内部的方法（比如`Object.defineProperty`），放到`Reflect`对象上。现阶段，某些方法同时在`Object`和`Reflect`对象上部署，未来的新方法将只部署在`Reflect`对象上。也就是说，从`Reflect`对象上可以拿到语言内部的方法。\\n（2） 修改某些`Object`方法的返回结果，让其变得更合理。比如，`Object.defineProperty(obj, na\"},{\"url\":\"/《ES6 教程》笔记/16.Promise 对象.html\",\"relativePath\":\"/《ES6 教程》笔记/16.Promise 对象.html\",\"frontmatter\":{\"title\":\"Promise 对象\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/2810ae8985e9bd52\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Promise 对象\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"promise-对象\\\" tabindex=\\\"-1\\\">Promise 对象 <a class=\\\"header-anchor\\\" href=\\\"#promise-对象\\\" aria-label=\\\"Permalink to &quot;Promise 对象&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"promise-的含义\\\" tabindex=\\\"-1\\\">Promise 的含义 <a class=\\\"header-anchor\\\" href=\\\"#promise-的含义\\\" aria-label=\\\"Permalink to &quot;Promise 的含义&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了<code>Promise</code>对象。</p>\\n\",\"capture\":\"Promise 的含义\\nPromise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了`Promise`对象。\\n所谓`Promise`，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。\\n`Promise`对象有以下两个特点。\\n（1）对象的状态不受外界影响。`Promise`对象代表一个异步操作，有三种状态：`pe\"},{\"url\":\"/《ES6 教程》笔记/17.Iterator 和 for-of 循环.html\",\"relativePath\":\"/《ES6 教程》笔记/17.Iterator 和 for-of 循环.html\",\"frontmatter\":{\"title\":\"Iterator 和 for-of 循环\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/48df907ad3570f3d\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Iterator 和 for-of 循环\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"iterator-和-for-of-循环\\\" tabindex=\\\"-1\\\">Iterator 和 for...of 循环 <a class=\\\"header-anchor\\\" href=\\\"#iterator-和-for-of-循环\\\" aria-label=\\\"Permalink to &quot;Iterator 和 for...of 循环&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"iterator-遍历器-的概念\\\" tabindex=\\\"-1\\\">Iterator（遍历器）的概念 <a class=\\\"header-anchor\\\" href=\\\"#iterator-遍历器-的概念\\\" aria-label=\\\"Permalink to &quot;Iterator（遍历器）的概念&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>JavaScript 原有的表示“集合”的数据结构，主要是数组（<code>Array</code>）和对象（<code>Object</code>），ES6 又添加了<code>Map</code>和<code>Set</code>。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是<code>Map</code>，<code>Map</code>的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。</p>\\n\",\"capture\":\"Iterator（遍历器）的概念\\nJavaScript 原有的表示“集合”的数据结构，主要是数组（`Array`）和对象（`Object`），ES6 又添加了`Map`和`Set`。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是`Map`，`Map`的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。\\n遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。\\nIterator 的作用有三个：一是为各\"},{\"url\":\"/《ES6 教程》笔记/18.Generator 函数的语法.html\",\"relativePath\":\"/《ES6 教程》笔记/18.Generator 函数的语法.html\",\"frontmatter\":{\"title\":\"Generator 函数的语法\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/718b48ed9ce0adce\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Generator 函数的语法\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"generator-函数的语法\\\" tabindex=\\\"-1\\\">Generator 函数的语法 <a class=\\\"header-anchor\\\" href=\\\"#generator-函数的语法\\\" aria-label=\\\"Permalink to &quot;Generator 函数的语法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"基本概念\\\" tabindex=\\\"-1\\\">基本概念 <a class=\\\"header-anchor\\\" href=\\\"#基本概念\\\" aria-label=\\\"Permalink to &quot;基本概念&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>Generator 函数是 ES6 提供的一种<strong>异步编程解决方案</strong>，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《Generator 函数的异步应用》一章。</p>\\n\",\"capture\":\"简介\\n 基本概念\\nGenerator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《Generator 函数的异步应用》一章。\\nGenerator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。\\n执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。\\n形式上，Generator 函数是一个\"},{\"url\":\"/《ES6 教程》笔记/19.Generator 函数的异步应用.html\",\"relativePath\":\"/《ES6 教程》笔记/19.Generator 函数的异步应用.html\",\"frontmatter\":{\"title\":\"Generator 函数的异步应用\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/75af7031eb66847b\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Generator 函数的异步应用\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"generator-函数的异步应用\\\" tabindex=\\\"-1\\\">Generator 函数的异步应用 <a class=\\\"header-anchor\\\" href=\\\"#generator-函数的异步应用\\\" aria-label=\\\"Permalink to &quot;Generator 函数的异步应用&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>异步编程对 JavaScript 语言太重要。JavaScript 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。本章主要介绍 Generator 函数如何完成异步操作。</p>\\n\",\"capture\":\"异步编程对 JavaScript 语言太重要。JavaScript 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。本章主要介绍 Generator 函数如何完成异步操作。\\n 传统方法\\nES6 诞生以前，异步编程的方法，大概有下面四种。\\n- 回调函数\\n- 事件监听\\n- 发布/订阅\\n- Promise 对象\\nGenerator 函数将 JavaScript 异步编程带入了一个全新的阶段。\\n 基本概念\\n 异步\\n所谓\\\"异步\\\"，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。\\n比如，有一个任\"},{\"url\":\"/《ES6 教程》笔记/20.async 函数.html\",\"relativePath\":\"/《ES6 教程》笔记/20.async 函数.html\",\"frontmatter\":{\"title\":\"async 函数\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/3777253e65bac487\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"async 函数\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"async-函数\\\" tabindex=\\\"-1\\\">async 函数 <a class=\\\"header-anchor\\\" href=\\\"#async-函数\\\" aria-label=\\\"Permalink to &quot;async 函数&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"含义\\\" tabindex=\\\"-1\\\">含义 <a class=\\\"header-anchor\\\" href=\\\"#含义\\\" aria-label=\\\"Permalink to &quot;含义&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p>\\n<p>async 函数是什么？一句话，它就<strong>是 Generator 函数的语法糖</strong>。</p>\\n<p>前文有一个 Generator 函数，依次读取两个文件。</p>\\n\",\"capture\":\"含义\\nES2017 标准引入了 async 函数，使得异步操作变得更加方便。\\nasync 函数是什么？一句话，它就是 Generator 函数的语法糖。\\n前文有一个 Generator 函数，依次读取两个文件。\\n```javascript\\nconst fs = require('fs');\\nconst readFile = function (fileName) {\\n  return new Promise(function (resolve, reject) {\\n    fs.readFile(fileName, function(error, data) {\\n      if (error\"},{\"url\":\"/《ES6 教程》笔记/21.Class 的基本语法.html\",\"relativePath\":\"/《ES6 教程》笔记/21.Class 的基本语法.html\",\"frontmatter\":{\"title\":\"Class 的基本语法\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/e831e1593c82bbe0\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Class 的基本语法\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"class-的基本语法\\\" tabindex=\\\"-1\\\">Class 的基本语法 <a class=\\\"header-anchor\\\" href=\\\"#class-的基本语法\\\" aria-label=\\\"Permalink to &quot;Class 的基本语法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"类的由来\\\" tabindex=\\\"-1\\\">类的由来 <a class=\\\"header-anchor\\\" href=\\\"#类的由来\\\" aria-label=\\\"Permalink to &quot;类的由来&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">function</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> Point</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#E36209;--shiki-dark:#FFAB70\\\">x</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#E36209;--shiki-dark:#FFAB70\\\">y</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">) {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">  this</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.x </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> x;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">  this</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.y </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> y;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">Point</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">prototype</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">toString</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> =</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> function</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> () {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">  return</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> '('</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> +</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> this</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.x </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">+</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> ', '</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> +</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> this</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.y </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">+</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> ')'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">};</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">var</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> p </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> new</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> Point</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">);</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br><span class=\\\"line-number\\\">8</span><br><span class=\\\"line-number\\\">9</span><br><span class=\\\"line-number\\\">10</span><br></div></div>\",\"capture\":\"简介\\n 类的由来\\nJavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。\\n```javascript\\nfunction Point(x, y) {\\n  this.x = x;\\n  this.y = y;\\n}\\nPoint.prototype.toString = function () {\\n  return '(' + this.x + ', ' + this.y + ')';\\n};\\nvar p = new Point(1, 2);\\n```\\n上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。\\nES6 提供\"},{\"url\":\"/《ES6 教程》笔记/22.Class 的继承.html\",\"relativePath\":\"/《ES6 教程》笔记/22.Class 的继承.html\",\"frontmatter\":{\"title\":\"Class 的继承\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/83f8c3a0cd87dd83\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Class 的继承\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"class-的继承\\\" tabindex=\\\"-1\\\">Class 的继承 <a class=\\\"header-anchor\\\" href=\\\"#class-的继承\\\" aria-label=\\\"Permalink to &quot;Class 的继承&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>Class 可以通过<code>extends</code>关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">class</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> Point</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">class</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> ColorPoint</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> extends</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> Point</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br></div></div>\",\"capture\":\"简介\\nClass 可以通过`extends`关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。\\n```javascript\\nclass Point {\\n}\\nclass ColorPoint extends Point {\\n}\\n```\\n上面代码定义了一个`ColorPoint`类，该类通过`extends`关键字，继承了`Point`类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个`Point`类。下面，我们在`ColorPoint`内部加上代码。\\n```javascript\\nclass ColorPoint extends Point \"},{\"url\":\"/《ES6 教程》笔记/23.Module 的语法.html\",\"relativePath\":\"/《ES6 教程》笔记/23.Module 的语法.html\",\"frontmatter\":{\"title\":\"Module 的语法\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/efe2fb04eb8ac5fb\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Module 的语法\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"module-的语法\\\" tabindex=\\\"-1\\\">Module 的语法 <a class=\\\"header-anchor\\\" href=\\\"#module-的语法\\\" aria-label=\\\"Permalink to &quot;Module 的语法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的<code>require</code>、Python 的<code>import</code>，甚至就连 CSS 都有<code>@import</code>，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p>\\n\",\"capture\":\"概述\\n历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的`require`、Python 的`import`，甚至就连 CSS 都有`@import`，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。\\n在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD \"},{\"url\":\"/《ES6 教程》笔记/24.Module 的加载实现.html\",\"relativePath\":\"/《ES6 教程》笔记/24.Module 的加载实现.html\",\"frontmatter\":{\"title\":\"Module 的加载实现\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/a79ca2e64ceae213\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Module 的加载实现\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"module-的加载实现\\\" tabindex=\\\"-1\\\">Module 的加载实现 <a class=\\\"header-anchor\\\" href=\\\"#module-的加载实现\\\" aria-label=\\\"Permalink to &quot;Module 的加载实现&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>上一章介绍了模块的语法，本章介绍如何在浏览器和 Node.js 之中加载 ES6 模块，以及实际开发中经常遇到的一些问题（比如循环加载）。</p>\\n\",\"capture\":\"上一章介绍了模块的语法，本章介绍如何在浏览器和 Node.js 之中加载 ES6 模块，以及实际开发中经常遇到的一些问题（比如循环加载）。\\n 浏览器加载\\n 传统方法\\nHTML 网页中，浏览器通过`&lt;script\\n```html\\n&lt;!-- 页面内嵌的脚本 --&gt;\\n&lt;script type=\\\"application/javascript\\\"&gt;\\n  // module code\\n&lt;/script&gt;\\n&lt;!-- 外部脚本 --&gt;\\n&lt;script type=\\\"application/javascript\\\" src=\\\"path/to/myModule\"},{\"url\":\"/《ES6 教程》笔记/25.编程风格.html\",\"relativePath\":\"/《ES6 教程》笔记/25.编程风格.html\",\"frontmatter\":{\"title\":\"编程风格\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/984bf549204bb266\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"编程风格\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"编程风格\\\" tabindex=\\\"-1\\\">编程风格 <a class=\\\"header-anchor\\\" href=\\\"#编程风格\\\" aria-label=\\\"Permalink to &quot;编程风格&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>本章探讨如何将 ES6 的新语法，运用到编码实践之中，与传统的 JavaScript 语法结合在一起，写出合理的、易于阅读和维护的代码。</p>\\n<p>多家公司和组织已经公开了它们的风格规范，下面的内容主要参考了 <a href=\\\"https://github.com/airbnb/javascript\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">Airbnb</a> 公司的 JavaScript 风格规范。</p>\\n\",\"capture\":\"本章探讨如何将 ES6 的新语法，运用到编码实践之中，与传统的 JavaScript 语法结合在一起，写出合理的、易于阅读和维护的代码。\\n多家公司和组织已经公开了它们的风格规范，下面的内容主要参考了 Airbnb 公司的 JavaScript 风格规范。\\n 块级作用域\\n（1）let 取代 var\\nES6 提出了两个新的声明变量的命令：`let`和`const`。其中，`let`完全可以取代`var`，因为两者语义相同，而且`let`没有副作用。\\n```javascript\\n'use strict';\\nif (true) {\\n  let x = 'hello';\\n}\\nfor (let i = 0\"},{\"url\":\"/《ES6 教程》笔记/26.读懂 ECMAScript 规格.html\",\"relativePath\":\"/《ES6 教程》笔记/26.读懂 ECMAScript 规格.html\",\"frontmatter\":{\"title\":\"读懂 ECMAScript 规格\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/32c35f7651d6e58e\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"读懂 ECMAScript 规格\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"读懂-ecmascript-规格\\\" tabindex=\\\"-1\\\">读懂 ECMAScript 规格 <a class=\\\"header-anchor\\\" href=\\\"#读懂-ecmascript-规格\\\" aria-label=\\\"Permalink to &quot;读懂 ECMAScript 规格&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>规格文件是计算机语言的官方标准，详细描述语法规则和实现方法。</p>\\n<p>一般来说，没有必要阅读规格，除非你要写编译器。因为规格写得非常抽象和精炼，又缺乏实例，不容易理解，而且对于解决实际的应用问题，帮助不大。但是，如果你遇到疑难的语法问题，实在找不到答案，这时可以去查看规格文件，了解语言标准是怎么说的。规格是解决问题的“最后一招”。</p>\\n\",\"capture\":\"概述\\n规格文件是计算机语言的官方标准，详细描述语法规则和实现方法。\\n一般来说，没有必要阅读规格，除非你要写编译器。因为规格写得非常抽象和精炼，又缺乏实例，不容易理解，而且对于解决实际的应用问题，帮助不大。但是，如果你遇到疑难的语法问题，实在找不到答案，这时可以去查看规格文件，了解语言标准是怎么说的。规格是解决问题的“最后一招”。\\n这对 JavaScript 语言很有必要。因为它的使用场景复杂，语法规则不统一，例外很多，各种运行环境的行为不一致，导致奇怪的语法问题层出不穷，任何语法书都不可能囊括所有情况。查看规格，不失为一种解决语法问题的最可靠、最权威的终极方法。\\n本章介绍如何读懂 ECMASc\"},{\"url\":\"/《ES6 教程》笔记/27.异步遍历器.html\",\"relativePath\":\"/《ES6 教程》笔记/27.异步遍历器.html\",\"frontmatter\":{\"title\":\"异步遍历器\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/16121351be68691b\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"异步遍历器\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"异步遍历器\\\" tabindex=\\\"-1\\\">异步遍历器 <a class=\\\"header-anchor\\\" href=\\\"#异步遍历器\\\" aria-label=\\\"Permalink to &quot;异步遍历器&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"同步遍历器的问题\\\" tabindex=\\\"-1\\\">同步遍历器的问题 <a class=\\\"header-anchor\\\" href=\\\"#同步遍历器的问题\\\" aria-label=\\\"Permalink to &quot;同步遍历器的问题&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>《遍历器》一章说过，Iterator 接口是一种数据遍历的协议，只要调用遍历器对象的<code>next</code>方法，就会得到一个对象，表示当前遍历指针所在的那个位置的信息。<code>next</code>方法返回的对象的结构是<code>{value, done}</code>，其中<code>value</code>表示当前的数据的值，<code>done</code>是一个布尔值，表示遍历是否结束。</p>\\n\",\"capture\":\"同步遍历器的问题\\n《遍历器》一章说过，Iterator 接口是一种数据遍历的协议，只要调用遍历器对象的`next`方法，就会得到一个对象，表示当前遍历指针所在的那个位置的信息。`next`方法返回的对象的结构是`{value, done}`，其中`value`表示当前的数据的值，`done`是一个布尔值，表示遍历是否结束。\\n```javascript\\nfunction idMaker() {\\n  let index = 0;\\n  return {\\n    next: function() {\\n      return { value: index++, done: false };\\n    }\"},{\"url\":\"/《ES6 教程》笔记/28.ArrayBuffer.html\",\"relativePath\":\"/《ES6 教程》笔记/28.ArrayBuffer.html\",\"frontmatter\":{\"title\":\"ArrayBuffer\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/a2ba314746bfdbdd\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"ArrayBuffer\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"arraybuffer\\\" tabindex=\\\"-1\\\">ArrayBuffer <a class=\\\"header-anchor\\\" href=\\\"#arraybuffer\\\" aria-label=\\\"Permalink to &quot;ArrayBuffer&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><code>ArrayBuffer</code>对象、<code>TypedArray</code>视图和<code>DataView</code>视图是 JavaScript 操作二进制数据的一个接口。这些对象早就存在，属于独立的规格（2011 年 2 月发布），ES6 将它们纳入了 ECMAScript 规格，并且增加了新的方法。它们都是以数组的语法处理二进制数据，所以统称为二进制数组。</p>\\n\",\"capture\":\"`ArrayBuffer`对象、`TypedArray`视图和`DataView`视图是 JavaScript 操作二进制数据的一个接口。这些对象早就存在，属于独立的规格（2011 年 2 月发布），ES6 将它们纳入了 ECMAScript 规格，并且增加了新的方法。它们都是以数组的语法处理二进制数据，所以统称为二进制数组。\\n这个接口的原始设计目的，与 WebGL 项目有关。所谓 WebGL，就是指浏览器与显卡之间的通信接口，为了满足 JavaScript 与显卡之间大量的、实时的数据交换，它们之间的数据通信必须是二进制的，而不能是传统的文本格式。文本格式传递一个 32 位整数，两端的 Ja\"},{\"url\":\"/01.前端/25.JavaScript文章/07.js随机打乱数组.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/07.js随机打乱数组.html\",\"frontmatter\":{\"title\":\"JS随机打乱数组\",\"date\":\"2020-02-08 17:42:03\",\"permalink\":\"/pages/40b4db2d38ba85f2\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"JS随机打乱数组\",\"date\":\"2020-02-08 17:42:03\",\"capture\":\"```js\\nfunction shuffle(arr) { // 随机打乱数组\\n  let _arr = arr.slice() // 调用数组副本，不改变原数组\\n  for (let i = 0; i &lt; _arr.length; i++) {\\n    let j = getRandomInt(0, i)\\n    let t = _arr[i]\\n    _arr[i] = _arr[j]\\n    _arr[j] = t\\n  }\\n  return _arr\\n}\\nfunction getRandomInt(min, max) { // 获取min到max的一个随机数，包含min和max本身\"},{\"url\":\"/《Vue》笔记/01.基础/35.列表渲染之数组、对象更新检测.html\",\"relativePath\":\"/《Vue》笔记/01.基础/35.列表渲染之数组、对象更新检测.html\",\"frontmatter\":{\"title\":\"列表渲染之数组、对象更新检测\",\"date\":\"2020-02-05 13:09:06\",\"permalink\":\"/pages/04783a6691cc9d06\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"列表渲染之数组、对象更新检测\",\"date\":\"2020-02-05 13:09:06\",\"excerpt\":\"<h1 id=\\\"列表渲染之数组、对象更新检测\\\" tabindex=\\\"-1\\\">列表渲染之数组、对象更新检测 <a class=\\\"header-anchor\\\" href=\\\"#列表渲染之数组、对象更新检测\\\" aria-label=\\\"Permalink to &quot;列表渲染之数组、对象更新检测&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/list.html#%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">数组更新检测API</a> <a href=\\\"https://cn.vuejs.org/v2/guide/list.html#%E5%AF%B9%E8%B1%A1%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">对象更新检测API</a></p>\\n<h2 id=\\\"数组更新检测\\\" tabindex=\\\"-1\\\">数组更新检测 <a class=\\\"header-anchor\\\" href=\\\"#数组更新检测\\\" aria-label=\\\"Permalink to &quot;数组更新检测&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h4 id=\\\"变异方法-mutation-method\\\" tabindex=\\\"-1\\\">变异方法 (mutation method) <a class=\\\"header-anchor\\\" href=\\\"#变异方法-mutation-method\\\" aria-label=\\\"Permalink to &quot;变异方法 (mutation method)&quot;\\\">&ZeroWidthSpace;</a></h4>\\n<p>Vue 将被侦听的数组的变异方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：</p>\\n\",\"capture\":\"数组更新检测API 对象更新检测API\\n 数组更新检测\\n 变异方法 (mutation method)\\nVue 将被侦听的数组的变异方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：\\n- `push()`末尾添加\\n- `pop()`末尾删除\\n- `shift()` 首位删除\\n- `unshift() ` 首位添加\\n- `splice()` 拼合\\n- `sort()` 排序\\n- `reverse()` 反转\\n数组实例方法\\n 替换数组\\n变异方法，顾名思义，会改变调用了这些方法的原始数组。相比之下，也有非变异 (non-mutating method) 方法，例如 `filter(\"},{\"url\":\"/《Vue》笔记/01.基础/30.v-if vs v-show.html\",\"relativePath\":\"/《Vue》笔记/01.基础/30.v-if vs v-show.html\",\"frontmatter\":{\"title\":\"v-if vs v-show\",\"date\":\"2020-02-04 17:32:23\",\"permalink\":\"/pages/73e4064340277b05\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"v-if vs v-show\",\"date\":\"2020-02-04 17:32:23\",\"excerpt\":\"<h1 id=\\\"v-if-vs-v-show\\\" tabindex=\\\"-1\\\">v-if vs v-show <a class=\\\"header-anchor\\\" href=\\\"#v-if-vs-v-show\\\" aria-label=\\\"Permalink to &quot;v-if vs v-show&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/conditional.html#v-if-vs-v-show\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">API</a></p>\\n<p><code>v-if</code> 根据渲染条件决定是否把元素渲染到DOM页面，而<code>v-show</code>不管渲染条件是什么，都会把元素渲染到DOM页面，只是简单的切换CSS的显示隐藏。</p>\\n\",\"capture\":\"API\\n`v-if` 根据渲染条件决定是否把元素渲染到DOM页面，而`v-show`不管渲染条件是什么，都会把元素渲染到DOM页面，只是简单的切换CSS的显示隐藏。\\n如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好。\"},{\"url\":\"/《Vue》笔记/01.基础/20.计算属性 vs 方法 vs 侦听属性.html\",\"relativePath\":\"/《Vue》笔记/01.基础/20.计算属性 vs 方法 vs 侦听属性.html\",\"frontmatter\":{\"title\":\"计算属性 vs 方法 vs 侦听属性\",\"date\":\"2020-02-04 16:37:51\",\"permalink\":\"/pages/351f72ecd9c41129\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"计算属性 vs 方法 vs 侦听属性\",\"date\":\"2020-02-04 16:37:51\",\"excerpt\":\"<h1 id=\\\"计算属性-vs-方法-vs-侦听属性\\\" tabindex=\\\"-1\\\">计算属性 vs 方法 vs 侦听属性 <a class=\\\"header-anchor\\\" href=\\\"#计算属性-vs-方法-vs-侦听属性\\\" aria-label=\\\"Permalink to &quot;计算属性 vs 方法 vs 侦听属性&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/computed.html#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%BC%93%E5%AD%98-vs-%E6%96%B9%E6%B3%95\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">API</a></p>\\n<p>如果一个功能同时可以使用计算属性(computed)、方法(methods)、侦听属性(watch)来实现的时候推荐使用计算属性。</p>\\n\",\"capture\":\"API\\n如果一个功能同时可以使用计算属性(computed)、方法(methods)、侦听属性(watch)来实现的时候推荐使用计算属性。\\n| 计算属性                                 | 方法                                               | 侦听属性                                     |\\n| ---------------------------------------- | --------------------------------------------------\"},{\"url\":\"/《Vue》笔记/01.基础/10.生命周期.html\",\"relativePath\":\"/《Vue》笔记/01.基础/10.生命周期.html\",\"frontmatter\":{\"title\":\"生命周期\",\"date\":\"2020-02-04 15:06:59\",\"permalink\":\"/pages/176808a1b5f843b8\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"生命周期\",\"date\":\"2020-02-04 15:06:59\",\"excerpt\":\"<h1 id=\\\"实例生命周期钩子\\\" tabindex=\\\"-1\\\">实例生命周期钩子 <a class=\\\"header-anchor\\\" href=\\\"#实例生命周期钩子\\\" aria-label=\\\"Permalink to &quot;实例生命周期钩子&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/instance.html#%E5%AE%9E%E4%BE%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">实例生命周期钩子API</a></p>\\n<p>简单理解，生命周期钩子函数就是vue实例在某一个时间点会自动执行的函数。</p>\\n\",\"capture\":\"实例生命周期钩子API\\n简单理解，生命周期钩子函数就是vue实例在某一个时间点会自动执行的函数。\\n```html\\n&lt;div id=\\\"app\\\"\\n&lt;script src=\\\"https://cdn.bootcss.com/vue/2.4.2/vue.js\\\"&gt;&lt;/script&gt;\\n&lt;script&gt;\\n  var vm = new Vue({\\n    el: 'app',\\n    data: {\\n      msg: 'Vue的生命周期'\\n    },\\n    beforeCreate: function() {\\n      console.group('-----\"},{\"url\":\"/《Vue》笔记/06.规模化/140.路由懒加载.html\",\"relativePath\":\"/《Vue》笔记/06.规模化/140.路由懒加载.html\",\"frontmatter\":{\"title\":\"路由懒加载\",\"date\":\"2020-02-04 13:20:20\",\"permalink\":\"/pages/38ecac9a9b92f037\",\"categories\":[\"《Vue》笔记\",\"规模化\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"路由懒加载\",\"date\":\"2020-02-04 13:20:20\",\"capture\":\"```js\\n// 路由同步加载\\n// import Recommend from '@/components/recommend/recommend'\\n// import Singer from '@/components/singer/singer'\\n// import Rank from '@/components/rank/rank'\\n// import Search from '@/components/search/search'\\n// import SingerDetail from '@/components/singer-detail/singer-detail'\\n// imp\"},{\"url\":\"/《Vue》笔记/03.过渡&动画/120.transition-group列表过渡.html\",\"relativePath\":\"/《Vue》笔记/03.过渡&动画/120.transition-group列表过渡.html\",\"frontmatter\":{\"title\":\"transition-group列表过渡\",\"date\":\"2020-02-04 13:17:42\",\"permalink\":\"/pages/0aa92922ace6bb5e\",\"categories\":[\"《Vue》笔记\",\"过渡&动画\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"transition-group列表过渡\",\"date\":\"2020-02-04 13:17:42\",\"excerpt\":\"<h1 id=\\\"transition-group列表过渡\\\" tabindex=\\\"-1\\\">transition-group列表过渡 <a class=\\\"header-anchor\\\" href=\\\"#transition-group列表过渡\\\" aria-label=\\\"Permalink to &quot;transition-group列表过渡&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"列表的进入-离开过渡\\\" tabindex=\\\"-1\\\">列表的进入/离开过渡 <a class=\\\"header-anchor\\\" href=\\\"#列表的进入-离开过渡\\\" aria-label=\\\"Permalink to &quot;列表的进入/离开过渡&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<div class=\\\"language-html vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">html</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">&#x3C;</span><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">transition-group</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> tag</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"ul\\\"</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">> </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">&#x3C;!--tag转为ul--></span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">    &#x3C;</span><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">li</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> v-for</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"item in list\\\"</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> :key</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"item\\\"</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">>{{item}}&#x3C;/</span><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">li</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">> </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">&#x3C;!--子元素要有key--></span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">&#x3C;/</span><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">transition-group</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">></span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br></div></div><p><strong>注意</strong>：列表元素一定要有<code>key</code></p>\\n\",\"capture\":\"列表的进入/离开过渡\\n```html\\n&lt;transition-group tag=\\\"ul\\\"\\n    &lt;li v-for=\\\"item in list\\\" :key=\\\"item\\\"&gt;{{item}}&lt;/li&gt; &lt;!--子元素要有key--&gt;\\n&lt;/transition-group&gt;\\n```\\n注意：列表元素一定要有`key`\\n```css\\n.v-enter,.v-leave-to{\\n  opacity: 0;\\n  transform: translateX(30px);\\n}\\n.v-enter-active,.v-leave-active{\\n  tran\"},{\"url\":\"/《Vue》笔记/03.过渡&动画/110.transition过渡&动画.html\",\"relativePath\":\"/《Vue》笔记/03.过渡&动画/110.transition过渡&动画.html\",\"frontmatter\":{\"title\":\"transition过渡&动画\",\"date\":\"2020-02-04 13:16:19\",\"permalink\":\"/pages/184a96b493a97078\",\"categories\":[\"《Vue》笔记\",\"过渡&动画\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"transition过渡&动画\",\"date\":\"2020-02-04 13:16:19\",\"excerpt\":\"<h1 id=\\\"transition过渡-动画\\\" tabindex=\\\"-1\\\">transition过渡&amp;动画 <a class=\\\"header-anchor\\\" href=\\\"#transition过渡-动画\\\" aria-label=\\\"Permalink to &quot;transition过渡&amp;动画&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/transitions.html\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">API</a></p>\\n<h2 id=\\\"使用\\\" tabindex=\\\"-1\\\">使用 <a class=\\\"header-anchor\\\" href=\\\"#使用\\\" aria-label=\\\"Permalink to &quot;使用&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>需要设置动画的元素或组件要在外边包裹一个<code>&lt;transition&gt;</code>标签，设置自定义的<code>name</code>，vue会根据元素的切换（进入/离开）过程添加相应的css类名，你可以<strong>自由地使用css类名来设置css过渡&amp;动画</strong>。</p>\\n\",\"capture\":\"API\\n 使用\\n需要设置动画的元素或组件要在外边包裹一个`&lt;transition\\n 过渡的类名\\n在进入/离开的过渡中，会有 6 个 class 切换。\\n各类名的生命周期\\n* 进入\\n  * `v-enter` 只存在于第一帧\\n  * `v-enter-active` 第一帧到最后一帧，结束后移除\\n  * `v-enter-to` 第二帧到最后一帧，结束后移除\\n* 离开\\n  * `v-leave` 只存在于第一帧\\n  * `v-leave-active` 第一帧到最后一帧，结束后移除\\n  * `v-leave-to` 第二帧到最后一帧，结束后移除\\n如果你使用一个没有`name`的`&lt;t\"},{\"url\":\"/《Vue》笔记/06.规模化/100.vuex操作相关.html\",\"relativePath\":\"/《Vue》笔记/06.规模化/100.vuex操作相关.html\",\"frontmatter\":{\"title\":\"vuex操作相关\",\"date\":\"2020-02-04 13:15:19\",\"permalink\":\"/pages/d9d62d6ab8ff99a6\",\"categories\":[\"《Vue》笔记\",\"规模化\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"vuex操作相关\",\"date\":\"2020-02-04 13:15:19\",\"capture\":\"```js\\nimport { mapActions, mapMutations, mapGetters } from 'vuex'\\ncomputed: {\\n    ...mapGetters([ // 获取数据，内部为数组\\n        'searchHistory' // 相当于在data插入searchHistory和获取到的数据\\n    ])\\n},\\nmethods: {\\n\\t某方法(){\\n\\t  this.saveSearchHistory(传入值)\\n\\t},\\n\\t...mapActions([ // 提交actions修改数据，内部为数组 因为actions文件已对方法进行了封装所有是数组类\"},{\"url\":\"/《Vue》笔记/99.其他/90.操作本地缓存.html\",\"relativePath\":\"/《Vue》笔记/99.其他/90.操作本地缓存.html\",\"frontmatter\":{\"title\":\"操作本地缓存\",\"date\":\"2020-02-04 13:14:19\",\"permalink\":\"/pages/30a94dbe96873b33\",\"categories\":[\"《Vue》笔记\",\"其他\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"操作本地缓存\",\"date\":\"2020-02-04 13:14:19\",\"capture\":\"&lt;https://github.com/ustbhuangyi/storage\\n操作 sessionStorage 和 localStorage 。\"},{\"url\":\"/《Vue》笔记/99.其他/80.Vue中的防抖函数封装和使用.html\",\"relativePath\":\"/《Vue》笔记/99.其他/80.Vue中的防抖函数封装和使用.html\",\"frontmatter\":{\"title\":\"Vue中的防抖函数封装和使用\",\"date\":\"2020-02-04 13:10:19\",\"permalink\":\"/pages/fb08e252dfd8fdfd\",\"categories\":[\"《Vue》笔记\",\"其他\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Vue中的防抖函数封装和使用\",\"date\":\"2020-02-04 13:10:19\",\"capture\":\"Vue中的防抖函数封装和使用\\n如搜索框中，每改变一个数值就请求一次搜索接口，当快速的改变数值时并不需要多次请求接口，这就需要一个防抖函数：\\n```js\\n// 防抖函数\\nexport function debounce(func, delay) { // func 函数 delay间隔时间\\n  let timer\\n  return function (...args) {\\n    if (timer) {\\n      clearTimeout(timer)\\n    }\\n    timer = setTimeout(() =\\n      func.apply(this, args)\\n    }, \"},{\"url\":\"/《Vue》笔记/02.组件/70.父组件调用子组件方法并传入值.html\",\"relativePath\":\"/《Vue》笔记/02.组件/70.父组件调用子组件方法并传入值.html\",\"frontmatter\":{\"title\":\"父组件调用子组件方法并传入值\",\"date\":\"2020-02-04 13:06:37\",\"permalink\":\"/pages/2e24dab728769e0c\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"父组件调用子组件方法并传入值\",\"date\":\"2020-02-04 13:06:37\",\"capture\":\"通过`ref`引用调用子组件内的方法并传入参数\\n父组件：\\n```js\\n&lt;子组件标签  ref=\\\"refName\\\"\\nmethods: {\\n    fnX(x) {\\n      this.$refs.refName.fnY(x) // 调用子组件方法并传入值\\n    }\\n}\\n```\\n子组件：\\n```js\\nmethods: {\\n    fnY(x) {\\n      this.x = x\\n    }\\n  }\\n}\\n```\"},{\"url\":\"/《Vue》笔记/02.组件/60.兄弟组件传值.html\",\"relativePath\":\"/《Vue》笔记/02.组件/60.兄弟组件传值.html\",\"frontmatter\":{\"title\":\"兄弟组件传值\",\"date\":\"2020-02-04 13:04:32\",\"permalink\":\"/pages/809f4582d9ca9552\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"兄弟组件传值\",\"date\":\"2020-02-04 13:04:32\",\"capture\":\"子组件1中把值传到父组件,父组件获取值传入子组件2\\n父组件：\\n```js\\n&lt;子组件1 @方法名x=\\\"方法名y\\\"\\n&lt;子组件2 :值名称x=\\\"值x\\\"&gt;&lt;/子组件2 &gt;\\ndata() {\\n\\treturn {\\n\\t 值x: ''\\n\\t}\\n},\\nmethods: {\\n\\t方法名y(值) {\\n\\t\\tthis.值x = 值\\n\\t}\\n}\\n```\\n子组件1：\\n```js\\nthis.$emit('方法名x', 值) // 传出值\\n```\\n子组件2：\\n```js\\nprops: {\\n    值名称x: { // 接收父组件传入值\\n        type: String,\\n        defa\"},{\"url\":\"/《Vue》笔记/02.组件/50.子组件派发事件和值给父组件.html\",\"relativePath\":\"/《Vue》笔记/02.组件/50.子组件派发事件和值给父组件.html\",\"frontmatter\":{\"title\":\"子组件派发事件和值给父组件\",\"date\":\"2020-02-04 12:56:51\",\"permalink\":\"/pages/0f19a1bcac14fd41\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"子组件派发事件和值给父组件\",\"date\":\"2020-02-04 12:56:51\",\"excerpt\":\"<h1 id=\\\"子组件派发事件和值给父组件\\\" tabindex=\\\"-1\\\">子组件派发事件和值给父组件 <a class=\\\"header-anchor\\\" href=\\\"#子组件派发事件和值给父组件\\\" aria-label=\\\"Permalink to &quot;子组件派发事件和值给父组件&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/components.html#%E7%9B%91%E5%90%AC%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">API</a></p>\\n<p>子组件通过<code>$emit</code>派发事件和值给父组件（值可以有多个）</p>\\n<div class=\\\"language-js vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">js</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">this</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">$emit</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'fnX'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, value)</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br></div></div>\",\"capture\":\"API\\n子组件通过`$emit`派发事件和值给父组件（值可以有多个）\\n```js\\nthis.$emit('fnX', value)\\n```\\n父组件通过`v-on`绑定子组件派发的事件，并触发一个新的事件，新的事件内可以接收传来的值\\n```js\\n&lt;ComponentName @fnX=\\\"fnY\\\"\\nmethods: {\\n\\tfnY(value) {\\n\\t\\tconsole.log(value)\\n\\t}\\n}\\n```\\n 父子组件间传递数据 demo\\n&lt;p class=\\\"codepen\\\" data-height=\\\"400\\\" data-theme-id=\\\"light\\\" data-default-tab\"},{\"url\":\"/《Vue》笔记/02.组件/40.父组件给子组件传值.html\",\"relativePath\":\"/《Vue》笔记/02.组件/40.父组件给子组件传值.html\",\"frontmatter\":{\"title\":\"父组件给子组件传值\",\"date\":\"2020-02-04 12:45:30\",\"permalink\":\"/pages/07b384c2e6232e07\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"父组件给子组件传值\",\"date\":\"2020-02-04 12:45:30\",\"excerpt\":\"<h1 id=\\\"父组件给子组件传值\\\" tabindex=\\\"-1\\\">父组件给子组件传值 <a class=\\\"header-anchor\\\" href=\\\"#父组件给子组件传值\\\" aria-label=\\\"Permalink to &quot;父组件给子组件传值&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>父组件中，通过给子组件标签v-bind绑定属性的方式传入值</p>\\n<div class=\\\"language-html vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">html</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">&#x3C;</span><span style=\\\"--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic\\\">ComponentName</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> v-bind:name</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"value\\\"</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">>&#x3C;/</span><span style=\\\"--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic\\\">ComponentName</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">></span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br></div></div><blockquote>\\n<p>如果不使用v-bind传入的值为字符串，使用v-bind绑定传入的值为表达式。</p>\\n</blockquote>\\n\",\"capture\":\"父组件中，通过给子组件标签v-bind绑定属性的方式传入值\\n```html\\n&lt;ComponentName v-bind:name=\\\"value\\\"\\n```\\n&gt; 如果不使用v-bind传入的值为字符串，使用v-bind绑定传入的值为表达式。\\n子组件中，通过props对象接收值\\n```js\\n props: {\\n    name: { // 接收父组件传入值\\n        type: String || ...,\\n        default: ''\\n    }\\n }\\n```\\n 单向数据流\\n所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向\"},{\"url\":\"/《Vue》笔记/01.基础/00.MVVM模式.html\",\"relativePath\":\"/《Vue》笔记/01.基础/00.MVVM模式.html\",\"frontmatter\":{\"title\":\"MVVM模式\",\"date\":\"2020-02-04 12:19:00\",\"permalink\":\"/pages/114158caa9e96df0\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"MVVM模式\",\"date\":\"2020-02-04 12:19:00\",\"excerpt\":\"<div class=\\\"tip custom-block\\\"><p class=\\\"custom-block-title\\\">TIP</p>\\n<p>说明：本章内容是博主的Vue学习笔记，以<a href=\\\"https://cn.vuejs.org/v2/guide/\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">官方文档</a>为准。</p>\\n</div>\\n<h1 id=\\\"mvvm模式\\\" tabindex=\\\"-1\\\">MVVM模式 <a class=\\\"header-anchor\\\" href=\\\"#mvvm模式\\\" aria-label=\\\"Permalink to &quot;MVVM模式&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>MVVM模式，<code>M</code>即 model，数据模型；<code>V</code>即 view，视图；<code>VM</code>即 view-model，视图模型。</p>\\n\",\"capture\":\"说明：本章内容是博主的Vue学习笔记，以官方文档为准。\\n MVVM模式\\nMVVM模式，`M`即 model，数据模型；`V`即 view，视图；`VM`即 view-model，视图模型。\\n理解\\n首先，数据Model通过Data Bindings把数据绑定在View视图上，\\n当View视图有交互（有改变）的时候，Dom listeners会自动监听，然后更新数据Model。\\nQ：什么是MVVM模式？\\nA：MVVM模式，第一个M代表数据模型，V代表视图，VM代表视图模型；\\n它的实际操作原理是：后台数据通过视图模型来渲染视图，就是页面。当用户在页面上进行操作的时候，\\n视图模型会自动监听到用户的操作\"},{\"url\":\"/《ES6 教程》笔记/01.ECMAScript 6 简介.html\",\"relativePath\":\"/《ES6 教程》笔记/01.ECMAScript 6 简介.html\",\"frontmatter\":{\"title\":\"ECMAScript 6 简介\",\"date\":\"2020-01-12 15:45:35\",\"permalink\":\"/pages/f344d070a1031ef7\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"ECMAScript 6 简介\",\"date\":\"2020-01-12 15:45:35\",\"excerpt\":\"<blockquote>\\n<p>说明：本章内容为博主在原教程基础上添加自己的学习笔记，来源<a href=\\\"http://es6.ruanyifeng.com/\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">http://es6.ruanyifeng.com/</a>，教程版权归原作者所有。</p>\\n</blockquote>\\n<h1 id=\\\"ecmascript-6-简介\\\" tabindex=\\\"-1\\\">ECMAScript 6 简介 <a class=\\\"header-anchor\\\" href=\\\"#ecmascript-6-简介\\\" aria-label=\\\"Permalink to &quot;ECMAScript 6 简介&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p>\\n\",\"capture\":\"ECMAScript 6 简介\\nECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。\\n ECMAScript 和 JavaScript 的关系\\n一个常见的问题是，ECMAScript 和 JavaScript 到底是什么关系？\\n要讲清楚这个问题，需要回顾历史。1996 年 11 月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给标准化组织 ECMA，希望这种语言能够成为国际标\"},{\"url\":\"/《JavaScript教程》笔记/01.基础.html\",\"relativePath\":\"/《JavaScript教程》笔记/01.基础.html\",\"frontmatter\":{\"title\":\"基础\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/0796ba76b4b55368\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"基础\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"基础篇\\n 一、JS的一些名词概念\\n 什么是作用域？\\n变量存在的范围。\\n可分为全局作用域和函数作用域，ES6新增块级作用域。\\n 什么是闭包？\\n闭包就是能够读取其他函数内部变量的函数。\\n* 闭包的形式：函数内部定义函数\\n* 本质上闭包就是将函数内部和外部连接起来的一座桥梁\\n闭包的作用：\\n* 可以读取函数内部变量\\n* 让这些变量始终保持在内存中，即闭包可以使得它诞生的环境一直存在。\\n*  封装对象的私有属性和私有方法\\n 什么是构造函数？\\n用于构造(生成)实例的一个函数，使实例拥有构造函数内定于的属性和方法。\\n 什么是实例对象？\\n实例对象就是通过new 构造函数生成的，拥有构造函数内定于的属性和方法的\"},{\"url\":\"/《JavaScript教程》笔记/02.内置对象.html\",\"relativePath\":\"/《JavaScript教程》笔记/02.内置对象.html\",\"frontmatter\":{\"title\":\"内置对象\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/74d2ab3fbfeaaa68\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"内置对象\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"内置对象篇\\n 一、Object对象\\n 1、概述\\nJavaScript 原生提供`Object`对象（注意起首的`O`是大写），本章介绍该对象原生的各种方法。\\nJavaScript 的所有其他对象都继承自`Object`对象，即那些对象都是`Object`的实例。\\n`Object`对象的原生方法分成两类：`Object`本身的方法与`Object`的实例方法。\\n（1）Object对象本身的方法\\n所谓“本身的方法”就是直接定义在`Object`对象的方法。\\n```js\\nObject.print = function (o) { console.log(o) };\\n```\\n上面代码中，`print`\"},{\"url\":\"/《JavaScript教程》笔记/03.面向对象.html\",\"relativePath\":\"/《JavaScript教程》笔记/03.面向对象.html\",\"frontmatter\":{\"title\":\"面向对象\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/659b5af5e2e704e0\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"面向对象\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"面向对象编程\\n 一、实例对象与new命令\\n 1、对象是什么\\n面向对象编程（Object Oriented Programming，缩写为 OOP）是目前主流的编程范式。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。\\n每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务。对象可以复用，通过继承机制还可以定制。因此，面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程（procedural programming），更适合多人合作的大型软件项目。\\n那么，“对象”\"},{\"url\":\"/《JavaScript教程》笔记/04.异步操作.html\",\"relativePath\":\"/《JavaScript教程》笔记/04.异步操作.html\",\"frontmatter\":{\"title\":\"异步操作\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/d61b1cb4cdac1f63\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"异步操作\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"异步操作\\n 一、异步操作概述\\n 1、单线程模型\\n单线程模型指的是，JavaScript 只在一个线程上运行。也就是说，JavaScript 同时只能执行一个任务，其他任务都必须在后面排队等待。\\n注意，JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合。\\nJavaScript 之所以采用单线程，而不是多线程，跟历史有关系。JavaScript 从诞生起就是单线程，原因是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对\"},{\"url\":\"/《JavaScript教程》笔记/05.DOM.html\",\"relativePath\":\"/《JavaScript教程》笔记/05.DOM.html\",\"frontmatter\":{\"title\":\"DOM\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/7d961b8030c6099e\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"DOM\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"DOM\\n 一、概述\\n 1、DOM\\nDOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。\\n浏览器会根据 DOM 模型，将结构化文档（比如 HTML 和 XML）解析成一系列的节点，再由这些节点组成一个树状结构（DOM Tree）。所有的节点和最终的树状结构，都有规范的对外接口。\\nDOM 只是一个接口规范，可以用各种语言实现。所以严格地说，DOM 不是 JavaScript 语法的一部分，但是 DOM 操作是 JavaScript 最\"},{\"url\":\"/《JavaScript教程》笔记/06.事件.html\",\"relativePath\":\"/《JavaScript教程》笔记/06.事件.html\",\"frontmatter\":{\"title\":\"事件\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/10b2761db5a8e089\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"事件\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"事件\\n 一、EventTarget 接口\\n 事件的本质是程序各个组成部分之间的一种通信方式，也是异步编程的一种实现。DOM 支持大量的事件，本章开始介绍 DOM 的事件编程。\\n 1、概述\\nDOM 的事件操作（监听和触发），都定义在`EventTarget`接口。所有节点对象都部署了这个接口，其他一些需要事件通信的浏览器内置对象（比如，`XMLHttpRequest`、`AudioNode`、`AudioContext`）也部署了这个接口。\\n该接口主要提供三个实例方法。\\n- `addEventListener`：绑定事件的监听函数\\n- `removeEventListener`：移除事件的监听函\"},{\"url\":\"/《JavaScript教程》笔记/07.浏览器模型.html\",\"relativePath\":\"/《JavaScript教程》笔记/07.浏览器模型.html\",\"frontmatter\":{\"title\":\"浏览器模型\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/bab4930124ad2c10\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"浏览器模型\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"一、浏览器环境概述\\nJavaScript 是浏览器的内置脚本语言。也就是说，浏览器内置了 JavaScript 引擎，并且提供各种接口，让 JavaScript 脚本可以控制浏览器的各种功能。一旦网页内嵌了 JavaScript 脚本，浏览器加载网页，就会去执行脚本，从而达到操作浏览器的目的，实现网页的各种动态效果。\\n本章开始介绍浏览器提供的各种 JavaScript 接口。首先，介绍 JavaScript 代码嵌入网页的方法。\\n 1、代码嵌入网页的方法\\n网页中嵌入 JavaScript 代码，主要有三种方法。\\n- `  &lt;script\\n- `  &lt;script&gt;  `标签加\"},{\"url\":\"/01.前端/25.JavaScript文章/08.判断是否为移动端浏览器.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/08.判断是否为移动端浏览器.html\",\"frontmatter\":{\"title\":\"判断是否为移动端浏览器\",\"date\":\"2020-01-04 15:25:11\",\"permalink\":\"/pages/40f623be692cf8bc\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"判断是否为移动端浏览器\",\"date\":\"2020-01-04 15:25:11\",\"capture\":\"```js\\nconst flag = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);\\nif(flag){\\n    // 移动端\\n} else {\\n    // PC端\\n}\\n```\"},{\"url\":\"/04.更多/01.学习/03.提高记忆的技巧.html\",\"relativePath\":\"/04.更多/01.学习/03.提高记忆的技巧.html\",\"frontmatter\":{\"title\":\"提高记忆的技巧\",\"date\":\"2020-01-03 14:34:48\",\"permalink\":\"/pages/996822b2a2ca6e3b\",\"categories\":[\"更多\",\"学习\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"提高记忆的技巧\",\"date\":\"2020-01-03 14:34:48\",\"excerpt\":\"<h1 id=\\\"提高记忆的技巧\\\" tabindex=\\\"-1\\\">提高记忆的技巧 <a class=\\\"header-anchor\\\" href=\\\"#提高记忆的技巧\\\" aria-label=\\\"Permalink to &quot;提高记忆的技巧&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<ol>\\n<li><strong>多个感官并用</strong>\\n记忆时调用一切感官。没人的话可以大声阅读，有人的话可以默念，轻微摇晃手指等，有助于保持专注。</li>\\n</ol>\\n\",\"capture\":\"1. 多个感官并用\\n   记忆时调用一切感官。没人的话可以大声阅读，有人的话可以默念，轻微摇晃手指等，有助于保持专注。\\n   \\n2. 重复记忆\\n   每天留出半个到一个小时，梳理总结今天所学的内容。每一章复习完成后做系统的知识整理。\\n   \\n3. 建立关联\\n   把你所学的新知识与已有的认知建立联系，对于记忆事半功倍。\\n   \\n4. 场景记忆\\n   把知识具象化为一个场景，想象自己在何时何地能用这些知识，与自身发生联系。\\n   \\n5. 提出问题\\n   每学习一个知识点，试着提问，然后给出答案。用了就记住了。\"},{\"url\":\"/03.技术/03.博客搭建/03.GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床.html\",\"relativePath\":\"/03.技术/03.博客搭建/03.GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床.html\",\"frontmatter\":{\"title\":\"GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床\",\"date\":\"2020-01-03 12:55:43\",\"permalink\":\"/pages/a5f73af5185fdf0a\",\"categories\":[\"技术\",\"博客搭建\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床\",\"date\":\"2020-01-03 12:55:43\",\"excerpt\":\"<h1 id=\\\"github-jsdelivr-tinypng-picgo-打造稳定快速、高效免费图床\\\" tabindex=\\\"-1\\\">GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床 <a class=\\\"header-anchor\\\" href=\\\"#github-jsdelivr-tinypng-picgo-打造稳定快速、高效免费图床\\\" aria-label=\\\"Permalink to &quot;GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"前言\\\" tabindex=\\\"-1\\\">前言 <a class=\\\"header-anchor\\\" href=\\\"#前言\\\" aria-label=\\\"Permalink to &quot;前言&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p><strong>Q：为什么要使用图床呢？什么是图床？</strong></p>\\n<p>A：写博客文章时，图片的上传和存放是一个问题，有的朋友可能会把图片放到和博客同一个仓库当中，使用相对路径来引用，这样后期维护起来会比较麻烦。还有的朋友会在不同的平台发布同一篇文章，这样一来每个平台都要上传图片，为了解决这些问题，比较推荐的做法是把图片统一上传到一个在线的第三方静态资源库中，我们把这个资源库称为图床，其返回一个图片的URL，使用<code>markdown+图片url</code>的方式写作文章，一次编写，到处使用~</p>\\n\",\"capture\":\"前言\\nQ：为什么要使用图床呢？什么是图床？\\nA：写博客文章时，图片的上传和存放是一个问题，有的朋友可能会把图片放到和博客同一个仓库当中，使用相对路径来引用，这样后期维护起来会比较麻烦。还有的朋友会在不同的平台发布同一篇文章，这样一来每个平台都要上传图片，为了解决这些问题，比较推荐的做法是把图片统一上传到一个在线的第三方静态资源库中，我们把这个资源库称为图床，其返回一个图片的URL，使用`markdown+图片url`的方式写作文章，一次编写，到处使用~\\n以下内容是比较旧的，现在我发现一个更好用，配置更方便的图床工具：&lt;https://picx.xpoet.cn/\\n使用方法看一下他网站的使\"},{\"url\":\"/03.技术/02.Nodejs/01.nodejs递归读取所有文件.html\",\"relativePath\":\"/03.技术/02.Nodejs/01.nodejs递归读取所有文件.html\",\"frontmatter\":{\"title\":\"nodejs递归读取所有文件\",\"date\":\"2019-12-26 15:57:32\",\"permalink\":\"/pages/117708e0af7f0bd9\",\"categories\":[\"技术\",\"Nodejs\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"nodejs递归读取所有文件\",\"date\":\"2019-12-26 15:57:32\",\"capture\":\"```js\\nvar fs = require('fs');\\nvar path = require('path');\\n \\nfunction readFileList(dir, filesList = []) {\\n    const files = fs.readdirSync(dir);\\n    console.log(files);\\n    files.forEach((item, index) =\\n        var fullPath = path.join(dir, item);\\n        const stat = fs.statSync(fullPath);\\n        i\"},{\"url\":\"/01.前端/25.JavaScript文章/02.new命令原理.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/02.new命令原理.html\",\"frontmatter\":{\"title\":\"new命令原理\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/8143cc480faf9a11\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"new命令原理\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"new命令原理\\\" tabindex=\\\"-1\\\">new命令原理 <a class=\\\"header-anchor\\\" href=\\\"#new命令原理\\\" aria-label=\\\"Permalink to &quot;new命令原理&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>使用new命令时，它后面的函数依次执行下面的步骤：</p>\\n<ol>\\n<li>创建一个空对象，作为将要返回的实例对象。</li>\\n<li>将这个空对象的原型，指向构造函数的prototype属性。</li>\\n<li>将这个空对象赋值给函数内部的this关键字。</li>\\n<li>开始执行构造函数内部的代码。</li>\\n<li>如果构造函数内有返回值且为对象类型，则返回该对象，否则返回上面创建的实例对象。</li>\\n</ol>\\n\",\"capture\":\"使用new命令时，它后面的函数依次执行下面的步骤：\\n1. 创建一个空对象，作为将要返回的实例对象。\\n2. 将这个空对象的原型，指向构造函数的prototype属性。\\n3. 将这个空对象赋值给函数内部的this关键字。\\n4. 开始执行构造函数内部的代码。\\n5. 如果构造函数内有返回值且为对象类型，则返回该对象，否则返回上面创建的实例对象。\\n```js\\n// 构造函数\\nfunction Person(name,age){\\n    this.name = name\\n    this.age = age\\n}\\n// 自定义_new\\nfunction _new() {\\n  // 将 arguments 对\"},{\"url\":\"/01.前端/25.JavaScript文章/04.ES6面向对象.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/04.ES6面向对象.html\",\"frontmatter\":{\"title\":\"ES6面向对象\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/1f4123be6f45abcd\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"ES6面向对象\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```js\\n//面向对象封装\\nclass Student{ //定义类 (尊从首字母大写的约定)\\n    constructor(props){  // 构造函数 （构造函数内定于属性）\\n        this.name = props.name || '匿名'; // 默认'匿名'\\n      this.grade = props.grade || 1;\\n    }\\n    hello(){ // 在构造函数的原型上定义方法\\n        console.log(`你好,${this.name}同学，你在${this.grade}年级`);\\n    }\\n}\\n//使用\\nfunction c\"},{\"url\":\"/01.前端/25.JavaScript文章/06.多种数组去重性能对比.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/06.多种数组去重性能对比.html\",\"frontmatter\":{\"title\":\"多种数组去重性能对比\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/e808fba1fa8fbab2\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"多种数组去重性能对比\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"测试模板\\n```js\\n// 创建一个 1 ~ 10w 的数组，Array.from为ES6语法\\nlet arr1 = Array.from(new Array(1000000), (x, index) =\\n  return index\\n})\\nlet arr2 = Array.from(new Array(500000), (x, index) =&gt; {\\n  return index + index\\n})\\nlet start = new Date().getTime()\\nconsole.log('开始数组去重')\\n// 数组去重\\nfunction distinct(a, b) {\\n  le\"},{\"url\":\"/01.前端/40.学习笔记/40.小程序笔记.html\",\"relativePath\":\"/01.前端/40.学习笔记/40.小程序笔记.html\",\"frontmatter\":{\"title\":\"小程序笔记\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/note/wx-miniprogram/\",\"tags\":[\"小程序\"],\"categories\":[\"前端\",\"学习笔记\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"小程序笔记\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"小程序笔记\\n 基础课程部分\\n 微信公众平台\\n&lt;https://mp.weixin.qq.com/\\n注册时可选择类型：订阅号、服务号、小程序、企业微信\\n每个邮箱仅能注册一个小程序。\\n个人类型小程序：无法使用微信支付、无法使用卡包功能\\n 小程序文档API\\n小程序开发文档\\n 微信开放社区\\n微信开发社区\\n 目录说明\\n默认目录\\npages-----------------------页面相关\\n​\\tindex  ----------------- 首页文件夹\\n​\\t\\tindex.js ------------首页js\\n​\\t\\tindex.json---------首页配置\\n​\\t\\tindex.wxml--\"},{\"url\":\"/02.页面/20.CSS/01.flex布局语法.html\",\"relativePath\":\"/02.页面/20.CSS/01.flex布局语法.html\",\"frontmatter\":{\"title\":\"flex布局语法\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/0a83b083bdf257cb\",\"author\":{\"name\":\"阮一峰\"},\"categories\":[\"页面\",\"CSS\"],\"tags\":[null]},\"author\":{\"name\":\"阮一峰\"},\"title\":\"flex布局语法\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"flex布局语法\\\" tabindex=\\\"-1\\\">flex布局语法 <a class=\\\"header-anchor\\\" href=\\\"#flex布局语法\\\" aria-label=\\\"Permalink to &quot;flex布局语法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"一、flex-布局是什么\\\" tabindex=\\\"-1\\\">一、flex 布局是什么？ <a class=\\\"header-anchor\\\" href=\\\"#一、flex-布局是什么\\\" aria-label=\\\"Permalink to &quot;一、flex 布局是什么？&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>Flex是 Flexible Box 的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性。</p>\\n<p><strong>任何一个容器</strong> 都可以指定为 Flex 布局。</p>\\n\",\"capture\":\"一、flex 布局是什么？\\nFlex是 Flexible Box 的缩写，意为\\\"弹性布局\\\"，用来为盒状模型提供最大的灵活性。\\n任何一个容器 都可以指定为 Flex 布局。\\n```css\\n.box{\\n  display: flex;\\n}\\n```\\n行内元素 也可以使用 Flex 布局。\\n```css\\n.box{\\n  display: inline-flex;\\n}\\n```\\nWebkit 内核的浏览器，必须加上`-webkit`前缀。\\n```css\\n.box{\\n  display: -webkit-flex; /* Safari */\\n  display: flex;\\n}\\n```\\n注意，设为 Flex\"},{\"url\":\"/02.页面/20.CSS/02.flex布局案例-基础.html\",\"relativePath\":\"/02.页面/20.CSS/02.flex布局案例-基础.html\",\"frontmatter\":{\"title\":\"flex布局案例-基础\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/ea6db1530c42ad51\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"flex布局案例-基础\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"``` html\\n&lt;html&gt;\\n  &lt;div class=\\\"box\\\"&gt;\\n    &lt;span&gt;1&lt;/span&gt;\\n    &lt;span&gt;2&lt;/span&gt;\\n    &lt;span&gt;3&lt;/span&gt;\\n    &lt;span&gt;4&lt;/span&gt;\\n    &lt;span&gt;5&lt;/span&gt;\\n    &lt;span&gt;6&lt;/span&gt;\\n    &lt;span&gt;7&lt;/span&gt;\\n  &lt;/div&gt;\\n&lt;/html&gt;\\n&lt;st\"},{\"url\":\"/02.页面/20.CSS/03.flex布局案例-骰子.html\",\"relativePath\":\"/02.页面/20.CSS/03.flex布局案例-骰子.html\",\"frontmatter\":{\"title\":\"flex布局案例-骰子\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/eff61bc8b4f4695d\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"flex布局案例-骰子\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```html\\n&lt;html&gt;\\n  &lt;div class=\\\"box2\\\"&gt;\\n    &lt;div class=\\\"first-face\\\"&gt;\\n      &lt;span class=\\\"pip\\\"&gt;&lt;/span&gt;\\n    &lt;/div&gt;\\n    &lt;div class=\\\"second-face\\\"&gt;\\n      &lt;span class=\\\"pip\\\"&gt;&lt;/span&gt;\\n      &lt;span class=\\\"pip\\\"&gt;&lt;/span&gt;\\n    &lt;/div&gt;\\n    &lt;div cla\"},{\"url\":\"/02.页面/20.CSS/04.flex布局案例-圣杯布局.html\",\"relativePath\":\"/02.页面/20.CSS/04.flex布局案例-圣杯布局.html\",\"frontmatter\":{\"title\":\"flex布局案例-圣杯布局\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/df9e7c7214fa5046\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"flex布局案例-圣杯布局\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```html\\n&lt;html&gt;\\n  &lt;div class=\\\"HolyGrail\\\"&gt;\\n    &lt;header&gt;header&lt;/header&gt;\\n    &lt;div class=\\\"wrap\\\"&gt;\\n      &lt;nav class=\\\"left\\\"&gt;left 宽度固定200px&lt;/nav&gt;\\n      &lt;main class=\\\"content\\\"&gt;center 宽度自适应&lt;/main&gt;\\n      &lt;aside class=\\\"right\\\"&gt;right 宽度固定200px&lt;/aside&gt\"},{\"url\":\"/02.页面/20.CSS/05.flex布局案例-网格布局.html\",\"relativePath\":\"/02.页面/20.CSS/05.flex布局案例-网格布局.html\",\"frontmatter\":{\"title\":\"flex布局案例-网格布局\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/85b5a3fe218a34b7\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"flex布局案例-网格布局\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```html\\n&lt;html&gt;\\n  &lt;div class=\\\"grid\\\"&gt;\\n    &lt;div class=\\\"grid-cell\\\"&gt;1/2&lt;/div&gt;\\n    &lt;div class=\\\"grid-cell\\\"&gt;1/2&lt;/div&gt;\\n  &lt;/div&gt;\\n  &lt;div class=\\\"grid\\\"&gt;\\n    &lt;div class=\\\"grid-cell\\\"&gt;1/3&lt;/div&gt;\\n    &lt;div class=\\\"grid-cell\\\"&gt;1/3&lt;/div&gt;\\n    &lt;div cl\"},{\"url\":\"/02.页面/20.CSS/06.flex布局案例-输入框布局.html\",\"relativePath\":\"/02.页面/20.CSS/06.flex布局案例-输入框布局.html\",\"frontmatter\":{\"title\":\"flex布局案例-输入框布局\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/05cc577fb51c7998\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"flex布局案例-输入框布局\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```html\\n&lt;html&gt;\\n  &lt;div class=\\\"InputAddOn\\\"&gt;\\n    &lt;span class=\\\"InputAddOn-item\\\"&gt;icon&lt;/span&gt;\\n    &lt;input class=\\\"InputAddOn-field\\\" placeholder=\\\"input宽度自适应\\\"&gt;\\n    &lt;button class=\\\"InputAddOn-item\\\"&gt;提交&lt;/button&gt;\\n  &lt;/div&gt;\\n  &lt;br/&gt;\\n  &lt;div class=\\\"Media\\\"&gt;\\n   \"},{\"url\":\"/02.页面/20.CSS/07.CSS3之transition过渡.html\",\"relativePath\":\"/02.页面/20.CSS/07.CSS3之transition过渡.html\",\"frontmatter\":{\"title\":\"CSS3之transition过渡\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/02d7f59d98d87409\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"CSS3之transition过渡\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"html结构\\n```html\\n&lt;div class=\\\"box1\\\"\\n  &lt;div class=\\\"div1\\\"&gt;&lt;/div&gt;\\n  &lt;div class=\\\"div2\\\"&gt;&lt;/div&gt;\\n  &lt;div class=\\\"div3\\\"&gt;&lt;/div&gt;\\n&lt;/div&gt;\\n```\\n先给元素设置transition过渡，指定样式和时间，这里设置all全部样式都采用0.3s的过渡\\n```css\\n.box1&gt;div{\\n  /* 给元素所有变化都添加过渡动画, 也可以指定唯一的过渡样式属性*/\\n  transition: all .3s;\"},{\"url\":\"/02.页面/20.CSS/08.CSS3之animation动画.html\",\"relativePath\":\"/02.页面/20.CSS/08.CSS3之animation动画.html\",\"frontmatter\":{\"title\":\"CSS3之animation动画\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/c2c0432138f6e042\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"CSS3之animation动画\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```html\\n&lt;html&gt;\\n  &lt;div class=\\\"animationBox\\\"&gt;\\n    &lt;div class=\\\"rotate\\\"&gt;旋转动画1&lt;/div&gt;\\n    &lt;div class=\\\"play\\\"&gt;\\n      &lt;div class=\\\"img\\\"&gt;旋转动画2&lt;/div&gt;\\n      &lt;span&gt;&lt;p class=\\\"p2\\\"&gt;&lt;/p&gt;&lt;/span&gt;\\n      &lt;span&gt;&lt;p&gt;&lt;/p&gt;&lt;/span&gt;\\n      &\"},{\"url\":\"/03.技术/01.技术文档/01.Git使用手册.html\",\"relativePath\":\"/03.技术/01.技术文档/01.Git使用手册.html\",\"frontmatter\":{\"title\":\"Git使用手册\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/9a7ee40fc232253e\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git使用手册\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"git使用手册\\\" tabindex=\\\"-1\\\">Git使用手册 <a class=\\\"header-anchor\\\" href=\\\"#git使用手册\\\" aria-label=\\\"Permalink to &quot;Git使用手册&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"安装\\\" tabindex=\\\"-1\\\">安装 <a class=\\\"header-anchor\\\" href=\\\"#安装\\\" aria-label=\\\"Permalink to &quot;安装&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>官网下载：<a href=\\\"https://git-scm.com/downloads\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">https://git-scm.com/downloads</a> 下载完成后使用默认进行安装。</p>\\n<p>安装完成后，在开始菜单里找到 <code>Git</code> -&gt; <code>Git Bash</code>，蹦出一个类似命令行窗口的东西，就说明Git安装成功！\\n还需要最后一步设置，在命令行输入：</p>\\n<div class=\\\"language-bash vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">bash</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">git</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> config</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> --global</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> user.name</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> \\\"Your Name\\\"</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">git</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> config</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> --global</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> user.email</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> \\\"email@example.com\\\"</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br></div></div><p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。</p>\\n\",\"capture\":\"Git使用手册\\n 安装\\n官网下载：&lt;https://git-scm.com/downloads\\n安装完成后，在开始菜单里找到 `Git` -&gt; `Git Bash`，蹦出一个类似命令行窗口的东西，就说明Git安装成功！\\n还需要最后一步设置，在命令行输入：\\n```bash\\ngit config --global user.name \\\"Your Name\\\"\\ngit config --global user.email \\\"email@example.com\\\"\\n```\\n因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。\\n 创建版本库（仓库）\\n```ba\"},{\"url\":\"/03.技术/01.技术文档/02.Markdown使用教程.html\",\"relativePath\":\"/03.技术/01.技术文档/02.Markdown使用教程.html\",\"frontmatter\":{\"title\":\"Markdown使用教程\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/ad247c4332211551\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Markdown使用教程\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"markdown使用教程\\\" tabindex=\\\"-1\\\">Markdown使用教程 <a class=\\\"header-anchor\\\" href=\\\"#markdown使用教程\\\" aria-label=\\\"Permalink to &quot;Markdown使用教程&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"一、markdown\\\" tabindex=\\\"-1\\\">一、Markdown <a class=\\\"header-anchor\\\" href=\\\"#一、markdown\\\" aria-label=\\\"Permalink to &quot;一、Markdown&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p><img src=\\\"https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/md_logo.png\\\" alt=\\\"logo\\\"></p>\\n<p><code>Markdown</code> 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>\\n\",\"capture\":\"一、Markdown\\n 简介\\n`Markdown` 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。\\n  应用\\n当前许多网站都广泛使用 `Markdown` 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、知乎等\\n 编辑器\\n推荐使用`Typora`，官网：&lt;https://typora.io/\\n 二、徽章\\n 什么是徽章\\n徽章是一种小巧精美的小图标，一般配有相关文字进行辅助说明，可对数据进行监控，链接跳转等，富有表现力。\\n常见于`github`项目主页，但其不仅出现于 `github` 项目主页，凡是能够表现图片的地方都可以出现徽章。\\n 徽章的使用\\n* 在\"},{\"url\":\"/03.技术/01.技术文档/03.npm常用命令.html\",\"relativePath\":\"/03.技术/01.技术文档/03.npm常用命令.html\",\"frontmatter\":{\"title\":\"npm常用命令\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/61f2f95fd7da14fd\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"npm常用命令\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"npm常用命令\\\" tabindex=\\\"-1\\\">npm常用命令 <a class=\\\"header-anchor\\\" href=\\\"#npm常用命令\\\" aria-label=\\\"Permalink to &quot;npm常用命令&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>npm是跟随node一起安装的包（模块）管理器。常见的使用场景有以下几种：</p>\\n<ul>\\n<li>允许用户从npm服务器下载别人编写的第三方包到本地使用。</li>\\n<li>允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用。</li>\\n<li>允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。</li>\\n</ul>\\n\",\"capture\":\"简介\\nnpm是跟随node一起安装的包（模块）管理器。常见的使用场景有以下几种：\\n* 允许用户从npm服务器下载别人编写的第三方包到本地使用。\\n* 允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用。\\n* 允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。\\n 常用命令\\n 检测是否安装及版本\\n```sh\\nnpm -v  显示版本号说明已经安装相应的版本\\n```\\n 生成package.json文件\\n```sh\\nnpm init\\n```\\n\\n 安装模块\\n```sh\\nnpm install  安装package.json定义好的模块，简写 npm i\\n 安装包指定模块\\nnpm \"},{\"url\":\"/03.技术/01.技术文档/15.yaml语言教程.html\",\"relativePath\":\"/03.技术/01.技术文档/15.yaml语言教程.html\",\"frontmatter\":{\"title\":\"yaml语言教程\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/4e8444e2d534d14f\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"yaml语言教程\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"yaml语言教程\\\" tabindex=\\\"-1\\\">yaml语言教程 <a class=\\\"header-anchor\\\" href=\\\"#yaml语言教程\\\" aria-label=\\\"Permalink to &quot;yaml语言教程&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>YAML 是 &quot;YAML Ain't a Markup Language&quot;（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：&quot;Yet Another Markup Language&quot;（仍是一种标记语言）。</p>\\n\",\"capture\":\"简介\\nYAML 是 \\\"YAML Ain't a Markup Language\\\"（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：\\\"Yet Another Markup Language\\\"（仍是一种标记语言）。\\nYAML 的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲（例如：许多电子邮件标题格式和YAML非常接近）。\\nYAML 的配置文件后缀为 .yml，如：runoob.yml 。\\n\\n 基本语法\\n- 大小写敏感\\n- 使用缩进\"},{\"url\":\"/03.技术/03.博客搭建/01.解决百度无法收录搭建在GitHub上的个人博客的问题.html\",\"relativePath\":\"/03.技术/03.博客搭建/01.解决百度无法收录搭建在GitHub上的个人博客的问题.html\",\"frontmatter\":{\"title\":\"解决百度无法收录搭建在GitHub上的个人博客的问题\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/41f87d890d0a02af\",\"categories\":[\"技术\",\"博客搭建\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"解决百度无法收录搭建在GitHub上的个人博客的问题\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"解决百度无法收录搭建在github上的静态博客的问题\\\" tabindex=\\\"-1\\\">解决百度无法收录搭建在GitHub上的静态博客的问题 <a class=\\\"header-anchor\\\" href=\\\"#解决百度无法收录搭建在github上的静态博客的问题\\\" aria-label=\\\"Permalink to &quot;解决百度无法收录搭建在GitHub上的静态博客的问题&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<div class=\\\"warning custom-block\\\"><p class=\\\"custom-block-title\\\">WARNING</p>\\n<p>如果你正在寻找本博客的搭建文档，博主建议您查看这个仓库的<a href=\\\"https://github.com/xugaoyi/vuepress-theme-vdoing\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">README</a>。</p>\\n</div>\\n<h2 id=\\\"背景\\\" tabindex=\\\"-1\\\">背景 <a class=\\\"header-anchor\\\" href=\\\"#背景\\\" aria-label=\\\"Permalink to &quot;背景&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>由于GitHub禁止百度爬虫访问，造成托管在GitHub Pages上的博客无法被百度收录。相关问题可以通过百度站长平台的<code>抓取诊断</code>再现，每次都是403 Forbidden的错误。</p>\\n\",\"capture\":\"如果你正在寻找本博客的搭建文档，博主建议您查看这个仓库的README。\\n 背景\\n由于GitHub禁止百度爬虫访问，造成托管在GitHub Pages上的博客无法被百度收录。相关问题可以通过百度站长平台的`抓取诊断`再现，每次都是403 Forbidden的错误。\\n 解决方案\\n同时将博客同时同步托管到GitHub Pages和coding pages上，解决百度不收录问题。最后发现在国内使用coding pages打开速度特别快，而且还会被百度收录，因此我把coding pages的站点作为主站点，原本在github pages的作为分站点。\\n步骤：\\n1、注册coding账号，创建仓库，把代码推\"},{\"url\":\"/03.技术/03.博客搭建/02.使用Gitalk实现静态博客无后台评论系统.html\",\"relativePath\":\"/03.技术/03.博客搭建/02.使用Gitalk实现静态博客无后台评论系统.html\",\"frontmatter\":{\"title\":\"使用Gitalk实现静态博客无后台评论系统\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/1da0bf9a988eafe5\",\"categories\":[\"技术\",\"博客搭建\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"使用Gitalk实现静态博客无后台评论系统\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"使用gitalk实现静态博客无后台评论系统\\\" tabindex=\\\"-1\\\">使用Gitalk实现静态博客无后台评论系统 <a class=\\\"header-anchor\\\" href=\\\"#使用gitalk实现静态博客无后台评论系统\\\" aria-label=\\\"Permalink to &quot;使用Gitalk实现静态博客无后台评论系统&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"前言\\\" tabindex=\\\"-1\\\">前言 <a class=\\\"header-anchor\\\" href=\\\"#前言\\\" aria-label=\\\"Permalink to &quot;前言&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>Gitalk，一个基于 Github Issue 和 Preact 开发的评论插件。</p>\\n<p>下面我们来用它在vuepress搭建的博客中搭建评论区吧</p>\\n\",\"capture\":\"前言\\nGitalk，一个基于 Github Issue 和 Preact 开发的评论插件。\\n下面我们来用它在vuepress搭建的博客中搭建评论区吧\\n 准备\\n使用一个新的东西首先当然是要了解它\\nGitalk demo：&lt;https://gitalk.github.io/\\nGitalk github：&lt;https://github.com/gitalk/gitalk&gt;\\n 实现\\n如何实现？最好的方法我认为是看官方文档，这里我只是记录一下实现的步骤。\\n使用一个别人已经开发好的 vuepress-plugin-comment 插件来帮助我们把Gitalk应用到vuepress搭建的静\"},{\"url\":\"/04.更多/03.面试/01.面试问题集锦.html\",\"relativePath\":\"/04.更多/03.面试/01.面试问题集锦.html\",\"frontmatter\":{\"title\":\"面试问题集锦\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/aea6571b7a8bae86\",\"categories\":[\"更多\",\"面试\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"面试问题集锦\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"请做一下自我介绍\\n回答提示： 一般人回答这个问题过于平常，只说姓名、年龄、工作经验，这些在简历上都有。其实，企业最希望知道的是求职者能否胜任工作，包括：最强的技能、最深入研究的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，要突出积极的个性和做事的能力，说的合情合理企业才会相信。\\n 你最大的优点是什么？\\n回答提示： 沉着冷静、条理清楚、立场坚定、乐于助人等，加上例子如：我在XX经过一到两年的培训及项目实战，加上实习工作，我想我适合这份工作。\\n 说说你最大的缺点？\\n回答提示： 这个问题企业问的概率很大，通常不希望听到直接回答的缺点是什么等，如果求职者说自己小心眼、非常懒、工作效率低\"}],\"sortPostsByDate\":[{\"url\":\"/04.更多/05.AI随笔/01.当珍妮机学会了写代码.html\",\"relativePath\":\"/04.更多/05.AI随笔/01.当珍妮机学会了写代码.html\",\"frontmatter\":{\"title\":\"当珍妮机学会了写代码\",\"date\":\"2026-02-26 20:00:00\",\"permalink\":\"/pages/ai-coding-revolution/\",\"categories\":[\"更多\",\"AI随笔\"],\"tags\":[\"AI\",\"思考\",\"编程\"],\"author\":{\"name\":\"刘志伟;AI\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟;AI\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"当珍妮机学会了写代码\",\"date\":\"2026-02-26 20:00:00\",\"capture\":\"当珍妮机学会了写代码\\n\\n 一、从一台纺纱机说起\\n1764 年的某个夜晚，英国兰开夏郡的织工詹姆斯·哈格里夫斯看着妻子的纺车被踢倒后仍在旋转，灵光一闪——如果把纱锭竖起来，一个轮子就能同时驱动八个纱锭。\\n珍妮纺纱机就这样诞生了。一个人能干八个人的活，效率提升 800%。\\n262 年后的 2026 年，我坐在屏幕前，让一个叫 Claude 的 AI 帮我重构整个博客系统。它用 Three.js 写了一个极光 Shader 背景，用 Vue 3 搭了全屏滚动首页，让它设计了五套可切换的艺术风格主题——赛博朋克、梵高、水墨、古典雕塑、现代。它还帮我写了一篇博客，就是现在你正在看的这篇。\\n如果哈格里夫斯\"},{\"url\":\"/《JavaScript教程》笔记/14.JS实现扫码登录.html\",\"relativePath\":\"/《JavaScript教程》笔记/14.JS实现扫码登录.html\",\"frontmatter\":{\"title\":\"JS实现扫码登录\",\"date\":\"2024-03-30 15:32:39\",\"permalink\":\"/pages/bdbdb8/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"JS实现扫码登录\",\"date\":\"2024-03-30 15:32:39\",\"capture\":\"JS实现扫码登录\\r\\n\\r\\n扫码登录是一种方便快捷的登录方式，用户可以通过扫描二维码来登录网站或应用程序。在本文中，我们将使用JavaScript实现一个简单的扫码登录功能。\\r\\n\\r\\n 步骤一：生成二维码\\r\\n\\r\\n首先，我们需要生成一个二维码，用于展示给用户扫描。我们可以使用第三方库 qrcode.js 来生成二维码。以下是使用qrcode.js生成二维码的示例代码：\\r\\n\\r\\n```html\\r\\n&lt;!-- 在HTML中引入qrcode.js库 --\\r\\n&lt;script src=\\\"https://cdn.bootcdn.net/ajax/libs/qrcodejs/1.0.0/qrcode.min\"},{\"url\":\"/《JavaScript教程》笔记/13.JS继承.html\",\"relativePath\":\"/《JavaScript教程》笔记/13.JS继承.html\",\"frontmatter\":{\"title\":\"JS继承\",\"date\":\"2024-03-30 15:32:05\",\"permalink\":\"/pages/b17c09/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"JS继承\",\"date\":\"2024-03-30 15:32:05\",\"capture\":\"在JavaScript中，继承是实现面向对象编程的重要方式之一。\\r\\n\\r\\n 原型继承\\r\\n\\r\\n原型继承是JavaScript中最常用的继承方式之一。在原型继承中，子类通过继承父类的原型对象来实现继承。\\r\\n\\r\\n```javascript\\r\\nfunction Parent() {\\r\\n  this.name = 'parent';\\r\\n}\\r\\n\\r\\nParent.prototype.sayHello = function() {\\r\\n  console.log('Hello from ' + this.name);\\r\\n}\\r\\n\\r\\nfunction Child() {\\r\\n  this.name = 'child';\"},{\"url\":\"/《JavaScript教程》笔记/12.console实用调试方法.html\",\"relativePath\":\"/《JavaScript教程》笔记/12.console实用调试方法.html\",\"frontmatter\":{\"title\":\"console实用调试方法\",\"date\":\"2024-03-30 15:31:48\",\"permalink\":\"/pages/602ffc/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"console实用调试方法\",\"date\":\"2024-03-30 15:31:48\",\"capture\":\"在JavaScript中，console是一个非常有用的工具，可以帮助我们在开发和调试过程中更好地了解代码的执行情况。本文将介绍console中一些常用的方法，并提供示例代码。\\r\\n console.time() & console.timeEnd()\\r\\nconsole.time()方法用于开始计时器，console.timeEnd()方法用于结束计时器并输出所花费的时间。这对于测试代码执行时间非常有用。\\r\\n```javascript\\r\\nconsole.time('myTimer');\\r\\nfor (let i = 0; i &lt; 1000000; i++) {\\r\\n  // do someth\"},{\"url\":\"/《Git》学习笔记/Git常用命令速查表.html\",\"relativePath\":\"/《Git》学习笔记/Git常用命令速查表.html\",\"frontmatter\":{\"title\":\"Git常用命令速查表\",\"date\":\"2024-03-30 15:26:32\",\"permalink\":\"/pages/3aa4fd/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git常用命令速查表\",\"date\":\"2024-03-30 15:26:32\",\"capture\":\"\"},{\"url\":\"/《JavaScript教程》笔记/11.`import`、`require`、`export`、`module.exports` 的区别和使用详解.html\",\"relativePath\":\"/《JavaScript教程》笔记/11.`import`、`require`、`export`、`module.exports` 的区别和使用详解.html\",\"frontmatter\":{\"title\":\"exports` 的区别和使用详解\",\"date\":\"2024-03-30 15:23:12\",\"permalink\":\"/pages/ff5679/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"exports` 的区别和使用详解\",\"date\":\"2024-03-30 15:23:12\",\"capture\":\"在 Node.js 和现代的 JavaScript 中，有多种方式可以导入和导出模块。其中最常见的是使用 `import` 和 `export`，但在 Node.js 中，也可以使用 `require` 和 `module.exports`。本篇文章将介绍这些不同的方式，以及它们之间的区别。\\r\\n\\r\\n `import` 和 `export`\\r\\n\\r\\n`import` 和 `export` 是 ES6 中引入的模块系统。它们允许我们将代码拆分成多个文件，并在不同的文件中共享代码。以下是一个简单的例子：\\r\\n\\r\\n```javascript\\r\\n// math.js\\r\\nexport const add = \"},{\"url\":\"/《JavaScript教程》笔记/10.JS中的？.和？？区别.html\",\"relativePath\":\"/《JavaScript教程》笔记/10.JS中的？.和？？区别.html\",\"frontmatter\":{\"title\":\"和？？区别\",\"date\":\"2024-03-30 15:22:03\",\"permalink\":\"/pages/176ae0/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"和？？区别\",\"date\":\"2024-03-30 15:22:03\",\"capture\":\"`??` 运算符\\r\\n\\r\\n`??` 运算符是 ES2020 中新增的空值合并运算符。它用于判断一个值是否为 `null` 或 `undefined`，如果是，则使用默认值。其语法如下：\\r\\n\\r\\n```javascript\\r\\ndefaultValue ?? value;\\r\\n```\\r\\n\\r\\n如果 `value` 不为 `null` 或 `undefined`，则 `??` 运算符返回 `value`；否则返回 `defaultValue`。\\r\\n\\r\\n```javascript\\r\\nconst a = null;\\r\\nconst b = 5;\\r\\n\\r\\nconsole.log(a ?? 10); // 10\\r\\nco\"},{\"url\":\"/《JavaScript教程》笔记/09.js 使用postMessage iframe跨域通信.html\",\"relativePath\":\"/《JavaScript教程》笔记/09.js 使用postMessage iframe跨域通信.html\",\"frontmatter\":{\"title\":\"js 使用postMessage iframe跨域通信\",\"date\":\"2024-03-30 15:21:11\",\"permalink\":\"/pages/d67bac/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"js 使用postMessage iframe跨域通信\",\"date\":\"2024-03-30 15:21:11\",\"capture\":\"在 Web 应用程序中，由于同源策略的限制，如果我们需要在一个页面中嵌入来自不同域的资源（例如图片、脚本或 iframe），那么就会出现跨域问题。在这种情况下，我们需要使用一些技术来实现跨域通信。\\r\\n\\r\\n其中一种解决方案是使用 HTML5 中引入的 postMessage API。postMessage 允许我们在不同窗口或 iframe 之间发送消息，这使得我们可以实现跨域通信，而不违反同源策略。\\r\\n\\r\\n postMessage 简介\\r\\n\\r\\npostMessage 是 HTML5 中引入的一种跨窗口通信机制。它允许我们在不同窗口之间发送消息，并且这些窗口可以来自不同的域。postMessag\"},{\"url\":\"/《uniapp》笔记/使用uniapp对接蓝牙设备.html\",\"relativePath\":\"/《uniapp》笔记/使用uniapp对接蓝牙设备.html\",\"frontmatter\":{\"title\":\"使用uniapp对接蓝牙设备\",\"date\":\"2024-03-30 15:20:23\",\"permalink\":\"/pages/35c361/\",\"categories\":[\"《uniapp》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"使用uniapp对接蓝牙设备\",\"date\":\"2024-03-30 15:20:23\",\"capture\":\"低功耗蓝牙 API 平台差异说明\\r\\n\\r\\n| App | H5  | 微信小程序 | 支付宝小程序 | 百度小程序 | 字节跳动小程序 | 飞书小程序 | QQ 小程序 | 快手小程序 | 京东小程序 |\\r\\n| :-: | :-: | :--------: | :----------: | :--------: | :------------: | :--------: | :-------: | :--------: | :--------: |\\r\\n|  √  |  x  |     √      |      √       |     x      |       x        |  \"},{\"url\":\"/《Vue》笔记/99.其他/79.Vue中编辑word文档以及预览word .html\",\"relativePath\":\"/《Vue》笔记/99.其他/79.Vue中编辑word文档以及预览word .html\",\"frontmatter\":{\"title\":\"Vue中编辑word文档以及预览word\",\"date\":\"2023-09-13 10:25:00\",\"permalink\":\"/pages/1ebccd/\",\"categories\":[\"《Vue》笔记\",\"其他\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Vue中编辑word文档以及预览word\",\"date\":\"2023-09-13 10:25:00\",\"capture\":\"首先通过XMLHttpRequest发送一个GET请求到指定的URL，获取Word文件的内容并将其转换为HTML格式。其中使用mammoth库的convertToHtml方法将二进制数组转换为HTML格式的文本。（mammoth我用了一个修改版本样式还原度要比官方好@shy1118/mammoth）编辑用到的是ckeditor5富文本编辑器,最后通过html-docx-js将html转换为docx在进行保存**\\n 安装主要依赖\\n```bash\\nnpm install --save @ckeditor/ckeditor5-build-decoupled-document @shy1118/mam\"},{\"url\":\"/《Electron》笔记/02.electron下使用puppeteer模拟用户操作,数据获取.html\",\"relativePath\":\"/《Electron》笔记/02.electron下使用puppeteer模拟用户操作,数据获取.html\",\"frontmatter\":{\"title\":\"electron下使用puppeteer模拟用户操作,数据获取\",\"date\":\"2023-09-09 15:15:18\",\"permalink\":\"/pages/56ebf1/\",\"categories\":[\"《Electron》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"electron下使用puppeteer模拟用户操作,数据获取\",\"date\":\"2023-09-09 15:15:18\",\"capture\":\"Puppeteer是一个由Google开发的Node.js库，它提供了一组用于控制和自动化Chrome或Chromium浏览器的API。它可以用于执行各种与浏览器相关的任务，如网页截图、生成PDF、模拟用户交互、爬取网页数据等。Puppeteer通过WebSocket连接与浏览器建立通信，并通过DevTools协议发送命令和接收浏览器的响应。\\n什么是 Chrome DevTool Protocol\\n- CDP 基于 WebSocket，利用 WebSocket 实现与浏览器内核的快速数据通道\\n- CDP 分为多个域（DOM，Debugger，Network，Profiler，Console..\"},{\"url\":\"/《Electron》笔记/01.electron记录.html\",\"relativePath\":\"/《Electron》笔记/01.electron记录.html\",\"frontmatter\":{\"title\":\"electron记录\",\"date\":\"2023-09-09 14:23:20\",\"permalink\":\"/pages/8e9a16/\",\"categories\":[\"《Electron》笔记\"],\"tags\":[\"electron\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"electron记录\",\"date\":\"2023-09-09 14:23:20\",\"capture\":\"事件周期\\n electron常用事件统计\\n主进程常用事件可以分为以下几类：\\n1. 应用程序生命周期事件：\\n    - `ready`: 当 Electron 应用程序初始化完成且准备好显示窗口时触发。\\n    - `window-all-closed`: 当所有窗口都关闭后触发，在 macOS 上通常不会退出应用程序。\\n    - `activate`: 在 macOS 上，当用户点击应用程序的 Dock 图标并且没有其他窗口打开时触发，用于重新创建新窗口。\\n2. 窗口相关事件：\\n    - `closed`: 窗口关闭时触发。\\n    - `dom-ready`: 窗口加载完毕并且 DOM \"},{\"url\":\"/《JavaScript教程》笔记/08.事件循环(evenloop).html\",\"relativePath\":\"/《JavaScript教程》笔记/08.事件循环(evenloop).html\",\"frontmatter\":{\"title\":\"事件循环(evenloop)\",\"date\":\"2023-09-08 16:20:58\",\"permalink\":\"/pages/eaf565/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"事件循环(evenloop)\",\"date\":\"2023-09-08 16:20:58\",\"capture\":\"JavaScript 是一门单线程的语言，它的异步和多线程的实现是通过 Event Loop 事件循环机制来实现的\\nEvent Loop 的机制\\n大体三个部分组成\\n1、调用栈 Stack\\n2、消息队列 Message Queue\\n3、微任务队列 Microtask Queue\\n Event Loop 开始的时候会从全局栈开始逐行执行，遇到函数调用，会把函数压入到调用栈中，当函数返回后，会从调用栈中弹出\\n```javascript\\nfunction func1(){\\n    console.log(1);\\n }\\n function func2(){\\n    console.log(2);\\n   \"},{\"url\":\"/《ES6 教程》笔记/35.了解ES6中的Map和Set.html\",\"relativePath\":\"/《ES6 教程》笔记/35.了解ES6中的Map和Set.html\",\"frontmatter\":{\"title\":\"了解ES6中的Map和Set\",\"date\":\"2023-09-08 16:10:10\",\"permalink\":\"/pages/bfde72/\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"了解ES6中的Map和Set\",\"date\":\"2023-09-08 16:10:10\",\"capture\":\"Map对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。构造函数Map可以接受一个数组作为参数。\\nMap对象的方法\\nset(key, val): 向Map中添加新元素\\nget(key): 通过键值查找特定的数值并返回\\nhas(key): 判断Map对象中是否有Key所对应的值，有返回true,否则返回false\\ndelete(key): 通过键值从Map中移除对应的数据\\nclear(): 将这个Map中的所有元素删除\\n```jsx\\nconst m1 = new Map([['a', 111], ['b', 222]])\\nconsole.log(m1) // {\\\"a\\\" =\\nm1\"},{\"url\":\"/《Vue》笔记/99.其他/91.vue2与vue3生命周期对照表.html\",\"relativePath\":\"/《Vue》笔记/99.其他/91.vue2与vue3生命周期对照表.html\",\"frontmatter\":{\"title\":\"vue2与vue3生命周期对照表\",\"date\":\"2023-09-08 14:57:40\",\"permalink\":\"/pages/e866b9/\",\"categories\":[\"《Vue》笔记\",\"其他\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"vue2与vue3生命周期对照表\",\"date\":\"2023-09-08 14:57:40\",\"capture\":\"\"},{\"url\":\"/01.前端/25.JavaScript文章/15.js实现深度优先遍历和广度优先遍历.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/15.js实现深度优先遍历和广度优先遍历.html\",\"frontmatter\":{\"title\":\"js实现深度优先遍历和广度优先遍历\",\"date\":\"2023-09-08 14:16:56\",\"permalink\":\"/pages/690414/\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"js实现深度优先遍历和广度优先遍历\",\"date\":\"2023-09-08 14:16:56\",\"capture\":\"什么是深度优先和广度优先\\n深度优先遍历用的是栈，而广度优先遍历要用队列来实现,深度优先就是自上而下的遍历搜索 广度优先则是逐层遍历, 如下图所示(图左深度优先遍历,图右广度)\\n 深度优先遍历\\n 广度优先遍历\\n 两者的区别\\n对于算法来说 无非就是时间换空间 空间换时间\\n1. 深度优先不需要记住所有的节点, 所以占用空间小, 而广度优先需要先记录所有的节点占用空间大\\n2. 深度优先有回溯的操作(没有路走了需要回头)所以相对而言时间会长一点\\n深度优先采用的是堆栈的形式, 即先进后出\\n广度优先则采用的是队列的形式, 即先进先出\\n```jsx\\nconst data = [\\n  {\\n      name:\"},{\"url\":\"/01.前端/25.JavaScript文章/14.js获取当前URL,域名,端口号.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/14.js获取当前URL,域名,端口号.html\",\"frontmatter\":{\"title\":\"js获取当前URL,域名,端口号\",\"date\":\"2023-09-08 13:57:22\",\"permalink\":\"/pages/c81259/\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"js获取当前URL,域名,端口号\",\"date\":\"2023-09-08 13:57:22\",\"capture\":\"| href | 完整的 URL | https://www.baidu.com:200/s?wd=1 |\\n| --- | --- | --- |\\n| protocol | 协议 | https: |\\n| hostname | 主机名 | www.baidu.com |\\n| port | 端口号 | 200 |\\n| host | 主机名+端口号 | www.baidu.com:200 |\\n```javascript\\nlet protocol = window.location.protocol,host = window.location.host;\\nlet url = `${protocol\"},{\"url\":\"/01.前端/25.JavaScript文章/13.javascript常用类型数值比较图.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/13.javascript常用类型数值比较图.html\",\"frontmatter\":{\"title\":\"javascript常用类型数值比较图\",\"date\":\"2023-09-08 13:34:43\",\"permalink\":\"/pages/360851/\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"javascript常用类型数值比较图\",\"date\":\"2023-09-08 13:34:43\",\"capture\":\"\"},{\"url\":\"/02.页面/20.CSS/16.css calc()使用.html\",\"relativePath\":\"/02.页面/20.CSS/16.css calc()使用.html\",\"frontmatter\":{\"title\":\"css calc()使用\",\"date\":\"2023-09-08 11:40:43\",\"permalink\":\"/pages/2ecc26/\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"css calc()使用\",\"date\":\"2023-09-08 11:40:43\",\"capture\":\"1.什么是 CSS calc() 函数？\\ncalc() 函数允许在指定 CSS 属性值时执行计算。它对于计算 length、 percentage、 time、 numbers、integers、frequencies 和 angles 等特别有用。 CSS calc() 函数的一个强大功能是能够组合不同的单位。这个函数可以执行预处理器不能执行的数学计算。\\nCSS 中的预处理器只能组合具有固定关系的单位，如角度单位、时间单位、频率单位、分辨率单位和特定长度单位。\\ncalc( Expression)\\ncalc() 函数接受一个表达式作为参数。然后将表达式的结果用作值。它可以采用任何形式并使用以下\"},{\"url\":\"/04.更多/99.友情链接.html\",\"relativePath\":\"/04.更多/99.友情链接.html\",\"frontmatter\":{\"title\":\"友情链接\",\"date\":\"2023-08-29 15:43:33\",\"permalink\":\"/pages/1bf946/\",\"categories\":[\"更多\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"友情链接\",\"date\":\"2023-08-29 15:43:33\",\"capture\":\"\"},{\"url\":\"/\",\"relativePath\":\"/\",\"frontmatter\":{\"layout\":\"page\",\"title\":\"首页\"},\"title\":\"首页\",\"date\":\"2023-08-29 07:43:33\",\"capture\":\"&lt;HomePage /\"},{\"url\":\"/03.技术/01.技术文档/20.Git修改分支名.html\",\"relativePath\":\"/03.技术/01.技术文档/20.Git修改分支名.html\",\"frontmatter\":{\"title\":\"Git修改分支名\",\"date\":\"2022-08-11 10:51:18\",\"permalink\":\"/pages/922650/\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git修改分支名\",\"date\":\"2022-08-11 10:51:18\",\"capture\":\"同时修改本地分支名和对应的远程分支名\\n修改前要确保本地分支的代码是最新的，并且修改后不会影响到同事的代码。\\n1. 修改本地分支名\\n```sh\\ngit branch -m oldBranchName newBranchName\\n```\\n2. 删除远程分支\\n```sh\\ngit push origin :oldBranchName\\n 或者 git push origin --delete oldBranchName\\n```\\n3. 改名后的本地分支推送到远程\\n```sh\\ngit push --set-upstream origin newBranchName\\n```\"},{\"url\":\"/02.页面/20.CSS/15.CSS给table的tbody添加滚动条.html\",\"relativePath\":\"/02.页面/20.CSS/15.CSS给table的tbody添加滚动条.html\",\"frontmatter\":{\"title\":\"CSS给table的tbody添加滚动条\",\"date\":\"2022-06-29 09:34:23\",\"permalink\":\"/pages/55f894/\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"CSS给table的tbody添加滚动条\",\"date\":\"2022-06-29 09:34:23\",\"capture\":\"```css\\ntable tbody {\\n  height: 200px;\\n  overflow-y: auto;\\n  display: block;\\n}\\ntable thead,\\ntbody tr {\\n  display: table;\\n  width: 100%;\\n}\\n```\"},{\"url\":\"/01.前端/25.JavaScript文章/01.33个非常实用的JavaScript一行代码.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/01.33个非常实用的JavaScript一行代码.html\",\"frontmatter\":{\"title\":\"33个非常实用的JavaScript一行代码\",\"date\":\"2021-11-02 09:51:37\",\"permalink\":\"/pages/a61298/\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[\"JavaScript\"],\"author\":\"CUGGZ\"},\"author\":\"CUGGZ\",\"title\":\"33个非常实用的JavaScript一行代码\",\"date\":\"2021-11-02 09:51:37\",\"capture\":\"一、日期处理\\n 1. 检察日期是否有效\\n该方法用于检测给出的日期是否有效：\\n```javascript\\nconst isDateValid = (...val) =\\nisDateValid(\\\"December 17, 1995 03:24:00\\\");  // true\\n复制代码\\n```\\n 2. 计算两个日期之间的间隔\\n该方法用于计算两个日期之间的间隔时间：\\n```javascript\\nconst dayDif = (date1, date2) =&gt; Math.ceil(Math.abs(date1.getTime() - date2.getTime()) / 86400000)\\ndayD\"},{\"url\":\"/01.前端/40.学习笔记/50.JS设计模式总结笔记.html\",\"relativePath\":\"/01.前端/40.学习笔记/50.JS设计模式总结笔记.html\",\"frontmatter\":{\"title\":\"JS设计模式总结笔记\",\"date\":\"2021-02-27 20:01:18\",\"permalink\":\"/pages/4643cd/\",\"categories\":[\"前端\",\"学习笔记\"],\"tags\":[\"设计模式\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"JS设计模式总结笔记\",\"date\":\"2021-02-27 20:01:18\",\"capture\":\"开篇：前端工程师的成长论\\n能够决定一个前端工程师的本质的，不是那些瞬息万变的技术点，而是那些不变的东西。\\n所谓“不变的东西”，就是驾驭技术的能力。\\n具体来说，它分为以下三个层次：\\n- 能用健壮的代码去解决具体的问题；\\n- 能用抽象的思维去应对复杂的系统；\\n- 能用工程化的思想去规划更大规模的业务。\\n\\n 设计模式之“道”\\n- 设计模式是“拿来主义”。如使用数学公式，不会从头推导一个公式。\\n  核心思想\\n- 设计模式的核心思想——封装变化\\n- 保证可维护性、可扩展性。\\n- 将变与不变分离，确保变化的部分灵活，不变的部分稳定。——这就是所谓的“健壮”的代码。\\n 设计模式之“术”\\n即最经典的23种设计\"},{\"url\":\"/01.前端/25.JavaScript文章/1110.三级目录/00.四级文件.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/1110.三级目录/00.四级文件.html\",\"frontmatter\":{\"title\":\"四级文件(测试)\",\"date\":\"2020-12-11 11:15:53\",\"permalink\":\"/pages/8481d1/\",\"categories\":[\"前端\",\"JavaScript文章\",\"三级目录\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"四级文件(测试)\",\"date\":\"2020-12-11 11:15:53\",\"capture\":\"测试文件\\nTest Test\\n&lt;code-group\\n  &lt;code-block title=\\\"YARN\\\" active&gt;\\n  ```bash\\n  yarn create vuepress-site [optionalDirectoryName]\\n   OR npx create-vuepress-site [optionalDirectoryName]\\n  ```\\n  &lt;/code-block&gt;\\n  &lt;code-block title=\\\"NPM\\\"&gt;\\n  ```bash\\n  npx create-vuepress-site [optionalDirec\"},{\"url\":\"/《Git》学习笔记/10.手册/00.常用Git命令清单.html\",\"relativePath\":\"/《Git》学习笔记/10.手册/00.常用Git命令清单.html\",\"frontmatter\":{\"title\":\"常用Git命令清单\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/8292d8/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"常用Git命令清单\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。\\n下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。\\n\\n&gt; - Index / Stage：暂存区\\n&gt; - Repository：仓库区（或本地仓库）\\n&gt; - Remote：远程仓库\\n 一、新建代码库\\n```bash\\n 在当前目录新建一个Git代码库\\n$ git init\\n 新建一个目录，将其初始化为Git代码库\\n$ git init [project-name]\\n 下载一个项目和它的整个代码历史\\n$ git clone [url]\\n```\\n 二、配置\\nGit的设置文件为\"},{\"url\":\"/《Git》学习笔记/10.手册/01.Git变基合并.html\",\"relativePath\":\"/《Git》学习笔记/10.手册/01.Git变基合并.html\",\"frontmatter\":{\"title\":\"Git变基合并\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/c10281/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git变基合并\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"说明\\n以下 `v2` 是某个需求的开发分支， `dev`是总的开发分支，`v2` 是基于`dev`分支签出的。\\n当完成`v2`的开发后，需要把代码合并到`dev`，我们可以使用`rebase`进行合并：\\n```sh\\n 首先将 v2 push到远程仓库\\ngit add .\\ngit commit -m 'xxx'\\ngit push origin v2\\n 切换到 dev 拉取最新代码\\ngit checkout dev\\ngit pull origin dev\\n 切换到 v2\\ngit checkout v2\\ngit rebase dev  将 v2 的所有[commit] 变基到(应用到) dev\\n 切\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/10.Git基础与命令.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/10.Git基础与命令.html\",\"frontmatter\":{\"title\":\"Git基础与命令\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/635088/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git基础与命令\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"官方文档（中文）：https://git-scm.com/book/zh/v2\\n\\n Git基础\\n 全局配置\\n```bash\\ngit config --global user.name 'your name'\\ngit config --global user.email 'xxx@xx.com'\\n```\\n自报家门\\n 检查配置信息\\n```sh\\ngit config --list\\n```\\n 获取帮助\\n```sh\\n 获取全局帮助手册\\ngit help\\n 获取特定命令的详细版帮助手册 (两个命令是等价的)\\ngit help &lt;某个命令&gt;\\ngit &lt;某个命令&gt; --help  两个\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/100.Git工具-重写历史.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/100.Git工具-重写历史.html\",\"frontmatter\":{\"title\":\"Git工具-重写历史\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/1832fe/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git工具-重写历史\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"许多时候，在使用 Git 时，你可能想要修订提交历史。 Git 很棒的一点是它允许你在最后时刻做决定。 你可以在将暂存区内容提交前决定哪些文件进入提交，可以通过 `git stash` 来决定不与某些内容工作， 也可以重写已经发生的提交就像它们以另一种方式发生的一样。 这可能涉及改变提交的顺序，改变提交中的信息或修改文件，将提交压缩或是拆分， 或完全地移除提交——在将你的工作成果与他人共享之前。\\n在本节中，你可以学到如何完成这些工作，这样在与他人分享你的工作成果时你的提交历史将如你所愿地展示出来。\\n| Note | 在满意之前不要推送你的工作Git 的基本原则之一是，由于克隆中有很多工作是本地\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/110.Git工具-重置揭密.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/110.Git工具-重置揭密.html\",\"frontmatter\":{\"title\":\"Git工具-重置揭密\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/d9e9c6/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git工具-重置揭密\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"在继续了解更专业的工具前，我们先探讨一下 Git 的 `reset` 和 `checkout` 命令。 在初遇的 Git 命令中，这两个是最让人困惑的。 它们能做很多事情，所以看起来我们很难真正地理解并恰当地运用它们。 针对这一点，我们先来做一个简单的比喻。\\n 三棵树\\n理解 `reset` 和 `checkout` 的最简方法，就是以 Git 的思维框架（将其作为内容管理器）来管理三棵不同的树。 “树” 在我们这里的实际意思是 “文件的集合”，而不是指特定的数据结构。 （在某些情况下索引看起来并不像一棵树，不过我们现在的目的是用简单的方式思考它。）\\nGit 作为一个系统，是以它的一般操作来管理\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/20.Git分支-分支原理.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/20.Git分支-分支原理.html\",\"frontmatter\":{\"title\":\"Git分支-分支原理\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/4bef1a/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支-分支原理\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。\\n 首次提交\\n在进行提交操作时，Git 会保存一个提交对象（commit object）。\\n假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 暂存操作会为每一个文件计算校验和（使用 SHA-1 哈希算法），然后会把当前版本的文件快照保存到 Git 仓库中 （Git 使用 *blob* 对象来保存它们），最终将校验和加入到暂存区域等待提交：\\n```sh\\n$ git\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/30.Git分支的新建与合并-分支操作.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/30.Git分支的新建与合并-分支操作.html\",\"frontmatter\":{\"title\":\"Git分支的新建与合并-分支操作\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/ea5a8c/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支的新建与合并-分支操作\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"文档：Git 分支 - 分支的新建与合并\\n 创建分支并切换\\n此时有一个需求需要在新的分支`iss53`上工作：\\n```sh\\n$ git checkout -b iss53   b表示branch\\n```\\n它是下面两条命令的简写：\\n```sh\\n$ git branch iss53\\n$ git checkout iss53\\n```\\n 切换分支\\n突然有一个紧急问题要解决，需要在原来的`master`分支进行修复：\\n```sh\\n$ git checkout master\\n```\\n在切换到`master`之前，需要`iss53`分支保持好一个干净的状态（修改都已提交）。\\n注意：切换分支Git 会重置你的\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/40.Git分支管理-查看分支.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/40.Git分支管理-查看分支.html\",\"frontmatter\":{\"title\":\"Git分支管理-查看分支\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/a399b3/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支管理-查看分支\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"查看分支\\n```sh\\n$ git branch\\n  iss53\\n* master   带星号*表示当前所在分支\\n  testing\\n```\\n`git branch` 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表。\\n 查看每个分支的最后提交\\n```sh\\n$ git branch -v\\n  iss53   93b412c fix javascript issue\\n* master  7a98805 Merge branch 'iss53'\\n  testing 782fd34 test\\n```\\n 查看已(未)合并的分支\\n`--merged` 与 `--no-m\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/50.Git分支开发工作流.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/50.Git分支开发工作流.html\",\"frontmatter\":{\"title\":\"Git分支开发工作流\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/49ee30/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支开发工作流\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"文档：Git分支开发工作流\\n 长期分支\\n因为 Git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。 也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些主题分支合并入其他分支中。\\n许多使用 Git 的开发者都喜欢使用这种方式来工作，比如只在 `master` 分支上保留完全稳定的代码，开发过程在`dev`分支，开发完成后并入`test`分支进行测试，通过测试的稳定代码才并入`master`分支中。\\n`dev`和`test`分支不需要保持绝对稳定，但在`test`通过测试达到稳定状态，就可以被合并入`mast\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/60.Git分支-远程分支.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/60.Git分支-远程分支.html\",\"frontmatter\":{\"title\":\"Git分支-远程分支\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/574d62/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支-远程分支\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"远程引用是对远程仓库的引用（指针），包括分支、标签等等。\\n\\n 查看远程引用列表与信息\\n```sh\\ngit ls-remote &lt;remote&gt;  远程引用的完整列表\\ngit remote show &lt;remote&gt;  远程分支的更多信息\\n```\\n上面两行命令比较少用，更常见的做法是利用远程跟踪分支。\\n 远程跟踪分支\\n远程跟踪分支是远程分支状态的引用。它们是你无法移动的本地引用。一旦你进行了网络通信， Git 就会为你移动它们以精确反映远程仓库的状态。请将它们看做书签， 这样可以提醒你该分支在远程仓库中的位置就是你最后一次连接到它们的位置。\\n它们以 `&lt;remote\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/70.Git分支-变基.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/70.Git分支-变基.html\",\"frontmatter\":{\"title\":\"Git分支-变基\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/3a3247/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支-变基\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"在 Git 中整合来自不同分支的修改主要有两种方法：`merge` 以及 `rebase`。 在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。\\n 变基的基本操作\\n请回顾之前在 分支的合并 中的一个例子，你会看到开发任务分叉到两个不同分支，又各自提交了更新。\\n&lt;p align=\\\"center\\\"\\n之前介绍过，整合分支最容易的方法是 `merge` 命令。 它会把两个分支的最新快照（`C3` 和 `C4`）以及二者最近的共同祖先（`C2`）进行三方合并，合并的结果是生成一个新的快照（并提交）。\\n &lt;p align=\\\"cen\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/80.Git工具-查看修订版本.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/80.Git工具-查看修订版本.html\",\"frontmatter\":{\"title\":\"Git工具-查看修订版本\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/c984d1/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git工具-查看修订版本\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"Git 能够以多种方式来指定单个提交、一组提交、或者一定范围内的提交。 了解它们并不是必需的，但是了解一下总没坏处。\\n修订版本指的是：提交\\n 单个修订版本\\n你可以通过任意一个提交的 40 个字符的完整 SHA-1 散列值来指定它， 不过还有很多更人性化的方式来做同样的事情。本节将会介绍获取单个提交的多种方法。\\n 简短的 SHA-1\\nGit 十分智能，你只需要提供 SHA-1 的前几个字符就可以获得对应的那次提交， 当然你提供的 SHA-1 字符数量不得少于 4 个，并且没有歧义——也就是说， 当前对象数据库中没有其它对象以这段 SHA-1 开头。\\n例如，要查看你知道其中添加了某个功能的提交，首\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/90.Git工具-交互式暂存.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/90.Git工具-交互式暂存.html\",\"frontmatter\":{\"title\":\"Git工具-交互式暂存\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/76d859/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git工具-交互式暂存\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"本节中的几个交互式 Git 命令可以帮助你将文件的特定部分组合成提交。 当你在修改了大量文件后，希望这些改动能拆分为若干提交而不是混杂在一起成为一个提交时，这几个工具会非常有用。 通过这种方式，可以确保提交是逻辑上独立的变更集，同时也会使其他开发者在与你工作时很容易地审核。 如果运行 `git add` 时使用 `-i` 或者 `--interactive` 选项，Git 将会进入一个交互式终端模式，显示类似下面的东西：\\n```sh\\n$ git add -i\\n           staged     unstaged path\\n  1:    unchanged        +0/-1 T\"},{\"url\":\"/01.前端/40.学习笔记/35.TypeScript笔记.html\",\"relativePath\":\"/01.前端/40.学习笔记/35.TypeScript笔记.html\",\"frontmatter\":{\"title\":\"TypeScript笔记\",\"date\":\"2020-10-08 13:02:48\",\"permalink\":\"/pages/51afd6/\",\"categories\":[\"前端\",\"学习笔记\"],\"tags\":[\"TypeScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"TypeScript笔记\",\"date\":\"2020-10-08 13:02:48\",\"capture\":\"TypeScript 的类型校验是给程序员看的，在编译后不会存在TS代码。\\n 类型注解\\n```typescript\\nfunction fn(person: string):void{ // 参数类型是字符串，没有返回值\\n    ///...\\n}\\nfn('str') // 如传递参数非字符串，vscode编辑器中或在编译时将给出错误提示\\nconst test:number = 1\\n```\\n 有哪些基础类型注解？\\n```typescript\\n// 基础类型\\n:string\\n:number\\n:boolean\\n:null  // 只能是null值\\n:undefined // 只能是undefined值\"},{\"url\":\"/02.页面/20.CSS/00.CSS教程和技巧收藏.html\",\"relativePath\":\"/02.页面/20.CSS/00.CSS教程和技巧收藏.html\",\"frontmatter\":{\"title\":\"CSS教程和技巧收藏\",\"date\":\"2020-08-11 17:13:52\",\"permalink\":\"/pages/c8f128/\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"CSS教程和技巧收藏\",\"date\":\"2020-08-11 17:13:52\",\"capture\":\"Flex 布局教程：语法篇\\n&lt;http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\\n CSS Grid 网格布局教程\\n&lt;http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html&gt;\\n 只要一行代码，实现五种 CSS 经典布局\\n&lt;http://www.ruanyifeng.com/blog/2020/08/five-css-layouts-in-one-line.html&gt;\\n* 空间居中布局\\n  &gt; 不管容器的大小，项目总是占据中心\"},{\"url\":\"/《Vue》笔记/10.Vuex/01.Vuex.html\",\"relativePath\":\"/《Vue》笔记/10.Vuex/01.Vuex.html\",\"frontmatter\":{\"title\":\"Vuex\",\"date\":\"2020-08-08 10:38:33\",\"permalink\":\"/pages/b30620/\",\"categories\":[\"《Vue》笔记\",\"Vuex\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Vuex\",\"date\":\"2020-08-08 10:38:33\",\"capture\":\"Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。\\n Vuex使用过程演示\\n以`vue-cli3`新创建出来的项目为例，演示Vuex的使用过程。\\n创建项目:\\n```sh\\nvue create vuex-test\\ncd vuex-test\\nnpm run serve\\n```\\n安装`vuex`:\\n```bash\\nnpm i vuex -S\\n```\\n进入项目的`src/`下新建一个文件`store/index.js`，并写入：\\n```js\\n// store/index.js\\nimport Vue from 'vue'\\nimport Vuex from 'vuex'\\nVue.use(Vu\"},{\"url\":\"/04.更多/01.学习/00.费曼学习法.html\",\"relativePath\":\"/04.更多/01.学习/00.费曼学习法.html\",\"frontmatter\":{\"title\":\"费曼学习法\",\"date\":\"2020-07-16 10:04:14\",\"permalink\":\"/pages/f2a556/\",\"categories\":[\"更多\",\"学习\"],\"tags\":[\"学习方法\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"费曼学习法\",\"date\":\"2020-07-16 10:04:14\",\"capture\":\"步骤\\n费曼学习法分为4个步骤:\\n1. 确定学习目标\\n你想学习的概念、内容、主题是什么。\\n2. 模拟教学学习法\\n你要模拟自己是一位老师，面对完全不懂这个领域的人，用自己的话，尽可能具体形象地讲诉。这样的讲诉有助于你活学活用，触类旁通，联系生活具体情境。\\n3. 回顾\\n反思第2步遇到的问题，哪些地方卡壳了，哪些地方对方没有真正听懂。找出问题的要害，把握关键环节。\\n4. 简化\\n把这些遇到问题的地方，重新梳理理解，尽可能了解更多背景和相关知识，再用尽可能简化的方式重新表达，设法看穿本质。然后，返回第2步。\\n\\n&gt; \\n&gt; 《费曼学习法：为何被称为史上最牛的学习法，它的本质究竟是什么？》\\n&gt;\"},{\"url\":\"/01.前端/40.学习笔记/05.《JavaScript高级程序设计》笔记.html\",\"relativePath\":\"/01.前端/40.学习笔记/05.《JavaScript高级程序设计》笔记.html\",\"frontmatter\":{\"title\":\"《JavaScript高级程序设计》笔记\",\"date\":\"2020-06-12 12:39:01\",\"permalink\":\"/note/js/\",\"categories\":[\"笔记\"],\"tags\":[\"笔记\",\"红宝书\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"《JavaScript高级程序设计》笔记\",\"date\":\"2020-06-12 12:39:01\",\"capture\":\"第1章  JavaScript简介\\n* JavaScript诞生于1995年\\n* 一个完整的JavaScript由这三部分组成：\\n  * ECMAScript (核心)\\n  * DOM (文档对象模型)\\n  * BOM (浏览器对象模型)\\n* ECMAScript的 宿主环境 包含 ：\\n  * 浏览器\\n  * Node\\n  * flash\\n* ECMAScript大致规定了下列组成部分：\\n  * 语法\\n  * 类型\\n  * 语句\\n  * 关键字\\n  * 保留字\\n  * 操作符\\n  * 对象\\n 第2章 在HTML中使用JavaScript\\n* `&lt;script\\n  * async 表示立即\"},{\"url\":\"/04.更多/01.学习/10.搜索引擎使用技巧.html\",\"relativePath\":\"/04.更多/01.学习/10.搜索引擎使用技巧.html\",\"frontmatter\":{\"title\":\"搜索引擎使用技巧\",\"date\":\"2020-05-24 11:44:19\",\"permalink\":\"/pages/ce818a\",\"categories\":[\"更多\",\"学习\"],\"tags\":[\"搜索技巧\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"搜索引擎使用技巧\",\"date\":\"2020-05-24 11:44:19\",\"capture\":\"搜索引擎相信大家经常在使用，但是有时候想搜某个信息时却搜出来一大堆不相关的（百度：你们都在看我干什么？）。下面我们来介绍几种搜索技巧，可以提升搜索效率，助你快速查资料，妈妈再也不担心我的学习了（'妈~我真的是在找学习资料'）\\n 技巧1：排除干扰项\\n方式：关键词1+空格+减号+关键词2，即 `关键词1 -关键词2`\\n功能：排除一些不想要的关键词\\n示例：\\n```\\n锤子 -锤子手机\\n```\\n示例中将在搜索结果排除与`锤子手机`相关的，只显示`锤子`本来的样子。\\n\\n 技巧2：精确搜索\\n方式：给关键词加双引号，`\\\"关键词\\\"`\\n功能：只搜索引号里的字，少一个字或者把字拆开都不行\\n示例：\\n```\\n\\\"达拉不崩\"},{\"url\":\"/02.页面/20.CSS/14.CSS-function汇总.html\",\"relativePath\":\"/02.页面/20.CSS/14.CSS-function汇总.html\",\"frontmatter\":{\"title\":\"CSS-function汇总\",\"date\":\"2020-05-12 09:36:44\",\"permalink\":\"/pages/3da0d7\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"CSS-function汇总\",\"date\":\"2020-05-12 09:36:44\",\"capture\":\"\"},{\"url\":\"/01.前端/25.JavaScript文章/12.比typeof运算符更准确的类型判断.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/12.比typeof运算符更准确的类型判断.html\",\"frontmatter\":{\"title\":\"比typeof运算符更准确的类型判断\",\"date\":\"2020-04-13 15:56:54\",\"permalink\":\"/pages/fd4a16d56b83c1bc\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"比typeof运算符更准确的类型判断\",\"date\":\"2020-04-13 15:56:54\",\"capture\":\"不同数据类型的`Object.prototype.toString`方法返回值如下。\\n- 数值：返回`[object Number]`。\\n- 字符串：返回`[object String]`。\\n- 布尔值：返回`[object Boolean]`。\\n- undefined：返回`[object Undefined]`。\\n- null：返回`[object Null]`。\\n- 数组：返回`[object Array]`。\\n- arguments 对象：返回`[object Arguments]`。\\n- 函数：返回`[object Function]`。\\n- Error 对象：返回`[object \"},{\"url\":\"/03.技术/01.技术文档/10.npm packageJson属性详解.html\",\"relativePath\":\"/03.技术/01.技术文档/10.npm packageJson属性详解.html\",\"frontmatter\":{\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"npm packageJson属性详解\",\"date\":\"2020-04-08 17:16:38\",\"permalink\":\"/pages/dec4f3f00e71a312\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null]},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"npm packageJson属性详解\",\"date\":\"2020-04-08 17:16:38\",\"excerpt\":\"<h1 id=\\\"npm-package-json属性详解\\\" tabindex=\\\"-1\\\">npm package.json属性详解 <a class=\\\"header-anchor\\\" href=\\\"#npm-package-json属性详解\\\" aria-label=\\\"Permalink to &quot;npm package.json属性详解&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<blockquote>\\n<p>本文转自<a href=\\\"https://www.cnblogs.com/tzyy/p/5193811.html\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">https://www.cnblogs.com/tzyy/p/5193811.html</a>，作者：TZYY</p>\\n</blockquote>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p><code>package.json</code>必须是一个严格的json文件，而不仅仅是js里边的一个对象。其中很多属性可以通过<code>npm-config</code>来生成</p>\\n\",\"capture\":\"npm package.json属性详解\\n\\n 概述\\n`package.json`必须是一个严格的json文件，而不仅仅是js里边的一个对象。其中很多属性可以通过`npm-config`来生成\\n name\\n`package.json`中最重要的属性是`name`和`version`两个属性，这两个属性是必须要有的，否则模块就无法被安装，这两个属性一起形成了一个npm模块的唯一标识符。模块中内容变更的同时，模块版本也应该一起变化。\\n`name`属性就是你的模块名称，下面是一些命名规则:\\n- `name`必须小于等于214个字节，包括前缀名称在内（如 xxx/xxxmodule）。\\n- `name`\"},{\"url\":\"/02.页面/20.CSS/13.如何根据系统主题自动响应CSS深色模式.html\",\"relativePath\":\"/02.页面/20.CSS/13.如何根据系统主题自动响应CSS深色模式.html\",\"frontmatter\":{\"title\":\"如何根据系统主题自动响应CSS深色模式\",\"date\":\"2020-03-31 14:06:26\",\"permalink\":\"/pages/5dde351274f1e39d\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[\"css\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"如何根据系统主题自动响应CSS深色模式\",\"date\":\"2020-03-31 14:06:26\",\"excerpt\":\"<h1 id=\\\"如何根据系统主题自动响应css深色模式\\\" tabindex=\\\"-1\\\">如何根据系统主题自动响应CSS深色模式 <a class=\\\"header-anchor\\\" href=\\\"#如何根据系统主题自动响应css深色模式\\\" aria-label=\\\"Permalink to &quot;如何根据系统主题自动响应CSS深色模式&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p align=\\\"center\\\">\\n  <img src=\\\"https://cdn.staticaly.com/gh/xugaoyi/image_store/blog/20200427163531.jpg\\\" width=\\\"500\\\">\\n</p>\\n<p>很多人喜欢选择APP或网站中的深色模式，也许他们更喜欢这样的外观，或者他们想让自己的眼睛免受疲劳。这篇文章将告诉你如何在网站中实现一个自动的CSS深色模式，根据访客的系统主题来自动响应。</p>\\n\",\"capture\":\"如何根据系统主题自动响应CSS深色模式\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"https://cdn.staticaly.com/gh/xugaoyi/image_store/blog/20200427163531.jpg\\\" width=\\\"500\\\"&gt;\\n&lt;/p&gt;\\n很多人喜欢选择APP或网站中的深色模式，也许他们更喜欢这样的外观，或者他们想让自己的眼睛免受疲劳。这篇文章将告诉你如何在网站中实现一个自动的CSS深色模式，根据访客的系统主题来自动响应。\\n CSS 深色模式 (Dark Mode)\\n在`:root`根元素中定义变量来设置主题的颜色。我建\"},{\"url\":\"/02.页面/20.CSS/12.水平垂直居中的几种方式-案例.html\",\"relativePath\":\"/02.页面/20.CSS/12.水平垂直居中的几种方式-案例.html\",\"frontmatter\":{\"title\":\"水平垂直居中的几种方式-案例\",\"date\":\"2020-03-13 16:13:43\",\"permalink\":\"/pages/cb7cb251adba4bf7\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"水平垂直居中的几种方式-案例\",\"date\":\"2020-03-13 16:13:43\",\"capture\":\"&lt;iframe height=\\\"880\\\" style=\\\"width: 100%;\\\" scrolling=\\\"no\\\" title=\\\"水平垂直居中的几种方式\\\" src=\\\"https://codepen.io/xugaoyi/embed/poJLeYv?height=880&theme-id=light&default-tab=result\\\" frameborder=\\\"no\\\" allowtransparency=\\\"true\\\" allowfullscreen=\\\"true\\\"\\n  See the Pen &lt;a href='https://codepen.io/xugaoyi/pen/poJLeY\"},{\"url\":\"/01.前端/25.JavaScript文章/11.JS获取和修改url参数.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/11.JS获取和修改url参数.html\",\"frontmatter\":{\"title\":\"JS获取和修改url参数\",\"date\":\"2020-03-05 12:45:37\",\"permalink\":\"/pages/7a91be2d502346ce\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"JS获取和修改url参数\",\"date\":\"2020-03-05 12:45:37\",\"capture\":\"获取url参数\\n```js\\n/**\\n * 获取url里的参数\\n * @param arg 参数名\\n * @returns\\n */\\nfunction getURLString(arg) {\\n    var reg = new RegExp(\\\"(^|&)\\\" + arg + \\\"=([^&]*)(&|$)\\\", \\\"i\\\");\\n    var r = window.location.search.substr(1).match(reg);\\n    if (r != null)\\n        return unescape(r[2]);\\n    return null;\\n}\\n```\\n 修改url参数\\n```\"},{\"url\":\"/01.前端/25.JavaScript文章/10.防抖与节流函数.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/10.防抖与节流函数.html\",\"frontmatter\":{\"title\":\"防抖与节流函数\",\"date\":\"2020-02-29 15:07:47\",\"permalink\":\"/pages/0f6a0ac99b62ede5\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"防抖与节流函数\",\"date\":\"2020-02-29 15:07:47\",\"excerpt\":\"<h1 id=\\\"防抖与节流函数\\\" tabindex=\\\"-1\\\">防抖与节流函数 <a class=\\\"header-anchor\\\" href=\\\"#防抖与节流函数\\\" aria-label=\\\"Permalink to &quot;防抖与节流函数&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>防抖和节流的作用都是在高频事件中防止函数被多次调用，是一种性能优化的方案。</p>\\n<p>区别在于，防抖函数只会在高频事件结束后n毫秒调用一次函数，节流函数会在高频事件触发过程当中每隔n毫秒调用一次函数。</p>\\n\",\"capture\":\"防抖和节流的作用都是在高频事件中防止函数被多次调用，是一种性能优化的方案。\\n区别在于，防抖函数只会在高频事件结束后n毫秒调用一次函数，节流函数会在高频事件触发过程当中每隔n毫秒调用一次函数。\\n 防抖函数\\n触发高频事件后一段时间（wait）只会执行一次函数，如果指定时间（wait）内高频事件再次被触发，则重新计算时间。\\n 封装\\n```js\\n// 防抖函数\\nfunction debounce(func, wait) {\\n    let timeout = null;\\n    return function () {\\n        let context = this;\\n        let a\"},{\"url\":\"/02.页面/20.CSS/11.从box-sizing属性入手，了解盒子模型.html\",\"relativePath\":\"/02.页面/20.CSS/11.从box-sizing属性入手，了解盒子模型.html\",\"frontmatter\":{\"title\":\"从box-sizing属性入手，了解盒子模型\",\"date\":\"2020-02-27 17:08:48\",\"permalink\":\"/pages/20a978023139589d\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"从box-sizing属性入手，了解盒子模型\",\"date\":\"2020-02-27 17:08:48\",\"excerpt\":\"<h1 id=\\\"从box-sizing属性入手-了解盒子模型\\\" tabindex=\\\"-1\\\">从box-sizing属性入手，了解盒子模型 <a class=\\\"header-anchor\\\" href=\\\"#从box-sizing属性入手-了解盒子模型\\\" aria-label=\\\"Permalink to &quot;从box-sizing属性入手，了解盒子模型&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"背景\\\" tabindex=\\\"-1\\\">背景 <a class=\\\"header-anchor\\\" href=\\\"#背景\\\" aria-label=\\\"Permalink to &quot;背景&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>先声明一下运用的场景，假如项目布局使用的是<strong>自适应</strong>的布局方式，div给出的宽度是<strong>百分比</strong>的形式，即占窗口宽度的100%，但边框<code>border</code>和内边距<code>padding</code>是用像素来表示的，此时就会造成一个问题是div总宽度超过窗口宽度。为了避免这种问题，可以使用属性<code>box-sizing:border-box</code>来把 <strong>标准盒模型</strong> 变成 <strong>代替(IE)盒模型</strong> ，从而使div的总宽度依然是100%</p>\\n\",\"capture\":\"背景\\n先声明一下运用的场景，假如项目布局使用的是自适应的布局方式，div给出的宽度是百分比的形式，即占窗口宽度的100%，但边框`border`和内边距`padding`是用像素来表示的，此时就会造成一个问题是div总宽度超过窗口宽度。为了避免这种问题，可以使用属性`box-sizing:border-box`来把 标准盒模型 变成 代替(IE)盒模型 ，从而使div的总宽度依然是100%\\n 什么是CSS 盒模型?\\n页面布局中，一个元素的外边距（margin）、 边框（border）、内边距（padding）、内容（content）组成一个盒模型。盒模型可分为标准盒模型 和 代替（IE）盒模型\"},{\"url\":\"/02.页面/20.CSS/10.文字在一行或多行时超出显示省略号.html\",\"relativePath\":\"/02.页面/20.CSS/10.文字在一行或多行时超出显示省略号.html\",\"frontmatter\":{\"title\":\"文字在一行或多行时超出显示省略号\",\"date\":\"2020-02-23 15:07:08\",\"permalink\":\"/pages/42b66999cc27dc25\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"文字在一行或多行时超出显示省略号\",\"date\":\"2020-02-23 15:07:08\",\"excerpt\":\"<h1 id=\\\"文字在一行或多行时超出显示省略号\\\" tabindex=\\\"-1\\\">文字在一行或多行时超出显示省略号 <a class=\\\"header-anchor\\\" href=\\\"#文字在一行或多行时超出显示省略号\\\" aria-label=\\\"Permalink to &quot;文字在一行或多行时超出显示省略号&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"一行超出显示省略\\\" tabindex=\\\"-1\\\">一行超出显示省略 <a class=\\\"header-anchor\\\" href=\\\"#一行超出显示省略\\\" aria-label=\\\"Permalink to &quot;一行超出显示省略&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<div class=\\\"language-css vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">css</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">overflow: hidden;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">white-space</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">: nowrap;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">text-overflow</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">: ellipsis;</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br></div></div>\",\"capture\":\"一行超出显示省略\\n```css\\noverflow: hidden;\\nwhite-space: nowrap;\\ntext-overflow: ellipsis;\\n```\\n```html\\n&lt;html\\n   &lt;div class=\\\"box-42b6\\\"&gt;演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字&lt;/div&gt;\\n&lt;/html&gt;\\n&lt;style&gt;\\n    .box-42b6{\\n        border: 1px solid 999;\\n        width\"},{\"url\":\"/01.前端/25.JavaScript文章/09.将一维数组按指定长度转为二维数组.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/09.将一维数组按指定长度转为二维数组.html\",\"frontmatter\":{\"title\":\"将一维数组按指定长度转为二维数组\",\"date\":\"2020-02-23 13:49:31\",\"permalink\":\"/pages/f1acb712033ac8da\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"将一维数组按指定长度转为二维数组\",\"date\":\"2020-02-23 13:49:31\",\"capture\":\"将一维数组按指定长度转为二维数组\\n```js\\nfunction pages(arr, len) {\\n    const pages = []\\n    arr.forEach((item, index) =\\n        const page = Math.floor(index / len)\\n        if (!pages[page]) {\\n            pages[page] = []\\n        }\\n        pages[page].push(item)\\n    })\\n    return pages\\n}\\n// 使用\\nconst arr = [1, 2, 3, \"},{\"url\":\"/02.页面/20.CSS/09.「布局技巧」图片未加载前自动撑开元素高度.html\",\"relativePath\":\"/02.页面/20.CSS/09.「布局技巧」图片未加载前自动撑开元素高度.html\",\"frontmatter\":{\"title\":\"「布局技巧」图片未加载前自动撑开元素高度\",\"date\":\"2020-02-22 16:37:10\",\"permalink\":\"/pages/3d52574260725aea\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"「布局技巧」图片未加载前自动撑开元素高度\",\"date\":\"2020-02-22 16:37:10\",\"excerpt\":\"<h1 id=\\\"「布局技巧」图片未加载前自动撑开元素高度\\\" tabindex=\\\"-1\\\">「布局技巧」图片未加载前自动撑开元素高度 <a class=\\\"header-anchor\\\" href=\\\"#「布局技巧」图片未加载前自动撑开元素高度\\\" aria-label=\\\"Permalink to &quot;「布局技巧」图片未加载前自动撑开元素高度&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>在移动端开发中，有一些元素是根据图片高度来自动撑开的 ，高度不能写死（如轮播图的外层元素）。在网络较慢的情况下，图片加载需要一些时间，此时该元素的高度没有被撑开，在网页布局上会有一些不想看到的效果。</p>\\n\",\"capture\":\"在移动端开发中，有一些元素是根据图片高度来自动撑开的 ，高度不能写死（如轮播图的外层元素）。在网络较慢的情况下，图片加载需要一些时间，此时该元素的高度没有被撑开，在网页布局上会有一些不想看到的效果。\\n这种情况我们可以设置如下样式来设置该元素的高度：\\n```stylus\\n.wrapper\\n  overflow hidden\\n  width 100%\\n  height 0\\n  padding-bottom 26.66% // 这个数值是图片的高宽比，即 高/宽\\n  background eee\\n```\\n上面代码中，`padding-bottom` 的取值是图片的高宽比（即，高/宽），它会根据 `w\"},{\"url\":\"/01.前端/25.JavaScript文章/03.ES5面向对象.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/03.ES5面向对象.html\",\"frontmatter\":{\"title\":\"ES5面向对象\",\"date\":\"2020-02-22 10:35:43\",\"permalink\":\"/pages/b1af5cb8996363c5\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"ES5面向对象\",\"date\":\"2020-02-22 10:35:43\",\"capture\":\"```js\\n//面向对象封装\\nfunction Student(props){ // 构造函数 （构造函数内定于属性。尊从首字母大写的约定）\\n  this.name = props.name || '匿名';  // 默认‘匿名’\\n  this.grade = props.grade || 1;\\n}\\nStudent.prototype.hello = function(){ // 在构造函数的原型上定义方法\\n  console.log('你好,'+ this.name +'同学，你在'+ this.grade+'年级');\\n}\\n//使用\\nfunction createStudent(props\"},{\"url\":\"/02.页面/10.HTML/10.常用meta整理.html\",\"relativePath\":\"/02.页面/10.HTML/10.常用meta整理.html\",\"frontmatter\":{\"title\":\"常用meta整理\",\"date\":\"2020-02-21 12:20:10\",\"permalink\":\"/pages/8309a5b876fc95e3\",\"categories\":[\"页面\",\"HTML\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"常用meta整理\",\"date\":\"2020-02-21 12:20:10\",\"excerpt\":\"<h1 id=\\\"常用meta整理\\\" tabindex=\\\"-1\\\">常用meta整理 <a class=\\\"header-anchor\\\" href=\\\"#常用meta整理\\\" aria-label=\\\"Permalink to &quot;常用meta整理&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"meta-元素\\\" tabindex=\\\"-1\\\">&lt;meta&gt; 元素 <a class=\\\"header-anchor\\\" href=\\\"#meta-元素\\\" aria-label=\\\"Permalink to &quot;&lt;meta\\\\&gt; 元素&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"概要\\\" tabindex=\\\"-1\\\">概要 <a class=\\\"header-anchor\\\" href=\\\"#概要\\\" aria-label=\\\"Permalink to &quot;概要&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>meta标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。</p>\\n\",\"capture\":\"&lt;meta\\\\\\n 概要\\nmeta标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。\\n必要属性\\n| 属性    | 值        | 描述                                   |\\n| ------- | --------- | -------------------------------------- |\\n| content | some text | 定义与http-equiv或name属性相关的元信息 |\\n可选属性\\n| 属性     \"},{\"url\":\"/《Vue》笔记/05.工具/10.Vue CLi v3 创建项目使用记录.html\",\"relativePath\":\"/《Vue》笔记/05.工具/10.Vue CLi v3 创建项目使用记录.html\",\"frontmatter\":{\"title\":\"Vue CLi v3 创建项目使用记录\",\"date\":\"2020-02-20 17:24:29\",\"permalink\":\"/pages/d00311f8174119b2\",\"categories\":[\"《Vue》笔记\",\"工具\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Vue CLi v3 创建项目使用记录\",\"date\":\"2020-02-20 17:24:29\",\"capture\":\"官方文档\\n以下使用的CLi版本是 v3.11.0\\n vue create\\n1. 运行以下命令来创建一个新项目\\n```sh\\nvue create hello-world\\n```\\n2. 你会被提示选取一个 preset (预设)。你可以选默认的包含了基本的 Babel + ESLint 设置的 preset，也可以选“手动选择特性”来选取需要的特性。\\n```sh\\nVue CLI v3.11.0\\n? Please pick a preset: (Use arrow keys)\\n\\n  Manually select features (手动选择特性)\\n```\\n默认预设只包含Babel + ESLint\"},{\"url\":\"/《Vue》笔记/04.可复用性&组合/01.Mixin混入.html\",\"relativePath\":\"/《Vue》笔记/04.可复用性&组合/01.Mixin混入.html\",\"frontmatter\":{\"title\":\"Mixin混入\",\"date\":\"2020-02-19 15:22:41\",\"permalink\":\"/pages/bd36a3c1bc3e0821\",\"categories\":[\"《Vue》笔记\",\"可复用性&组合\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Mixin混入\",\"date\":\"2020-02-19 15:22:41\",\"excerpt\":\"<h1 id=\\\"mixin混入\\\" tabindex=\\\"-1\\\">Mixin混入 <a class=\\\"header-anchor\\\" href=\\\"#mixin混入\\\" aria-label=\\\"Permalink to &quot;Mixin混入&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"基础\\\" tabindex=\\\"-1\\\">基础 <a class=\\\"header-anchor\\\" href=\\\"#基础\\\" aria-label=\\\"Permalink to &quot;基础&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。</p>\\n\",\"capture\":\"基础\\n混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。\\n\\n&gt;\\n&gt; 可通过 `this.$options` 查看选项\\n例子：\\n```js\\n// 定义一个混入对象\\nvar myMixin = {\\n  created: function () {\\n    this.hello()\\n  },\\n  methods: {\\n    hello: function () {\\n      console.log('hello from mixin!')\\n  \"},{\"url\":\"/《Vue》笔记/02.组件/90.vue父子组件的生命周期顺序.html\",\"relativePath\":\"/《Vue》笔记/02.组件/90.vue父子组件的生命周期顺序.html\",\"frontmatter\":{\"title\":\"vue父子组件的生命周期顺序\",\"date\":\"2020-02-18 16:39:33\",\"permalink\":\"/pages/e6cec47efa42d7f1\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"vue父子组件的生命周期顺序\",\"date\":\"2020-02-18 16:39:33\",\"capture\":\"加载渲染过程\\n```\\n父beforeCreate -\\n```\\n父组件会先执行到beforeMount，接着会执行子组件钩子到挂载结束，再挂载父组件。\\n 子组件更新过程\\n```\\n父beforeUpdate -&gt; 子beforeUpdate -&gt; 子updated -&gt; 父updated\\n```\\n 父组件更新过程\\n```\\n父beforeUpdate -&gt; 父updated\\n```\\n 销毁过程\\n```\\n父beforeDestroy -&gt; 子beforeDestroy -&gt; 子destroyed -&gt; 父destroyed\\n```\"},{\"url\":\"/《Vue》笔记/03.过渡&动画/112.使用animate库.html\",\"relativePath\":\"/《Vue》笔记/03.过渡&动画/112.使用animate库.html\",\"frontmatter\":{\"title\":\"使用animate库\",\"date\":\"2020-02-17 16:05:52\",\"permalink\":\"/pages/3b0a20e70805fcea\",\"categories\":[\"《Vue》笔记\",\"过渡&动画\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"使用animate库\",\"date\":\"2020-02-17 16:05:52\",\"excerpt\":\"<h1 id=\\\"vue中使用animate-css库\\\" tabindex=\\\"-1\\\">vue中使用Animate.css库 <a class=\\\"header-anchor\\\" href=\\\"#vue中使用animate-css库\\\" aria-label=\\\"Permalink to &quot;vue中使用Animate.css库&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"自定义过渡类名\\\" tabindex=\\\"-1\\\">自定义过渡类名 <a class=\\\"header-anchor\\\" href=\\\"#自定义过渡类名\\\" aria-label=\\\"Permalink to &quot;自定义过渡类名&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>我们可以通过以下 attribute 来自定义过渡类名：</p>\\n<ul>\\n<li><code>enter-class</code></li>\\n<li><code>enter-active-class</code></li>\\n<li><code>enter-to-class</code> (2.1.8+)</li>\\n<li><code>leave-class</code></li>\\n<li><code>leave-active-class</code></li>\\n<li><code>leave-to-class</code> (2.1.8+)</li>\\n</ul>\\n\",\"capture\":\"自定义过渡类名\\n我们可以通过以下 attribute 来自定义过渡类名：\\n- `enter-class`\\n- `enter-active-class`\\n- `enter-to-class` (2.1.8+)\\n- `leave-class`\\n- `leave-active-class`\\n- `leave-to-class` (2.1.8+)\\n他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 Animate.css结合使用十分有用。\\n 使用Animate.css库\\n```html\\n&lt;transition\\n            name=\\\"custom-\"},{\"url\":\"/《Vue》笔记/02.组件/80.动态组件与 v-once 指令.html\",\"relativePath\":\"/《Vue》笔记/02.组件/80.动态组件与 v-once 指令.html\",\"frontmatter\":{\"title\":\"动态组件与 v-once 指令\",\"date\":\"2020-02-16 15:52:19\",\"permalink\":\"/pages/636ca33122e9a64b\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"动态组件与 v-once 指令\",\"date\":\"2020-02-16 15:52:19\",\"capture\":\"动态组件\\n```html\\n&lt;div id=\\\"root\\\"\\n\\t&lt;component :is=\\\"type\\\"&gt;&lt;/component&gt; &lt;!--其效果如同下面两行被注释的代码--&gt;\\n\\t&lt;!-- &lt;child-one v-if=\\\"type === 'child-one'\\\"&gt;&lt;/child-one&gt;\\n\\t    &lt;child-two v-if=\\\"type === 'child-two'\\\"&gt;&lt;/child-two&gt; --&gt;\\n\\t&lt;button @click=\\\"handleClick\\\"&gt;change&\"},{\"url\":\"/《Vue》笔记/02.组件/75.插槽slot.html\",\"relativePath\":\"/《Vue》笔记/02.组件/75.插槽slot.html\",\"frontmatter\":{\"title\":\"插槽slot\",\"date\":\"2020-02-16 11:46:27\",\"permalink\":\"/pages/055ecee9a4325386\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"插槽slot\",\"date\":\"2020-02-16 11:46:27\",\"capture\":\"API\\n 插槽\\n```html\\n&lt;div id=\\\"root\\\"\\n    &lt;child&gt; &lt;!-- 组件标签 --&gt;\\n        &lt;h1&gt;hello&lt;/h1&gt;\\n    &lt;/child&gt;\\n&lt;/div&gt;\\n&lt;script type=\\\"text/javascript\\\"&gt;\\n    Vue.component('child', { // 子组件\\n        template: '&lt;div&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;'\\n    })\\n    var vm \"},{\"url\":\"/《Vue》笔记/02.组件/65.非父子组件传值.html\",\"relativePath\":\"/《Vue》笔记/02.组件/65.非父子组件传值.html\",\"frontmatter\":{\"title\":\"非父子组件传值\",\"date\":\"2020-02-15 14:55:03\",\"permalink\":\"/pages/d408e64f666f146d\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"非父子组件传值\",\"date\":\"2020-02-15 14:55:03\",\"excerpt\":\"<h1 id=\\\"非父子组件间传值\\\" tabindex=\\\"-1\\\">非父子组件间传值 <a class=\\\"header-anchor\\\" href=\\\"#非父子组件间传值\\\" aria-label=\\\"Permalink to &quot;非父子组件间传值&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>当组件的嵌套多时，非父子组件间传值就显得复杂，除了使用<a href=\\\"https://vuex.vuejs.org/zh/\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">vuex</a>实现之外，还可以通过Bus（或者叫 总线/发布订阅模式/观察者模式）的方式实现非父子组件间传值。</p>\\n\",\"capture\":\"当组件的嵌套多时，非父子组件间传值就显得复杂，除了使用vuex实现之外，还可以通过Bus（或者叫 总线/发布订阅模式/观察者模式）的方式实现非父子组件间传值。\\n&lt;div id=\\\"root\\\"\\n\\t\\t&lt;child1 content=\\\"组件1：点我传出值\\\"&gt;&lt;/child1&gt;\\n\\t\\t&lt;child2 content=\\\"组件2\\\"&gt;&lt;/child2&gt;\\n\\t&lt;/div&gt;\\n```html\\n&lt;div id=\\\"root\\\"&gt;\\n    &lt;child1 content=\\\"组件1：点我传出值\\\"&gt;&lt;/child1&gt;\\n    &l\"},{\"url\":\"/《Vue》笔记/02.组件/55.自定义事件.html\",\"relativePath\":\"/《Vue》笔记/02.组件/55.自定义事件.html\",\"frontmatter\":{\"title\":\"自定义事件\",\"date\":\"2020-02-15 11:27:45\",\"permalink\":\"/pages/9651417d08d1779d\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"自定义事件\",\"date\":\"2020-02-15 11:27:45\",\"capture\":\"API\\n 在组件标签v-on绑定的事件是自定义事件\\n```html\\n&lt;div id=\\\"root\\\"\\n    &lt;child @click=\\\"handleClick\\\"&gt;&lt;/child&gt; &lt;!--这里click是自定义事件--&gt;\\n&lt;/div&gt;\\n&lt;script type=\\\"text/javascript\\\"&gt;\\n    Vue.component('child', {\\n        template: '&lt;button&gt;Child&lt;/button&gt;',\\n    })\\n    var vm = new Vue({\\n  \"},{\"url\":\"/《Vue》笔记/02.组件/52.Prop 验证 与 非 Prop 的 Attribute.html\",\"relativePath\":\"/《Vue》笔记/02.组件/52.Prop 验证 与 非 Prop 的 Attribute.html\",\"frontmatter\":{\"title\":\"Prop 验证 与 非 Prop 的 Attribute\",\"date\":\"2020-02-15 10:49:04\",\"permalink\":\"/pages/a3080f60f6596eb4\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Prop 验证 与 非 Prop 的 Attribute\",\"date\":\"2020-02-15 10:49:04\",\"capture\":\"Prop 验证\\nAPI\\n子组件对父组件传递来的参数进行校验\\n```js\\nVue.component('my-component', {\\n  props: {\\n    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)\\n    propA: Number,\\n    // 多个可能的类型\\n    propB: [String, Number],\\n    // 必填的字符串\\n    propC: {\\n      type: String,\\n      required: true\\n    },\\n    // 带有默认值的数字\\n    propD: {\\n      \"},{\"url\":\"/《Vue》笔记/02.组件/36.使用组件的细节点.html\",\"relativePath\":\"/《Vue》笔记/02.组件/36.使用组件的细节点.html\",\"frontmatter\":{\"title\":\"使用组件的细节点\",\"date\":\"2020-02-13 13:26:20\",\"permalink\":\"/pages/83a1ab785e7fd70c\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"使用组件的细节点\",\"date\":\"2020-02-13 13:26:20\",\"capture\":\"解析 DOM 模板时的注意事项\\n```html\\n&lt;div id=\\\"root\\\"\\n    &lt;table&gt;\\n        &lt;tbody&gt;\\n            &lt;row&gt;&lt;/row&gt;\\n            &lt;row&gt;&lt;/row&gt;\\n            &lt;row&gt;&lt;/row&gt;\\n        &lt;/tbody&gt;\\n    &lt;/table&gt;\\n&lt;/div&gt;\\n&lt;script type=\\\"text/javascript\\\"&gt;\\n    Vue.component\"},{\"url\":\"/《ES6 教程》笔记/29.最新提案.html\",\"relativePath\":\"/《ES6 教程》笔记/29.最新提案.html\",\"frontmatter\":{\"title\":\"最新提案\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/7188882b8d65af1b\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"最新提案\",\"date\":\"2020-02-09 16:00:30\",\"excerpt\":\"<h1 id=\\\"最新提案\\\" tabindex=\\\"-1\\\">最新提案 <a class=\\\"header-anchor\\\" href=\\\"#最新提案\\\" aria-label=\\\"Permalink to &quot;最新提案&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>本章介绍一些尚未进入标准、但很有希望的最新提案。</p>\\n<h2 id=\\\"do-表达式\\\" tabindex=\\\"-1\\\">do 表达式 <a class=\\\"header-anchor\\\" href=\\\"#do-表达式\\\" aria-label=\\\"Permalink to &quot;do 表达式&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">{</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">  let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> t </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> f</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">();</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">  t </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> t </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">*</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> t </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">+</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br></div></div>\",\"capture\":\"本章介绍一些尚未进入标准、但很有希望的最新提案。\\n do 表达式\\n本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。\\n```javascript\\n{\\n  let t = f();\\n  t = t * t + 1;\\n}\\n```\\n上面代码中，块级作用域将两个语句封装在一起。但是，在块级作用域以外，没有办法得到`t`的值，因为块级作用域不返回值，除非`t`是全局变量。\\n现在有一个提案，使得块级作用域可以变为表达式，也就是说可以返回值，办法就是在块级作用域之前加上`do`，使它变为`do`表达式，然后就会返回内部最后执行的表达式的值。\\n```javascript\\nlet x = do {\"},{\"url\":\"/《ES6 教程》笔记/30.装饰器.html\",\"relativePath\":\"/《ES6 教程》笔记/30.装饰器.html\",\"frontmatter\":{\"title\":\"装饰器\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/e97bc1e5626b082c\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"装饰器\",\"date\":\"2020-02-09 16:00:30\",\"excerpt\":\"<h1 id=\\\"装饰器\\\" tabindex=\\\"-1\\\">装饰器 <a class=\\\"header-anchor\\\" href=\\\"#装饰器\\\" aria-label=\\\"Permalink to &quot;装饰器&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>[说明] Decorator 提案经过了大幅修改，目前还没有定案，不知道语法会不会再变。下面的内容完全依据以前的提案，已经有点过时了。等待定案以后，需要完全重写。</p>\\n<p>装饰器（Decorator）是一种与类（class）相关的语法，用来注释或修改类和类方法。许多面向对象的语言都有这项功能，目前有一个<a href=\\\"https://github.com/tc39/proposal-decorators\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">提案</a>将其引入了 ECMAScript。</p>\\n\",\"capture\":\"[说明] Decorator 提案经过了大幅修改，目前还没有定案，不知道语法会不会再变。下面的内容完全依据以前的提案，已经有点过时了。等待定案以后，需要完全重写。\\n装饰器（Decorator）是一种与类（class）相关的语法，用来注释或修改类和类方法。许多面向对象的语言都有这项功能，目前有一个提案将其引入了 ECMAScript。\\n装饰器是一种函数，写成`@ + 函数名`。它可以放在类和类方法的定义前面。\\n```javascript\\n@frozen class Foo {\\n  @configurable(false)\\n  @enumerable(true)\\n  method() {}\\n  @\"},{\"url\":\"/《ES6 教程》笔记/31.函数式编程.html\",\"relativePath\":\"/《ES6 教程》笔记/31.函数式编程.html\",\"frontmatter\":{\"title\":\"函数式编程\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/1cf50330655efc69\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"函数式编程\",\"date\":\"2020-02-09 16:00:30\",\"excerpt\":\"<h1 id=\\\"函数式编程\\\" tabindex=\\\"-1\\\">函数式编程 <a class=\\\"header-anchor\\\" href=\\\"#函数式编程\\\" aria-label=\\\"Permalink to &quot;函数式编程&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>JavaScript 语言从一诞生，就具有函数式编程的烙印。它将函数作为一种独立的数据类型，与其他数据类型处于完全平等的地位。在 JavaScript 语言中，你可以采用面向对象编程，也可以采用函数式编程。有人甚至说，JavaScript 是有史以来第一种被大规模采用的函数式编程语言。</p>\\n\",\"capture\":\"JavaScript 语言从一诞生，就具有函数式编程的烙印。它将函数作为一种独立的数据类型，与其他数据类型处于完全平等的地位。在 JavaScript 语言中，你可以采用面向对象编程，也可以采用函数式编程。有人甚至说，JavaScript 是有史以来第一种被大规模采用的函数式编程语言。\\nES6 的种种新增功能，使得函数式编程变得更方便、更强大。本章介绍 ES6 如何进行函数式编程。\\n 柯里化\\n柯里化（currying）指的是将一个多参数的函数拆分成一系列函数，每个拆分后的函数都只接受一个参数（unary）。\\n```javascript\\nfunction add (a, b) {\\n  retur\"},{\"url\":\"/《ES6 教程》笔记/32.Mixin.html\",\"relativePath\":\"/《ES6 教程》笔记/32.Mixin.html\",\"frontmatter\":{\"title\":\"Mixin\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/6a8e2dc558da1b39\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Mixin\",\"date\":\"2020-02-09 16:00:30\",\"excerpt\":\"<h1 id=\\\"mixin\\\" tabindex=\\\"-1\\\">Mixin <a class=\\\"header-anchor\\\" href=\\\"#mixin\\\" aria-label=\\\"Permalink to &quot;Mixin&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>JavaScript 语言的设计是单一继承，即子类只能继承一个父类，不允许继承多个父类。这种设计保证了对象继承的层次结构是树状的，而不是复杂的<a href=\\\"https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">网状结构</a>。</p>\\n\",\"capture\":\"JavaScript 语言的设计是单一继承，即子类只能继承一个父类，不允许继承多个父类。这种设计保证了对象继承的层次结构是树状的，而不是复杂的网状结构。\\n但是，这大大降低了编程的灵活性。因为实际开发中，有时不可避免，子类需要继承多个父类。举例来说，“猫”可以继承“哺乳类动物”，也可以继承“宠物”。\\n各种单一继承的编程语言，有不同的多重继承解决方案。比如，Java 语言也是子类只能继承一个父类，但是还允许继承多个界面（interface），这样就间接实现了多重继承。Interface 与父类一样，也是一个类，只不过它只定义接口（method signature），不定义实现，因此又被称为“抽象类\"},{\"url\":\"/《ES6 教程》笔记/33.SIMD.html\",\"relativePath\":\"/《ES6 教程》笔记/33.SIMD.html\",\"frontmatter\":{\"title\":\"SIMD\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/8e8f80f69b775a56\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"SIMD\",\"date\":\"2020-02-09 16:00:30\",\"excerpt\":\"<h1 id=\\\"simd\\\" tabindex=\\\"-1\\\">SIMD <a class=\\\"header-anchor\\\" href=\\\"#simd\\\" aria-label=\\\"Permalink to &quot;SIMD&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>SIMD（发音<code>/sim-dee/</code>）是“Single Instruction/Multiple Data”的缩写，意为“单指令，多数据”。它是 JavaScript 操作 CPU 对应指令的接口，你可以看做这是一种不同的运算执行模式。与它相对的是 SISD（“Single Instruction/Single Data”），即“单指令，单数据”。</p>\\n\",\"capture\":\"概述\\nSIMD（发音`/sim-dee/`）是“Single Instruction/Multiple Data”的缩写，意为“单指令，多数据”。它是 JavaScript 操作 CPU 对应指令的接口，你可以看做这是一种不同的运算执行模式。与它相对的是 SISD（“Single Instruction/Single Data”），即“单指令，单数据”。\\nSIMD 的含义是使用一个指令，完成多个数据的运算；SISD 的含义是使用一个指令，完成单个数据的运算，这是 JavaScript 的默认运算模式。显而易见，SIMD 的执行效率要高于 SISD，所以被广泛用于 3D 图形运算、物理模拟等运算\"},{\"url\":\"/《ES6 教程》笔记/34.参考链接.html\",\"relativePath\":\"/《ES6 教程》笔记/34.参考链接.html\",\"frontmatter\":{\"title\":\"参考链接\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/ea6f3b870f6dab69\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"参考链接\",\"date\":\"2020-02-09 16:00:30\",\"capture\":\"官方文件\\n- ECMAScript® 2015 Language Specification: ECMAScript 2015 规格\\n- ECMAScript® 2016 Language Specification: ECMAScript 2016 规格\\n- ECMAScript® 2017 Language Specification：ECMAScript 2017 规格（草案）\\n- ECMAScript Current Proposals: ECMAScript 当前的所有提案\\n- ECMAScript Active Proposals: 已经进入正式流程的提案\\n- ECMAScript\"},{\"url\":\"/《ES6 教程》笔记/02.let 和 const 命令.html\",\"relativePath\":\"/《ES6 教程》笔记/02.let 和 const 命令.html\",\"frontmatter\":{\"title\":\"let 和 const 命令\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/c1edd70a6b7c7872\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"let 和 const 命令\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"let-和-const-命令\\\" tabindex=\\\"-1\\\">let 和 const 命令 <a class=\\\"header-anchor\\\" href=\\\"#let-和-const-命令\\\" aria-label=\\\"Permalink to &quot;let 和 const 命令&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"let-命令\\\" tabindex=\\\"-1\\\">let 命令 <a class=\\\"header-anchor\\\" href=\\\"#let-命令\\\" aria-label=\\\"Permalink to &quot;let 命令&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"基本用法\\\" tabindex=\\\"-1\\\">基本用法 <a class=\\\"header-anchor\\\" href=\\\"#基本用法\\\" aria-label=\\\"Permalink to &quot;基本用法&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>ES6 新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code>，但是所声明的变量，<strong>只在<code>let</code>命令所在的代码块内有效(块级作用域)</strong>。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">{</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">  let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> a </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 10</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">  var</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> b </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">a </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// ReferenceError: a is not defined.</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">b </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// 1</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br></div></div>\",\"capture\":\"let 命令\\n 基本用法\\nES6 新增了`let`命令，用来声明变量。它的用法类似于`var`，但是所声明的变量，只在`let`命令所在的代码块内有效(块级作用域)。\\n```javascript\\n{\\n  let a = 10;\\n  var b = 1;\\n}\\na // ReferenceError: a is not defined.\\nb // 1\\n```\\n上面代码在代码块之中，分别用`let`和`var`声明了两个变量。然后在代码块之外调用这两个变量，结果`let`声明的变量报错，`var`声明的变量返回了正确的值。这表明，`let`声明的变量只在它所在的代码块有效。\\n`for`循环的计数器，\"},{\"url\":\"/《ES6 教程》笔记/03.变量的解构赋值.html\",\"relativePath\":\"/《ES6 教程》笔记/03.变量的解构赋值.html\",\"frontmatter\":{\"title\":\"变量的解构赋值\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/b1ab10a62f7564da\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"变量的解构赋值\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"变量的解构赋值\\\" tabindex=\\\"-1\\\">变量的解构赋值 <a class=\\\"header-anchor\\\" href=\\\"#变量的解构赋值\\\" aria-label=\\\"Permalink to &quot;变量的解构赋值&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"数组的解构赋值\\\" tabindex=\\\"-1\\\">数组的解构赋值 <a class=\\\"header-anchor\\\" href=\\\"#数组的解构赋值\\\" aria-label=\\\"Permalink to &quot;数组的解构赋值&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"基本用法\\\" tabindex=\\\"-1\\\">基本用法 <a class=\\\"header-anchor\\\" href=\\\"#基本用法\\\" aria-label=\\\"Permalink to &quot;基本用法&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>ES6 允许按照一定模式，<strong>从数组和对象中提取值，对变量进行赋值，这被称为解构</strong>（Destructuring）。</p>\\n<p>以前，为变量赋值，只能直接指定值。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> a </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> b </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> c </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 3</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br></div></div>\",\"capture\":\"数组的解构赋值\\n 基本用法\\nES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。\\n以前，为变量赋值，只能直接指定值。\\n```javascript\\nlet a = 1;\\nlet b = 2;\\nlet c = 3;\\n```\\nES6 允许写成下面这样。\\n```javascript\\nlet [a, b, c] = [1, 2, 3];\\n```\\n上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。\\n本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。\\n```javas\"},{\"url\":\"/《ES6 教程》笔记/04.字符串的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/04.字符串的扩展.html\",\"frontmatter\":{\"title\":\"字符串的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/ca89eca8adeba5f4\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"字符串的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"字符串的扩展\\\" tabindex=\\\"-1\\\">字符串的扩展 <a class=\\\"header-anchor\\\" href=\\\"#字符串的扩展\\\" aria-label=\\\"Permalink to &quot;字符串的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>本章介绍 ES6 对字符串的改造和增强，下一章介绍字符串对象的新增方法。</p>\\n<h2 id=\\\"字符的-unicode-表示法\\\" tabindex=\\\"-1\\\">字符的 Unicode 表示法 <a class=\\\"header-anchor\\\" href=\\\"#字符的-unicode-表示法\\\" aria-label=\\\"Permalink to &quot;字符的 Unicode 表示法&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES6 加强了对 Unicode 的支持，允许采用<code>\\\\uxxxx</code>形式表示一个字符，其中<code>xxxx</code>表示字符的 Unicode 码点。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">\\\\u0061</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// \\\"a\\\"</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br></div></div>\",\"capture\":\"本章介绍 ES6 对字符串的改造和增强，下一章介绍字符串对象的新增方法。\\n 字符的 Unicode 表示法\\nES6 加强了对 Unicode 的支持，允许采用`\\\\uxxxx`形式表示一个字符，其中`xxxx`表示字符的 Unicode 码点。\\n```javascript\\n\\\"\\\\u0061\\\"\\n// \\\"a\\\"\\n```\\n但是，这种表示法只限于码点在`\\\\u0000`~`\\\\uFFFF`之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。\\n```javascript\\n\\\"\\\\uD842\\\\uDFB7\\\"\\n// \\\"𠮷\\\"\\n\\\"\\\\u20BB7\\\"\\n// \\\" 7\\\"\\n```\\n上面代码表示，如果直接在`\\\\u`后面跟上超过`\"},{\"url\":\"/《ES6 教程》笔记/05.字符串的新增方法.html\",\"relativePath\":\"/《ES6 教程》笔记/05.字符串的新增方法.html\",\"frontmatter\":{\"title\":\"字符串的新增方法\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/a650b4a0ebfc9350\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"字符串的新增方法\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"字符串的新增方法\\\" tabindex=\\\"-1\\\">字符串的新增方法 <a class=\\\"header-anchor\\\" href=\\\"#字符串的新增方法\\\" aria-label=\\\"Permalink to &quot;字符串的新增方法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>本章介绍字符串对象的新增方法。</p>\\n<h2 id=\\\"string-fromcodepoint\\\" tabindex=\\\"-1\\\">String.fromCodePoint() <a class=\\\"header-anchor\\\" href=\\\"#string-fromcodepoint\\\" aria-label=\\\"Permalink to &quot;String.fromCodePoint()&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES5 提供<code>String.fromCharCode()</code>方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于<code>0xFFFF</code>的字符。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">String.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">fromCharCode</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">0x20BB7</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">)</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// \\\"ஷ\\\"</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br></div></div>\",\"capture\":\"本章介绍字符串对象的新增方法。\\n String.fromCodePoint()\\nES5 提供`String.fromCharCode()`方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于`0xFFFF`的字符。\\n```javascript\\nString.fromCharCode(0x20BB7)\\n// \\\"ஷ\\\"\\n```\\n上面代码中，`String.fromCharCode()`不能识别大于`0xFFFF`的码点，所以`0x20BB7`就发生了溢出，最高位`2`被舍弃了，最后返回码点`U+0BB7`对应的字符，而不是码点`U+20BB7`对应的字符。\\nES6 提供了`S\"},{\"url\":\"/《ES6 教程》笔记/06.正则的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/06.正则的扩展.html\",\"frontmatter\":{\"title\":\"正则的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/0473261a6ab0ee8c\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"正则的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"正则的扩展\\\" tabindex=\\\"-1\\\">正则的扩展 <a class=\\\"header-anchor\\\" href=\\\"#正则的扩展\\\" aria-label=\\\"Permalink to &quot;正则的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"regexp-构造函数\\\" tabindex=\\\"-1\\\">RegExp 构造函数 <a class=\\\"header-anchor\\\" href=\\\"#regexp-构造函数\\\" aria-label=\\\"Permalink to &quot;RegExp 构造函数&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>在 ES5 中，<code>RegExp</code>构造函数的参数有两种情况。</p>\\n<p>第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">var</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> regex </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> new</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> RegExp</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'xyz'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'i'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">);</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// 等价于</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">var</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> regex </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> /</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#DBEDFF\\\">xyz</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">/</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">i</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br></div></div>\",\"capture\":\"RegExp 构造函数\\n在 ES5 中，`RegExp`构造函数的参数有两种情况。\\n第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。\\n```javascript\\nvar regex = new RegExp('xyz', 'i');\\n// 等价于\\nvar regex = /xyz/i;\\n```\\n第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。\\n```javascript\\nvar regex = new RegExp(/xyz/i);\\n// 等价于\\nvar regex = /xyz/i;\\n```\\n但是，ES5 不允许此时使用第二个参数添加修饰\"},{\"url\":\"/《ES6 教程》笔记/07.数值的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/07.数值的扩展.html\",\"frontmatter\":{\"title\":\"数值的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/5dfea9a0f2d1a392\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"数值的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"数值的扩展\\\" tabindex=\\\"-1\\\">数值的扩展 <a class=\\\"header-anchor\\\" href=\\\"#数值的扩展\\\" aria-label=\\\"Permalink to &quot;数值的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"二进制和八进制表示法\\\" tabindex=\\\"-1\\\">二进制和八进制表示法 <a class=\\\"header-anchor\\\" href=\\\"#二进制和八进制表示法\\\" aria-label=\\\"Permalink to &quot;二进制和八进制表示法&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES6 提供了二进制和八进制数值的新的写法，分别用前缀<code>0b</code>（或<code>0B</code>）和<code>0o</code>（或<code>0O</code>）表示。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">0b111110111</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> ===</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 503</span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\"> // true</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">0o767</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> ===</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 503</span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\"> // true</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br></div></div>\",\"capture\":\"二进制和八进制表示法\\nES6 提供了二进制和八进制数值的新的写法，分别用前缀`0b`（或`0B`）和`0o`（或`0O`）表示。\\n```javascript\\n0b111110111 === 503 // true\\n0o767 === 503 // true\\n```\\n从 ES5 开始，在严格模式之中，八进制就不再允许使用前缀`0`表示，ES6 进一步明确，要使用前缀`0o`表示。\\n```javascript\\n// 非严格模式\\n(function(){\\n  console.log(0o11 === 011);\\n})() // true\\n// 严格模式\\n(function(){\\n  'use str\"},{\"url\":\"/《ES6 教程》笔记/08.函数的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/08.函数的扩展.html\",\"frontmatter\":{\"title\":\"函数的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/8ed309d668b20264\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"函数的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"函数的扩展\\\" tabindex=\\\"-1\\\">函数的扩展 <a class=\\\"header-anchor\\\" href=\\\"#函数的扩展\\\" aria-label=\\\"Permalink to &quot;函数的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"函数参数的默认值\\\" tabindex=\\\"-1\\\">函数参数的默认值 <a class=\\\"header-anchor\\\" href=\\\"#函数参数的默认值\\\" aria-label=\\\"Permalink to &quot;函数参数的默认值&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"基本用法\\\" tabindex=\\\"-1\\\">基本用法 <a class=\\\"header-anchor\\\" href=\\\"#基本用法\\\" aria-label=\\\"Permalink to &quot;基本用法&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">function</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#E36209;--shiki-dark:#FFAB70\\\">x</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#E36209;--shiki-dark:#FFAB70\\\">y</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">) {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">  y </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> y </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">||</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> 'World'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">  console.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(x, y);</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'Hello'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">) </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// Hello World</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'Hello'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'China'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">) </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// Hello China</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'Hello'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">''</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">) </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// Hello World</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br><span class=\\\"line-number\\\">8</span><br></div></div>\",\"capture\":\"函数参数的默认值\\n 基本用法\\nES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。\\n```javascript\\nfunction log(x, y) {\\n  y = y || 'World';\\n  console.log(x, y);\\n}\\nlog('Hello') // Hello World\\nlog('Hello', 'China') // Hello China\\nlog('Hello', '') // Hello World\\n```\\n上面代码检查函数`log`的参数`y`有没有赋值，如果没有，则指定默认值为`World`。这种写法的缺点在于，如果参数`y`赋值了，但是对应的布\"},{\"url\":\"/《ES6 教程》笔记/09.数组的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/09.数组的扩展.html\",\"frontmatter\":{\"title\":\"数组的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/e34009d60d8bc4b2\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"数组的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"数组的扩展\\\" tabindex=\\\"-1\\\">数组的扩展 <a class=\\\"header-anchor\\\" href=\\\"#数组的扩展\\\" aria-label=\\\"Permalink to &quot;数组的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"扩展运算符\\\" tabindex=\\\"-1\\\">扩展运算符 <a class=\\\"header-anchor\\\" href=\\\"#扩展运算符\\\" aria-label=\\\"Permalink to &quot;扩展运算符&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"含义\\\" tabindex=\\\"-1\\\">含义 <a class=\\\"header-anchor\\\" href=\\\"#含义\\\" aria-label=\\\"Permalink to &quot;含义&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>扩展运算符（spread）是三个点（<code>...</code>）。它好比 rest 参数的逆运算，<strong>将一个数组转为用逗号分隔的参数序列</strong>。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">console.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">...</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">[</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">3</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">])</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// 1 2 3</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">console.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">...</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">[</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">3</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">4</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">], </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">5</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">)</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// 1 2 3 4 5</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">[</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">...</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">document.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">querySelectorAll</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'div'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">)]</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// [&#x3C;div>, &#x3C;div>, &#x3C;div>]</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br><span class=\\\"line-number\\\">8</span><br></div></div>\",\"capture\":\"扩展运算符\\n 含义\\n扩展运算符（spread）是三个点（`...`）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。\\n```javascript\\nconsole.log(...[1, 2, 3])\\n// 1 2 3\\nconsole.log(1, ...[2, 3, 4], 5)\\n// 1 2 3 4 5\\n[...document.querySelectorAll('div')]\\n// [&lt;div\\n```\\n该运算符主要用于函数调用。\\n```javascript\\nfunction push(array, ...items) {\\n  array.push(...items\"},{\"url\":\"/《ES6 教程》笔记/10.对象的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/10.对象的扩展.html\",\"frontmatter\":{\"title\":\"对象的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/b5e3e0a0ff6e9c25\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"对象的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"对象的扩展\\\" tabindex=\\\"-1\\\">对象的扩展 <a class=\\\"header-anchor\\\" href=\\\"#对象的扩展\\\" aria-label=\\\"Permalink to &quot;对象的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>对象（object）是 JavaScript 最重要的数据结构。ES6 对它进行了重大升级，本章介绍数据结构本身的改变，下一章介绍<code>Object</code>对象的新增方法。</p>\\n\",\"capture\":\"对象（object）是 JavaScript 最重要的数据结构。ES6 对它进行了重大升级，本章介绍数据结构本身的改变，下一章介绍`Object`对象的新增方法。\\n 属性的简洁表示法\\nES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。\\n```javascript\\nconst foo = 'bar';\\nconst baz = {foo};\\nbaz // {foo: \\\"bar\\\"}\\n// 等同于\\nconst baz = {foo: foo};\\n```\\n上面代码中，变量`foo`直接写在大括号里面。这时，属性名就是变量名, 属性值就是变量值。下面是另一个例子。\\n`\"},{\"url\":\"/《ES6 教程》笔记/11.对象的新增方法.html\",\"relativePath\":\"/《ES6 教程》笔记/11.对象的新增方法.html\",\"frontmatter\":{\"title\":\"对象的新增方法\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/e85e68947502cf90\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"对象的新增方法\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"对象的新增方法\\\" tabindex=\\\"-1\\\">对象的新增方法 <a class=\\\"header-anchor\\\" href=\\\"#对象的新增方法\\\" aria-label=\\\"Permalink to &quot;对象的新增方法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>本章介绍 Object 对象的新增方法。</p>\\n<h2 id=\\\"object-is\\\" tabindex=\\\"-1\\\">Object.is() <a class=\\\"header-anchor\\\" href=\\\"#object-is\\\" aria-label=\\\"Permalink to &quot;Object.is()&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES5 比较两个值是否相等，只有两个运算符：相等运算符（<code>==</code>）和严格相等运算符（<code>===</code>）。它们都有缺点，前者会自动转换数据类型，后者的<code>NaN</code>不等于自身，以及<code>+0</code>等于<code>-0</code>。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</p>\\n<p>ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。<code>Object.is</code>就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</p>\\n\",\"capture\":\"本章介绍 Object 对象的新增方法。\\n Object.is()\\nES5 比较两个值是否相等，只有两个运算符：相等运算符（`==`）和严格相等运算符（`===`）。它们都有缺点，前者会自动转换数据类型，后者的`NaN`不等于自身，以及`+0`等于`-0`。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。\\nES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。`Object.is`就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。\\n```javascript\\nObject.\"},{\"url\":\"/《ES6 教程》笔记/12.Symbol.html\",\"relativePath\":\"/《ES6 教程》笔记/12.Symbol.html\",\"frontmatter\":{\"title\":\"Symbol\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/02c86eb2792f3262\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Symbol\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"symbol\\\" tabindex=\\\"-1\\\">Symbol <a class=\\\"header-anchor\\\" href=\\\"#symbol\\\" aria-label=\\\"Permalink to &quot;Symbol&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，<strong>保证每个属性的名字都是独一无二</strong>的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入<code>Symbol</code>的原因。</p>\\n\",\"capture\":\"概述\\nES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入`Symbol`的原因。\\nES6 引入了一种新的原始数据类型`Symbol`，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：`undefined`、`null`、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。\\nSymbol 值\"},{\"url\":\"/《ES6 教程》笔记/13.Set 和 Map 数据结构.html\",\"relativePath\":\"/《ES6 教程》笔记/13.Set 和 Map 数据结构.html\",\"frontmatter\":{\"title\":\"Set 和 Map 数据结构\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/0c21dae358fca16b\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Set 和 Map 数据结构\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"set-和-map-数据结构\\\" tabindex=\\\"-1\\\">Set 和 Map 数据结构 <a class=\\\"header-anchor\\\" href=\\\"#set-和-map-数据结构\\\" aria-label=\\\"Permalink to &quot;Set 和 Map 数据结构&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"set\\\" tabindex=\\\"-1\\\">Set <a class=\\\"header-anchor\\\" href=\\\"#set\\\" aria-label=\\\"Permalink to &quot;Set&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"基本用法\\\" tabindex=\\\"-1\\\">基本用法 <a class=\\\"header-anchor\\\" href=\\\"#基本用法\\\" aria-label=\\\"Permalink to &quot;基本用法&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>ES6 提供了新的数据结构 Set。它<strong>类似于数组，但是成员的值都是唯一的，没有重复的值</strong>。</p>\\n<p><strong><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构</strong>。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">const</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> s</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> =</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> new</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> Set</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">();</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">[</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">3</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">5</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">4</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">5</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">].</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">forEach</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#E36209;--shiki-dark:#FFAB70\\\">x</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> =></span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> s.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">add</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(x));</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">for</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> (</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> i </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">of</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> s) {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">  console.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(i);</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// 2 3 5 4</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br><span class=\\\"line-number\\\">8</span><br></div></div>\",\"capture\":\"Set\\n 基本用法\\nES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。\\n`Set`本身是一个构造函数，用来生成 Set 数据结构。\\n```javascript\\nconst s = new Set();\\n[2, 3, 5, 4, 5, 2, 2].forEach(x =\\nfor (let i of s) {\\n  console.log(i);\\n}\\n// 2 3 5 4\\n```\\n上面代码通过`add()`方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。\\n`Set`函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参\"},{\"url\":\"/《ES6 教程》笔记/14.Proxy.html\",\"relativePath\":\"/《ES6 教程》笔记/14.Proxy.html\",\"frontmatter\":{\"title\":\"Proxy\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/f56ec2ab97d60483\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Proxy\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"proxy\\\" tabindex=\\\"-1\\\">Proxy <a class=\\\"header-anchor\\\" href=\\\"#proxy\\\" aria-label=\\\"Permalink to &quot;Proxy&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“<strong>元编程</strong>”（meta programming），即<strong>对编程语言进行编程</strong>。</p>\\n<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，<strong>外界对该对象的访问，都必须先通过这层拦截</strong>，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>\\n\",\"capture\":\"概述\\nProxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。\\nProxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。\\n```javascript\\nvar obj = new Proxy({}, {\\n  get: function (target, propKey, receiver) {\\n    console.log(\"},{\"url\":\"/《ES6 教程》笔记/15.Reflect.html\",\"relativePath\":\"/《ES6 教程》笔记/15.Reflect.html\",\"frontmatter\":{\"title\":\"Reflect\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/74de3e45e4491e95\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Reflect\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"reflect\\\" tabindex=\\\"-1\\\">Reflect <a class=\\\"header-anchor\\\" href=\\\"#reflect\\\" aria-label=\\\"Permalink to &quot;Reflect&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p><code>Reflect</code>对象与<code>Proxy</code>对象一样，也是 ES6 为了操作对象而提供的新 API。<code>Reflect</code>对象的设计目的有这样几个。</p>\\n<p>（1） **将<code>Object</code>对象的一些明显属于语言内部的方法（比如<code>Object.defineProperty</code>），放到<code>Reflect</code>对象上。**现阶段，某些方法同时在<code>Object</code>和<code>Reflect</code>对象上部署，未来的新方法将只部署在<code>Reflect</code>对象上。也就是说，从<code>Reflect</code>对象上可以拿到语言内部的方法。</p>\\n\",\"capture\":\"概述\\n`Reflect`对象与`Proxy`对象一样，也是 ES6 为了操作对象而提供的新 API。`Reflect`对象的设计目的有这样几个。\\n（1） 将`Object`对象的一些明显属于语言内部的方法（比如`Object.defineProperty`），放到`Reflect`对象上。现阶段，某些方法同时在`Object`和`Reflect`对象上部署，未来的新方法将只部署在`Reflect`对象上。也就是说，从`Reflect`对象上可以拿到语言内部的方法。\\n（2） 修改某些`Object`方法的返回结果，让其变得更合理。比如，`Object.defineProperty(obj, na\"},{\"url\":\"/《ES6 教程》笔记/16.Promise 对象.html\",\"relativePath\":\"/《ES6 教程》笔记/16.Promise 对象.html\",\"frontmatter\":{\"title\":\"Promise 对象\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/2810ae8985e9bd52\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Promise 对象\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"promise-对象\\\" tabindex=\\\"-1\\\">Promise 对象 <a class=\\\"header-anchor\\\" href=\\\"#promise-对象\\\" aria-label=\\\"Permalink to &quot;Promise 对象&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"promise-的含义\\\" tabindex=\\\"-1\\\">Promise 的含义 <a class=\\\"header-anchor\\\" href=\\\"#promise-的含义\\\" aria-label=\\\"Permalink to &quot;Promise 的含义&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了<code>Promise</code>对象。</p>\\n\",\"capture\":\"Promise 的含义\\nPromise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了`Promise`对象。\\n所谓`Promise`，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。\\n`Promise`对象有以下两个特点。\\n（1）对象的状态不受外界影响。`Promise`对象代表一个异步操作，有三种状态：`pe\"},{\"url\":\"/《ES6 教程》笔记/17.Iterator 和 for-of 循环.html\",\"relativePath\":\"/《ES6 教程》笔记/17.Iterator 和 for-of 循环.html\",\"frontmatter\":{\"title\":\"Iterator 和 for-of 循环\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/48df907ad3570f3d\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Iterator 和 for-of 循环\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"iterator-和-for-of-循环\\\" tabindex=\\\"-1\\\">Iterator 和 for...of 循环 <a class=\\\"header-anchor\\\" href=\\\"#iterator-和-for-of-循环\\\" aria-label=\\\"Permalink to &quot;Iterator 和 for...of 循环&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"iterator-遍历器-的概念\\\" tabindex=\\\"-1\\\">Iterator（遍历器）的概念 <a class=\\\"header-anchor\\\" href=\\\"#iterator-遍历器-的概念\\\" aria-label=\\\"Permalink to &quot;Iterator（遍历器）的概念&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>JavaScript 原有的表示“集合”的数据结构，主要是数组（<code>Array</code>）和对象（<code>Object</code>），ES6 又添加了<code>Map</code>和<code>Set</code>。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是<code>Map</code>，<code>Map</code>的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。</p>\\n\",\"capture\":\"Iterator（遍历器）的概念\\nJavaScript 原有的表示“集合”的数据结构，主要是数组（`Array`）和对象（`Object`），ES6 又添加了`Map`和`Set`。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是`Map`，`Map`的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。\\n遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。\\nIterator 的作用有三个：一是为各\"},{\"url\":\"/《ES6 教程》笔记/18.Generator 函数的语法.html\",\"relativePath\":\"/《ES6 教程》笔记/18.Generator 函数的语法.html\",\"frontmatter\":{\"title\":\"Generator 函数的语法\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/718b48ed9ce0adce\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Generator 函数的语法\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"generator-函数的语法\\\" tabindex=\\\"-1\\\">Generator 函数的语法 <a class=\\\"header-anchor\\\" href=\\\"#generator-函数的语法\\\" aria-label=\\\"Permalink to &quot;Generator 函数的语法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"基本概念\\\" tabindex=\\\"-1\\\">基本概念 <a class=\\\"header-anchor\\\" href=\\\"#基本概念\\\" aria-label=\\\"Permalink to &quot;基本概念&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>Generator 函数是 ES6 提供的一种<strong>异步编程解决方案</strong>，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《Generator 函数的异步应用》一章。</p>\\n\",\"capture\":\"简介\\n 基本概念\\nGenerator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《Generator 函数的异步应用》一章。\\nGenerator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。\\n执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。\\n形式上，Generator 函数是一个\"},{\"url\":\"/《ES6 教程》笔记/19.Generator 函数的异步应用.html\",\"relativePath\":\"/《ES6 教程》笔记/19.Generator 函数的异步应用.html\",\"frontmatter\":{\"title\":\"Generator 函数的异步应用\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/75af7031eb66847b\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Generator 函数的异步应用\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"generator-函数的异步应用\\\" tabindex=\\\"-1\\\">Generator 函数的异步应用 <a class=\\\"header-anchor\\\" href=\\\"#generator-函数的异步应用\\\" aria-label=\\\"Permalink to &quot;Generator 函数的异步应用&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>异步编程对 JavaScript 语言太重要。JavaScript 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。本章主要介绍 Generator 函数如何完成异步操作。</p>\\n\",\"capture\":\"异步编程对 JavaScript 语言太重要。JavaScript 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。本章主要介绍 Generator 函数如何完成异步操作。\\n 传统方法\\nES6 诞生以前，异步编程的方法，大概有下面四种。\\n- 回调函数\\n- 事件监听\\n- 发布/订阅\\n- Promise 对象\\nGenerator 函数将 JavaScript 异步编程带入了一个全新的阶段。\\n 基本概念\\n 异步\\n所谓\\\"异步\\\"，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。\\n比如，有一个任\"},{\"url\":\"/《ES6 教程》笔记/20.async 函数.html\",\"relativePath\":\"/《ES6 教程》笔记/20.async 函数.html\",\"frontmatter\":{\"title\":\"async 函数\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/3777253e65bac487\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"async 函数\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"async-函数\\\" tabindex=\\\"-1\\\">async 函数 <a class=\\\"header-anchor\\\" href=\\\"#async-函数\\\" aria-label=\\\"Permalink to &quot;async 函数&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"含义\\\" tabindex=\\\"-1\\\">含义 <a class=\\\"header-anchor\\\" href=\\\"#含义\\\" aria-label=\\\"Permalink to &quot;含义&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p>\\n<p>async 函数是什么？一句话，它就<strong>是 Generator 函数的语法糖</strong>。</p>\\n<p>前文有一个 Generator 函数，依次读取两个文件。</p>\\n\",\"capture\":\"含义\\nES2017 标准引入了 async 函数，使得异步操作变得更加方便。\\nasync 函数是什么？一句话，它就是 Generator 函数的语法糖。\\n前文有一个 Generator 函数，依次读取两个文件。\\n```javascript\\nconst fs = require('fs');\\nconst readFile = function (fileName) {\\n  return new Promise(function (resolve, reject) {\\n    fs.readFile(fileName, function(error, data) {\\n      if (error\"},{\"url\":\"/《ES6 教程》笔记/21.Class 的基本语法.html\",\"relativePath\":\"/《ES6 教程》笔记/21.Class 的基本语法.html\",\"frontmatter\":{\"title\":\"Class 的基本语法\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/e831e1593c82bbe0\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Class 的基本语法\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"class-的基本语法\\\" tabindex=\\\"-1\\\">Class 的基本语法 <a class=\\\"header-anchor\\\" href=\\\"#class-的基本语法\\\" aria-label=\\\"Permalink to &quot;Class 的基本语法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"类的由来\\\" tabindex=\\\"-1\\\">类的由来 <a class=\\\"header-anchor\\\" href=\\\"#类的由来\\\" aria-label=\\\"Permalink to &quot;类的由来&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">function</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> Point</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#E36209;--shiki-dark:#FFAB70\\\">x</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#E36209;--shiki-dark:#FFAB70\\\">y</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">) {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">  this</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.x </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> x;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">  this</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.y </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> y;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">Point</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">prototype</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">toString</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> =</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> function</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> () {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">  return</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> '('</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> +</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> this</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.x </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">+</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> ', '</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> +</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> this</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.y </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">+</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> ')'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">};</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">var</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> p </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> new</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> Point</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">);</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br><span class=\\\"line-number\\\">8</span><br><span class=\\\"line-number\\\">9</span><br><span class=\\\"line-number\\\">10</span><br></div></div>\",\"capture\":\"简介\\n 类的由来\\nJavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。\\n```javascript\\nfunction Point(x, y) {\\n  this.x = x;\\n  this.y = y;\\n}\\nPoint.prototype.toString = function () {\\n  return '(' + this.x + ', ' + this.y + ')';\\n};\\nvar p = new Point(1, 2);\\n```\\n上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。\\nES6 提供\"},{\"url\":\"/《ES6 教程》笔记/22.Class 的继承.html\",\"relativePath\":\"/《ES6 教程》笔记/22.Class 的继承.html\",\"frontmatter\":{\"title\":\"Class 的继承\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/83f8c3a0cd87dd83\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Class 的继承\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"class-的继承\\\" tabindex=\\\"-1\\\">Class 的继承 <a class=\\\"header-anchor\\\" href=\\\"#class-的继承\\\" aria-label=\\\"Permalink to &quot;Class 的继承&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>Class 可以通过<code>extends</code>关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">class</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> Point</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">class</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> ColorPoint</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> extends</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> Point</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br></div></div>\",\"capture\":\"简介\\nClass 可以通过`extends`关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。\\n```javascript\\nclass Point {\\n}\\nclass ColorPoint extends Point {\\n}\\n```\\n上面代码定义了一个`ColorPoint`类，该类通过`extends`关键字，继承了`Point`类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个`Point`类。下面，我们在`ColorPoint`内部加上代码。\\n```javascript\\nclass ColorPoint extends Point \"},{\"url\":\"/《ES6 教程》笔记/23.Module 的语法.html\",\"relativePath\":\"/《ES6 教程》笔记/23.Module 的语法.html\",\"frontmatter\":{\"title\":\"Module 的语法\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/efe2fb04eb8ac5fb\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Module 的语法\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"module-的语法\\\" tabindex=\\\"-1\\\">Module 的语法 <a class=\\\"header-anchor\\\" href=\\\"#module-的语法\\\" aria-label=\\\"Permalink to &quot;Module 的语法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的<code>require</code>、Python 的<code>import</code>，甚至就连 CSS 都有<code>@import</code>，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p>\\n\",\"capture\":\"概述\\n历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的`require`、Python 的`import`，甚至就连 CSS 都有`@import`，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。\\n在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD \"},{\"url\":\"/《ES6 教程》笔记/24.Module 的加载实现.html\",\"relativePath\":\"/《ES6 教程》笔记/24.Module 的加载实现.html\",\"frontmatter\":{\"title\":\"Module 的加载实现\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/a79ca2e64ceae213\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Module 的加载实现\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"module-的加载实现\\\" tabindex=\\\"-1\\\">Module 的加载实现 <a class=\\\"header-anchor\\\" href=\\\"#module-的加载实现\\\" aria-label=\\\"Permalink to &quot;Module 的加载实现&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>上一章介绍了模块的语法，本章介绍如何在浏览器和 Node.js 之中加载 ES6 模块，以及实际开发中经常遇到的一些问题（比如循环加载）。</p>\\n\",\"capture\":\"上一章介绍了模块的语法，本章介绍如何在浏览器和 Node.js 之中加载 ES6 模块，以及实际开发中经常遇到的一些问题（比如循环加载）。\\n 浏览器加载\\n 传统方法\\nHTML 网页中，浏览器通过`&lt;script\\n```html\\n&lt;!-- 页面内嵌的脚本 --&gt;\\n&lt;script type=\\\"application/javascript\\\"&gt;\\n  // module code\\n&lt;/script&gt;\\n&lt;!-- 外部脚本 --&gt;\\n&lt;script type=\\\"application/javascript\\\" src=\\\"path/to/myModule\"},{\"url\":\"/《ES6 教程》笔记/25.编程风格.html\",\"relativePath\":\"/《ES6 教程》笔记/25.编程风格.html\",\"frontmatter\":{\"title\":\"编程风格\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/984bf549204bb266\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"编程风格\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"编程风格\\\" tabindex=\\\"-1\\\">编程风格 <a class=\\\"header-anchor\\\" href=\\\"#编程风格\\\" aria-label=\\\"Permalink to &quot;编程风格&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>本章探讨如何将 ES6 的新语法，运用到编码实践之中，与传统的 JavaScript 语法结合在一起，写出合理的、易于阅读和维护的代码。</p>\\n<p>多家公司和组织已经公开了它们的风格规范，下面的内容主要参考了 <a href=\\\"https://github.com/airbnb/javascript\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">Airbnb</a> 公司的 JavaScript 风格规范。</p>\\n\",\"capture\":\"本章探讨如何将 ES6 的新语法，运用到编码实践之中，与传统的 JavaScript 语法结合在一起，写出合理的、易于阅读和维护的代码。\\n多家公司和组织已经公开了它们的风格规范，下面的内容主要参考了 Airbnb 公司的 JavaScript 风格规范。\\n 块级作用域\\n（1）let 取代 var\\nES6 提出了两个新的声明变量的命令：`let`和`const`。其中，`let`完全可以取代`var`，因为两者语义相同，而且`let`没有副作用。\\n```javascript\\n'use strict';\\nif (true) {\\n  let x = 'hello';\\n}\\nfor (let i = 0\"},{\"url\":\"/《ES6 教程》笔记/26.读懂 ECMAScript 规格.html\",\"relativePath\":\"/《ES6 教程》笔记/26.读懂 ECMAScript 规格.html\",\"frontmatter\":{\"title\":\"读懂 ECMAScript 规格\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/32c35f7651d6e58e\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"读懂 ECMAScript 规格\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"读懂-ecmascript-规格\\\" tabindex=\\\"-1\\\">读懂 ECMAScript 规格 <a class=\\\"header-anchor\\\" href=\\\"#读懂-ecmascript-规格\\\" aria-label=\\\"Permalink to &quot;读懂 ECMAScript 规格&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>规格文件是计算机语言的官方标准，详细描述语法规则和实现方法。</p>\\n<p>一般来说，没有必要阅读规格，除非你要写编译器。因为规格写得非常抽象和精炼，又缺乏实例，不容易理解，而且对于解决实际的应用问题，帮助不大。但是，如果你遇到疑难的语法问题，实在找不到答案，这时可以去查看规格文件，了解语言标准是怎么说的。规格是解决问题的“最后一招”。</p>\\n\",\"capture\":\"概述\\n规格文件是计算机语言的官方标准，详细描述语法规则和实现方法。\\n一般来说，没有必要阅读规格，除非你要写编译器。因为规格写得非常抽象和精炼，又缺乏实例，不容易理解，而且对于解决实际的应用问题，帮助不大。但是，如果你遇到疑难的语法问题，实在找不到答案，这时可以去查看规格文件，了解语言标准是怎么说的。规格是解决问题的“最后一招”。\\n这对 JavaScript 语言很有必要。因为它的使用场景复杂，语法规则不统一，例外很多，各种运行环境的行为不一致，导致奇怪的语法问题层出不穷，任何语法书都不可能囊括所有情况。查看规格，不失为一种解决语法问题的最可靠、最权威的终极方法。\\n本章介绍如何读懂 ECMASc\"},{\"url\":\"/《ES6 教程》笔记/27.异步遍历器.html\",\"relativePath\":\"/《ES6 教程》笔记/27.异步遍历器.html\",\"frontmatter\":{\"title\":\"异步遍历器\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/16121351be68691b\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"异步遍历器\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"异步遍历器\\\" tabindex=\\\"-1\\\">异步遍历器 <a class=\\\"header-anchor\\\" href=\\\"#异步遍历器\\\" aria-label=\\\"Permalink to &quot;异步遍历器&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"同步遍历器的问题\\\" tabindex=\\\"-1\\\">同步遍历器的问题 <a class=\\\"header-anchor\\\" href=\\\"#同步遍历器的问题\\\" aria-label=\\\"Permalink to &quot;同步遍历器的问题&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>《遍历器》一章说过，Iterator 接口是一种数据遍历的协议，只要调用遍历器对象的<code>next</code>方法，就会得到一个对象，表示当前遍历指针所在的那个位置的信息。<code>next</code>方法返回的对象的结构是<code>{value, done}</code>，其中<code>value</code>表示当前的数据的值，<code>done</code>是一个布尔值，表示遍历是否结束。</p>\\n\",\"capture\":\"同步遍历器的问题\\n《遍历器》一章说过，Iterator 接口是一种数据遍历的协议，只要调用遍历器对象的`next`方法，就会得到一个对象，表示当前遍历指针所在的那个位置的信息。`next`方法返回的对象的结构是`{value, done}`，其中`value`表示当前的数据的值，`done`是一个布尔值，表示遍历是否结束。\\n```javascript\\nfunction idMaker() {\\n  let index = 0;\\n  return {\\n    next: function() {\\n      return { value: index++, done: false };\\n    }\"},{\"url\":\"/《ES6 教程》笔记/28.ArrayBuffer.html\",\"relativePath\":\"/《ES6 教程》笔记/28.ArrayBuffer.html\",\"frontmatter\":{\"title\":\"ArrayBuffer\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/a2ba314746bfdbdd\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"ArrayBuffer\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"arraybuffer\\\" tabindex=\\\"-1\\\">ArrayBuffer <a class=\\\"header-anchor\\\" href=\\\"#arraybuffer\\\" aria-label=\\\"Permalink to &quot;ArrayBuffer&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><code>ArrayBuffer</code>对象、<code>TypedArray</code>视图和<code>DataView</code>视图是 JavaScript 操作二进制数据的一个接口。这些对象早就存在，属于独立的规格（2011 年 2 月发布），ES6 将它们纳入了 ECMAScript 规格，并且增加了新的方法。它们都是以数组的语法处理二进制数据，所以统称为二进制数组。</p>\\n\",\"capture\":\"`ArrayBuffer`对象、`TypedArray`视图和`DataView`视图是 JavaScript 操作二进制数据的一个接口。这些对象早就存在，属于独立的规格（2011 年 2 月发布），ES6 将它们纳入了 ECMAScript 规格，并且增加了新的方法。它们都是以数组的语法处理二进制数据，所以统称为二进制数组。\\n这个接口的原始设计目的，与 WebGL 项目有关。所谓 WebGL，就是指浏览器与显卡之间的通信接口，为了满足 JavaScript 与显卡之间大量的、实时的数据交换，它们之间的数据通信必须是二进制的，而不能是传统的文本格式。文本格式传递一个 32 位整数，两端的 Ja\"},{\"url\":\"/01.前端/25.JavaScript文章/07.js随机打乱数组.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/07.js随机打乱数组.html\",\"frontmatter\":{\"title\":\"JS随机打乱数组\",\"date\":\"2020-02-08 17:42:03\",\"permalink\":\"/pages/40b4db2d38ba85f2\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"JS随机打乱数组\",\"date\":\"2020-02-08 17:42:03\",\"capture\":\"```js\\nfunction shuffle(arr) { // 随机打乱数组\\n  let _arr = arr.slice() // 调用数组副本，不改变原数组\\n  for (let i = 0; i &lt; _arr.length; i++) {\\n    let j = getRandomInt(0, i)\\n    let t = _arr[i]\\n    _arr[i] = _arr[j]\\n    _arr[j] = t\\n  }\\n  return _arr\\n}\\nfunction getRandomInt(min, max) { // 获取min到max的一个随机数，包含min和max本身\"},{\"url\":\"/《Vue》笔记/01.基础/35.列表渲染之数组、对象更新检测.html\",\"relativePath\":\"/《Vue》笔记/01.基础/35.列表渲染之数组、对象更新检测.html\",\"frontmatter\":{\"title\":\"列表渲染之数组、对象更新检测\",\"date\":\"2020-02-05 13:09:06\",\"permalink\":\"/pages/04783a6691cc9d06\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"列表渲染之数组、对象更新检测\",\"date\":\"2020-02-05 13:09:06\",\"excerpt\":\"<h1 id=\\\"列表渲染之数组、对象更新检测\\\" tabindex=\\\"-1\\\">列表渲染之数组、对象更新检测 <a class=\\\"header-anchor\\\" href=\\\"#列表渲染之数组、对象更新检测\\\" aria-label=\\\"Permalink to &quot;列表渲染之数组、对象更新检测&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/list.html#%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">数组更新检测API</a> <a href=\\\"https://cn.vuejs.org/v2/guide/list.html#%E5%AF%B9%E8%B1%A1%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">对象更新检测API</a></p>\\n<h2 id=\\\"数组更新检测\\\" tabindex=\\\"-1\\\">数组更新检测 <a class=\\\"header-anchor\\\" href=\\\"#数组更新检测\\\" aria-label=\\\"Permalink to &quot;数组更新检测&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h4 id=\\\"变异方法-mutation-method\\\" tabindex=\\\"-1\\\">变异方法 (mutation method) <a class=\\\"header-anchor\\\" href=\\\"#变异方法-mutation-method\\\" aria-label=\\\"Permalink to &quot;变异方法 (mutation method)&quot;\\\">&ZeroWidthSpace;</a></h4>\\n<p>Vue 将被侦听的数组的变异方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：</p>\\n\",\"capture\":\"数组更新检测API 对象更新检测API\\n 数组更新检测\\n 变异方法 (mutation method)\\nVue 将被侦听的数组的变异方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：\\n- `push()`末尾添加\\n- `pop()`末尾删除\\n- `shift()` 首位删除\\n- `unshift() ` 首位添加\\n- `splice()` 拼合\\n- `sort()` 排序\\n- `reverse()` 反转\\n数组实例方法\\n 替换数组\\n变异方法，顾名思义，会改变调用了这些方法的原始数组。相比之下，也有非变异 (non-mutating method) 方法，例如 `filter(\"},{\"url\":\"/《Vue》笔记/01.基础/30.v-if vs v-show.html\",\"relativePath\":\"/《Vue》笔记/01.基础/30.v-if vs v-show.html\",\"frontmatter\":{\"title\":\"v-if vs v-show\",\"date\":\"2020-02-04 17:32:23\",\"permalink\":\"/pages/73e4064340277b05\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"v-if vs v-show\",\"date\":\"2020-02-04 17:32:23\",\"excerpt\":\"<h1 id=\\\"v-if-vs-v-show\\\" tabindex=\\\"-1\\\">v-if vs v-show <a class=\\\"header-anchor\\\" href=\\\"#v-if-vs-v-show\\\" aria-label=\\\"Permalink to &quot;v-if vs v-show&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/conditional.html#v-if-vs-v-show\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">API</a></p>\\n<p><code>v-if</code> 根据渲染条件决定是否把元素渲染到DOM页面，而<code>v-show</code>不管渲染条件是什么，都会把元素渲染到DOM页面，只是简单的切换CSS的显示隐藏。</p>\\n\",\"capture\":\"API\\n`v-if` 根据渲染条件决定是否把元素渲染到DOM页面，而`v-show`不管渲染条件是什么，都会把元素渲染到DOM页面，只是简单的切换CSS的显示隐藏。\\n如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好。\"},{\"url\":\"/《Vue》笔记/01.基础/20.计算属性 vs 方法 vs 侦听属性.html\",\"relativePath\":\"/《Vue》笔记/01.基础/20.计算属性 vs 方法 vs 侦听属性.html\",\"frontmatter\":{\"title\":\"计算属性 vs 方法 vs 侦听属性\",\"date\":\"2020-02-04 16:37:51\",\"permalink\":\"/pages/351f72ecd9c41129\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"计算属性 vs 方法 vs 侦听属性\",\"date\":\"2020-02-04 16:37:51\",\"excerpt\":\"<h1 id=\\\"计算属性-vs-方法-vs-侦听属性\\\" tabindex=\\\"-1\\\">计算属性 vs 方法 vs 侦听属性 <a class=\\\"header-anchor\\\" href=\\\"#计算属性-vs-方法-vs-侦听属性\\\" aria-label=\\\"Permalink to &quot;计算属性 vs 方法 vs 侦听属性&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/computed.html#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%BC%93%E5%AD%98-vs-%E6%96%B9%E6%B3%95\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">API</a></p>\\n<p>如果一个功能同时可以使用计算属性(computed)、方法(methods)、侦听属性(watch)来实现的时候推荐使用计算属性。</p>\\n\",\"capture\":\"API\\n如果一个功能同时可以使用计算属性(computed)、方法(methods)、侦听属性(watch)来实现的时候推荐使用计算属性。\\n| 计算属性                                 | 方法                                               | 侦听属性                                     |\\n| ---------------------------------------- | --------------------------------------------------\"},{\"url\":\"/《Vue》笔记/01.基础/10.生命周期.html\",\"relativePath\":\"/《Vue》笔记/01.基础/10.生命周期.html\",\"frontmatter\":{\"title\":\"生命周期\",\"date\":\"2020-02-04 15:06:59\",\"permalink\":\"/pages/176808a1b5f843b8\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"生命周期\",\"date\":\"2020-02-04 15:06:59\",\"excerpt\":\"<h1 id=\\\"实例生命周期钩子\\\" tabindex=\\\"-1\\\">实例生命周期钩子 <a class=\\\"header-anchor\\\" href=\\\"#实例生命周期钩子\\\" aria-label=\\\"Permalink to &quot;实例生命周期钩子&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/instance.html#%E5%AE%9E%E4%BE%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">实例生命周期钩子API</a></p>\\n<p>简单理解，生命周期钩子函数就是vue实例在某一个时间点会自动执行的函数。</p>\\n\",\"capture\":\"实例生命周期钩子API\\n简单理解，生命周期钩子函数就是vue实例在某一个时间点会自动执行的函数。\\n```html\\n&lt;div id=\\\"app\\\"\\n&lt;script src=\\\"https://cdn.bootcss.com/vue/2.4.2/vue.js\\\"&gt;&lt;/script&gt;\\n&lt;script&gt;\\n  var vm = new Vue({\\n    el: 'app',\\n    data: {\\n      msg: 'Vue的生命周期'\\n    },\\n    beforeCreate: function() {\\n      console.group('-----\"},{\"url\":\"/《Vue》笔记/06.规模化/140.路由懒加载.html\",\"relativePath\":\"/《Vue》笔记/06.规模化/140.路由懒加载.html\",\"frontmatter\":{\"title\":\"路由懒加载\",\"date\":\"2020-02-04 13:20:20\",\"permalink\":\"/pages/38ecac9a9b92f037\",\"categories\":[\"《Vue》笔记\",\"规模化\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"路由懒加载\",\"date\":\"2020-02-04 13:20:20\",\"capture\":\"```js\\n// 路由同步加载\\n// import Recommend from '@/components/recommend/recommend'\\n// import Singer from '@/components/singer/singer'\\n// import Rank from '@/components/rank/rank'\\n// import Search from '@/components/search/search'\\n// import SingerDetail from '@/components/singer-detail/singer-detail'\\n// imp\"},{\"url\":\"/《Vue》笔记/03.过渡&动画/120.transition-group列表过渡.html\",\"relativePath\":\"/《Vue》笔记/03.过渡&动画/120.transition-group列表过渡.html\",\"frontmatter\":{\"title\":\"transition-group列表过渡\",\"date\":\"2020-02-04 13:17:42\",\"permalink\":\"/pages/0aa92922ace6bb5e\",\"categories\":[\"《Vue》笔记\",\"过渡&动画\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"transition-group列表过渡\",\"date\":\"2020-02-04 13:17:42\",\"excerpt\":\"<h1 id=\\\"transition-group列表过渡\\\" tabindex=\\\"-1\\\">transition-group列表过渡 <a class=\\\"header-anchor\\\" href=\\\"#transition-group列表过渡\\\" aria-label=\\\"Permalink to &quot;transition-group列表过渡&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"列表的进入-离开过渡\\\" tabindex=\\\"-1\\\">列表的进入/离开过渡 <a class=\\\"header-anchor\\\" href=\\\"#列表的进入-离开过渡\\\" aria-label=\\\"Permalink to &quot;列表的进入/离开过渡&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<div class=\\\"language-html vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">html</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">&#x3C;</span><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">transition-group</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> tag</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"ul\\\"</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">> </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">&#x3C;!--tag转为ul--></span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">    &#x3C;</span><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">li</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> v-for</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"item in list\\\"</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> :key</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"item\\\"</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">>{{item}}&#x3C;/</span><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">li</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">> </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">&#x3C;!--子元素要有key--></span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">&#x3C;/</span><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">transition-group</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">></span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br></div></div><p><strong>注意</strong>：列表元素一定要有<code>key</code></p>\\n\",\"capture\":\"列表的进入/离开过渡\\n```html\\n&lt;transition-group tag=\\\"ul\\\"\\n    &lt;li v-for=\\\"item in list\\\" :key=\\\"item\\\"&gt;{{item}}&lt;/li&gt; &lt;!--子元素要有key--&gt;\\n&lt;/transition-group&gt;\\n```\\n注意：列表元素一定要有`key`\\n```css\\n.v-enter,.v-leave-to{\\n  opacity: 0;\\n  transform: translateX(30px);\\n}\\n.v-enter-active,.v-leave-active{\\n  tran\"},{\"url\":\"/《Vue》笔记/03.过渡&动画/110.transition过渡&动画.html\",\"relativePath\":\"/《Vue》笔记/03.过渡&动画/110.transition过渡&动画.html\",\"frontmatter\":{\"title\":\"transition过渡&动画\",\"date\":\"2020-02-04 13:16:19\",\"permalink\":\"/pages/184a96b493a97078\",\"categories\":[\"《Vue》笔记\",\"过渡&动画\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"transition过渡&动画\",\"date\":\"2020-02-04 13:16:19\",\"excerpt\":\"<h1 id=\\\"transition过渡-动画\\\" tabindex=\\\"-1\\\">transition过渡&amp;动画 <a class=\\\"header-anchor\\\" href=\\\"#transition过渡-动画\\\" aria-label=\\\"Permalink to &quot;transition过渡&amp;动画&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/transitions.html\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">API</a></p>\\n<h2 id=\\\"使用\\\" tabindex=\\\"-1\\\">使用 <a class=\\\"header-anchor\\\" href=\\\"#使用\\\" aria-label=\\\"Permalink to &quot;使用&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>需要设置动画的元素或组件要在外边包裹一个<code>&lt;transition&gt;</code>标签，设置自定义的<code>name</code>，vue会根据元素的切换（进入/离开）过程添加相应的css类名，你可以<strong>自由地使用css类名来设置css过渡&amp;动画</strong>。</p>\\n\",\"capture\":\"API\\n 使用\\n需要设置动画的元素或组件要在外边包裹一个`&lt;transition\\n 过渡的类名\\n在进入/离开的过渡中，会有 6 个 class 切换。\\n各类名的生命周期\\n* 进入\\n  * `v-enter` 只存在于第一帧\\n  * `v-enter-active` 第一帧到最后一帧，结束后移除\\n  * `v-enter-to` 第二帧到最后一帧，结束后移除\\n* 离开\\n  * `v-leave` 只存在于第一帧\\n  * `v-leave-active` 第一帧到最后一帧，结束后移除\\n  * `v-leave-to` 第二帧到最后一帧，结束后移除\\n如果你使用一个没有`name`的`&lt;t\"},{\"url\":\"/《Vue》笔记/06.规模化/100.vuex操作相关.html\",\"relativePath\":\"/《Vue》笔记/06.规模化/100.vuex操作相关.html\",\"frontmatter\":{\"title\":\"vuex操作相关\",\"date\":\"2020-02-04 13:15:19\",\"permalink\":\"/pages/d9d62d6ab8ff99a6\",\"categories\":[\"《Vue》笔记\",\"规模化\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"vuex操作相关\",\"date\":\"2020-02-04 13:15:19\",\"capture\":\"```js\\nimport { mapActions, mapMutations, mapGetters } from 'vuex'\\ncomputed: {\\n    ...mapGetters([ // 获取数据，内部为数组\\n        'searchHistory' // 相当于在data插入searchHistory和获取到的数据\\n    ])\\n},\\nmethods: {\\n\\t某方法(){\\n\\t  this.saveSearchHistory(传入值)\\n\\t},\\n\\t...mapActions([ // 提交actions修改数据，内部为数组 因为actions文件已对方法进行了封装所有是数组类\"},{\"url\":\"/《Vue》笔记/99.其他/90.操作本地缓存.html\",\"relativePath\":\"/《Vue》笔记/99.其他/90.操作本地缓存.html\",\"frontmatter\":{\"title\":\"操作本地缓存\",\"date\":\"2020-02-04 13:14:19\",\"permalink\":\"/pages/30a94dbe96873b33\",\"categories\":[\"《Vue》笔记\",\"其他\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"操作本地缓存\",\"date\":\"2020-02-04 13:14:19\",\"capture\":\"&lt;https://github.com/ustbhuangyi/storage\\n操作 sessionStorage 和 localStorage 。\"},{\"url\":\"/《Vue》笔记/99.其他/80.Vue中的防抖函数封装和使用.html\",\"relativePath\":\"/《Vue》笔记/99.其他/80.Vue中的防抖函数封装和使用.html\",\"frontmatter\":{\"title\":\"Vue中的防抖函数封装和使用\",\"date\":\"2020-02-04 13:10:19\",\"permalink\":\"/pages/fb08e252dfd8fdfd\",\"categories\":[\"《Vue》笔记\",\"其他\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Vue中的防抖函数封装和使用\",\"date\":\"2020-02-04 13:10:19\",\"capture\":\"Vue中的防抖函数封装和使用\\n如搜索框中，每改变一个数值就请求一次搜索接口，当快速的改变数值时并不需要多次请求接口，这就需要一个防抖函数：\\n```js\\n// 防抖函数\\nexport function debounce(func, delay) { // func 函数 delay间隔时间\\n  let timer\\n  return function (...args) {\\n    if (timer) {\\n      clearTimeout(timer)\\n    }\\n    timer = setTimeout(() =\\n      func.apply(this, args)\\n    }, \"},{\"url\":\"/《Vue》笔记/02.组件/70.父组件调用子组件方法并传入值.html\",\"relativePath\":\"/《Vue》笔记/02.组件/70.父组件调用子组件方法并传入值.html\",\"frontmatter\":{\"title\":\"父组件调用子组件方法并传入值\",\"date\":\"2020-02-04 13:06:37\",\"permalink\":\"/pages/2e24dab728769e0c\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"父组件调用子组件方法并传入值\",\"date\":\"2020-02-04 13:06:37\",\"capture\":\"通过`ref`引用调用子组件内的方法并传入参数\\n父组件：\\n```js\\n&lt;子组件标签  ref=\\\"refName\\\"\\nmethods: {\\n    fnX(x) {\\n      this.$refs.refName.fnY(x) // 调用子组件方法并传入值\\n    }\\n}\\n```\\n子组件：\\n```js\\nmethods: {\\n    fnY(x) {\\n      this.x = x\\n    }\\n  }\\n}\\n```\"},{\"url\":\"/《Vue》笔记/02.组件/60.兄弟组件传值.html\",\"relativePath\":\"/《Vue》笔记/02.组件/60.兄弟组件传值.html\",\"frontmatter\":{\"title\":\"兄弟组件传值\",\"date\":\"2020-02-04 13:04:32\",\"permalink\":\"/pages/809f4582d9ca9552\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"兄弟组件传值\",\"date\":\"2020-02-04 13:04:32\",\"capture\":\"子组件1中把值传到父组件,父组件获取值传入子组件2\\n父组件：\\n```js\\n&lt;子组件1 @方法名x=\\\"方法名y\\\"\\n&lt;子组件2 :值名称x=\\\"值x\\\"&gt;&lt;/子组件2 &gt;\\ndata() {\\n\\treturn {\\n\\t 值x: ''\\n\\t}\\n},\\nmethods: {\\n\\t方法名y(值) {\\n\\t\\tthis.值x = 值\\n\\t}\\n}\\n```\\n子组件1：\\n```js\\nthis.$emit('方法名x', 值) // 传出值\\n```\\n子组件2：\\n```js\\nprops: {\\n    值名称x: { // 接收父组件传入值\\n        type: String,\\n        defa\"},{\"url\":\"/《Vue》笔记/02.组件/50.子组件派发事件和值给父组件.html\",\"relativePath\":\"/《Vue》笔记/02.组件/50.子组件派发事件和值给父组件.html\",\"frontmatter\":{\"title\":\"子组件派发事件和值给父组件\",\"date\":\"2020-02-04 12:56:51\",\"permalink\":\"/pages/0f19a1bcac14fd41\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"子组件派发事件和值给父组件\",\"date\":\"2020-02-04 12:56:51\",\"excerpt\":\"<h1 id=\\\"子组件派发事件和值给父组件\\\" tabindex=\\\"-1\\\">子组件派发事件和值给父组件 <a class=\\\"header-anchor\\\" href=\\\"#子组件派发事件和值给父组件\\\" aria-label=\\\"Permalink to &quot;子组件派发事件和值给父组件&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/components.html#%E7%9B%91%E5%90%AC%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">API</a></p>\\n<p>子组件通过<code>$emit</code>派发事件和值给父组件（值可以有多个）</p>\\n<div class=\\\"language-js vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">js</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">this</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">$emit</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'fnX'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, value)</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br></div></div>\",\"capture\":\"API\\n子组件通过`$emit`派发事件和值给父组件（值可以有多个）\\n```js\\nthis.$emit('fnX', value)\\n```\\n父组件通过`v-on`绑定子组件派发的事件，并触发一个新的事件，新的事件内可以接收传来的值\\n```js\\n&lt;ComponentName @fnX=\\\"fnY\\\"\\nmethods: {\\n\\tfnY(value) {\\n\\t\\tconsole.log(value)\\n\\t}\\n}\\n```\\n 父子组件间传递数据 demo\\n&lt;p class=\\\"codepen\\\" data-height=\\\"400\\\" data-theme-id=\\\"light\\\" data-default-tab\"},{\"url\":\"/《Vue》笔记/02.组件/40.父组件给子组件传值.html\",\"relativePath\":\"/《Vue》笔记/02.组件/40.父组件给子组件传值.html\",\"frontmatter\":{\"title\":\"父组件给子组件传值\",\"date\":\"2020-02-04 12:45:30\",\"permalink\":\"/pages/07b384c2e6232e07\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"父组件给子组件传值\",\"date\":\"2020-02-04 12:45:30\",\"excerpt\":\"<h1 id=\\\"父组件给子组件传值\\\" tabindex=\\\"-1\\\">父组件给子组件传值 <a class=\\\"header-anchor\\\" href=\\\"#父组件给子组件传值\\\" aria-label=\\\"Permalink to &quot;父组件给子组件传值&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>父组件中，通过给子组件标签v-bind绑定属性的方式传入值</p>\\n<div class=\\\"language-html vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">html</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">&#x3C;</span><span style=\\\"--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic\\\">ComponentName</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> v-bind:name</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"value\\\"</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">>&#x3C;/</span><span style=\\\"--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic\\\">ComponentName</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">></span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br></div></div><blockquote>\\n<p>如果不使用v-bind传入的值为字符串，使用v-bind绑定传入的值为表达式。</p>\\n</blockquote>\\n\",\"capture\":\"父组件中，通过给子组件标签v-bind绑定属性的方式传入值\\n```html\\n&lt;ComponentName v-bind:name=\\\"value\\\"\\n```\\n&gt; 如果不使用v-bind传入的值为字符串，使用v-bind绑定传入的值为表达式。\\n子组件中，通过props对象接收值\\n```js\\n props: {\\n    name: { // 接收父组件传入值\\n        type: String || ...,\\n        default: ''\\n    }\\n }\\n```\\n 单向数据流\\n所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向\"},{\"url\":\"/《Vue》笔记/01.基础/00.MVVM模式.html\",\"relativePath\":\"/《Vue》笔记/01.基础/00.MVVM模式.html\",\"frontmatter\":{\"title\":\"MVVM模式\",\"date\":\"2020-02-04 12:19:00\",\"permalink\":\"/pages/114158caa9e96df0\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"MVVM模式\",\"date\":\"2020-02-04 12:19:00\",\"excerpt\":\"<div class=\\\"tip custom-block\\\"><p class=\\\"custom-block-title\\\">TIP</p>\\n<p>说明：本章内容是博主的Vue学习笔记，以<a href=\\\"https://cn.vuejs.org/v2/guide/\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">官方文档</a>为准。</p>\\n</div>\\n<h1 id=\\\"mvvm模式\\\" tabindex=\\\"-1\\\">MVVM模式 <a class=\\\"header-anchor\\\" href=\\\"#mvvm模式\\\" aria-label=\\\"Permalink to &quot;MVVM模式&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>MVVM模式，<code>M</code>即 model，数据模型；<code>V</code>即 view，视图；<code>VM</code>即 view-model，视图模型。</p>\\n\",\"capture\":\"说明：本章内容是博主的Vue学习笔记，以官方文档为准。\\n MVVM模式\\nMVVM模式，`M`即 model，数据模型；`V`即 view，视图；`VM`即 view-model，视图模型。\\n理解\\n首先，数据Model通过Data Bindings把数据绑定在View视图上，\\n当View视图有交互（有改变）的时候，Dom listeners会自动监听，然后更新数据Model。\\nQ：什么是MVVM模式？\\nA：MVVM模式，第一个M代表数据模型，V代表视图，VM代表视图模型；\\n它的实际操作原理是：后台数据通过视图模型来渲染视图，就是页面。当用户在页面上进行操作的时候，\\n视图模型会自动监听到用户的操作\"},{\"url\":\"/《ES6 教程》笔记/01.ECMAScript 6 简介.html\",\"relativePath\":\"/《ES6 教程》笔记/01.ECMAScript 6 简介.html\",\"frontmatter\":{\"title\":\"ECMAScript 6 简介\",\"date\":\"2020-01-12 15:45:35\",\"permalink\":\"/pages/f344d070a1031ef7\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"ECMAScript 6 简介\",\"date\":\"2020-01-12 15:45:35\",\"excerpt\":\"<blockquote>\\n<p>说明：本章内容为博主在原教程基础上添加自己的学习笔记，来源<a href=\\\"http://es6.ruanyifeng.com/\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">http://es6.ruanyifeng.com/</a>，教程版权归原作者所有。</p>\\n</blockquote>\\n<h1 id=\\\"ecmascript-6-简介\\\" tabindex=\\\"-1\\\">ECMAScript 6 简介 <a class=\\\"header-anchor\\\" href=\\\"#ecmascript-6-简介\\\" aria-label=\\\"Permalink to &quot;ECMAScript 6 简介&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p>\\n\",\"capture\":\"ECMAScript 6 简介\\nECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。\\n ECMAScript 和 JavaScript 的关系\\n一个常见的问题是，ECMAScript 和 JavaScript 到底是什么关系？\\n要讲清楚这个问题，需要回顾历史。1996 年 11 月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给标准化组织 ECMA，希望这种语言能够成为国际标\"},{\"url\":\"/《JavaScript教程》笔记/01.基础.html\",\"relativePath\":\"/《JavaScript教程》笔记/01.基础.html\",\"frontmatter\":{\"title\":\"基础\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/0796ba76b4b55368\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"基础\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"基础篇\\n 一、JS的一些名词概念\\n 什么是作用域？\\n变量存在的范围。\\n可分为全局作用域和函数作用域，ES6新增块级作用域。\\n 什么是闭包？\\n闭包就是能够读取其他函数内部变量的函数。\\n* 闭包的形式：函数内部定义函数\\n* 本质上闭包就是将函数内部和外部连接起来的一座桥梁\\n闭包的作用：\\n* 可以读取函数内部变量\\n* 让这些变量始终保持在内存中，即闭包可以使得它诞生的环境一直存在。\\n*  封装对象的私有属性和私有方法\\n 什么是构造函数？\\n用于构造(生成)实例的一个函数，使实例拥有构造函数内定于的属性和方法。\\n 什么是实例对象？\\n实例对象就是通过new 构造函数生成的，拥有构造函数内定于的属性和方法的\"},{\"url\":\"/《JavaScript教程》笔记/02.内置对象.html\",\"relativePath\":\"/《JavaScript教程》笔记/02.内置对象.html\",\"frontmatter\":{\"title\":\"内置对象\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/74d2ab3fbfeaaa68\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"内置对象\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"内置对象篇\\n 一、Object对象\\n 1、概述\\nJavaScript 原生提供`Object`对象（注意起首的`O`是大写），本章介绍该对象原生的各种方法。\\nJavaScript 的所有其他对象都继承自`Object`对象，即那些对象都是`Object`的实例。\\n`Object`对象的原生方法分成两类：`Object`本身的方法与`Object`的实例方法。\\n（1）Object对象本身的方法\\n所谓“本身的方法”就是直接定义在`Object`对象的方法。\\n```js\\nObject.print = function (o) { console.log(o) };\\n```\\n上面代码中，`print`\"},{\"url\":\"/《JavaScript教程》笔记/03.面向对象.html\",\"relativePath\":\"/《JavaScript教程》笔记/03.面向对象.html\",\"frontmatter\":{\"title\":\"面向对象\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/659b5af5e2e704e0\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"面向对象\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"面向对象编程\\n 一、实例对象与new命令\\n 1、对象是什么\\n面向对象编程（Object Oriented Programming，缩写为 OOP）是目前主流的编程范式。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。\\n每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务。对象可以复用，通过继承机制还可以定制。因此，面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程（procedural programming），更适合多人合作的大型软件项目。\\n那么，“对象”\"},{\"url\":\"/《JavaScript教程》笔记/04.异步操作.html\",\"relativePath\":\"/《JavaScript教程》笔记/04.异步操作.html\",\"frontmatter\":{\"title\":\"异步操作\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/d61b1cb4cdac1f63\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"异步操作\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"异步操作\\n 一、异步操作概述\\n 1、单线程模型\\n单线程模型指的是，JavaScript 只在一个线程上运行。也就是说，JavaScript 同时只能执行一个任务，其他任务都必须在后面排队等待。\\n注意，JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合。\\nJavaScript 之所以采用单线程，而不是多线程，跟历史有关系。JavaScript 从诞生起就是单线程，原因是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对\"},{\"url\":\"/《JavaScript教程》笔记/05.DOM.html\",\"relativePath\":\"/《JavaScript教程》笔记/05.DOM.html\",\"frontmatter\":{\"title\":\"DOM\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/7d961b8030c6099e\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"DOM\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"DOM\\n 一、概述\\n 1、DOM\\nDOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。\\n浏览器会根据 DOM 模型，将结构化文档（比如 HTML 和 XML）解析成一系列的节点，再由这些节点组成一个树状结构（DOM Tree）。所有的节点和最终的树状结构，都有规范的对外接口。\\nDOM 只是一个接口规范，可以用各种语言实现。所以严格地说，DOM 不是 JavaScript 语法的一部分，但是 DOM 操作是 JavaScript 最\"},{\"url\":\"/《JavaScript教程》笔记/06.事件.html\",\"relativePath\":\"/《JavaScript教程》笔记/06.事件.html\",\"frontmatter\":{\"title\":\"事件\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/10b2761db5a8e089\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"事件\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"事件\\n 一、EventTarget 接口\\n 事件的本质是程序各个组成部分之间的一种通信方式，也是异步编程的一种实现。DOM 支持大量的事件，本章开始介绍 DOM 的事件编程。\\n 1、概述\\nDOM 的事件操作（监听和触发），都定义在`EventTarget`接口。所有节点对象都部署了这个接口，其他一些需要事件通信的浏览器内置对象（比如，`XMLHttpRequest`、`AudioNode`、`AudioContext`）也部署了这个接口。\\n该接口主要提供三个实例方法。\\n- `addEventListener`：绑定事件的监听函数\\n- `removeEventListener`：移除事件的监听函\"},{\"url\":\"/《JavaScript教程》笔记/07.浏览器模型.html\",\"relativePath\":\"/《JavaScript教程》笔记/07.浏览器模型.html\",\"frontmatter\":{\"title\":\"浏览器模型\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/bab4930124ad2c10\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"浏览器模型\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"一、浏览器环境概述\\nJavaScript 是浏览器的内置脚本语言。也就是说，浏览器内置了 JavaScript 引擎，并且提供各种接口，让 JavaScript 脚本可以控制浏览器的各种功能。一旦网页内嵌了 JavaScript 脚本，浏览器加载网页，就会去执行脚本，从而达到操作浏览器的目的，实现网页的各种动态效果。\\n本章开始介绍浏览器提供的各种 JavaScript 接口。首先，介绍 JavaScript 代码嵌入网页的方法。\\n 1、代码嵌入网页的方法\\n网页中嵌入 JavaScript 代码，主要有三种方法。\\n- `  &lt;script\\n- `  &lt;script&gt;  `标签加\"},{\"url\":\"/01.前端/25.JavaScript文章/08.判断是否为移动端浏览器.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/08.判断是否为移动端浏览器.html\",\"frontmatter\":{\"title\":\"判断是否为移动端浏览器\",\"date\":\"2020-01-04 15:25:11\",\"permalink\":\"/pages/40f623be692cf8bc\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"判断是否为移动端浏览器\",\"date\":\"2020-01-04 15:25:11\",\"capture\":\"```js\\nconst flag = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);\\nif(flag){\\n    // 移动端\\n} else {\\n    // PC端\\n}\\n```\"},{\"url\":\"/04.更多/01.学习/03.提高记忆的技巧.html\",\"relativePath\":\"/04.更多/01.学习/03.提高记忆的技巧.html\",\"frontmatter\":{\"title\":\"提高记忆的技巧\",\"date\":\"2020-01-03 14:34:48\",\"permalink\":\"/pages/996822b2a2ca6e3b\",\"categories\":[\"更多\",\"学习\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"提高记忆的技巧\",\"date\":\"2020-01-03 14:34:48\",\"excerpt\":\"<h1 id=\\\"提高记忆的技巧\\\" tabindex=\\\"-1\\\">提高记忆的技巧 <a class=\\\"header-anchor\\\" href=\\\"#提高记忆的技巧\\\" aria-label=\\\"Permalink to &quot;提高记忆的技巧&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<ol>\\n<li><strong>多个感官并用</strong>\\n记忆时调用一切感官。没人的话可以大声阅读，有人的话可以默念，轻微摇晃手指等，有助于保持专注。</li>\\n</ol>\\n\",\"capture\":\"1. 多个感官并用\\n   记忆时调用一切感官。没人的话可以大声阅读，有人的话可以默念，轻微摇晃手指等，有助于保持专注。\\n   \\n2. 重复记忆\\n   每天留出半个到一个小时，梳理总结今天所学的内容。每一章复习完成后做系统的知识整理。\\n   \\n3. 建立关联\\n   把你所学的新知识与已有的认知建立联系，对于记忆事半功倍。\\n   \\n4. 场景记忆\\n   把知识具象化为一个场景，想象自己在何时何地能用这些知识，与自身发生联系。\\n   \\n5. 提出问题\\n   每学习一个知识点，试着提问，然后给出答案。用了就记住了。\"},{\"url\":\"/03.技术/03.博客搭建/03.GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床.html\",\"relativePath\":\"/03.技术/03.博客搭建/03.GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床.html\",\"frontmatter\":{\"title\":\"GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床\",\"date\":\"2020-01-03 12:55:43\",\"permalink\":\"/pages/a5f73af5185fdf0a\",\"categories\":[\"技术\",\"博客搭建\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床\",\"date\":\"2020-01-03 12:55:43\",\"excerpt\":\"<h1 id=\\\"github-jsdelivr-tinypng-picgo-打造稳定快速、高效免费图床\\\" tabindex=\\\"-1\\\">GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床 <a class=\\\"header-anchor\\\" href=\\\"#github-jsdelivr-tinypng-picgo-打造稳定快速、高效免费图床\\\" aria-label=\\\"Permalink to &quot;GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"前言\\\" tabindex=\\\"-1\\\">前言 <a class=\\\"header-anchor\\\" href=\\\"#前言\\\" aria-label=\\\"Permalink to &quot;前言&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p><strong>Q：为什么要使用图床呢？什么是图床？</strong></p>\\n<p>A：写博客文章时，图片的上传和存放是一个问题，有的朋友可能会把图片放到和博客同一个仓库当中，使用相对路径来引用，这样后期维护起来会比较麻烦。还有的朋友会在不同的平台发布同一篇文章，这样一来每个平台都要上传图片，为了解决这些问题，比较推荐的做法是把图片统一上传到一个在线的第三方静态资源库中，我们把这个资源库称为图床，其返回一个图片的URL，使用<code>markdown+图片url</code>的方式写作文章，一次编写，到处使用~</p>\\n\",\"capture\":\"前言\\nQ：为什么要使用图床呢？什么是图床？\\nA：写博客文章时，图片的上传和存放是一个问题，有的朋友可能会把图片放到和博客同一个仓库当中，使用相对路径来引用，这样后期维护起来会比较麻烦。还有的朋友会在不同的平台发布同一篇文章，这样一来每个平台都要上传图片，为了解决这些问题，比较推荐的做法是把图片统一上传到一个在线的第三方静态资源库中，我们把这个资源库称为图床，其返回一个图片的URL，使用`markdown+图片url`的方式写作文章，一次编写，到处使用~\\n以下内容是比较旧的，现在我发现一个更好用，配置更方便的图床工具：&lt;https://picx.xpoet.cn/\\n使用方法看一下他网站的使\"},{\"url\":\"/03.技术/02.Nodejs/01.nodejs递归读取所有文件.html\",\"relativePath\":\"/03.技术/02.Nodejs/01.nodejs递归读取所有文件.html\",\"frontmatter\":{\"title\":\"nodejs递归读取所有文件\",\"date\":\"2019-12-26 15:57:32\",\"permalink\":\"/pages/117708e0af7f0bd9\",\"categories\":[\"技术\",\"Nodejs\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"nodejs递归读取所有文件\",\"date\":\"2019-12-26 15:57:32\",\"capture\":\"```js\\nvar fs = require('fs');\\nvar path = require('path');\\n \\nfunction readFileList(dir, filesList = []) {\\n    const files = fs.readdirSync(dir);\\n    console.log(files);\\n    files.forEach((item, index) =\\n        var fullPath = path.join(dir, item);\\n        const stat = fs.statSync(fullPath);\\n        i\"},{\"url\":\"/01.前端/25.JavaScript文章/02.new命令原理.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/02.new命令原理.html\",\"frontmatter\":{\"title\":\"new命令原理\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/8143cc480faf9a11\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"new命令原理\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"new命令原理\\\" tabindex=\\\"-1\\\">new命令原理 <a class=\\\"header-anchor\\\" href=\\\"#new命令原理\\\" aria-label=\\\"Permalink to &quot;new命令原理&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>使用new命令时，它后面的函数依次执行下面的步骤：</p>\\n<ol>\\n<li>创建一个空对象，作为将要返回的实例对象。</li>\\n<li>将这个空对象的原型，指向构造函数的prototype属性。</li>\\n<li>将这个空对象赋值给函数内部的this关键字。</li>\\n<li>开始执行构造函数内部的代码。</li>\\n<li>如果构造函数内有返回值且为对象类型，则返回该对象，否则返回上面创建的实例对象。</li>\\n</ol>\\n\",\"capture\":\"使用new命令时，它后面的函数依次执行下面的步骤：\\n1. 创建一个空对象，作为将要返回的实例对象。\\n2. 将这个空对象的原型，指向构造函数的prototype属性。\\n3. 将这个空对象赋值给函数内部的this关键字。\\n4. 开始执行构造函数内部的代码。\\n5. 如果构造函数内有返回值且为对象类型，则返回该对象，否则返回上面创建的实例对象。\\n```js\\n// 构造函数\\nfunction Person(name,age){\\n    this.name = name\\n    this.age = age\\n}\\n// 自定义_new\\nfunction _new() {\\n  // 将 arguments 对\"},{\"url\":\"/01.前端/25.JavaScript文章/04.ES6面向对象.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/04.ES6面向对象.html\",\"frontmatter\":{\"title\":\"ES6面向对象\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/1f4123be6f45abcd\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"ES6面向对象\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```js\\n//面向对象封装\\nclass Student{ //定义类 (尊从首字母大写的约定)\\n    constructor(props){  // 构造函数 （构造函数内定于属性）\\n        this.name = props.name || '匿名'; // 默认'匿名'\\n      this.grade = props.grade || 1;\\n    }\\n    hello(){ // 在构造函数的原型上定义方法\\n        console.log(`你好,${this.name}同学，你在${this.grade}年级`);\\n    }\\n}\\n//使用\\nfunction c\"},{\"url\":\"/01.前端/25.JavaScript文章/06.多种数组去重性能对比.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/06.多种数组去重性能对比.html\",\"frontmatter\":{\"title\":\"多种数组去重性能对比\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/e808fba1fa8fbab2\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"多种数组去重性能对比\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"测试模板\\n```js\\n// 创建一个 1 ~ 10w 的数组，Array.from为ES6语法\\nlet arr1 = Array.from(new Array(1000000), (x, index) =\\n  return index\\n})\\nlet arr2 = Array.from(new Array(500000), (x, index) =&gt; {\\n  return index + index\\n})\\nlet start = new Date().getTime()\\nconsole.log('开始数组去重')\\n// 数组去重\\nfunction distinct(a, b) {\\n  le\"},{\"url\":\"/01.前端/40.学习笔记/40.小程序笔记.html\",\"relativePath\":\"/01.前端/40.学习笔记/40.小程序笔记.html\",\"frontmatter\":{\"title\":\"小程序笔记\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/note/wx-miniprogram/\",\"tags\":[\"小程序\"],\"categories\":[\"前端\",\"学习笔记\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"小程序笔记\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"小程序笔记\\n 基础课程部分\\n 微信公众平台\\n&lt;https://mp.weixin.qq.com/\\n注册时可选择类型：订阅号、服务号、小程序、企业微信\\n每个邮箱仅能注册一个小程序。\\n个人类型小程序：无法使用微信支付、无法使用卡包功能\\n 小程序文档API\\n小程序开发文档\\n 微信开放社区\\n微信开发社区\\n 目录说明\\n默认目录\\npages-----------------------页面相关\\n​\\tindex  ----------------- 首页文件夹\\n​\\t\\tindex.js ------------首页js\\n​\\t\\tindex.json---------首页配置\\n​\\t\\tindex.wxml--\"},{\"url\":\"/02.页面/20.CSS/01.flex布局语法.html\",\"relativePath\":\"/02.页面/20.CSS/01.flex布局语法.html\",\"frontmatter\":{\"title\":\"flex布局语法\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/0a83b083bdf257cb\",\"author\":{\"name\":\"阮一峰\"},\"categories\":[\"页面\",\"CSS\"],\"tags\":[null]},\"author\":{\"name\":\"阮一峰\"},\"title\":\"flex布局语法\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"flex布局语法\\\" tabindex=\\\"-1\\\">flex布局语法 <a class=\\\"header-anchor\\\" href=\\\"#flex布局语法\\\" aria-label=\\\"Permalink to &quot;flex布局语法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"一、flex-布局是什么\\\" tabindex=\\\"-1\\\">一、flex 布局是什么？ <a class=\\\"header-anchor\\\" href=\\\"#一、flex-布局是什么\\\" aria-label=\\\"Permalink to &quot;一、flex 布局是什么？&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>Flex是 Flexible Box 的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性。</p>\\n<p><strong>任何一个容器</strong> 都可以指定为 Flex 布局。</p>\\n\",\"capture\":\"一、flex 布局是什么？\\nFlex是 Flexible Box 的缩写，意为\\\"弹性布局\\\"，用来为盒状模型提供最大的灵活性。\\n任何一个容器 都可以指定为 Flex 布局。\\n```css\\n.box{\\n  display: flex;\\n}\\n```\\n行内元素 也可以使用 Flex 布局。\\n```css\\n.box{\\n  display: inline-flex;\\n}\\n```\\nWebkit 内核的浏览器，必须加上`-webkit`前缀。\\n```css\\n.box{\\n  display: -webkit-flex; /* Safari */\\n  display: flex;\\n}\\n```\\n注意，设为 Flex\"},{\"url\":\"/02.页面/20.CSS/02.flex布局案例-基础.html\",\"relativePath\":\"/02.页面/20.CSS/02.flex布局案例-基础.html\",\"frontmatter\":{\"title\":\"flex布局案例-基础\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/ea6db1530c42ad51\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"flex布局案例-基础\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"``` html\\n&lt;html&gt;\\n  &lt;div class=\\\"box\\\"&gt;\\n    &lt;span&gt;1&lt;/span&gt;\\n    &lt;span&gt;2&lt;/span&gt;\\n    &lt;span&gt;3&lt;/span&gt;\\n    &lt;span&gt;4&lt;/span&gt;\\n    &lt;span&gt;5&lt;/span&gt;\\n    &lt;span&gt;6&lt;/span&gt;\\n    &lt;span&gt;7&lt;/span&gt;\\n  &lt;/div&gt;\\n&lt;/html&gt;\\n&lt;st\"},{\"url\":\"/02.页面/20.CSS/03.flex布局案例-骰子.html\",\"relativePath\":\"/02.页面/20.CSS/03.flex布局案例-骰子.html\",\"frontmatter\":{\"title\":\"flex布局案例-骰子\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/eff61bc8b4f4695d\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"flex布局案例-骰子\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```html\\n&lt;html&gt;\\n  &lt;div class=\\\"box2\\\"&gt;\\n    &lt;div class=\\\"first-face\\\"&gt;\\n      &lt;span class=\\\"pip\\\"&gt;&lt;/span&gt;\\n    &lt;/div&gt;\\n    &lt;div class=\\\"second-face\\\"&gt;\\n      &lt;span class=\\\"pip\\\"&gt;&lt;/span&gt;\\n      &lt;span class=\\\"pip\\\"&gt;&lt;/span&gt;\\n    &lt;/div&gt;\\n    &lt;div cla\"},{\"url\":\"/02.页面/20.CSS/04.flex布局案例-圣杯布局.html\",\"relativePath\":\"/02.页面/20.CSS/04.flex布局案例-圣杯布局.html\",\"frontmatter\":{\"title\":\"flex布局案例-圣杯布局\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/df9e7c7214fa5046\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"flex布局案例-圣杯布局\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```html\\n&lt;html&gt;\\n  &lt;div class=\\\"HolyGrail\\\"&gt;\\n    &lt;header&gt;header&lt;/header&gt;\\n    &lt;div class=\\\"wrap\\\"&gt;\\n      &lt;nav class=\\\"left\\\"&gt;left 宽度固定200px&lt;/nav&gt;\\n      &lt;main class=\\\"content\\\"&gt;center 宽度自适应&lt;/main&gt;\\n      &lt;aside class=\\\"right\\\"&gt;right 宽度固定200px&lt;/aside&gt\"},{\"url\":\"/02.页面/20.CSS/05.flex布局案例-网格布局.html\",\"relativePath\":\"/02.页面/20.CSS/05.flex布局案例-网格布局.html\",\"frontmatter\":{\"title\":\"flex布局案例-网格布局\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/85b5a3fe218a34b7\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"flex布局案例-网格布局\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```html\\n&lt;html&gt;\\n  &lt;div class=\\\"grid\\\"&gt;\\n    &lt;div class=\\\"grid-cell\\\"&gt;1/2&lt;/div&gt;\\n    &lt;div class=\\\"grid-cell\\\"&gt;1/2&lt;/div&gt;\\n  &lt;/div&gt;\\n  &lt;div class=\\\"grid\\\"&gt;\\n    &lt;div class=\\\"grid-cell\\\"&gt;1/3&lt;/div&gt;\\n    &lt;div class=\\\"grid-cell\\\"&gt;1/3&lt;/div&gt;\\n    &lt;div cl\"},{\"url\":\"/02.页面/20.CSS/06.flex布局案例-输入框布局.html\",\"relativePath\":\"/02.页面/20.CSS/06.flex布局案例-输入框布局.html\",\"frontmatter\":{\"title\":\"flex布局案例-输入框布局\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/05cc577fb51c7998\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"flex布局案例-输入框布局\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```html\\n&lt;html&gt;\\n  &lt;div class=\\\"InputAddOn\\\"&gt;\\n    &lt;span class=\\\"InputAddOn-item\\\"&gt;icon&lt;/span&gt;\\n    &lt;input class=\\\"InputAddOn-field\\\" placeholder=\\\"input宽度自适应\\\"&gt;\\n    &lt;button class=\\\"InputAddOn-item\\\"&gt;提交&lt;/button&gt;\\n  &lt;/div&gt;\\n  &lt;br/&gt;\\n  &lt;div class=\\\"Media\\\"&gt;\\n   \"},{\"url\":\"/02.页面/20.CSS/07.CSS3之transition过渡.html\",\"relativePath\":\"/02.页面/20.CSS/07.CSS3之transition过渡.html\",\"frontmatter\":{\"title\":\"CSS3之transition过渡\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/02d7f59d98d87409\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"CSS3之transition过渡\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"html结构\\n```html\\n&lt;div class=\\\"box1\\\"\\n  &lt;div class=\\\"div1\\\"&gt;&lt;/div&gt;\\n  &lt;div class=\\\"div2\\\"&gt;&lt;/div&gt;\\n  &lt;div class=\\\"div3\\\"&gt;&lt;/div&gt;\\n&lt;/div&gt;\\n```\\n先给元素设置transition过渡，指定样式和时间，这里设置all全部样式都采用0.3s的过渡\\n```css\\n.box1&gt;div{\\n  /* 给元素所有变化都添加过渡动画, 也可以指定唯一的过渡样式属性*/\\n  transition: all .3s;\"},{\"url\":\"/02.页面/20.CSS/08.CSS3之animation动画.html\",\"relativePath\":\"/02.页面/20.CSS/08.CSS3之animation动画.html\",\"frontmatter\":{\"title\":\"CSS3之animation动画\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/c2c0432138f6e042\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"CSS3之animation动画\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```html\\n&lt;html&gt;\\n  &lt;div class=\\\"animationBox\\\"&gt;\\n    &lt;div class=\\\"rotate\\\"&gt;旋转动画1&lt;/div&gt;\\n    &lt;div class=\\\"play\\\"&gt;\\n      &lt;div class=\\\"img\\\"&gt;旋转动画2&lt;/div&gt;\\n      &lt;span&gt;&lt;p class=\\\"p2\\\"&gt;&lt;/p&gt;&lt;/span&gt;\\n      &lt;span&gt;&lt;p&gt;&lt;/p&gt;&lt;/span&gt;\\n      &\"},{\"url\":\"/03.技术/01.技术文档/01.Git使用手册.html\",\"relativePath\":\"/03.技术/01.技术文档/01.Git使用手册.html\",\"frontmatter\":{\"title\":\"Git使用手册\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/9a7ee40fc232253e\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git使用手册\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"git使用手册\\\" tabindex=\\\"-1\\\">Git使用手册 <a class=\\\"header-anchor\\\" href=\\\"#git使用手册\\\" aria-label=\\\"Permalink to &quot;Git使用手册&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"安装\\\" tabindex=\\\"-1\\\">安装 <a class=\\\"header-anchor\\\" href=\\\"#安装\\\" aria-label=\\\"Permalink to &quot;安装&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>官网下载：<a href=\\\"https://git-scm.com/downloads\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">https://git-scm.com/downloads</a> 下载完成后使用默认进行安装。</p>\\n<p>安装完成后，在开始菜单里找到 <code>Git</code> -&gt; <code>Git Bash</code>，蹦出一个类似命令行窗口的东西，就说明Git安装成功！\\n还需要最后一步设置，在命令行输入：</p>\\n<div class=\\\"language-bash vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">bash</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">git</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> config</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> --global</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> user.name</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> \\\"Your Name\\\"</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">git</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> config</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> --global</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> user.email</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> \\\"email@example.com\\\"</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br></div></div><p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。</p>\\n\",\"capture\":\"Git使用手册\\n 安装\\n官网下载：&lt;https://git-scm.com/downloads\\n安装完成后，在开始菜单里找到 `Git` -&gt; `Git Bash`，蹦出一个类似命令行窗口的东西，就说明Git安装成功！\\n还需要最后一步设置，在命令行输入：\\n```bash\\ngit config --global user.name \\\"Your Name\\\"\\ngit config --global user.email \\\"email@example.com\\\"\\n```\\n因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。\\n 创建版本库（仓库）\\n```ba\"},{\"url\":\"/03.技术/01.技术文档/02.Markdown使用教程.html\",\"relativePath\":\"/03.技术/01.技术文档/02.Markdown使用教程.html\",\"frontmatter\":{\"title\":\"Markdown使用教程\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/ad247c4332211551\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Markdown使用教程\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"markdown使用教程\\\" tabindex=\\\"-1\\\">Markdown使用教程 <a class=\\\"header-anchor\\\" href=\\\"#markdown使用教程\\\" aria-label=\\\"Permalink to &quot;Markdown使用教程&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"一、markdown\\\" tabindex=\\\"-1\\\">一、Markdown <a class=\\\"header-anchor\\\" href=\\\"#一、markdown\\\" aria-label=\\\"Permalink to &quot;一、Markdown&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p><img src=\\\"https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/md_logo.png\\\" alt=\\\"logo\\\"></p>\\n<p><code>Markdown</code> 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>\\n\",\"capture\":\"一、Markdown\\n 简介\\n`Markdown` 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。\\n  应用\\n当前许多网站都广泛使用 `Markdown` 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、知乎等\\n 编辑器\\n推荐使用`Typora`，官网：&lt;https://typora.io/\\n 二、徽章\\n 什么是徽章\\n徽章是一种小巧精美的小图标，一般配有相关文字进行辅助说明，可对数据进行监控，链接跳转等，富有表现力。\\n常见于`github`项目主页，但其不仅出现于 `github` 项目主页，凡是能够表现图片的地方都可以出现徽章。\\n 徽章的使用\\n* 在\"},{\"url\":\"/03.技术/01.技术文档/03.npm常用命令.html\",\"relativePath\":\"/03.技术/01.技术文档/03.npm常用命令.html\",\"frontmatter\":{\"title\":\"npm常用命令\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/61f2f95fd7da14fd\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"npm常用命令\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"npm常用命令\\\" tabindex=\\\"-1\\\">npm常用命令 <a class=\\\"header-anchor\\\" href=\\\"#npm常用命令\\\" aria-label=\\\"Permalink to &quot;npm常用命令&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>npm是跟随node一起安装的包（模块）管理器。常见的使用场景有以下几种：</p>\\n<ul>\\n<li>允许用户从npm服务器下载别人编写的第三方包到本地使用。</li>\\n<li>允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用。</li>\\n<li>允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。</li>\\n</ul>\\n\",\"capture\":\"简介\\nnpm是跟随node一起安装的包（模块）管理器。常见的使用场景有以下几种：\\n* 允许用户从npm服务器下载别人编写的第三方包到本地使用。\\n* 允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用。\\n* 允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。\\n 常用命令\\n 检测是否安装及版本\\n```sh\\nnpm -v  显示版本号说明已经安装相应的版本\\n```\\n 生成package.json文件\\n```sh\\nnpm init\\n```\\n\\n 安装模块\\n```sh\\nnpm install  安装package.json定义好的模块，简写 npm i\\n 安装包指定模块\\nnpm \"},{\"url\":\"/03.技术/01.技术文档/15.yaml语言教程.html\",\"relativePath\":\"/03.技术/01.技术文档/15.yaml语言教程.html\",\"frontmatter\":{\"title\":\"yaml语言教程\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/4e8444e2d534d14f\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"yaml语言教程\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"yaml语言教程\\\" tabindex=\\\"-1\\\">yaml语言教程 <a class=\\\"header-anchor\\\" href=\\\"#yaml语言教程\\\" aria-label=\\\"Permalink to &quot;yaml语言教程&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>YAML 是 &quot;YAML Ain't a Markup Language&quot;（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：&quot;Yet Another Markup Language&quot;（仍是一种标记语言）。</p>\\n\",\"capture\":\"简介\\nYAML 是 \\\"YAML Ain't a Markup Language\\\"（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：\\\"Yet Another Markup Language\\\"（仍是一种标记语言）。\\nYAML 的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲（例如：许多电子邮件标题格式和YAML非常接近）。\\nYAML 的配置文件后缀为 .yml，如：runoob.yml 。\\n\\n 基本语法\\n- 大小写敏感\\n- 使用缩进\"},{\"url\":\"/03.技术/03.博客搭建/01.解决百度无法收录搭建在GitHub上的个人博客的问题.html\",\"relativePath\":\"/03.技术/03.博客搭建/01.解决百度无法收录搭建在GitHub上的个人博客的问题.html\",\"frontmatter\":{\"title\":\"解决百度无法收录搭建在GitHub上的个人博客的问题\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/41f87d890d0a02af\",\"categories\":[\"技术\",\"博客搭建\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"解决百度无法收录搭建在GitHub上的个人博客的问题\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"解决百度无法收录搭建在github上的静态博客的问题\\\" tabindex=\\\"-1\\\">解决百度无法收录搭建在GitHub上的静态博客的问题 <a class=\\\"header-anchor\\\" href=\\\"#解决百度无法收录搭建在github上的静态博客的问题\\\" aria-label=\\\"Permalink to &quot;解决百度无法收录搭建在GitHub上的静态博客的问题&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<div class=\\\"warning custom-block\\\"><p class=\\\"custom-block-title\\\">WARNING</p>\\n<p>如果你正在寻找本博客的搭建文档，博主建议您查看这个仓库的<a href=\\\"https://github.com/xugaoyi/vuepress-theme-vdoing\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">README</a>。</p>\\n</div>\\n<h2 id=\\\"背景\\\" tabindex=\\\"-1\\\">背景 <a class=\\\"header-anchor\\\" href=\\\"#背景\\\" aria-label=\\\"Permalink to &quot;背景&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>由于GitHub禁止百度爬虫访问，造成托管在GitHub Pages上的博客无法被百度收录。相关问题可以通过百度站长平台的<code>抓取诊断</code>再现，每次都是403 Forbidden的错误。</p>\\n\",\"capture\":\"如果你正在寻找本博客的搭建文档，博主建议您查看这个仓库的README。\\n 背景\\n由于GitHub禁止百度爬虫访问，造成托管在GitHub Pages上的博客无法被百度收录。相关问题可以通过百度站长平台的`抓取诊断`再现，每次都是403 Forbidden的错误。\\n 解决方案\\n同时将博客同时同步托管到GitHub Pages和coding pages上，解决百度不收录问题。最后发现在国内使用coding pages打开速度特别快，而且还会被百度收录，因此我把coding pages的站点作为主站点，原本在github pages的作为分站点。\\n步骤：\\n1、注册coding账号，创建仓库，把代码推\"},{\"url\":\"/03.技术/03.博客搭建/02.使用Gitalk实现静态博客无后台评论系统.html\",\"relativePath\":\"/03.技术/03.博客搭建/02.使用Gitalk实现静态博客无后台评论系统.html\",\"frontmatter\":{\"title\":\"使用Gitalk实现静态博客无后台评论系统\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/1da0bf9a988eafe5\",\"categories\":[\"技术\",\"博客搭建\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"使用Gitalk实现静态博客无后台评论系统\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"使用gitalk实现静态博客无后台评论系统\\\" tabindex=\\\"-1\\\">使用Gitalk实现静态博客无后台评论系统 <a class=\\\"header-anchor\\\" href=\\\"#使用gitalk实现静态博客无后台评论系统\\\" aria-label=\\\"Permalink to &quot;使用Gitalk实现静态博客无后台评论系统&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"前言\\\" tabindex=\\\"-1\\\">前言 <a class=\\\"header-anchor\\\" href=\\\"#前言\\\" aria-label=\\\"Permalink to &quot;前言&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>Gitalk，一个基于 Github Issue 和 Preact 开发的评论插件。</p>\\n<p>下面我们来用它在vuepress搭建的博客中搭建评论区吧</p>\\n\",\"capture\":\"前言\\nGitalk，一个基于 Github Issue 和 Preact 开发的评论插件。\\n下面我们来用它在vuepress搭建的博客中搭建评论区吧\\n 准备\\n使用一个新的东西首先当然是要了解它\\nGitalk demo：&lt;https://gitalk.github.io/\\nGitalk github：&lt;https://github.com/gitalk/gitalk&gt;\\n 实现\\n如何实现？最好的方法我认为是看官方文档，这里我只是记录一下实现的步骤。\\n使用一个别人已经开发好的 vuepress-plugin-comment 插件来帮助我们把Gitalk应用到vuepress搭建的静\"},{\"url\":\"/04.更多/03.面试/01.面试问题集锦.html\",\"relativePath\":\"/04.更多/03.面试/01.面试问题集锦.html\",\"frontmatter\":{\"title\":\"面试问题集锦\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/aea6571b7a8bae86\",\"categories\":[\"更多\",\"面试\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"面试问题集锦\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"请做一下自我介绍\\n回答提示： 一般人回答这个问题过于平常，只说姓名、年龄、工作经验，这些在简历上都有。其实，企业最希望知道的是求职者能否胜任工作，包括：最强的技能、最深入研究的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，要突出积极的个性和做事的能力，说的合情合理企业才会相信。\\n 你最大的优点是什么？\\n回答提示： 沉着冷静、条理清楚、立场坚定、乐于助人等，加上例子如：我在XX经过一到两年的培训及项目实战，加上实习工作，我想我适合这份工作。\\n 说说你最大的缺点？\\n回答提示： 这个问题企业问的概率很大，通常不希望听到直接回答的缺点是什么等，如果求职者说自己小心眼、非常懒、工作效率低\"}],\"groupPostsByYear\":{\"2026 \":[{\"url\":\"/04.更多/05.AI随笔/01.当珍妮机学会了写代码.html\",\"relativePath\":\"/04.更多/05.AI随笔/01.当珍妮机学会了写代码.html\",\"frontmatter\":{\"title\":\"当珍妮机学会了写代码\",\"date\":\"2026-02-26 20:00:00\",\"permalink\":\"/pages/ai-coding-revolution/\",\"categories\":[\"更多\",\"AI随笔\"],\"tags\":[\"AI\",\"思考\",\"编程\"],\"author\":{\"name\":\"刘志伟;AI\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟;AI\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"当珍妮机学会了写代码\",\"date\":\"2026-02-26 20:00:00\",\"capture\":\"当珍妮机学会了写代码\\n\\n 一、从一台纺纱机说起\\n1764 年的某个夜晚，英国兰开夏郡的织工詹姆斯·哈格里夫斯看着妻子的纺车被踢倒后仍在旋转，灵光一闪——如果把纱锭竖起来，一个轮子就能同时驱动八个纱锭。\\n珍妮纺纱机就这样诞生了。一个人能干八个人的活，效率提升 800%。\\n262 年后的 2026 年，我坐在屏幕前，让一个叫 Claude 的 AI 帮我重构整个博客系统。它用 Three.js 写了一个极光 Shader 背景，用 Vue 3 搭了全屏滚动首页，让它设计了五套可切换的艺术风格主题——赛博朋克、梵高、水墨、古典雕塑、现代。它还帮我写了一篇博客，就是现在你正在看的这篇。\\n如果哈格里夫斯\"}],\"2024 \":[{\"url\":\"/《JavaScript教程》笔记/14.JS实现扫码登录.html\",\"relativePath\":\"/《JavaScript教程》笔记/14.JS实现扫码登录.html\",\"frontmatter\":{\"title\":\"JS实现扫码登录\",\"date\":\"2024-03-30 15:32:39\",\"permalink\":\"/pages/bdbdb8/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"JS实现扫码登录\",\"date\":\"2024-03-30 15:32:39\",\"capture\":\"JS实现扫码登录\\r\\n\\r\\n扫码登录是一种方便快捷的登录方式，用户可以通过扫描二维码来登录网站或应用程序。在本文中，我们将使用JavaScript实现一个简单的扫码登录功能。\\r\\n\\r\\n 步骤一：生成二维码\\r\\n\\r\\n首先，我们需要生成一个二维码，用于展示给用户扫描。我们可以使用第三方库 qrcode.js 来生成二维码。以下是使用qrcode.js生成二维码的示例代码：\\r\\n\\r\\n```html\\r\\n&lt;!-- 在HTML中引入qrcode.js库 --\\r\\n&lt;script src=\\\"https://cdn.bootcdn.net/ajax/libs/qrcodejs/1.0.0/qrcode.min\"},{\"url\":\"/《JavaScript教程》笔记/13.JS继承.html\",\"relativePath\":\"/《JavaScript教程》笔记/13.JS继承.html\",\"frontmatter\":{\"title\":\"JS继承\",\"date\":\"2024-03-30 15:32:05\",\"permalink\":\"/pages/b17c09/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"JS继承\",\"date\":\"2024-03-30 15:32:05\",\"capture\":\"在JavaScript中，继承是实现面向对象编程的重要方式之一。\\r\\n\\r\\n 原型继承\\r\\n\\r\\n原型继承是JavaScript中最常用的继承方式之一。在原型继承中，子类通过继承父类的原型对象来实现继承。\\r\\n\\r\\n```javascript\\r\\nfunction Parent() {\\r\\n  this.name = 'parent';\\r\\n}\\r\\n\\r\\nParent.prototype.sayHello = function() {\\r\\n  console.log('Hello from ' + this.name);\\r\\n}\\r\\n\\r\\nfunction Child() {\\r\\n  this.name = 'child';\"},{\"url\":\"/《JavaScript教程》笔记/12.console实用调试方法.html\",\"relativePath\":\"/《JavaScript教程》笔记/12.console实用调试方法.html\",\"frontmatter\":{\"title\":\"console实用调试方法\",\"date\":\"2024-03-30 15:31:48\",\"permalink\":\"/pages/602ffc/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"console实用调试方法\",\"date\":\"2024-03-30 15:31:48\",\"capture\":\"在JavaScript中，console是一个非常有用的工具，可以帮助我们在开发和调试过程中更好地了解代码的执行情况。本文将介绍console中一些常用的方法，并提供示例代码。\\r\\n console.time() & console.timeEnd()\\r\\nconsole.time()方法用于开始计时器，console.timeEnd()方法用于结束计时器并输出所花费的时间。这对于测试代码执行时间非常有用。\\r\\n```javascript\\r\\nconsole.time('myTimer');\\r\\nfor (let i = 0; i &lt; 1000000; i++) {\\r\\n  // do someth\"},{\"url\":\"/《Git》学习笔记/Git常用命令速查表.html\",\"relativePath\":\"/《Git》学习笔记/Git常用命令速查表.html\",\"frontmatter\":{\"title\":\"Git常用命令速查表\",\"date\":\"2024-03-30 15:26:32\",\"permalink\":\"/pages/3aa4fd/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git常用命令速查表\",\"date\":\"2024-03-30 15:26:32\",\"capture\":\"\"},{\"url\":\"/《JavaScript教程》笔记/11.`import`、`require`、`export`、`module.exports` 的区别和使用详解.html\",\"relativePath\":\"/《JavaScript教程》笔记/11.`import`、`require`、`export`、`module.exports` 的区别和使用详解.html\",\"frontmatter\":{\"title\":\"exports` 的区别和使用详解\",\"date\":\"2024-03-30 15:23:12\",\"permalink\":\"/pages/ff5679/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"exports` 的区别和使用详解\",\"date\":\"2024-03-30 15:23:12\",\"capture\":\"在 Node.js 和现代的 JavaScript 中，有多种方式可以导入和导出模块。其中最常见的是使用 `import` 和 `export`，但在 Node.js 中，也可以使用 `require` 和 `module.exports`。本篇文章将介绍这些不同的方式，以及它们之间的区别。\\r\\n\\r\\n `import` 和 `export`\\r\\n\\r\\n`import` 和 `export` 是 ES6 中引入的模块系统。它们允许我们将代码拆分成多个文件，并在不同的文件中共享代码。以下是一个简单的例子：\\r\\n\\r\\n```javascript\\r\\n// math.js\\r\\nexport const add = \"},{\"url\":\"/《JavaScript教程》笔记/10.JS中的？.和？？区别.html\",\"relativePath\":\"/《JavaScript教程》笔记/10.JS中的？.和？？区别.html\",\"frontmatter\":{\"title\":\"和？？区别\",\"date\":\"2024-03-30 15:22:03\",\"permalink\":\"/pages/176ae0/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"和？？区别\",\"date\":\"2024-03-30 15:22:03\",\"capture\":\"`??` 运算符\\r\\n\\r\\n`??` 运算符是 ES2020 中新增的空值合并运算符。它用于判断一个值是否为 `null` 或 `undefined`，如果是，则使用默认值。其语法如下：\\r\\n\\r\\n```javascript\\r\\ndefaultValue ?? value;\\r\\n```\\r\\n\\r\\n如果 `value` 不为 `null` 或 `undefined`，则 `??` 运算符返回 `value`；否则返回 `defaultValue`。\\r\\n\\r\\n```javascript\\r\\nconst a = null;\\r\\nconst b = 5;\\r\\n\\r\\nconsole.log(a ?? 10); // 10\\r\\nco\"},{\"url\":\"/《JavaScript教程》笔记/09.js 使用postMessage iframe跨域通信.html\",\"relativePath\":\"/《JavaScript教程》笔记/09.js 使用postMessage iframe跨域通信.html\",\"frontmatter\":{\"title\":\"js 使用postMessage iframe跨域通信\",\"date\":\"2024-03-30 15:21:11\",\"permalink\":\"/pages/d67bac/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"js 使用postMessage iframe跨域通信\",\"date\":\"2024-03-30 15:21:11\",\"capture\":\"在 Web 应用程序中，由于同源策略的限制，如果我们需要在一个页面中嵌入来自不同域的资源（例如图片、脚本或 iframe），那么就会出现跨域问题。在这种情况下，我们需要使用一些技术来实现跨域通信。\\r\\n\\r\\n其中一种解决方案是使用 HTML5 中引入的 postMessage API。postMessage 允许我们在不同窗口或 iframe 之间发送消息，这使得我们可以实现跨域通信，而不违反同源策略。\\r\\n\\r\\n postMessage 简介\\r\\n\\r\\npostMessage 是 HTML5 中引入的一种跨窗口通信机制。它允许我们在不同窗口之间发送消息，并且这些窗口可以来自不同的域。postMessag\"},{\"url\":\"/《uniapp》笔记/使用uniapp对接蓝牙设备.html\",\"relativePath\":\"/《uniapp》笔记/使用uniapp对接蓝牙设备.html\",\"frontmatter\":{\"title\":\"使用uniapp对接蓝牙设备\",\"date\":\"2024-03-30 15:20:23\",\"permalink\":\"/pages/35c361/\",\"categories\":[\"《uniapp》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"使用uniapp对接蓝牙设备\",\"date\":\"2024-03-30 15:20:23\",\"capture\":\"低功耗蓝牙 API 平台差异说明\\r\\n\\r\\n| App | H5  | 微信小程序 | 支付宝小程序 | 百度小程序 | 字节跳动小程序 | 飞书小程序 | QQ 小程序 | 快手小程序 | 京东小程序 |\\r\\n| :-: | :-: | :--------: | :----------: | :--------: | :------------: | :--------: | :-------: | :--------: | :--------: |\\r\\n|  √  |  x  |     √      |      √       |     x      |       x        |  \"}],\"2023 \":[{\"url\":\"/《Vue》笔记/99.其他/79.Vue中编辑word文档以及预览word .html\",\"relativePath\":\"/《Vue》笔记/99.其他/79.Vue中编辑word文档以及预览word .html\",\"frontmatter\":{\"title\":\"Vue中编辑word文档以及预览word\",\"date\":\"2023-09-13 10:25:00\",\"permalink\":\"/pages/1ebccd/\",\"categories\":[\"《Vue》笔记\",\"其他\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Vue中编辑word文档以及预览word\",\"date\":\"2023-09-13 10:25:00\",\"capture\":\"首先通过XMLHttpRequest发送一个GET请求到指定的URL，获取Word文件的内容并将其转换为HTML格式。其中使用mammoth库的convertToHtml方法将二进制数组转换为HTML格式的文本。（mammoth我用了一个修改版本样式还原度要比官方好@shy1118/mammoth）编辑用到的是ckeditor5富文本编辑器,最后通过html-docx-js将html转换为docx在进行保存**\\n 安装主要依赖\\n```bash\\nnpm install --save @ckeditor/ckeditor5-build-decoupled-document @shy1118/mam\"},{\"url\":\"/《Electron》笔记/02.electron下使用puppeteer模拟用户操作,数据获取.html\",\"relativePath\":\"/《Electron》笔记/02.electron下使用puppeteer模拟用户操作,数据获取.html\",\"frontmatter\":{\"title\":\"electron下使用puppeteer模拟用户操作,数据获取\",\"date\":\"2023-09-09 15:15:18\",\"permalink\":\"/pages/56ebf1/\",\"categories\":[\"《Electron》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"electron下使用puppeteer模拟用户操作,数据获取\",\"date\":\"2023-09-09 15:15:18\",\"capture\":\"Puppeteer是一个由Google开发的Node.js库，它提供了一组用于控制和自动化Chrome或Chromium浏览器的API。它可以用于执行各种与浏览器相关的任务，如网页截图、生成PDF、模拟用户交互、爬取网页数据等。Puppeteer通过WebSocket连接与浏览器建立通信，并通过DevTools协议发送命令和接收浏览器的响应。\\n什么是 Chrome DevTool Protocol\\n- CDP 基于 WebSocket，利用 WebSocket 实现与浏览器内核的快速数据通道\\n- CDP 分为多个域（DOM，Debugger，Network，Profiler，Console..\"},{\"url\":\"/《Electron》笔记/01.electron记录.html\",\"relativePath\":\"/《Electron》笔记/01.electron记录.html\",\"frontmatter\":{\"title\":\"electron记录\",\"date\":\"2023-09-09 14:23:20\",\"permalink\":\"/pages/8e9a16/\",\"categories\":[\"《Electron》笔记\"],\"tags\":[\"electron\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"electron记录\",\"date\":\"2023-09-09 14:23:20\",\"capture\":\"事件周期\\n electron常用事件统计\\n主进程常用事件可以分为以下几类：\\n1. 应用程序生命周期事件：\\n    - `ready`: 当 Electron 应用程序初始化完成且准备好显示窗口时触发。\\n    - `window-all-closed`: 当所有窗口都关闭后触发，在 macOS 上通常不会退出应用程序。\\n    - `activate`: 在 macOS 上，当用户点击应用程序的 Dock 图标并且没有其他窗口打开时触发，用于重新创建新窗口。\\n2. 窗口相关事件：\\n    - `closed`: 窗口关闭时触发。\\n    - `dom-ready`: 窗口加载完毕并且 DOM \"},{\"url\":\"/《JavaScript教程》笔记/08.事件循环(evenloop).html\",\"relativePath\":\"/《JavaScript教程》笔记/08.事件循环(evenloop).html\",\"frontmatter\":{\"title\":\"事件循环(evenloop)\",\"date\":\"2023-09-08 16:20:58\",\"permalink\":\"/pages/eaf565/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"事件循环(evenloop)\",\"date\":\"2023-09-08 16:20:58\",\"capture\":\"JavaScript 是一门单线程的语言，它的异步和多线程的实现是通过 Event Loop 事件循环机制来实现的\\nEvent Loop 的机制\\n大体三个部分组成\\n1、调用栈 Stack\\n2、消息队列 Message Queue\\n3、微任务队列 Microtask Queue\\n Event Loop 开始的时候会从全局栈开始逐行执行，遇到函数调用，会把函数压入到调用栈中，当函数返回后，会从调用栈中弹出\\n```javascript\\nfunction func1(){\\n    console.log(1);\\n }\\n function func2(){\\n    console.log(2);\\n   \"},{\"url\":\"/《ES6 教程》笔记/35.了解ES6中的Map和Set.html\",\"relativePath\":\"/《ES6 教程》笔记/35.了解ES6中的Map和Set.html\",\"frontmatter\":{\"title\":\"了解ES6中的Map和Set\",\"date\":\"2023-09-08 16:10:10\",\"permalink\":\"/pages/bfde72/\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"了解ES6中的Map和Set\",\"date\":\"2023-09-08 16:10:10\",\"capture\":\"Map对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。构造函数Map可以接受一个数组作为参数。\\nMap对象的方法\\nset(key, val): 向Map中添加新元素\\nget(key): 通过键值查找特定的数值并返回\\nhas(key): 判断Map对象中是否有Key所对应的值，有返回true,否则返回false\\ndelete(key): 通过键值从Map中移除对应的数据\\nclear(): 将这个Map中的所有元素删除\\n```jsx\\nconst m1 = new Map([['a', 111], ['b', 222]])\\nconsole.log(m1) // {\\\"a\\\" =\\nm1\"},{\"url\":\"/《Vue》笔记/99.其他/91.vue2与vue3生命周期对照表.html\",\"relativePath\":\"/《Vue》笔记/99.其他/91.vue2与vue3生命周期对照表.html\",\"frontmatter\":{\"title\":\"vue2与vue3生命周期对照表\",\"date\":\"2023-09-08 14:57:40\",\"permalink\":\"/pages/e866b9/\",\"categories\":[\"《Vue》笔记\",\"其他\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"vue2与vue3生命周期对照表\",\"date\":\"2023-09-08 14:57:40\",\"capture\":\"\"},{\"url\":\"/01.前端/25.JavaScript文章/15.js实现深度优先遍历和广度优先遍历.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/15.js实现深度优先遍历和广度优先遍历.html\",\"frontmatter\":{\"title\":\"js实现深度优先遍历和广度优先遍历\",\"date\":\"2023-09-08 14:16:56\",\"permalink\":\"/pages/690414/\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"js实现深度优先遍历和广度优先遍历\",\"date\":\"2023-09-08 14:16:56\",\"capture\":\"什么是深度优先和广度优先\\n深度优先遍历用的是栈，而广度优先遍历要用队列来实现,深度优先就是自上而下的遍历搜索 广度优先则是逐层遍历, 如下图所示(图左深度优先遍历,图右广度)\\n 深度优先遍历\\n 广度优先遍历\\n 两者的区别\\n对于算法来说 无非就是时间换空间 空间换时间\\n1. 深度优先不需要记住所有的节点, 所以占用空间小, 而广度优先需要先记录所有的节点占用空间大\\n2. 深度优先有回溯的操作(没有路走了需要回头)所以相对而言时间会长一点\\n深度优先采用的是堆栈的形式, 即先进后出\\n广度优先则采用的是队列的形式, 即先进先出\\n```jsx\\nconst data = [\\n  {\\n      name:\"},{\"url\":\"/01.前端/25.JavaScript文章/14.js获取当前URL,域名,端口号.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/14.js获取当前URL,域名,端口号.html\",\"frontmatter\":{\"title\":\"js获取当前URL,域名,端口号\",\"date\":\"2023-09-08 13:57:22\",\"permalink\":\"/pages/c81259/\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"js获取当前URL,域名,端口号\",\"date\":\"2023-09-08 13:57:22\",\"capture\":\"| href | 完整的 URL | https://www.baidu.com:200/s?wd=1 |\\n| --- | --- | --- |\\n| protocol | 协议 | https: |\\n| hostname | 主机名 | www.baidu.com |\\n| port | 端口号 | 200 |\\n| host | 主机名+端口号 | www.baidu.com:200 |\\n```javascript\\nlet protocol = window.location.protocol,host = window.location.host;\\nlet url = `${protocol\"},{\"url\":\"/01.前端/25.JavaScript文章/13.javascript常用类型数值比较图.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/13.javascript常用类型数值比较图.html\",\"frontmatter\":{\"title\":\"javascript常用类型数值比较图\",\"date\":\"2023-09-08 13:34:43\",\"permalink\":\"/pages/360851/\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"javascript常用类型数值比较图\",\"date\":\"2023-09-08 13:34:43\",\"capture\":\"\"},{\"url\":\"/02.页面/20.CSS/16.css calc()使用.html\",\"relativePath\":\"/02.页面/20.CSS/16.css calc()使用.html\",\"frontmatter\":{\"title\":\"css calc()使用\",\"date\":\"2023-09-08 11:40:43\",\"permalink\":\"/pages/2ecc26/\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"css calc()使用\",\"date\":\"2023-09-08 11:40:43\",\"capture\":\"1.什么是 CSS calc() 函数？\\ncalc() 函数允许在指定 CSS 属性值时执行计算。它对于计算 length、 percentage、 time、 numbers、integers、frequencies 和 angles 等特别有用。 CSS calc() 函数的一个强大功能是能够组合不同的单位。这个函数可以执行预处理器不能执行的数学计算。\\nCSS 中的预处理器只能组合具有固定关系的单位，如角度单位、时间单位、频率单位、分辨率单位和特定长度单位。\\ncalc( Expression)\\ncalc() 函数接受一个表达式作为参数。然后将表达式的结果用作值。它可以采用任何形式并使用以下\"},{\"url\":\"/04.更多/99.友情链接.html\",\"relativePath\":\"/04.更多/99.友情链接.html\",\"frontmatter\":{\"title\":\"友情链接\",\"date\":\"2023-08-29 15:43:33\",\"permalink\":\"/pages/1bf946/\",\"categories\":[\"更多\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"友情链接\",\"date\":\"2023-08-29 15:43:33\",\"capture\":\"\"},{\"url\":\"/\",\"relativePath\":\"/\",\"frontmatter\":{\"layout\":\"page\",\"title\":\"首页\"},\"title\":\"首页\",\"date\":\"2023-08-29 07:43:33\",\"capture\":\"&lt;HomePage /\"}],\"2022 \":[{\"url\":\"/03.技术/01.技术文档/20.Git修改分支名.html\",\"relativePath\":\"/03.技术/01.技术文档/20.Git修改分支名.html\",\"frontmatter\":{\"title\":\"Git修改分支名\",\"date\":\"2022-08-11 10:51:18\",\"permalink\":\"/pages/922650/\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git修改分支名\",\"date\":\"2022-08-11 10:51:18\",\"capture\":\"同时修改本地分支名和对应的远程分支名\\n修改前要确保本地分支的代码是最新的，并且修改后不会影响到同事的代码。\\n1. 修改本地分支名\\n```sh\\ngit branch -m oldBranchName newBranchName\\n```\\n2. 删除远程分支\\n```sh\\ngit push origin :oldBranchName\\n 或者 git push origin --delete oldBranchName\\n```\\n3. 改名后的本地分支推送到远程\\n```sh\\ngit push --set-upstream origin newBranchName\\n```\"},{\"url\":\"/02.页面/20.CSS/15.CSS给table的tbody添加滚动条.html\",\"relativePath\":\"/02.页面/20.CSS/15.CSS给table的tbody添加滚动条.html\",\"frontmatter\":{\"title\":\"CSS给table的tbody添加滚动条\",\"date\":\"2022-06-29 09:34:23\",\"permalink\":\"/pages/55f894/\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"CSS给table的tbody添加滚动条\",\"date\":\"2022-06-29 09:34:23\",\"capture\":\"```css\\ntable tbody {\\n  height: 200px;\\n  overflow-y: auto;\\n  display: block;\\n}\\ntable thead,\\ntbody tr {\\n  display: table;\\n  width: 100%;\\n}\\n```\"}],\"2021 \":[{\"url\":\"/01.前端/25.JavaScript文章/01.33个非常实用的JavaScript一行代码.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/01.33个非常实用的JavaScript一行代码.html\",\"frontmatter\":{\"title\":\"33个非常实用的JavaScript一行代码\",\"date\":\"2021-11-02 09:51:37\",\"permalink\":\"/pages/a61298/\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[\"JavaScript\"],\"author\":\"CUGGZ\"},\"author\":\"CUGGZ\",\"title\":\"33个非常实用的JavaScript一行代码\",\"date\":\"2021-11-02 09:51:37\",\"capture\":\"一、日期处理\\n 1. 检察日期是否有效\\n该方法用于检测给出的日期是否有效：\\n```javascript\\nconst isDateValid = (...val) =\\nisDateValid(\\\"December 17, 1995 03:24:00\\\");  // true\\n复制代码\\n```\\n 2. 计算两个日期之间的间隔\\n该方法用于计算两个日期之间的间隔时间：\\n```javascript\\nconst dayDif = (date1, date2) =&gt; Math.ceil(Math.abs(date1.getTime() - date2.getTime()) / 86400000)\\ndayD\"},{\"url\":\"/01.前端/40.学习笔记/50.JS设计模式总结笔记.html\",\"relativePath\":\"/01.前端/40.学习笔记/50.JS设计模式总结笔记.html\",\"frontmatter\":{\"title\":\"JS设计模式总结笔记\",\"date\":\"2021-02-27 20:01:18\",\"permalink\":\"/pages/4643cd/\",\"categories\":[\"前端\",\"学习笔记\"],\"tags\":[\"设计模式\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"JS设计模式总结笔记\",\"date\":\"2021-02-27 20:01:18\",\"capture\":\"开篇：前端工程师的成长论\\n能够决定一个前端工程师的本质的，不是那些瞬息万变的技术点，而是那些不变的东西。\\n所谓“不变的东西”，就是驾驭技术的能力。\\n具体来说，它分为以下三个层次：\\n- 能用健壮的代码去解决具体的问题；\\n- 能用抽象的思维去应对复杂的系统；\\n- 能用工程化的思想去规划更大规模的业务。\\n\\n 设计模式之“道”\\n- 设计模式是“拿来主义”。如使用数学公式，不会从头推导一个公式。\\n  核心思想\\n- 设计模式的核心思想——封装变化\\n- 保证可维护性、可扩展性。\\n- 将变与不变分离，确保变化的部分灵活，不变的部分稳定。——这就是所谓的“健壮”的代码。\\n 设计模式之“术”\\n即最经典的23种设计\"}],\"2020 \":[{\"url\":\"/01.前端/25.JavaScript文章/1110.三级目录/00.四级文件.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/1110.三级目录/00.四级文件.html\",\"frontmatter\":{\"title\":\"四级文件(测试)\",\"date\":\"2020-12-11 11:15:53\",\"permalink\":\"/pages/8481d1/\",\"categories\":[\"前端\",\"JavaScript文章\",\"三级目录\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"四级文件(测试)\",\"date\":\"2020-12-11 11:15:53\",\"capture\":\"测试文件\\nTest Test\\n&lt;code-group\\n  &lt;code-block title=\\\"YARN\\\" active&gt;\\n  ```bash\\n  yarn create vuepress-site [optionalDirectoryName]\\n   OR npx create-vuepress-site [optionalDirectoryName]\\n  ```\\n  &lt;/code-block&gt;\\n  &lt;code-block title=\\\"NPM\\\"&gt;\\n  ```bash\\n  npx create-vuepress-site [optionalDirec\"},{\"url\":\"/《Git》学习笔记/10.手册/00.常用Git命令清单.html\",\"relativePath\":\"/《Git》学习笔记/10.手册/00.常用Git命令清单.html\",\"frontmatter\":{\"title\":\"常用Git命令清单\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/8292d8/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"常用Git命令清单\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。\\n下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。\\n\\n&gt; - Index / Stage：暂存区\\n&gt; - Repository：仓库区（或本地仓库）\\n&gt; - Remote：远程仓库\\n 一、新建代码库\\n```bash\\n 在当前目录新建一个Git代码库\\n$ git init\\n 新建一个目录，将其初始化为Git代码库\\n$ git init [project-name]\\n 下载一个项目和它的整个代码历史\\n$ git clone [url]\\n```\\n 二、配置\\nGit的设置文件为\"},{\"url\":\"/《Git》学习笔记/10.手册/01.Git变基合并.html\",\"relativePath\":\"/《Git》学习笔记/10.手册/01.Git变基合并.html\",\"frontmatter\":{\"title\":\"Git变基合并\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/c10281/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git变基合并\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"说明\\n以下 `v2` 是某个需求的开发分支， `dev`是总的开发分支，`v2` 是基于`dev`分支签出的。\\n当完成`v2`的开发后，需要把代码合并到`dev`，我们可以使用`rebase`进行合并：\\n```sh\\n 首先将 v2 push到远程仓库\\ngit add .\\ngit commit -m 'xxx'\\ngit push origin v2\\n 切换到 dev 拉取最新代码\\ngit checkout dev\\ngit pull origin dev\\n 切换到 v2\\ngit checkout v2\\ngit rebase dev  将 v2 的所有[commit] 变基到(应用到) dev\\n 切\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/10.Git基础与命令.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/10.Git基础与命令.html\",\"frontmatter\":{\"title\":\"Git基础与命令\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/635088/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git基础与命令\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"官方文档（中文）：https://git-scm.com/book/zh/v2\\n\\n Git基础\\n 全局配置\\n```bash\\ngit config --global user.name 'your name'\\ngit config --global user.email 'xxx@xx.com'\\n```\\n自报家门\\n 检查配置信息\\n```sh\\ngit config --list\\n```\\n 获取帮助\\n```sh\\n 获取全局帮助手册\\ngit help\\n 获取特定命令的详细版帮助手册 (两个命令是等价的)\\ngit help &lt;某个命令&gt;\\ngit &lt;某个命令&gt; --help  两个\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/100.Git工具-重写历史.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/100.Git工具-重写历史.html\",\"frontmatter\":{\"title\":\"Git工具-重写历史\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/1832fe/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git工具-重写历史\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"许多时候，在使用 Git 时，你可能想要修订提交历史。 Git 很棒的一点是它允许你在最后时刻做决定。 你可以在将暂存区内容提交前决定哪些文件进入提交，可以通过 `git stash` 来决定不与某些内容工作， 也可以重写已经发生的提交就像它们以另一种方式发生的一样。 这可能涉及改变提交的顺序，改变提交中的信息或修改文件，将提交压缩或是拆分， 或完全地移除提交——在将你的工作成果与他人共享之前。\\n在本节中，你可以学到如何完成这些工作，这样在与他人分享你的工作成果时你的提交历史将如你所愿地展示出来。\\n| Note | 在满意之前不要推送你的工作Git 的基本原则之一是，由于克隆中有很多工作是本地\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/110.Git工具-重置揭密.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/110.Git工具-重置揭密.html\",\"frontmatter\":{\"title\":\"Git工具-重置揭密\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/d9e9c6/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git工具-重置揭密\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"在继续了解更专业的工具前，我们先探讨一下 Git 的 `reset` 和 `checkout` 命令。 在初遇的 Git 命令中，这两个是最让人困惑的。 它们能做很多事情，所以看起来我们很难真正地理解并恰当地运用它们。 针对这一点，我们先来做一个简单的比喻。\\n 三棵树\\n理解 `reset` 和 `checkout` 的最简方法，就是以 Git 的思维框架（将其作为内容管理器）来管理三棵不同的树。 “树” 在我们这里的实际意思是 “文件的集合”，而不是指特定的数据结构。 （在某些情况下索引看起来并不像一棵树，不过我们现在的目的是用简单的方式思考它。）\\nGit 作为一个系统，是以它的一般操作来管理\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/20.Git分支-分支原理.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/20.Git分支-分支原理.html\",\"frontmatter\":{\"title\":\"Git分支-分支原理\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/4bef1a/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支-分支原理\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。\\n 首次提交\\n在进行提交操作时，Git 会保存一个提交对象（commit object）。\\n假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 暂存操作会为每一个文件计算校验和（使用 SHA-1 哈希算法），然后会把当前版本的文件快照保存到 Git 仓库中 （Git 使用 *blob* 对象来保存它们），最终将校验和加入到暂存区域等待提交：\\n```sh\\n$ git\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/30.Git分支的新建与合并-分支操作.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/30.Git分支的新建与合并-分支操作.html\",\"frontmatter\":{\"title\":\"Git分支的新建与合并-分支操作\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/ea5a8c/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支的新建与合并-分支操作\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"文档：Git 分支 - 分支的新建与合并\\n 创建分支并切换\\n此时有一个需求需要在新的分支`iss53`上工作：\\n```sh\\n$ git checkout -b iss53   b表示branch\\n```\\n它是下面两条命令的简写：\\n```sh\\n$ git branch iss53\\n$ git checkout iss53\\n```\\n 切换分支\\n突然有一个紧急问题要解决，需要在原来的`master`分支进行修复：\\n```sh\\n$ git checkout master\\n```\\n在切换到`master`之前，需要`iss53`分支保持好一个干净的状态（修改都已提交）。\\n注意：切换分支Git 会重置你的\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/40.Git分支管理-查看分支.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/40.Git分支管理-查看分支.html\",\"frontmatter\":{\"title\":\"Git分支管理-查看分支\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/a399b3/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支管理-查看分支\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"查看分支\\n```sh\\n$ git branch\\n  iss53\\n* master   带星号*表示当前所在分支\\n  testing\\n```\\n`git branch` 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表。\\n 查看每个分支的最后提交\\n```sh\\n$ git branch -v\\n  iss53   93b412c fix javascript issue\\n* master  7a98805 Merge branch 'iss53'\\n  testing 782fd34 test\\n```\\n 查看已(未)合并的分支\\n`--merged` 与 `--no-m\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/50.Git分支开发工作流.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/50.Git分支开发工作流.html\",\"frontmatter\":{\"title\":\"Git分支开发工作流\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/49ee30/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支开发工作流\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"文档：Git分支开发工作流\\n 长期分支\\n因为 Git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。 也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些主题分支合并入其他分支中。\\n许多使用 Git 的开发者都喜欢使用这种方式来工作，比如只在 `master` 分支上保留完全稳定的代码，开发过程在`dev`分支，开发完成后并入`test`分支进行测试，通过测试的稳定代码才并入`master`分支中。\\n`dev`和`test`分支不需要保持绝对稳定，但在`test`通过测试达到稳定状态，就可以被合并入`mast\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/60.Git分支-远程分支.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/60.Git分支-远程分支.html\",\"frontmatter\":{\"title\":\"Git分支-远程分支\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/574d62/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支-远程分支\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"远程引用是对远程仓库的引用（指针），包括分支、标签等等。\\n\\n 查看远程引用列表与信息\\n```sh\\ngit ls-remote &lt;remote&gt;  远程引用的完整列表\\ngit remote show &lt;remote&gt;  远程分支的更多信息\\n```\\n上面两行命令比较少用，更常见的做法是利用远程跟踪分支。\\n 远程跟踪分支\\n远程跟踪分支是远程分支状态的引用。它们是你无法移动的本地引用。一旦你进行了网络通信， Git 就会为你移动它们以精确反映远程仓库的状态。请将它们看做书签， 这样可以提醒你该分支在远程仓库中的位置就是你最后一次连接到它们的位置。\\n它们以 `&lt;remote\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/70.Git分支-变基.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/70.Git分支-变基.html\",\"frontmatter\":{\"title\":\"Git分支-变基\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/3a3247/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支-变基\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"在 Git 中整合来自不同分支的修改主要有两种方法：`merge` 以及 `rebase`。 在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。\\n 变基的基本操作\\n请回顾之前在 分支的合并 中的一个例子，你会看到开发任务分叉到两个不同分支，又各自提交了更新。\\n&lt;p align=\\\"center\\\"\\n之前介绍过，整合分支最容易的方法是 `merge` 命令。 它会把两个分支的最新快照（`C3` 和 `C4`）以及二者最近的共同祖先（`C2`）进行三方合并，合并的结果是生成一个新的快照（并提交）。\\n &lt;p align=\\\"cen\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/80.Git工具-查看修订版本.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/80.Git工具-查看修订版本.html\",\"frontmatter\":{\"title\":\"Git工具-查看修订版本\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/c984d1/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git工具-查看修订版本\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"Git 能够以多种方式来指定单个提交、一组提交、或者一定范围内的提交。 了解它们并不是必需的，但是了解一下总没坏处。\\n修订版本指的是：提交\\n 单个修订版本\\n你可以通过任意一个提交的 40 个字符的完整 SHA-1 散列值来指定它， 不过还有很多更人性化的方式来做同样的事情。本节将会介绍获取单个提交的多种方法。\\n 简短的 SHA-1\\nGit 十分智能，你只需要提供 SHA-1 的前几个字符就可以获得对应的那次提交， 当然你提供的 SHA-1 字符数量不得少于 4 个，并且没有歧义——也就是说， 当前对象数据库中没有其它对象以这段 SHA-1 开头。\\n例如，要查看你知道其中添加了某个功能的提交，首\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/90.Git工具-交互式暂存.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/90.Git工具-交互式暂存.html\",\"frontmatter\":{\"title\":\"Git工具-交互式暂存\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/76d859/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git工具-交互式暂存\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"本节中的几个交互式 Git 命令可以帮助你将文件的特定部分组合成提交。 当你在修改了大量文件后，希望这些改动能拆分为若干提交而不是混杂在一起成为一个提交时，这几个工具会非常有用。 通过这种方式，可以确保提交是逻辑上独立的变更集，同时也会使其他开发者在与你工作时很容易地审核。 如果运行 `git add` 时使用 `-i` 或者 `--interactive` 选项，Git 将会进入一个交互式终端模式，显示类似下面的东西：\\n```sh\\n$ git add -i\\n           staged     unstaged path\\n  1:    unchanged        +0/-1 T\"},{\"url\":\"/01.前端/40.学习笔记/35.TypeScript笔记.html\",\"relativePath\":\"/01.前端/40.学习笔记/35.TypeScript笔记.html\",\"frontmatter\":{\"title\":\"TypeScript笔记\",\"date\":\"2020-10-08 13:02:48\",\"permalink\":\"/pages/51afd6/\",\"categories\":[\"前端\",\"学习笔记\"],\"tags\":[\"TypeScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"TypeScript笔记\",\"date\":\"2020-10-08 13:02:48\",\"capture\":\"TypeScript 的类型校验是给程序员看的，在编译后不会存在TS代码。\\n 类型注解\\n```typescript\\nfunction fn(person: string):void{ // 参数类型是字符串，没有返回值\\n    ///...\\n}\\nfn('str') // 如传递参数非字符串，vscode编辑器中或在编译时将给出错误提示\\nconst test:number = 1\\n```\\n 有哪些基础类型注解？\\n```typescript\\n// 基础类型\\n:string\\n:number\\n:boolean\\n:null  // 只能是null值\\n:undefined // 只能是undefined值\"},{\"url\":\"/02.页面/20.CSS/00.CSS教程和技巧收藏.html\",\"relativePath\":\"/02.页面/20.CSS/00.CSS教程和技巧收藏.html\",\"frontmatter\":{\"title\":\"CSS教程和技巧收藏\",\"date\":\"2020-08-11 17:13:52\",\"permalink\":\"/pages/c8f128/\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"CSS教程和技巧收藏\",\"date\":\"2020-08-11 17:13:52\",\"capture\":\"Flex 布局教程：语法篇\\n&lt;http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\\n CSS Grid 网格布局教程\\n&lt;http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html&gt;\\n 只要一行代码，实现五种 CSS 经典布局\\n&lt;http://www.ruanyifeng.com/blog/2020/08/five-css-layouts-in-one-line.html&gt;\\n* 空间居中布局\\n  &gt; 不管容器的大小，项目总是占据中心\"},{\"url\":\"/《Vue》笔记/10.Vuex/01.Vuex.html\",\"relativePath\":\"/《Vue》笔记/10.Vuex/01.Vuex.html\",\"frontmatter\":{\"title\":\"Vuex\",\"date\":\"2020-08-08 10:38:33\",\"permalink\":\"/pages/b30620/\",\"categories\":[\"《Vue》笔记\",\"Vuex\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Vuex\",\"date\":\"2020-08-08 10:38:33\",\"capture\":\"Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。\\n Vuex使用过程演示\\n以`vue-cli3`新创建出来的项目为例，演示Vuex的使用过程。\\n创建项目:\\n```sh\\nvue create vuex-test\\ncd vuex-test\\nnpm run serve\\n```\\n安装`vuex`:\\n```bash\\nnpm i vuex -S\\n```\\n进入项目的`src/`下新建一个文件`store/index.js`，并写入：\\n```js\\n// store/index.js\\nimport Vue from 'vue'\\nimport Vuex from 'vuex'\\nVue.use(Vu\"},{\"url\":\"/04.更多/01.学习/00.费曼学习法.html\",\"relativePath\":\"/04.更多/01.学习/00.费曼学习法.html\",\"frontmatter\":{\"title\":\"费曼学习法\",\"date\":\"2020-07-16 10:04:14\",\"permalink\":\"/pages/f2a556/\",\"categories\":[\"更多\",\"学习\"],\"tags\":[\"学习方法\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"费曼学习法\",\"date\":\"2020-07-16 10:04:14\",\"capture\":\"步骤\\n费曼学习法分为4个步骤:\\n1. 确定学习目标\\n你想学习的概念、内容、主题是什么。\\n2. 模拟教学学习法\\n你要模拟自己是一位老师，面对完全不懂这个领域的人，用自己的话，尽可能具体形象地讲诉。这样的讲诉有助于你活学活用，触类旁通，联系生活具体情境。\\n3. 回顾\\n反思第2步遇到的问题，哪些地方卡壳了，哪些地方对方没有真正听懂。找出问题的要害，把握关键环节。\\n4. 简化\\n把这些遇到问题的地方，重新梳理理解，尽可能了解更多背景和相关知识，再用尽可能简化的方式重新表达，设法看穿本质。然后，返回第2步。\\n\\n&gt; \\n&gt; 《费曼学习法：为何被称为史上最牛的学习法，它的本质究竟是什么？》\\n&gt;\"},{\"url\":\"/01.前端/40.学习笔记/05.《JavaScript高级程序设计》笔记.html\",\"relativePath\":\"/01.前端/40.学习笔记/05.《JavaScript高级程序设计》笔记.html\",\"frontmatter\":{\"title\":\"《JavaScript高级程序设计》笔记\",\"date\":\"2020-06-12 12:39:01\",\"permalink\":\"/note/js/\",\"categories\":[\"笔记\"],\"tags\":[\"笔记\",\"红宝书\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"《JavaScript高级程序设计》笔记\",\"date\":\"2020-06-12 12:39:01\",\"capture\":\"第1章  JavaScript简介\\n* JavaScript诞生于1995年\\n* 一个完整的JavaScript由这三部分组成：\\n  * ECMAScript (核心)\\n  * DOM (文档对象模型)\\n  * BOM (浏览器对象模型)\\n* ECMAScript的 宿主环境 包含 ：\\n  * 浏览器\\n  * Node\\n  * flash\\n* ECMAScript大致规定了下列组成部分：\\n  * 语法\\n  * 类型\\n  * 语句\\n  * 关键字\\n  * 保留字\\n  * 操作符\\n  * 对象\\n 第2章 在HTML中使用JavaScript\\n* `&lt;script\\n  * async 表示立即\"},{\"url\":\"/04.更多/01.学习/10.搜索引擎使用技巧.html\",\"relativePath\":\"/04.更多/01.学习/10.搜索引擎使用技巧.html\",\"frontmatter\":{\"title\":\"搜索引擎使用技巧\",\"date\":\"2020-05-24 11:44:19\",\"permalink\":\"/pages/ce818a\",\"categories\":[\"更多\",\"学习\"],\"tags\":[\"搜索技巧\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"搜索引擎使用技巧\",\"date\":\"2020-05-24 11:44:19\",\"capture\":\"搜索引擎相信大家经常在使用，但是有时候想搜某个信息时却搜出来一大堆不相关的（百度：你们都在看我干什么？）。下面我们来介绍几种搜索技巧，可以提升搜索效率，助你快速查资料，妈妈再也不担心我的学习了（'妈~我真的是在找学习资料'）\\n 技巧1：排除干扰项\\n方式：关键词1+空格+减号+关键词2，即 `关键词1 -关键词2`\\n功能：排除一些不想要的关键词\\n示例：\\n```\\n锤子 -锤子手机\\n```\\n示例中将在搜索结果排除与`锤子手机`相关的，只显示`锤子`本来的样子。\\n\\n 技巧2：精确搜索\\n方式：给关键词加双引号，`\\\"关键词\\\"`\\n功能：只搜索引号里的字，少一个字或者把字拆开都不行\\n示例：\\n```\\n\\\"达拉不崩\"},{\"url\":\"/02.页面/20.CSS/14.CSS-function汇总.html\",\"relativePath\":\"/02.页面/20.CSS/14.CSS-function汇总.html\",\"frontmatter\":{\"title\":\"CSS-function汇总\",\"date\":\"2020-05-12 09:36:44\",\"permalink\":\"/pages/3da0d7\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"CSS-function汇总\",\"date\":\"2020-05-12 09:36:44\",\"capture\":\"\"},{\"url\":\"/01.前端/25.JavaScript文章/12.比typeof运算符更准确的类型判断.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/12.比typeof运算符更准确的类型判断.html\",\"frontmatter\":{\"title\":\"比typeof运算符更准确的类型判断\",\"date\":\"2020-04-13 15:56:54\",\"permalink\":\"/pages/fd4a16d56b83c1bc\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"比typeof运算符更准确的类型判断\",\"date\":\"2020-04-13 15:56:54\",\"capture\":\"不同数据类型的`Object.prototype.toString`方法返回值如下。\\n- 数值：返回`[object Number]`。\\n- 字符串：返回`[object String]`。\\n- 布尔值：返回`[object Boolean]`。\\n- undefined：返回`[object Undefined]`。\\n- null：返回`[object Null]`。\\n- 数组：返回`[object Array]`。\\n- arguments 对象：返回`[object Arguments]`。\\n- 函数：返回`[object Function]`。\\n- Error 对象：返回`[object \"},{\"url\":\"/03.技术/01.技术文档/10.npm packageJson属性详解.html\",\"relativePath\":\"/03.技术/01.技术文档/10.npm packageJson属性详解.html\",\"frontmatter\":{\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"npm packageJson属性详解\",\"date\":\"2020-04-08 17:16:38\",\"permalink\":\"/pages/dec4f3f00e71a312\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null]},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"npm packageJson属性详解\",\"date\":\"2020-04-08 17:16:38\",\"excerpt\":\"<h1 id=\\\"npm-package-json属性详解\\\" tabindex=\\\"-1\\\">npm package.json属性详解 <a class=\\\"header-anchor\\\" href=\\\"#npm-package-json属性详解\\\" aria-label=\\\"Permalink to &quot;npm package.json属性详解&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<blockquote>\\n<p>本文转自<a href=\\\"https://www.cnblogs.com/tzyy/p/5193811.html\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">https://www.cnblogs.com/tzyy/p/5193811.html</a>，作者：TZYY</p>\\n</blockquote>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p><code>package.json</code>必须是一个严格的json文件，而不仅仅是js里边的一个对象。其中很多属性可以通过<code>npm-config</code>来生成</p>\\n\",\"capture\":\"npm package.json属性详解\\n\\n 概述\\n`package.json`必须是一个严格的json文件，而不仅仅是js里边的一个对象。其中很多属性可以通过`npm-config`来生成\\n name\\n`package.json`中最重要的属性是`name`和`version`两个属性，这两个属性是必须要有的，否则模块就无法被安装，这两个属性一起形成了一个npm模块的唯一标识符。模块中内容变更的同时，模块版本也应该一起变化。\\n`name`属性就是你的模块名称，下面是一些命名规则:\\n- `name`必须小于等于214个字节，包括前缀名称在内（如 xxx/xxxmodule）。\\n- `name`\"},{\"url\":\"/02.页面/20.CSS/13.如何根据系统主题自动响应CSS深色模式.html\",\"relativePath\":\"/02.页面/20.CSS/13.如何根据系统主题自动响应CSS深色模式.html\",\"frontmatter\":{\"title\":\"如何根据系统主题自动响应CSS深色模式\",\"date\":\"2020-03-31 14:06:26\",\"permalink\":\"/pages/5dde351274f1e39d\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[\"css\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"如何根据系统主题自动响应CSS深色模式\",\"date\":\"2020-03-31 14:06:26\",\"excerpt\":\"<h1 id=\\\"如何根据系统主题自动响应css深色模式\\\" tabindex=\\\"-1\\\">如何根据系统主题自动响应CSS深色模式 <a class=\\\"header-anchor\\\" href=\\\"#如何根据系统主题自动响应css深色模式\\\" aria-label=\\\"Permalink to &quot;如何根据系统主题自动响应CSS深色模式&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p align=\\\"center\\\">\\n  <img src=\\\"https://cdn.staticaly.com/gh/xugaoyi/image_store/blog/20200427163531.jpg\\\" width=\\\"500\\\">\\n</p>\\n<p>很多人喜欢选择APP或网站中的深色模式，也许他们更喜欢这样的外观，或者他们想让自己的眼睛免受疲劳。这篇文章将告诉你如何在网站中实现一个自动的CSS深色模式，根据访客的系统主题来自动响应。</p>\\n\",\"capture\":\"如何根据系统主题自动响应CSS深色模式\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"https://cdn.staticaly.com/gh/xugaoyi/image_store/blog/20200427163531.jpg\\\" width=\\\"500\\\"&gt;\\n&lt;/p&gt;\\n很多人喜欢选择APP或网站中的深色模式，也许他们更喜欢这样的外观，或者他们想让自己的眼睛免受疲劳。这篇文章将告诉你如何在网站中实现一个自动的CSS深色模式，根据访客的系统主题来自动响应。\\n CSS 深色模式 (Dark Mode)\\n在`:root`根元素中定义变量来设置主题的颜色。我建\"},{\"url\":\"/02.页面/20.CSS/12.水平垂直居中的几种方式-案例.html\",\"relativePath\":\"/02.页面/20.CSS/12.水平垂直居中的几种方式-案例.html\",\"frontmatter\":{\"title\":\"水平垂直居中的几种方式-案例\",\"date\":\"2020-03-13 16:13:43\",\"permalink\":\"/pages/cb7cb251adba4bf7\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"水平垂直居中的几种方式-案例\",\"date\":\"2020-03-13 16:13:43\",\"capture\":\"&lt;iframe height=\\\"880\\\" style=\\\"width: 100%;\\\" scrolling=\\\"no\\\" title=\\\"水平垂直居中的几种方式\\\" src=\\\"https://codepen.io/xugaoyi/embed/poJLeYv?height=880&theme-id=light&default-tab=result\\\" frameborder=\\\"no\\\" allowtransparency=\\\"true\\\" allowfullscreen=\\\"true\\\"\\n  See the Pen &lt;a href='https://codepen.io/xugaoyi/pen/poJLeY\"},{\"url\":\"/01.前端/25.JavaScript文章/11.JS获取和修改url参数.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/11.JS获取和修改url参数.html\",\"frontmatter\":{\"title\":\"JS获取和修改url参数\",\"date\":\"2020-03-05 12:45:37\",\"permalink\":\"/pages/7a91be2d502346ce\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"JS获取和修改url参数\",\"date\":\"2020-03-05 12:45:37\",\"capture\":\"获取url参数\\n```js\\n/**\\n * 获取url里的参数\\n * @param arg 参数名\\n * @returns\\n */\\nfunction getURLString(arg) {\\n    var reg = new RegExp(\\\"(^|&)\\\" + arg + \\\"=([^&]*)(&|$)\\\", \\\"i\\\");\\n    var r = window.location.search.substr(1).match(reg);\\n    if (r != null)\\n        return unescape(r[2]);\\n    return null;\\n}\\n```\\n 修改url参数\\n```\"},{\"url\":\"/01.前端/25.JavaScript文章/10.防抖与节流函数.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/10.防抖与节流函数.html\",\"frontmatter\":{\"title\":\"防抖与节流函数\",\"date\":\"2020-02-29 15:07:47\",\"permalink\":\"/pages/0f6a0ac99b62ede5\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"防抖与节流函数\",\"date\":\"2020-02-29 15:07:47\",\"excerpt\":\"<h1 id=\\\"防抖与节流函数\\\" tabindex=\\\"-1\\\">防抖与节流函数 <a class=\\\"header-anchor\\\" href=\\\"#防抖与节流函数\\\" aria-label=\\\"Permalink to &quot;防抖与节流函数&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>防抖和节流的作用都是在高频事件中防止函数被多次调用，是一种性能优化的方案。</p>\\n<p>区别在于，防抖函数只会在高频事件结束后n毫秒调用一次函数，节流函数会在高频事件触发过程当中每隔n毫秒调用一次函数。</p>\\n\",\"capture\":\"防抖和节流的作用都是在高频事件中防止函数被多次调用，是一种性能优化的方案。\\n区别在于，防抖函数只会在高频事件结束后n毫秒调用一次函数，节流函数会在高频事件触发过程当中每隔n毫秒调用一次函数。\\n 防抖函数\\n触发高频事件后一段时间（wait）只会执行一次函数，如果指定时间（wait）内高频事件再次被触发，则重新计算时间。\\n 封装\\n```js\\n// 防抖函数\\nfunction debounce(func, wait) {\\n    let timeout = null;\\n    return function () {\\n        let context = this;\\n        let a\"},{\"url\":\"/02.页面/20.CSS/11.从box-sizing属性入手，了解盒子模型.html\",\"relativePath\":\"/02.页面/20.CSS/11.从box-sizing属性入手，了解盒子模型.html\",\"frontmatter\":{\"title\":\"从box-sizing属性入手，了解盒子模型\",\"date\":\"2020-02-27 17:08:48\",\"permalink\":\"/pages/20a978023139589d\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"从box-sizing属性入手，了解盒子模型\",\"date\":\"2020-02-27 17:08:48\",\"excerpt\":\"<h1 id=\\\"从box-sizing属性入手-了解盒子模型\\\" tabindex=\\\"-1\\\">从box-sizing属性入手，了解盒子模型 <a class=\\\"header-anchor\\\" href=\\\"#从box-sizing属性入手-了解盒子模型\\\" aria-label=\\\"Permalink to &quot;从box-sizing属性入手，了解盒子模型&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"背景\\\" tabindex=\\\"-1\\\">背景 <a class=\\\"header-anchor\\\" href=\\\"#背景\\\" aria-label=\\\"Permalink to &quot;背景&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>先声明一下运用的场景，假如项目布局使用的是<strong>自适应</strong>的布局方式，div给出的宽度是<strong>百分比</strong>的形式，即占窗口宽度的100%，但边框<code>border</code>和内边距<code>padding</code>是用像素来表示的，此时就会造成一个问题是div总宽度超过窗口宽度。为了避免这种问题，可以使用属性<code>box-sizing:border-box</code>来把 <strong>标准盒模型</strong> 变成 <strong>代替(IE)盒模型</strong> ，从而使div的总宽度依然是100%</p>\\n\",\"capture\":\"背景\\n先声明一下运用的场景，假如项目布局使用的是自适应的布局方式，div给出的宽度是百分比的形式，即占窗口宽度的100%，但边框`border`和内边距`padding`是用像素来表示的，此时就会造成一个问题是div总宽度超过窗口宽度。为了避免这种问题，可以使用属性`box-sizing:border-box`来把 标准盒模型 变成 代替(IE)盒模型 ，从而使div的总宽度依然是100%\\n 什么是CSS 盒模型?\\n页面布局中，一个元素的外边距（margin）、 边框（border）、内边距（padding）、内容（content）组成一个盒模型。盒模型可分为标准盒模型 和 代替（IE）盒模型\"},{\"url\":\"/02.页面/20.CSS/10.文字在一行或多行时超出显示省略号.html\",\"relativePath\":\"/02.页面/20.CSS/10.文字在一行或多行时超出显示省略号.html\",\"frontmatter\":{\"title\":\"文字在一行或多行时超出显示省略号\",\"date\":\"2020-02-23 15:07:08\",\"permalink\":\"/pages/42b66999cc27dc25\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"文字在一行或多行时超出显示省略号\",\"date\":\"2020-02-23 15:07:08\",\"excerpt\":\"<h1 id=\\\"文字在一行或多行时超出显示省略号\\\" tabindex=\\\"-1\\\">文字在一行或多行时超出显示省略号 <a class=\\\"header-anchor\\\" href=\\\"#文字在一行或多行时超出显示省略号\\\" aria-label=\\\"Permalink to &quot;文字在一行或多行时超出显示省略号&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"一行超出显示省略\\\" tabindex=\\\"-1\\\">一行超出显示省略 <a class=\\\"header-anchor\\\" href=\\\"#一行超出显示省略\\\" aria-label=\\\"Permalink to &quot;一行超出显示省略&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<div class=\\\"language-css vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">css</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">overflow: hidden;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">white-space</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">: nowrap;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">text-overflow</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">: ellipsis;</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br></div></div>\",\"capture\":\"一行超出显示省略\\n```css\\noverflow: hidden;\\nwhite-space: nowrap;\\ntext-overflow: ellipsis;\\n```\\n```html\\n&lt;html\\n   &lt;div class=\\\"box-42b6\\\"&gt;演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字&lt;/div&gt;\\n&lt;/html&gt;\\n&lt;style&gt;\\n    .box-42b6{\\n        border: 1px solid 999;\\n        width\"},{\"url\":\"/01.前端/25.JavaScript文章/09.将一维数组按指定长度转为二维数组.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/09.将一维数组按指定长度转为二维数组.html\",\"frontmatter\":{\"title\":\"将一维数组按指定长度转为二维数组\",\"date\":\"2020-02-23 13:49:31\",\"permalink\":\"/pages/f1acb712033ac8da\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"将一维数组按指定长度转为二维数组\",\"date\":\"2020-02-23 13:49:31\",\"capture\":\"将一维数组按指定长度转为二维数组\\n```js\\nfunction pages(arr, len) {\\n    const pages = []\\n    arr.forEach((item, index) =\\n        const page = Math.floor(index / len)\\n        if (!pages[page]) {\\n            pages[page] = []\\n        }\\n        pages[page].push(item)\\n    })\\n    return pages\\n}\\n// 使用\\nconst arr = [1, 2, 3, \"},{\"url\":\"/02.页面/20.CSS/09.「布局技巧」图片未加载前自动撑开元素高度.html\",\"relativePath\":\"/02.页面/20.CSS/09.「布局技巧」图片未加载前自动撑开元素高度.html\",\"frontmatter\":{\"title\":\"「布局技巧」图片未加载前自动撑开元素高度\",\"date\":\"2020-02-22 16:37:10\",\"permalink\":\"/pages/3d52574260725aea\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"「布局技巧」图片未加载前自动撑开元素高度\",\"date\":\"2020-02-22 16:37:10\",\"excerpt\":\"<h1 id=\\\"「布局技巧」图片未加载前自动撑开元素高度\\\" tabindex=\\\"-1\\\">「布局技巧」图片未加载前自动撑开元素高度 <a class=\\\"header-anchor\\\" href=\\\"#「布局技巧」图片未加载前自动撑开元素高度\\\" aria-label=\\\"Permalink to &quot;「布局技巧」图片未加载前自动撑开元素高度&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>在移动端开发中，有一些元素是根据图片高度来自动撑开的 ，高度不能写死（如轮播图的外层元素）。在网络较慢的情况下，图片加载需要一些时间，此时该元素的高度没有被撑开，在网页布局上会有一些不想看到的效果。</p>\\n\",\"capture\":\"在移动端开发中，有一些元素是根据图片高度来自动撑开的 ，高度不能写死（如轮播图的外层元素）。在网络较慢的情况下，图片加载需要一些时间，此时该元素的高度没有被撑开，在网页布局上会有一些不想看到的效果。\\n这种情况我们可以设置如下样式来设置该元素的高度：\\n```stylus\\n.wrapper\\n  overflow hidden\\n  width 100%\\n  height 0\\n  padding-bottom 26.66% // 这个数值是图片的高宽比，即 高/宽\\n  background eee\\n```\\n上面代码中，`padding-bottom` 的取值是图片的高宽比（即，高/宽），它会根据 `w\"},{\"url\":\"/01.前端/25.JavaScript文章/03.ES5面向对象.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/03.ES5面向对象.html\",\"frontmatter\":{\"title\":\"ES5面向对象\",\"date\":\"2020-02-22 10:35:43\",\"permalink\":\"/pages/b1af5cb8996363c5\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"ES5面向对象\",\"date\":\"2020-02-22 10:35:43\",\"capture\":\"```js\\n//面向对象封装\\nfunction Student(props){ // 构造函数 （构造函数内定于属性。尊从首字母大写的约定）\\n  this.name = props.name || '匿名';  // 默认‘匿名’\\n  this.grade = props.grade || 1;\\n}\\nStudent.prototype.hello = function(){ // 在构造函数的原型上定义方法\\n  console.log('你好,'+ this.name +'同学，你在'+ this.grade+'年级');\\n}\\n//使用\\nfunction createStudent(props\"},{\"url\":\"/02.页面/10.HTML/10.常用meta整理.html\",\"relativePath\":\"/02.页面/10.HTML/10.常用meta整理.html\",\"frontmatter\":{\"title\":\"常用meta整理\",\"date\":\"2020-02-21 12:20:10\",\"permalink\":\"/pages/8309a5b876fc95e3\",\"categories\":[\"页面\",\"HTML\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"常用meta整理\",\"date\":\"2020-02-21 12:20:10\",\"excerpt\":\"<h1 id=\\\"常用meta整理\\\" tabindex=\\\"-1\\\">常用meta整理 <a class=\\\"header-anchor\\\" href=\\\"#常用meta整理\\\" aria-label=\\\"Permalink to &quot;常用meta整理&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"meta-元素\\\" tabindex=\\\"-1\\\">&lt;meta&gt; 元素 <a class=\\\"header-anchor\\\" href=\\\"#meta-元素\\\" aria-label=\\\"Permalink to &quot;&lt;meta\\\\&gt; 元素&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"概要\\\" tabindex=\\\"-1\\\">概要 <a class=\\\"header-anchor\\\" href=\\\"#概要\\\" aria-label=\\\"Permalink to &quot;概要&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>meta标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。</p>\\n\",\"capture\":\"&lt;meta\\\\\\n 概要\\nmeta标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。\\n必要属性\\n| 属性    | 值        | 描述                                   |\\n| ------- | --------- | -------------------------------------- |\\n| content | some text | 定义与http-equiv或name属性相关的元信息 |\\n可选属性\\n| 属性     \"},{\"url\":\"/《Vue》笔记/05.工具/10.Vue CLi v3 创建项目使用记录.html\",\"relativePath\":\"/《Vue》笔记/05.工具/10.Vue CLi v3 创建项目使用记录.html\",\"frontmatter\":{\"title\":\"Vue CLi v3 创建项目使用记录\",\"date\":\"2020-02-20 17:24:29\",\"permalink\":\"/pages/d00311f8174119b2\",\"categories\":[\"《Vue》笔记\",\"工具\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Vue CLi v3 创建项目使用记录\",\"date\":\"2020-02-20 17:24:29\",\"capture\":\"官方文档\\n以下使用的CLi版本是 v3.11.0\\n vue create\\n1. 运行以下命令来创建一个新项目\\n```sh\\nvue create hello-world\\n```\\n2. 你会被提示选取一个 preset (预设)。你可以选默认的包含了基本的 Babel + ESLint 设置的 preset，也可以选“手动选择特性”来选取需要的特性。\\n```sh\\nVue CLI v3.11.0\\n? Please pick a preset: (Use arrow keys)\\n\\n  Manually select features (手动选择特性)\\n```\\n默认预设只包含Babel + ESLint\"},{\"url\":\"/《Vue》笔记/04.可复用性&组合/01.Mixin混入.html\",\"relativePath\":\"/《Vue》笔记/04.可复用性&组合/01.Mixin混入.html\",\"frontmatter\":{\"title\":\"Mixin混入\",\"date\":\"2020-02-19 15:22:41\",\"permalink\":\"/pages/bd36a3c1bc3e0821\",\"categories\":[\"《Vue》笔记\",\"可复用性&组合\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Mixin混入\",\"date\":\"2020-02-19 15:22:41\",\"excerpt\":\"<h1 id=\\\"mixin混入\\\" tabindex=\\\"-1\\\">Mixin混入 <a class=\\\"header-anchor\\\" href=\\\"#mixin混入\\\" aria-label=\\\"Permalink to &quot;Mixin混入&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"基础\\\" tabindex=\\\"-1\\\">基础 <a class=\\\"header-anchor\\\" href=\\\"#基础\\\" aria-label=\\\"Permalink to &quot;基础&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。</p>\\n\",\"capture\":\"基础\\n混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。\\n\\n&gt;\\n&gt; 可通过 `this.$options` 查看选项\\n例子：\\n```js\\n// 定义一个混入对象\\nvar myMixin = {\\n  created: function () {\\n    this.hello()\\n  },\\n  methods: {\\n    hello: function () {\\n      console.log('hello from mixin!')\\n  \"},{\"url\":\"/《Vue》笔记/02.组件/90.vue父子组件的生命周期顺序.html\",\"relativePath\":\"/《Vue》笔记/02.组件/90.vue父子组件的生命周期顺序.html\",\"frontmatter\":{\"title\":\"vue父子组件的生命周期顺序\",\"date\":\"2020-02-18 16:39:33\",\"permalink\":\"/pages/e6cec47efa42d7f1\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"vue父子组件的生命周期顺序\",\"date\":\"2020-02-18 16:39:33\",\"capture\":\"加载渲染过程\\n```\\n父beforeCreate -\\n```\\n父组件会先执行到beforeMount，接着会执行子组件钩子到挂载结束，再挂载父组件。\\n 子组件更新过程\\n```\\n父beforeUpdate -&gt; 子beforeUpdate -&gt; 子updated -&gt; 父updated\\n```\\n 父组件更新过程\\n```\\n父beforeUpdate -&gt; 父updated\\n```\\n 销毁过程\\n```\\n父beforeDestroy -&gt; 子beforeDestroy -&gt; 子destroyed -&gt; 父destroyed\\n```\"},{\"url\":\"/《Vue》笔记/03.过渡&动画/112.使用animate库.html\",\"relativePath\":\"/《Vue》笔记/03.过渡&动画/112.使用animate库.html\",\"frontmatter\":{\"title\":\"使用animate库\",\"date\":\"2020-02-17 16:05:52\",\"permalink\":\"/pages/3b0a20e70805fcea\",\"categories\":[\"《Vue》笔记\",\"过渡&动画\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"使用animate库\",\"date\":\"2020-02-17 16:05:52\",\"excerpt\":\"<h1 id=\\\"vue中使用animate-css库\\\" tabindex=\\\"-1\\\">vue中使用Animate.css库 <a class=\\\"header-anchor\\\" href=\\\"#vue中使用animate-css库\\\" aria-label=\\\"Permalink to &quot;vue中使用Animate.css库&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"自定义过渡类名\\\" tabindex=\\\"-1\\\">自定义过渡类名 <a class=\\\"header-anchor\\\" href=\\\"#自定义过渡类名\\\" aria-label=\\\"Permalink to &quot;自定义过渡类名&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>我们可以通过以下 attribute 来自定义过渡类名：</p>\\n<ul>\\n<li><code>enter-class</code></li>\\n<li><code>enter-active-class</code></li>\\n<li><code>enter-to-class</code> (2.1.8+)</li>\\n<li><code>leave-class</code></li>\\n<li><code>leave-active-class</code></li>\\n<li><code>leave-to-class</code> (2.1.8+)</li>\\n</ul>\\n\",\"capture\":\"自定义过渡类名\\n我们可以通过以下 attribute 来自定义过渡类名：\\n- `enter-class`\\n- `enter-active-class`\\n- `enter-to-class` (2.1.8+)\\n- `leave-class`\\n- `leave-active-class`\\n- `leave-to-class` (2.1.8+)\\n他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 Animate.css结合使用十分有用。\\n 使用Animate.css库\\n```html\\n&lt;transition\\n            name=\\\"custom-\"},{\"url\":\"/《Vue》笔记/02.组件/80.动态组件与 v-once 指令.html\",\"relativePath\":\"/《Vue》笔记/02.组件/80.动态组件与 v-once 指令.html\",\"frontmatter\":{\"title\":\"动态组件与 v-once 指令\",\"date\":\"2020-02-16 15:52:19\",\"permalink\":\"/pages/636ca33122e9a64b\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"动态组件与 v-once 指令\",\"date\":\"2020-02-16 15:52:19\",\"capture\":\"动态组件\\n```html\\n&lt;div id=\\\"root\\\"\\n\\t&lt;component :is=\\\"type\\\"&gt;&lt;/component&gt; &lt;!--其效果如同下面两行被注释的代码--&gt;\\n\\t&lt;!-- &lt;child-one v-if=\\\"type === 'child-one'\\\"&gt;&lt;/child-one&gt;\\n\\t    &lt;child-two v-if=\\\"type === 'child-two'\\\"&gt;&lt;/child-two&gt; --&gt;\\n\\t&lt;button @click=\\\"handleClick\\\"&gt;change&\"},{\"url\":\"/《Vue》笔记/02.组件/75.插槽slot.html\",\"relativePath\":\"/《Vue》笔记/02.组件/75.插槽slot.html\",\"frontmatter\":{\"title\":\"插槽slot\",\"date\":\"2020-02-16 11:46:27\",\"permalink\":\"/pages/055ecee9a4325386\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"插槽slot\",\"date\":\"2020-02-16 11:46:27\",\"capture\":\"API\\n 插槽\\n```html\\n&lt;div id=\\\"root\\\"\\n    &lt;child&gt; &lt;!-- 组件标签 --&gt;\\n        &lt;h1&gt;hello&lt;/h1&gt;\\n    &lt;/child&gt;\\n&lt;/div&gt;\\n&lt;script type=\\\"text/javascript\\\"&gt;\\n    Vue.component('child', { // 子组件\\n        template: '&lt;div&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;'\\n    })\\n    var vm \"},{\"url\":\"/《Vue》笔记/02.组件/65.非父子组件传值.html\",\"relativePath\":\"/《Vue》笔记/02.组件/65.非父子组件传值.html\",\"frontmatter\":{\"title\":\"非父子组件传值\",\"date\":\"2020-02-15 14:55:03\",\"permalink\":\"/pages/d408e64f666f146d\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"非父子组件传值\",\"date\":\"2020-02-15 14:55:03\",\"excerpt\":\"<h1 id=\\\"非父子组件间传值\\\" tabindex=\\\"-1\\\">非父子组件间传值 <a class=\\\"header-anchor\\\" href=\\\"#非父子组件间传值\\\" aria-label=\\\"Permalink to &quot;非父子组件间传值&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>当组件的嵌套多时，非父子组件间传值就显得复杂，除了使用<a href=\\\"https://vuex.vuejs.org/zh/\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">vuex</a>实现之外，还可以通过Bus（或者叫 总线/发布订阅模式/观察者模式）的方式实现非父子组件间传值。</p>\\n\",\"capture\":\"当组件的嵌套多时，非父子组件间传值就显得复杂，除了使用vuex实现之外，还可以通过Bus（或者叫 总线/发布订阅模式/观察者模式）的方式实现非父子组件间传值。\\n&lt;div id=\\\"root\\\"\\n\\t\\t&lt;child1 content=\\\"组件1：点我传出值\\\"&gt;&lt;/child1&gt;\\n\\t\\t&lt;child2 content=\\\"组件2\\\"&gt;&lt;/child2&gt;\\n\\t&lt;/div&gt;\\n```html\\n&lt;div id=\\\"root\\\"&gt;\\n    &lt;child1 content=\\\"组件1：点我传出值\\\"&gt;&lt;/child1&gt;\\n    &l\"},{\"url\":\"/《Vue》笔记/02.组件/55.自定义事件.html\",\"relativePath\":\"/《Vue》笔记/02.组件/55.自定义事件.html\",\"frontmatter\":{\"title\":\"自定义事件\",\"date\":\"2020-02-15 11:27:45\",\"permalink\":\"/pages/9651417d08d1779d\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"自定义事件\",\"date\":\"2020-02-15 11:27:45\",\"capture\":\"API\\n 在组件标签v-on绑定的事件是自定义事件\\n```html\\n&lt;div id=\\\"root\\\"\\n    &lt;child @click=\\\"handleClick\\\"&gt;&lt;/child&gt; &lt;!--这里click是自定义事件--&gt;\\n&lt;/div&gt;\\n&lt;script type=\\\"text/javascript\\\"&gt;\\n    Vue.component('child', {\\n        template: '&lt;button&gt;Child&lt;/button&gt;',\\n    })\\n    var vm = new Vue({\\n  \"},{\"url\":\"/《Vue》笔记/02.组件/52.Prop 验证 与 非 Prop 的 Attribute.html\",\"relativePath\":\"/《Vue》笔记/02.组件/52.Prop 验证 与 非 Prop 的 Attribute.html\",\"frontmatter\":{\"title\":\"Prop 验证 与 非 Prop 的 Attribute\",\"date\":\"2020-02-15 10:49:04\",\"permalink\":\"/pages/a3080f60f6596eb4\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Prop 验证 与 非 Prop 的 Attribute\",\"date\":\"2020-02-15 10:49:04\",\"capture\":\"Prop 验证\\nAPI\\n子组件对父组件传递来的参数进行校验\\n```js\\nVue.component('my-component', {\\n  props: {\\n    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)\\n    propA: Number,\\n    // 多个可能的类型\\n    propB: [String, Number],\\n    // 必填的字符串\\n    propC: {\\n      type: String,\\n      required: true\\n    },\\n    // 带有默认值的数字\\n    propD: {\\n      \"},{\"url\":\"/《Vue》笔记/02.组件/36.使用组件的细节点.html\",\"relativePath\":\"/《Vue》笔记/02.组件/36.使用组件的细节点.html\",\"frontmatter\":{\"title\":\"使用组件的细节点\",\"date\":\"2020-02-13 13:26:20\",\"permalink\":\"/pages/83a1ab785e7fd70c\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"使用组件的细节点\",\"date\":\"2020-02-13 13:26:20\",\"capture\":\"解析 DOM 模板时的注意事项\\n```html\\n&lt;div id=\\\"root\\\"\\n    &lt;table&gt;\\n        &lt;tbody&gt;\\n            &lt;row&gt;&lt;/row&gt;\\n            &lt;row&gt;&lt;/row&gt;\\n            &lt;row&gt;&lt;/row&gt;\\n        &lt;/tbody&gt;\\n    &lt;/table&gt;\\n&lt;/div&gt;\\n&lt;script type=\\\"text/javascript\\\"&gt;\\n    Vue.component\"},{\"url\":\"/《ES6 教程》笔记/29.最新提案.html\",\"relativePath\":\"/《ES6 教程》笔记/29.最新提案.html\",\"frontmatter\":{\"title\":\"最新提案\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/7188882b8d65af1b\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"最新提案\",\"date\":\"2020-02-09 16:00:30\",\"excerpt\":\"<h1 id=\\\"最新提案\\\" tabindex=\\\"-1\\\">最新提案 <a class=\\\"header-anchor\\\" href=\\\"#最新提案\\\" aria-label=\\\"Permalink to &quot;最新提案&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>本章介绍一些尚未进入标准、但很有希望的最新提案。</p>\\n<h2 id=\\\"do-表达式\\\" tabindex=\\\"-1\\\">do 表达式 <a class=\\\"header-anchor\\\" href=\\\"#do-表达式\\\" aria-label=\\\"Permalink to &quot;do 表达式&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">{</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">  let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> t </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> f</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">();</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">  t </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> t </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">*</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> t </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">+</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br></div></div>\",\"capture\":\"本章介绍一些尚未进入标准、但很有希望的最新提案。\\n do 表达式\\n本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。\\n```javascript\\n{\\n  let t = f();\\n  t = t * t + 1;\\n}\\n```\\n上面代码中，块级作用域将两个语句封装在一起。但是，在块级作用域以外，没有办法得到`t`的值，因为块级作用域不返回值，除非`t`是全局变量。\\n现在有一个提案，使得块级作用域可以变为表达式，也就是说可以返回值，办法就是在块级作用域之前加上`do`，使它变为`do`表达式，然后就会返回内部最后执行的表达式的值。\\n```javascript\\nlet x = do {\"},{\"url\":\"/《ES6 教程》笔记/30.装饰器.html\",\"relativePath\":\"/《ES6 教程》笔记/30.装饰器.html\",\"frontmatter\":{\"title\":\"装饰器\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/e97bc1e5626b082c\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"装饰器\",\"date\":\"2020-02-09 16:00:30\",\"excerpt\":\"<h1 id=\\\"装饰器\\\" tabindex=\\\"-1\\\">装饰器 <a class=\\\"header-anchor\\\" href=\\\"#装饰器\\\" aria-label=\\\"Permalink to &quot;装饰器&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>[说明] Decorator 提案经过了大幅修改，目前还没有定案，不知道语法会不会再变。下面的内容完全依据以前的提案，已经有点过时了。等待定案以后，需要完全重写。</p>\\n<p>装饰器（Decorator）是一种与类（class）相关的语法，用来注释或修改类和类方法。许多面向对象的语言都有这项功能，目前有一个<a href=\\\"https://github.com/tc39/proposal-decorators\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">提案</a>将其引入了 ECMAScript。</p>\\n\",\"capture\":\"[说明] Decorator 提案经过了大幅修改，目前还没有定案，不知道语法会不会再变。下面的内容完全依据以前的提案，已经有点过时了。等待定案以后，需要完全重写。\\n装饰器（Decorator）是一种与类（class）相关的语法，用来注释或修改类和类方法。许多面向对象的语言都有这项功能，目前有一个提案将其引入了 ECMAScript。\\n装饰器是一种函数，写成`@ + 函数名`。它可以放在类和类方法的定义前面。\\n```javascript\\n@frozen class Foo {\\n  @configurable(false)\\n  @enumerable(true)\\n  method() {}\\n  @\"},{\"url\":\"/《ES6 教程》笔记/31.函数式编程.html\",\"relativePath\":\"/《ES6 教程》笔记/31.函数式编程.html\",\"frontmatter\":{\"title\":\"函数式编程\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/1cf50330655efc69\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"函数式编程\",\"date\":\"2020-02-09 16:00:30\",\"excerpt\":\"<h1 id=\\\"函数式编程\\\" tabindex=\\\"-1\\\">函数式编程 <a class=\\\"header-anchor\\\" href=\\\"#函数式编程\\\" aria-label=\\\"Permalink to &quot;函数式编程&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>JavaScript 语言从一诞生，就具有函数式编程的烙印。它将函数作为一种独立的数据类型，与其他数据类型处于完全平等的地位。在 JavaScript 语言中，你可以采用面向对象编程，也可以采用函数式编程。有人甚至说，JavaScript 是有史以来第一种被大规模采用的函数式编程语言。</p>\\n\",\"capture\":\"JavaScript 语言从一诞生，就具有函数式编程的烙印。它将函数作为一种独立的数据类型，与其他数据类型处于完全平等的地位。在 JavaScript 语言中，你可以采用面向对象编程，也可以采用函数式编程。有人甚至说，JavaScript 是有史以来第一种被大规模采用的函数式编程语言。\\nES6 的种种新增功能，使得函数式编程变得更方便、更强大。本章介绍 ES6 如何进行函数式编程。\\n 柯里化\\n柯里化（currying）指的是将一个多参数的函数拆分成一系列函数，每个拆分后的函数都只接受一个参数（unary）。\\n```javascript\\nfunction add (a, b) {\\n  retur\"},{\"url\":\"/《ES6 教程》笔记/32.Mixin.html\",\"relativePath\":\"/《ES6 教程》笔记/32.Mixin.html\",\"frontmatter\":{\"title\":\"Mixin\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/6a8e2dc558da1b39\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Mixin\",\"date\":\"2020-02-09 16:00:30\",\"excerpt\":\"<h1 id=\\\"mixin\\\" tabindex=\\\"-1\\\">Mixin <a class=\\\"header-anchor\\\" href=\\\"#mixin\\\" aria-label=\\\"Permalink to &quot;Mixin&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>JavaScript 语言的设计是单一继承，即子类只能继承一个父类，不允许继承多个父类。这种设计保证了对象继承的层次结构是树状的，而不是复杂的<a href=\\\"https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">网状结构</a>。</p>\\n\",\"capture\":\"JavaScript 语言的设计是单一继承，即子类只能继承一个父类，不允许继承多个父类。这种设计保证了对象继承的层次结构是树状的，而不是复杂的网状结构。\\n但是，这大大降低了编程的灵活性。因为实际开发中，有时不可避免，子类需要继承多个父类。举例来说，“猫”可以继承“哺乳类动物”，也可以继承“宠物”。\\n各种单一继承的编程语言，有不同的多重继承解决方案。比如，Java 语言也是子类只能继承一个父类，但是还允许继承多个界面（interface），这样就间接实现了多重继承。Interface 与父类一样，也是一个类，只不过它只定义接口（method signature），不定义实现，因此又被称为“抽象类\"},{\"url\":\"/《ES6 教程》笔记/33.SIMD.html\",\"relativePath\":\"/《ES6 教程》笔记/33.SIMD.html\",\"frontmatter\":{\"title\":\"SIMD\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/8e8f80f69b775a56\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"SIMD\",\"date\":\"2020-02-09 16:00:30\",\"excerpt\":\"<h1 id=\\\"simd\\\" tabindex=\\\"-1\\\">SIMD <a class=\\\"header-anchor\\\" href=\\\"#simd\\\" aria-label=\\\"Permalink to &quot;SIMD&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>SIMD（发音<code>/sim-dee/</code>）是“Single Instruction/Multiple Data”的缩写，意为“单指令，多数据”。它是 JavaScript 操作 CPU 对应指令的接口，你可以看做这是一种不同的运算执行模式。与它相对的是 SISD（“Single Instruction/Single Data”），即“单指令，单数据”。</p>\\n\",\"capture\":\"概述\\nSIMD（发音`/sim-dee/`）是“Single Instruction/Multiple Data”的缩写，意为“单指令，多数据”。它是 JavaScript 操作 CPU 对应指令的接口，你可以看做这是一种不同的运算执行模式。与它相对的是 SISD（“Single Instruction/Single Data”），即“单指令，单数据”。\\nSIMD 的含义是使用一个指令，完成多个数据的运算；SISD 的含义是使用一个指令，完成单个数据的运算，这是 JavaScript 的默认运算模式。显而易见，SIMD 的执行效率要高于 SISD，所以被广泛用于 3D 图形运算、物理模拟等运算\"},{\"url\":\"/《ES6 教程》笔记/34.参考链接.html\",\"relativePath\":\"/《ES6 教程》笔记/34.参考链接.html\",\"frontmatter\":{\"title\":\"参考链接\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/ea6f3b870f6dab69\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"参考链接\",\"date\":\"2020-02-09 16:00:30\",\"capture\":\"官方文件\\n- ECMAScript® 2015 Language Specification: ECMAScript 2015 规格\\n- ECMAScript® 2016 Language Specification: ECMAScript 2016 规格\\n- ECMAScript® 2017 Language Specification：ECMAScript 2017 规格（草案）\\n- ECMAScript Current Proposals: ECMAScript 当前的所有提案\\n- ECMAScript Active Proposals: 已经进入正式流程的提案\\n- ECMAScript\"},{\"url\":\"/《ES6 教程》笔记/02.let 和 const 命令.html\",\"relativePath\":\"/《ES6 教程》笔记/02.let 和 const 命令.html\",\"frontmatter\":{\"title\":\"let 和 const 命令\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/c1edd70a6b7c7872\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"let 和 const 命令\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"let-和-const-命令\\\" tabindex=\\\"-1\\\">let 和 const 命令 <a class=\\\"header-anchor\\\" href=\\\"#let-和-const-命令\\\" aria-label=\\\"Permalink to &quot;let 和 const 命令&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"let-命令\\\" tabindex=\\\"-1\\\">let 命令 <a class=\\\"header-anchor\\\" href=\\\"#let-命令\\\" aria-label=\\\"Permalink to &quot;let 命令&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"基本用法\\\" tabindex=\\\"-1\\\">基本用法 <a class=\\\"header-anchor\\\" href=\\\"#基本用法\\\" aria-label=\\\"Permalink to &quot;基本用法&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>ES6 新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code>，但是所声明的变量，<strong>只在<code>let</code>命令所在的代码块内有效(块级作用域)</strong>。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">{</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">  let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> a </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 10</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">  var</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> b </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">a </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// ReferenceError: a is not defined.</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">b </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// 1</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br></div></div>\",\"capture\":\"let 命令\\n 基本用法\\nES6 新增了`let`命令，用来声明变量。它的用法类似于`var`，但是所声明的变量，只在`let`命令所在的代码块内有效(块级作用域)。\\n```javascript\\n{\\n  let a = 10;\\n  var b = 1;\\n}\\na // ReferenceError: a is not defined.\\nb // 1\\n```\\n上面代码在代码块之中，分别用`let`和`var`声明了两个变量。然后在代码块之外调用这两个变量，结果`let`声明的变量报错，`var`声明的变量返回了正确的值。这表明，`let`声明的变量只在它所在的代码块有效。\\n`for`循环的计数器，\"},{\"url\":\"/《ES6 教程》笔记/03.变量的解构赋值.html\",\"relativePath\":\"/《ES6 教程》笔记/03.变量的解构赋值.html\",\"frontmatter\":{\"title\":\"变量的解构赋值\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/b1ab10a62f7564da\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"变量的解构赋值\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"变量的解构赋值\\\" tabindex=\\\"-1\\\">变量的解构赋值 <a class=\\\"header-anchor\\\" href=\\\"#变量的解构赋值\\\" aria-label=\\\"Permalink to &quot;变量的解构赋值&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"数组的解构赋值\\\" tabindex=\\\"-1\\\">数组的解构赋值 <a class=\\\"header-anchor\\\" href=\\\"#数组的解构赋值\\\" aria-label=\\\"Permalink to &quot;数组的解构赋值&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"基本用法\\\" tabindex=\\\"-1\\\">基本用法 <a class=\\\"header-anchor\\\" href=\\\"#基本用法\\\" aria-label=\\\"Permalink to &quot;基本用法&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>ES6 允许按照一定模式，<strong>从数组和对象中提取值，对变量进行赋值，这被称为解构</strong>（Destructuring）。</p>\\n<p>以前，为变量赋值，只能直接指定值。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> a </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> b </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> c </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 3</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br></div></div>\",\"capture\":\"数组的解构赋值\\n 基本用法\\nES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。\\n以前，为变量赋值，只能直接指定值。\\n```javascript\\nlet a = 1;\\nlet b = 2;\\nlet c = 3;\\n```\\nES6 允许写成下面这样。\\n```javascript\\nlet [a, b, c] = [1, 2, 3];\\n```\\n上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。\\n本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。\\n```javas\"},{\"url\":\"/《ES6 教程》笔记/04.字符串的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/04.字符串的扩展.html\",\"frontmatter\":{\"title\":\"字符串的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/ca89eca8adeba5f4\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"字符串的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"字符串的扩展\\\" tabindex=\\\"-1\\\">字符串的扩展 <a class=\\\"header-anchor\\\" href=\\\"#字符串的扩展\\\" aria-label=\\\"Permalink to &quot;字符串的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>本章介绍 ES6 对字符串的改造和增强，下一章介绍字符串对象的新增方法。</p>\\n<h2 id=\\\"字符的-unicode-表示法\\\" tabindex=\\\"-1\\\">字符的 Unicode 表示法 <a class=\\\"header-anchor\\\" href=\\\"#字符的-unicode-表示法\\\" aria-label=\\\"Permalink to &quot;字符的 Unicode 表示法&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES6 加强了对 Unicode 的支持，允许采用<code>\\\\uxxxx</code>形式表示一个字符，其中<code>xxxx</code>表示字符的 Unicode 码点。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">\\\\u0061</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// \\\"a\\\"</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br></div></div>\",\"capture\":\"本章介绍 ES6 对字符串的改造和增强，下一章介绍字符串对象的新增方法。\\n 字符的 Unicode 表示法\\nES6 加强了对 Unicode 的支持，允许采用`\\\\uxxxx`形式表示一个字符，其中`xxxx`表示字符的 Unicode 码点。\\n```javascript\\n\\\"\\\\u0061\\\"\\n// \\\"a\\\"\\n```\\n但是，这种表示法只限于码点在`\\\\u0000`~`\\\\uFFFF`之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。\\n```javascript\\n\\\"\\\\uD842\\\\uDFB7\\\"\\n// \\\"𠮷\\\"\\n\\\"\\\\u20BB7\\\"\\n// \\\" 7\\\"\\n```\\n上面代码表示，如果直接在`\\\\u`后面跟上超过`\"},{\"url\":\"/《ES6 教程》笔记/05.字符串的新增方法.html\",\"relativePath\":\"/《ES6 教程》笔记/05.字符串的新增方法.html\",\"frontmatter\":{\"title\":\"字符串的新增方法\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/a650b4a0ebfc9350\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"字符串的新增方法\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"字符串的新增方法\\\" tabindex=\\\"-1\\\">字符串的新增方法 <a class=\\\"header-anchor\\\" href=\\\"#字符串的新增方法\\\" aria-label=\\\"Permalink to &quot;字符串的新增方法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>本章介绍字符串对象的新增方法。</p>\\n<h2 id=\\\"string-fromcodepoint\\\" tabindex=\\\"-1\\\">String.fromCodePoint() <a class=\\\"header-anchor\\\" href=\\\"#string-fromcodepoint\\\" aria-label=\\\"Permalink to &quot;String.fromCodePoint()&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES5 提供<code>String.fromCharCode()</code>方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于<code>0xFFFF</code>的字符。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">String.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">fromCharCode</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">0x20BB7</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">)</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// \\\"ஷ\\\"</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br></div></div>\",\"capture\":\"本章介绍字符串对象的新增方法。\\n String.fromCodePoint()\\nES5 提供`String.fromCharCode()`方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于`0xFFFF`的字符。\\n```javascript\\nString.fromCharCode(0x20BB7)\\n// \\\"ஷ\\\"\\n```\\n上面代码中，`String.fromCharCode()`不能识别大于`0xFFFF`的码点，所以`0x20BB7`就发生了溢出，最高位`2`被舍弃了，最后返回码点`U+0BB7`对应的字符，而不是码点`U+20BB7`对应的字符。\\nES6 提供了`S\"},{\"url\":\"/《ES6 教程》笔记/06.正则的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/06.正则的扩展.html\",\"frontmatter\":{\"title\":\"正则的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/0473261a6ab0ee8c\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"正则的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"正则的扩展\\\" tabindex=\\\"-1\\\">正则的扩展 <a class=\\\"header-anchor\\\" href=\\\"#正则的扩展\\\" aria-label=\\\"Permalink to &quot;正则的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"regexp-构造函数\\\" tabindex=\\\"-1\\\">RegExp 构造函数 <a class=\\\"header-anchor\\\" href=\\\"#regexp-构造函数\\\" aria-label=\\\"Permalink to &quot;RegExp 构造函数&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>在 ES5 中，<code>RegExp</code>构造函数的参数有两种情况。</p>\\n<p>第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">var</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> regex </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> new</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> RegExp</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'xyz'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'i'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">);</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// 等价于</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">var</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> regex </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> /</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#DBEDFF\\\">xyz</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">/</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">i</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br></div></div>\",\"capture\":\"RegExp 构造函数\\n在 ES5 中，`RegExp`构造函数的参数有两种情况。\\n第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。\\n```javascript\\nvar regex = new RegExp('xyz', 'i');\\n// 等价于\\nvar regex = /xyz/i;\\n```\\n第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。\\n```javascript\\nvar regex = new RegExp(/xyz/i);\\n// 等价于\\nvar regex = /xyz/i;\\n```\\n但是，ES5 不允许此时使用第二个参数添加修饰\"},{\"url\":\"/《ES6 教程》笔记/07.数值的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/07.数值的扩展.html\",\"frontmatter\":{\"title\":\"数值的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/5dfea9a0f2d1a392\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"数值的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"数值的扩展\\\" tabindex=\\\"-1\\\">数值的扩展 <a class=\\\"header-anchor\\\" href=\\\"#数值的扩展\\\" aria-label=\\\"Permalink to &quot;数值的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"二进制和八进制表示法\\\" tabindex=\\\"-1\\\">二进制和八进制表示法 <a class=\\\"header-anchor\\\" href=\\\"#二进制和八进制表示法\\\" aria-label=\\\"Permalink to &quot;二进制和八进制表示法&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES6 提供了二进制和八进制数值的新的写法，分别用前缀<code>0b</code>（或<code>0B</code>）和<code>0o</code>（或<code>0O</code>）表示。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">0b111110111</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> ===</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 503</span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\"> // true</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">0o767</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> ===</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 503</span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\"> // true</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br></div></div>\",\"capture\":\"二进制和八进制表示法\\nES6 提供了二进制和八进制数值的新的写法，分别用前缀`0b`（或`0B`）和`0o`（或`0O`）表示。\\n```javascript\\n0b111110111 === 503 // true\\n0o767 === 503 // true\\n```\\n从 ES5 开始，在严格模式之中，八进制就不再允许使用前缀`0`表示，ES6 进一步明确，要使用前缀`0o`表示。\\n```javascript\\n// 非严格模式\\n(function(){\\n  console.log(0o11 === 011);\\n})() // true\\n// 严格模式\\n(function(){\\n  'use str\"},{\"url\":\"/《ES6 教程》笔记/08.函数的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/08.函数的扩展.html\",\"frontmatter\":{\"title\":\"函数的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/8ed309d668b20264\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"函数的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"函数的扩展\\\" tabindex=\\\"-1\\\">函数的扩展 <a class=\\\"header-anchor\\\" href=\\\"#函数的扩展\\\" aria-label=\\\"Permalink to &quot;函数的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"函数参数的默认值\\\" tabindex=\\\"-1\\\">函数参数的默认值 <a class=\\\"header-anchor\\\" href=\\\"#函数参数的默认值\\\" aria-label=\\\"Permalink to &quot;函数参数的默认值&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"基本用法\\\" tabindex=\\\"-1\\\">基本用法 <a class=\\\"header-anchor\\\" href=\\\"#基本用法\\\" aria-label=\\\"Permalink to &quot;基本用法&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">function</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#E36209;--shiki-dark:#FFAB70\\\">x</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#E36209;--shiki-dark:#FFAB70\\\">y</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">) {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">  y </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> y </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">||</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> 'World'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">  console.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(x, y);</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'Hello'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">) </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// Hello World</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'Hello'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'China'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">) </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// Hello China</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'Hello'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">''</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">) </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// Hello World</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br><span class=\\\"line-number\\\">8</span><br></div></div>\",\"capture\":\"函数参数的默认值\\n 基本用法\\nES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。\\n```javascript\\nfunction log(x, y) {\\n  y = y || 'World';\\n  console.log(x, y);\\n}\\nlog('Hello') // Hello World\\nlog('Hello', 'China') // Hello China\\nlog('Hello', '') // Hello World\\n```\\n上面代码检查函数`log`的参数`y`有没有赋值，如果没有，则指定默认值为`World`。这种写法的缺点在于，如果参数`y`赋值了，但是对应的布\"},{\"url\":\"/《ES6 教程》笔记/09.数组的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/09.数组的扩展.html\",\"frontmatter\":{\"title\":\"数组的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/e34009d60d8bc4b2\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"数组的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"数组的扩展\\\" tabindex=\\\"-1\\\">数组的扩展 <a class=\\\"header-anchor\\\" href=\\\"#数组的扩展\\\" aria-label=\\\"Permalink to &quot;数组的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"扩展运算符\\\" tabindex=\\\"-1\\\">扩展运算符 <a class=\\\"header-anchor\\\" href=\\\"#扩展运算符\\\" aria-label=\\\"Permalink to &quot;扩展运算符&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"含义\\\" tabindex=\\\"-1\\\">含义 <a class=\\\"header-anchor\\\" href=\\\"#含义\\\" aria-label=\\\"Permalink to &quot;含义&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>扩展运算符（spread）是三个点（<code>...</code>）。它好比 rest 参数的逆运算，<strong>将一个数组转为用逗号分隔的参数序列</strong>。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">console.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">...</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">[</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">3</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">])</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// 1 2 3</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">console.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">...</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">[</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">3</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">4</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">], </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">5</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">)</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// 1 2 3 4 5</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">[</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">...</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">document.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">querySelectorAll</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'div'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">)]</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// [&#x3C;div>, &#x3C;div>, &#x3C;div>]</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br><span class=\\\"line-number\\\">8</span><br></div></div>\",\"capture\":\"扩展运算符\\n 含义\\n扩展运算符（spread）是三个点（`...`）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。\\n```javascript\\nconsole.log(...[1, 2, 3])\\n// 1 2 3\\nconsole.log(1, ...[2, 3, 4], 5)\\n// 1 2 3 4 5\\n[...document.querySelectorAll('div')]\\n// [&lt;div\\n```\\n该运算符主要用于函数调用。\\n```javascript\\nfunction push(array, ...items) {\\n  array.push(...items\"},{\"url\":\"/《ES6 教程》笔记/10.对象的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/10.对象的扩展.html\",\"frontmatter\":{\"title\":\"对象的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/b5e3e0a0ff6e9c25\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"对象的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"对象的扩展\\\" tabindex=\\\"-1\\\">对象的扩展 <a class=\\\"header-anchor\\\" href=\\\"#对象的扩展\\\" aria-label=\\\"Permalink to &quot;对象的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>对象（object）是 JavaScript 最重要的数据结构。ES6 对它进行了重大升级，本章介绍数据结构本身的改变，下一章介绍<code>Object</code>对象的新增方法。</p>\\n\",\"capture\":\"对象（object）是 JavaScript 最重要的数据结构。ES6 对它进行了重大升级，本章介绍数据结构本身的改变，下一章介绍`Object`对象的新增方法。\\n 属性的简洁表示法\\nES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。\\n```javascript\\nconst foo = 'bar';\\nconst baz = {foo};\\nbaz // {foo: \\\"bar\\\"}\\n// 等同于\\nconst baz = {foo: foo};\\n```\\n上面代码中，变量`foo`直接写在大括号里面。这时，属性名就是变量名, 属性值就是变量值。下面是另一个例子。\\n`\"},{\"url\":\"/《ES6 教程》笔记/11.对象的新增方法.html\",\"relativePath\":\"/《ES6 教程》笔记/11.对象的新增方法.html\",\"frontmatter\":{\"title\":\"对象的新增方法\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/e85e68947502cf90\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"对象的新增方法\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"对象的新增方法\\\" tabindex=\\\"-1\\\">对象的新增方法 <a class=\\\"header-anchor\\\" href=\\\"#对象的新增方法\\\" aria-label=\\\"Permalink to &quot;对象的新增方法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>本章介绍 Object 对象的新增方法。</p>\\n<h2 id=\\\"object-is\\\" tabindex=\\\"-1\\\">Object.is() <a class=\\\"header-anchor\\\" href=\\\"#object-is\\\" aria-label=\\\"Permalink to &quot;Object.is()&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES5 比较两个值是否相等，只有两个运算符：相等运算符（<code>==</code>）和严格相等运算符（<code>===</code>）。它们都有缺点，前者会自动转换数据类型，后者的<code>NaN</code>不等于自身，以及<code>+0</code>等于<code>-0</code>。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</p>\\n<p>ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。<code>Object.is</code>就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</p>\\n\",\"capture\":\"本章介绍 Object 对象的新增方法。\\n Object.is()\\nES5 比较两个值是否相等，只有两个运算符：相等运算符（`==`）和严格相等运算符（`===`）。它们都有缺点，前者会自动转换数据类型，后者的`NaN`不等于自身，以及`+0`等于`-0`。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。\\nES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。`Object.is`就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。\\n```javascript\\nObject.\"},{\"url\":\"/《ES6 教程》笔记/12.Symbol.html\",\"relativePath\":\"/《ES6 教程》笔记/12.Symbol.html\",\"frontmatter\":{\"title\":\"Symbol\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/02c86eb2792f3262\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Symbol\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"symbol\\\" tabindex=\\\"-1\\\">Symbol <a class=\\\"header-anchor\\\" href=\\\"#symbol\\\" aria-label=\\\"Permalink to &quot;Symbol&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，<strong>保证每个属性的名字都是独一无二</strong>的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入<code>Symbol</code>的原因。</p>\\n\",\"capture\":\"概述\\nES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入`Symbol`的原因。\\nES6 引入了一种新的原始数据类型`Symbol`，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：`undefined`、`null`、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。\\nSymbol 值\"},{\"url\":\"/《ES6 教程》笔记/13.Set 和 Map 数据结构.html\",\"relativePath\":\"/《ES6 教程》笔记/13.Set 和 Map 数据结构.html\",\"frontmatter\":{\"title\":\"Set 和 Map 数据结构\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/0c21dae358fca16b\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Set 和 Map 数据结构\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"set-和-map-数据结构\\\" tabindex=\\\"-1\\\">Set 和 Map 数据结构 <a class=\\\"header-anchor\\\" href=\\\"#set-和-map-数据结构\\\" aria-label=\\\"Permalink to &quot;Set 和 Map 数据结构&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"set\\\" tabindex=\\\"-1\\\">Set <a class=\\\"header-anchor\\\" href=\\\"#set\\\" aria-label=\\\"Permalink to &quot;Set&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"基本用法\\\" tabindex=\\\"-1\\\">基本用法 <a class=\\\"header-anchor\\\" href=\\\"#基本用法\\\" aria-label=\\\"Permalink to &quot;基本用法&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>ES6 提供了新的数据结构 Set。它<strong>类似于数组，但是成员的值都是唯一的，没有重复的值</strong>。</p>\\n<p><strong><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构</strong>。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">const</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> s</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> =</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> new</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> Set</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">();</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">[</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">3</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">5</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">4</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">5</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">].</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">forEach</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#E36209;--shiki-dark:#FFAB70\\\">x</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> =></span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> s.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">add</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(x));</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">for</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> (</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> i </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">of</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> s) {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">  console.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(i);</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// 2 3 5 4</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br><span class=\\\"line-number\\\">8</span><br></div></div>\",\"capture\":\"Set\\n 基本用法\\nES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。\\n`Set`本身是一个构造函数，用来生成 Set 数据结构。\\n```javascript\\nconst s = new Set();\\n[2, 3, 5, 4, 5, 2, 2].forEach(x =\\nfor (let i of s) {\\n  console.log(i);\\n}\\n// 2 3 5 4\\n```\\n上面代码通过`add()`方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。\\n`Set`函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参\"},{\"url\":\"/《ES6 教程》笔记/14.Proxy.html\",\"relativePath\":\"/《ES6 教程》笔记/14.Proxy.html\",\"frontmatter\":{\"title\":\"Proxy\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/f56ec2ab97d60483\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Proxy\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"proxy\\\" tabindex=\\\"-1\\\">Proxy <a class=\\\"header-anchor\\\" href=\\\"#proxy\\\" aria-label=\\\"Permalink to &quot;Proxy&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“<strong>元编程</strong>”（meta programming），即<strong>对编程语言进行编程</strong>。</p>\\n<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，<strong>外界对该对象的访问，都必须先通过这层拦截</strong>，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>\\n\",\"capture\":\"概述\\nProxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。\\nProxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。\\n```javascript\\nvar obj = new Proxy({}, {\\n  get: function (target, propKey, receiver) {\\n    console.log(\"},{\"url\":\"/《ES6 教程》笔记/15.Reflect.html\",\"relativePath\":\"/《ES6 教程》笔记/15.Reflect.html\",\"frontmatter\":{\"title\":\"Reflect\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/74de3e45e4491e95\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Reflect\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"reflect\\\" tabindex=\\\"-1\\\">Reflect <a class=\\\"header-anchor\\\" href=\\\"#reflect\\\" aria-label=\\\"Permalink to &quot;Reflect&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p><code>Reflect</code>对象与<code>Proxy</code>对象一样，也是 ES6 为了操作对象而提供的新 API。<code>Reflect</code>对象的设计目的有这样几个。</p>\\n<p>（1） **将<code>Object</code>对象的一些明显属于语言内部的方法（比如<code>Object.defineProperty</code>），放到<code>Reflect</code>对象上。**现阶段，某些方法同时在<code>Object</code>和<code>Reflect</code>对象上部署，未来的新方法将只部署在<code>Reflect</code>对象上。也就是说，从<code>Reflect</code>对象上可以拿到语言内部的方法。</p>\\n\",\"capture\":\"概述\\n`Reflect`对象与`Proxy`对象一样，也是 ES6 为了操作对象而提供的新 API。`Reflect`对象的设计目的有这样几个。\\n（1） 将`Object`对象的一些明显属于语言内部的方法（比如`Object.defineProperty`），放到`Reflect`对象上。现阶段，某些方法同时在`Object`和`Reflect`对象上部署，未来的新方法将只部署在`Reflect`对象上。也就是说，从`Reflect`对象上可以拿到语言内部的方法。\\n（2） 修改某些`Object`方法的返回结果，让其变得更合理。比如，`Object.defineProperty(obj, na\"},{\"url\":\"/《ES6 教程》笔记/16.Promise 对象.html\",\"relativePath\":\"/《ES6 教程》笔记/16.Promise 对象.html\",\"frontmatter\":{\"title\":\"Promise 对象\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/2810ae8985e9bd52\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Promise 对象\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"promise-对象\\\" tabindex=\\\"-1\\\">Promise 对象 <a class=\\\"header-anchor\\\" href=\\\"#promise-对象\\\" aria-label=\\\"Permalink to &quot;Promise 对象&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"promise-的含义\\\" tabindex=\\\"-1\\\">Promise 的含义 <a class=\\\"header-anchor\\\" href=\\\"#promise-的含义\\\" aria-label=\\\"Permalink to &quot;Promise 的含义&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了<code>Promise</code>对象。</p>\\n\",\"capture\":\"Promise 的含义\\nPromise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了`Promise`对象。\\n所谓`Promise`，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。\\n`Promise`对象有以下两个特点。\\n（1）对象的状态不受外界影响。`Promise`对象代表一个异步操作，有三种状态：`pe\"},{\"url\":\"/《ES6 教程》笔记/17.Iterator 和 for-of 循环.html\",\"relativePath\":\"/《ES6 教程》笔记/17.Iterator 和 for-of 循环.html\",\"frontmatter\":{\"title\":\"Iterator 和 for-of 循环\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/48df907ad3570f3d\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Iterator 和 for-of 循环\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"iterator-和-for-of-循环\\\" tabindex=\\\"-1\\\">Iterator 和 for...of 循环 <a class=\\\"header-anchor\\\" href=\\\"#iterator-和-for-of-循环\\\" aria-label=\\\"Permalink to &quot;Iterator 和 for...of 循环&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"iterator-遍历器-的概念\\\" tabindex=\\\"-1\\\">Iterator（遍历器）的概念 <a class=\\\"header-anchor\\\" href=\\\"#iterator-遍历器-的概念\\\" aria-label=\\\"Permalink to &quot;Iterator（遍历器）的概念&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>JavaScript 原有的表示“集合”的数据结构，主要是数组（<code>Array</code>）和对象（<code>Object</code>），ES6 又添加了<code>Map</code>和<code>Set</code>。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是<code>Map</code>，<code>Map</code>的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。</p>\\n\",\"capture\":\"Iterator（遍历器）的概念\\nJavaScript 原有的表示“集合”的数据结构，主要是数组（`Array`）和对象（`Object`），ES6 又添加了`Map`和`Set`。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是`Map`，`Map`的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。\\n遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。\\nIterator 的作用有三个：一是为各\"},{\"url\":\"/《ES6 教程》笔记/18.Generator 函数的语法.html\",\"relativePath\":\"/《ES6 教程》笔记/18.Generator 函数的语法.html\",\"frontmatter\":{\"title\":\"Generator 函数的语法\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/718b48ed9ce0adce\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Generator 函数的语法\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"generator-函数的语法\\\" tabindex=\\\"-1\\\">Generator 函数的语法 <a class=\\\"header-anchor\\\" href=\\\"#generator-函数的语法\\\" aria-label=\\\"Permalink to &quot;Generator 函数的语法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"基本概念\\\" tabindex=\\\"-1\\\">基本概念 <a class=\\\"header-anchor\\\" href=\\\"#基本概念\\\" aria-label=\\\"Permalink to &quot;基本概念&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>Generator 函数是 ES6 提供的一种<strong>异步编程解决方案</strong>，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《Generator 函数的异步应用》一章。</p>\\n\",\"capture\":\"简介\\n 基本概念\\nGenerator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《Generator 函数的异步应用》一章。\\nGenerator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。\\n执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。\\n形式上，Generator 函数是一个\"},{\"url\":\"/《ES6 教程》笔记/19.Generator 函数的异步应用.html\",\"relativePath\":\"/《ES6 教程》笔记/19.Generator 函数的异步应用.html\",\"frontmatter\":{\"title\":\"Generator 函数的异步应用\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/75af7031eb66847b\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Generator 函数的异步应用\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"generator-函数的异步应用\\\" tabindex=\\\"-1\\\">Generator 函数的异步应用 <a class=\\\"header-anchor\\\" href=\\\"#generator-函数的异步应用\\\" aria-label=\\\"Permalink to &quot;Generator 函数的异步应用&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>异步编程对 JavaScript 语言太重要。JavaScript 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。本章主要介绍 Generator 函数如何完成异步操作。</p>\\n\",\"capture\":\"异步编程对 JavaScript 语言太重要。JavaScript 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。本章主要介绍 Generator 函数如何完成异步操作。\\n 传统方法\\nES6 诞生以前，异步编程的方法，大概有下面四种。\\n- 回调函数\\n- 事件监听\\n- 发布/订阅\\n- Promise 对象\\nGenerator 函数将 JavaScript 异步编程带入了一个全新的阶段。\\n 基本概念\\n 异步\\n所谓\\\"异步\\\"，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。\\n比如，有一个任\"},{\"url\":\"/《ES6 教程》笔记/20.async 函数.html\",\"relativePath\":\"/《ES6 教程》笔记/20.async 函数.html\",\"frontmatter\":{\"title\":\"async 函数\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/3777253e65bac487\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"async 函数\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"async-函数\\\" tabindex=\\\"-1\\\">async 函数 <a class=\\\"header-anchor\\\" href=\\\"#async-函数\\\" aria-label=\\\"Permalink to &quot;async 函数&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"含义\\\" tabindex=\\\"-1\\\">含义 <a class=\\\"header-anchor\\\" href=\\\"#含义\\\" aria-label=\\\"Permalink to &quot;含义&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p>\\n<p>async 函数是什么？一句话，它就<strong>是 Generator 函数的语法糖</strong>。</p>\\n<p>前文有一个 Generator 函数，依次读取两个文件。</p>\\n\",\"capture\":\"含义\\nES2017 标准引入了 async 函数，使得异步操作变得更加方便。\\nasync 函数是什么？一句话，它就是 Generator 函数的语法糖。\\n前文有一个 Generator 函数，依次读取两个文件。\\n```javascript\\nconst fs = require('fs');\\nconst readFile = function (fileName) {\\n  return new Promise(function (resolve, reject) {\\n    fs.readFile(fileName, function(error, data) {\\n      if (error\"},{\"url\":\"/《ES6 教程》笔记/21.Class 的基本语法.html\",\"relativePath\":\"/《ES6 教程》笔记/21.Class 的基本语法.html\",\"frontmatter\":{\"title\":\"Class 的基本语法\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/e831e1593c82bbe0\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Class 的基本语法\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"class-的基本语法\\\" tabindex=\\\"-1\\\">Class 的基本语法 <a class=\\\"header-anchor\\\" href=\\\"#class-的基本语法\\\" aria-label=\\\"Permalink to &quot;Class 的基本语法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"类的由来\\\" tabindex=\\\"-1\\\">类的由来 <a class=\\\"header-anchor\\\" href=\\\"#类的由来\\\" aria-label=\\\"Permalink to &quot;类的由来&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">function</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> Point</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#E36209;--shiki-dark:#FFAB70\\\">x</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#E36209;--shiki-dark:#FFAB70\\\">y</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">) {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">  this</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.x </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> x;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">  this</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.y </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> y;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">Point</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">prototype</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">toString</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> =</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> function</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> () {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">  return</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> '('</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> +</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> this</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.x </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">+</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> ', '</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> +</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> this</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.y </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">+</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> ')'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">};</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">var</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> p </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> new</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> Point</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">);</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br><span class=\\\"line-number\\\">8</span><br><span class=\\\"line-number\\\">9</span><br><span class=\\\"line-number\\\">10</span><br></div></div>\",\"capture\":\"简介\\n 类的由来\\nJavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。\\n```javascript\\nfunction Point(x, y) {\\n  this.x = x;\\n  this.y = y;\\n}\\nPoint.prototype.toString = function () {\\n  return '(' + this.x + ', ' + this.y + ')';\\n};\\nvar p = new Point(1, 2);\\n```\\n上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。\\nES6 提供\"},{\"url\":\"/《ES6 教程》笔记/22.Class 的继承.html\",\"relativePath\":\"/《ES6 教程》笔记/22.Class 的继承.html\",\"frontmatter\":{\"title\":\"Class 的继承\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/83f8c3a0cd87dd83\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Class 的继承\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"class-的继承\\\" tabindex=\\\"-1\\\">Class 的继承 <a class=\\\"header-anchor\\\" href=\\\"#class-的继承\\\" aria-label=\\\"Permalink to &quot;Class 的继承&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>Class 可以通过<code>extends</code>关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">class</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> Point</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">class</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> ColorPoint</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> extends</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> Point</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br></div></div>\",\"capture\":\"简介\\nClass 可以通过`extends`关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。\\n```javascript\\nclass Point {\\n}\\nclass ColorPoint extends Point {\\n}\\n```\\n上面代码定义了一个`ColorPoint`类，该类通过`extends`关键字，继承了`Point`类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个`Point`类。下面，我们在`ColorPoint`内部加上代码。\\n```javascript\\nclass ColorPoint extends Point \"},{\"url\":\"/《ES6 教程》笔记/23.Module 的语法.html\",\"relativePath\":\"/《ES6 教程》笔记/23.Module 的语法.html\",\"frontmatter\":{\"title\":\"Module 的语法\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/efe2fb04eb8ac5fb\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Module 的语法\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"module-的语法\\\" tabindex=\\\"-1\\\">Module 的语法 <a class=\\\"header-anchor\\\" href=\\\"#module-的语法\\\" aria-label=\\\"Permalink to &quot;Module 的语法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的<code>require</code>、Python 的<code>import</code>，甚至就连 CSS 都有<code>@import</code>，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p>\\n\",\"capture\":\"概述\\n历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的`require`、Python 的`import`，甚至就连 CSS 都有`@import`，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。\\n在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD \"},{\"url\":\"/《ES6 教程》笔记/24.Module 的加载实现.html\",\"relativePath\":\"/《ES6 教程》笔记/24.Module 的加载实现.html\",\"frontmatter\":{\"title\":\"Module 的加载实现\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/a79ca2e64ceae213\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Module 的加载实现\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"module-的加载实现\\\" tabindex=\\\"-1\\\">Module 的加载实现 <a class=\\\"header-anchor\\\" href=\\\"#module-的加载实现\\\" aria-label=\\\"Permalink to &quot;Module 的加载实现&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>上一章介绍了模块的语法，本章介绍如何在浏览器和 Node.js 之中加载 ES6 模块，以及实际开发中经常遇到的一些问题（比如循环加载）。</p>\\n\",\"capture\":\"上一章介绍了模块的语法，本章介绍如何在浏览器和 Node.js 之中加载 ES6 模块，以及实际开发中经常遇到的一些问题（比如循环加载）。\\n 浏览器加载\\n 传统方法\\nHTML 网页中，浏览器通过`&lt;script\\n```html\\n&lt;!-- 页面内嵌的脚本 --&gt;\\n&lt;script type=\\\"application/javascript\\\"&gt;\\n  // module code\\n&lt;/script&gt;\\n&lt;!-- 外部脚本 --&gt;\\n&lt;script type=\\\"application/javascript\\\" src=\\\"path/to/myModule\"},{\"url\":\"/《ES6 教程》笔记/25.编程风格.html\",\"relativePath\":\"/《ES6 教程》笔记/25.编程风格.html\",\"frontmatter\":{\"title\":\"编程风格\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/984bf549204bb266\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"编程风格\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"编程风格\\\" tabindex=\\\"-1\\\">编程风格 <a class=\\\"header-anchor\\\" href=\\\"#编程风格\\\" aria-label=\\\"Permalink to &quot;编程风格&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>本章探讨如何将 ES6 的新语法，运用到编码实践之中，与传统的 JavaScript 语法结合在一起，写出合理的、易于阅读和维护的代码。</p>\\n<p>多家公司和组织已经公开了它们的风格规范，下面的内容主要参考了 <a href=\\\"https://github.com/airbnb/javascript\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">Airbnb</a> 公司的 JavaScript 风格规范。</p>\\n\",\"capture\":\"本章探讨如何将 ES6 的新语法，运用到编码实践之中，与传统的 JavaScript 语法结合在一起，写出合理的、易于阅读和维护的代码。\\n多家公司和组织已经公开了它们的风格规范，下面的内容主要参考了 Airbnb 公司的 JavaScript 风格规范。\\n 块级作用域\\n（1）let 取代 var\\nES6 提出了两个新的声明变量的命令：`let`和`const`。其中，`let`完全可以取代`var`，因为两者语义相同，而且`let`没有副作用。\\n```javascript\\n'use strict';\\nif (true) {\\n  let x = 'hello';\\n}\\nfor (let i = 0\"},{\"url\":\"/《ES6 教程》笔记/26.读懂 ECMAScript 规格.html\",\"relativePath\":\"/《ES6 教程》笔记/26.读懂 ECMAScript 规格.html\",\"frontmatter\":{\"title\":\"读懂 ECMAScript 规格\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/32c35f7651d6e58e\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"读懂 ECMAScript 规格\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"读懂-ecmascript-规格\\\" tabindex=\\\"-1\\\">读懂 ECMAScript 规格 <a class=\\\"header-anchor\\\" href=\\\"#读懂-ecmascript-规格\\\" aria-label=\\\"Permalink to &quot;读懂 ECMAScript 规格&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>规格文件是计算机语言的官方标准，详细描述语法规则和实现方法。</p>\\n<p>一般来说，没有必要阅读规格，除非你要写编译器。因为规格写得非常抽象和精炼，又缺乏实例，不容易理解，而且对于解决实际的应用问题，帮助不大。但是，如果你遇到疑难的语法问题，实在找不到答案，这时可以去查看规格文件，了解语言标准是怎么说的。规格是解决问题的“最后一招”。</p>\\n\",\"capture\":\"概述\\n规格文件是计算机语言的官方标准，详细描述语法规则和实现方法。\\n一般来说，没有必要阅读规格，除非你要写编译器。因为规格写得非常抽象和精炼，又缺乏实例，不容易理解，而且对于解决实际的应用问题，帮助不大。但是，如果你遇到疑难的语法问题，实在找不到答案，这时可以去查看规格文件，了解语言标准是怎么说的。规格是解决问题的“最后一招”。\\n这对 JavaScript 语言很有必要。因为它的使用场景复杂，语法规则不统一，例外很多，各种运行环境的行为不一致，导致奇怪的语法问题层出不穷，任何语法书都不可能囊括所有情况。查看规格，不失为一种解决语法问题的最可靠、最权威的终极方法。\\n本章介绍如何读懂 ECMASc\"},{\"url\":\"/《ES6 教程》笔记/27.异步遍历器.html\",\"relativePath\":\"/《ES6 教程》笔记/27.异步遍历器.html\",\"frontmatter\":{\"title\":\"异步遍历器\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/16121351be68691b\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"异步遍历器\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"异步遍历器\\\" tabindex=\\\"-1\\\">异步遍历器 <a class=\\\"header-anchor\\\" href=\\\"#异步遍历器\\\" aria-label=\\\"Permalink to &quot;异步遍历器&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"同步遍历器的问题\\\" tabindex=\\\"-1\\\">同步遍历器的问题 <a class=\\\"header-anchor\\\" href=\\\"#同步遍历器的问题\\\" aria-label=\\\"Permalink to &quot;同步遍历器的问题&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>《遍历器》一章说过，Iterator 接口是一种数据遍历的协议，只要调用遍历器对象的<code>next</code>方法，就会得到一个对象，表示当前遍历指针所在的那个位置的信息。<code>next</code>方法返回的对象的结构是<code>{value, done}</code>，其中<code>value</code>表示当前的数据的值，<code>done</code>是一个布尔值，表示遍历是否结束。</p>\\n\",\"capture\":\"同步遍历器的问题\\n《遍历器》一章说过，Iterator 接口是一种数据遍历的协议，只要调用遍历器对象的`next`方法，就会得到一个对象，表示当前遍历指针所在的那个位置的信息。`next`方法返回的对象的结构是`{value, done}`，其中`value`表示当前的数据的值，`done`是一个布尔值，表示遍历是否结束。\\n```javascript\\nfunction idMaker() {\\n  let index = 0;\\n  return {\\n    next: function() {\\n      return { value: index++, done: false };\\n    }\"},{\"url\":\"/《ES6 教程》笔记/28.ArrayBuffer.html\",\"relativePath\":\"/《ES6 教程》笔记/28.ArrayBuffer.html\",\"frontmatter\":{\"title\":\"ArrayBuffer\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/a2ba314746bfdbdd\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"ArrayBuffer\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"arraybuffer\\\" tabindex=\\\"-1\\\">ArrayBuffer <a class=\\\"header-anchor\\\" href=\\\"#arraybuffer\\\" aria-label=\\\"Permalink to &quot;ArrayBuffer&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><code>ArrayBuffer</code>对象、<code>TypedArray</code>视图和<code>DataView</code>视图是 JavaScript 操作二进制数据的一个接口。这些对象早就存在，属于独立的规格（2011 年 2 月发布），ES6 将它们纳入了 ECMAScript 规格，并且增加了新的方法。它们都是以数组的语法处理二进制数据，所以统称为二进制数组。</p>\\n\",\"capture\":\"`ArrayBuffer`对象、`TypedArray`视图和`DataView`视图是 JavaScript 操作二进制数据的一个接口。这些对象早就存在，属于独立的规格（2011 年 2 月发布），ES6 将它们纳入了 ECMAScript 规格，并且增加了新的方法。它们都是以数组的语法处理二进制数据，所以统称为二进制数组。\\n这个接口的原始设计目的，与 WebGL 项目有关。所谓 WebGL，就是指浏览器与显卡之间的通信接口，为了满足 JavaScript 与显卡之间大量的、实时的数据交换，它们之间的数据通信必须是二进制的，而不能是传统的文本格式。文本格式传递一个 32 位整数，两端的 Ja\"},{\"url\":\"/01.前端/25.JavaScript文章/07.js随机打乱数组.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/07.js随机打乱数组.html\",\"frontmatter\":{\"title\":\"JS随机打乱数组\",\"date\":\"2020-02-08 17:42:03\",\"permalink\":\"/pages/40b4db2d38ba85f2\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"JS随机打乱数组\",\"date\":\"2020-02-08 17:42:03\",\"capture\":\"```js\\nfunction shuffle(arr) { // 随机打乱数组\\n  let _arr = arr.slice() // 调用数组副本，不改变原数组\\n  for (let i = 0; i &lt; _arr.length; i++) {\\n    let j = getRandomInt(0, i)\\n    let t = _arr[i]\\n    _arr[i] = _arr[j]\\n    _arr[j] = t\\n  }\\n  return _arr\\n}\\nfunction getRandomInt(min, max) { // 获取min到max的一个随机数，包含min和max本身\"},{\"url\":\"/《Vue》笔记/01.基础/35.列表渲染之数组、对象更新检测.html\",\"relativePath\":\"/《Vue》笔记/01.基础/35.列表渲染之数组、对象更新检测.html\",\"frontmatter\":{\"title\":\"列表渲染之数组、对象更新检测\",\"date\":\"2020-02-05 13:09:06\",\"permalink\":\"/pages/04783a6691cc9d06\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"列表渲染之数组、对象更新检测\",\"date\":\"2020-02-05 13:09:06\",\"excerpt\":\"<h1 id=\\\"列表渲染之数组、对象更新检测\\\" tabindex=\\\"-1\\\">列表渲染之数组、对象更新检测 <a class=\\\"header-anchor\\\" href=\\\"#列表渲染之数组、对象更新检测\\\" aria-label=\\\"Permalink to &quot;列表渲染之数组、对象更新检测&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/list.html#%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">数组更新检测API</a> <a href=\\\"https://cn.vuejs.org/v2/guide/list.html#%E5%AF%B9%E8%B1%A1%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">对象更新检测API</a></p>\\n<h2 id=\\\"数组更新检测\\\" tabindex=\\\"-1\\\">数组更新检测 <a class=\\\"header-anchor\\\" href=\\\"#数组更新检测\\\" aria-label=\\\"Permalink to &quot;数组更新检测&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h4 id=\\\"变异方法-mutation-method\\\" tabindex=\\\"-1\\\">变异方法 (mutation method) <a class=\\\"header-anchor\\\" href=\\\"#变异方法-mutation-method\\\" aria-label=\\\"Permalink to &quot;变异方法 (mutation method)&quot;\\\">&ZeroWidthSpace;</a></h4>\\n<p>Vue 将被侦听的数组的变异方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：</p>\\n\",\"capture\":\"数组更新检测API 对象更新检测API\\n 数组更新检测\\n 变异方法 (mutation method)\\nVue 将被侦听的数组的变异方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：\\n- `push()`末尾添加\\n- `pop()`末尾删除\\n- `shift()` 首位删除\\n- `unshift() ` 首位添加\\n- `splice()` 拼合\\n- `sort()` 排序\\n- `reverse()` 反转\\n数组实例方法\\n 替换数组\\n变异方法，顾名思义，会改变调用了这些方法的原始数组。相比之下，也有非变异 (non-mutating method) 方法，例如 `filter(\"},{\"url\":\"/《Vue》笔记/01.基础/30.v-if vs v-show.html\",\"relativePath\":\"/《Vue》笔记/01.基础/30.v-if vs v-show.html\",\"frontmatter\":{\"title\":\"v-if vs v-show\",\"date\":\"2020-02-04 17:32:23\",\"permalink\":\"/pages/73e4064340277b05\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"v-if vs v-show\",\"date\":\"2020-02-04 17:32:23\",\"excerpt\":\"<h1 id=\\\"v-if-vs-v-show\\\" tabindex=\\\"-1\\\">v-if vs v-show <a class=\\\"header-anchor\\\" href=\\\"#v-if-vs-v-show\\\" aria-label=\\\"Permalink to &quot;v-if vs v-show&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/conditional.html#v-if-vs-v-show\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">API</a></p>\\n<p><code>v-if</code> 根据渲染条件决定是否把元素渲染到DOM页面，而<code>v-show</code>不管渲染条件是什么，都会把元素渲染到DOM页面，只是简单的切换CSS的显示隐藏。</p>\\n\",\"capture\":\"API\\n`v-if` 根据渲染条件决定是否把元素渲染到DOM页面，而`v-show`不管渲染条件是什么，都会把元素渲染到DOM页面，只是简单的切换CSS的显示隐藏。\\n如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好。\"},{\"url\":\"/《Vue》笔记/01.基础/20.计算属性 vs 方法 vs 侦听属性.html\",\"relativePath\":\"/《Vue》笔记/01.基础/20.计算属性 vs 方法 vs 侦听属性.html\",\"frontmatter\":{\"title\":\"计算属性 vs 方法 vs 侦听属性\",\"date\":\"2020-02-04 16:37:51\",\"permalink\":\"/pages/351f72ecd9c41129\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"计算属性 vs 方法 vs 侦听属性\",\"date\":\"2020-02-04 16:37:51\",\"excerpt\":\"<h1 id=\\\"计算属性-vs-方法-vs-侦听属性\\\" tabindex=\\\"-1\\\">计算属性 vs 方法 vs 侦听属性 <a class=\\\"header-anchor\\\" href=\\\"#计算属性-vs-方法-vs-侦听属性\\\" aria-label=\\\"Permalink to &quot;计算属性 vs 方法 vs 侦听属性&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/computed.html#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%BC%93%E5%AD%98-vs-%E6%96%B9%E6%B3%95\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">API</a></p>\\n<p>如果一个功能同时可以使用计算属性(computed)、方法(methods)、侦听属性(watch)来实现的时候推荐使用计算属性。</p>\\n\",\"capture\":\"API\\n如果一个功能同时可以使用计算属性(computed)、方法(methods)、侦听属性(watch)来实现的时候推荐使用计算属性。\\n| 计算属性                                 | 方法                                               | 侦听属性                                     |\\n| ---------------------------------------- | --------------------------------------------------\"},{\"url\":\"/《Vue》笔记/01.基础/10.生命周期.html\",\"relativePath\":\"/《Vue》笔记/01.基础/10.生命周期.html\",\"frontmatter\":{\"title\":\"生命周期\",\"date\":\"2020-02-04 15:06:59\",\"permalink\":\"/pages/176808a1b5f843b8\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"生命周期\",\"date\":\"2020-02-04 15:06:59\",\"excerpt\":\"<h1 id=\\\"实例生命周期钩子\\\" tabindex=\\\"-1\\\">实例生命周期钩子 <a class=\\\"header-anchor\\\" href=\\\"#实例生命周期钩子\\\" aria-label=\\\"Permalink to &quot;实例生命周期钩子&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/instance.html#%E5%AE%9E%E4%BE%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">实例生命周期钩子API</a></p>\\n<p>简单理解，生命周期钩子函数就是vue实例在某一个时间点会自动执行的函数。</p>\\n\",\"capture\":\"实例生命周期钩子API\\n简单理解，生命周期钩子函数就是vue实例在某一个时间点会自动执行的函数。\\n```html\\n&lt;div id=\\\"app\\\"\\n&lt;script src=\\\"https://cdn.bootcss.com/vue/2.4.2/vue.js\\\"&gt;&lt;/script&gt;\\n&lt;script&gt;\\n  var vm = new Vue({\\n    el: 'app',\\n    data: {\\n      msg: 'Vue的生命周期'\\n    },\\n    beforeCreate: function() {\\n      console.group('-----\"},{\"url\":\"/《Vue》笔记/06.规模化/140.路由懒加载.html\",\"relativePath\":\"/《Vue》笔记/06.规模化/140.路由懒加载.html\",\"frontmatter\":{\"title\":\"路由懒加载\",\"date\":\"2020-02-04 13:20:20\",\"permalink\":\"/pages/38ecac9a9b92f037\",\"categories\":[\"《Vue》笔记\",\"规模化\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"路由懒加载\",\"date\":\"2020-02-04 13:20:20\",\"capture\":\"```js\\n// 路由同步加载\\n// import Recommend from '@/components/recommend/recommend'\\n// import Singer from '@/components/singer/singer'\\n// import Rank from '@/components/rank/rank'\\n// import Search from '@/components/search/search'\\n// import SingerDetail from '@/components/singer-detail/singer-detail'\\n// imp\"},{\"url\":\"/《Vue》笔记/03.过渡&动画/120.transition-group列表过渡.html\",\"relativePath\":\"/《Vue》笔记/03.过渡&动画/120.transition-group列表过渡.html\",\"frontmatter\":{\"title\":\"transition-group列表过渡\",\"date\":\"2020-02-04 13:17:42\",\"permalink\":\"/pages/0aa92922ace6bb5e\",\"categories\":[\"《Vue》笔记\",\"过渡&动画\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"transition-group列表过渡\",\"date\":\"2020-02-04 13:17:42\",\"excerpt\":\"<h1 id=\\\"transition-group列表过渡\\\" tabindex=\\\"-1\\\">transition-group列表过渡 <a class=\\\"header-anchor\\\" href=\\\"#transition-group列表过渡\\\" aria-label=\\\"Permalink to &quot;transition-group列表过渡&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"列表的进入-离开过渡\\\" tabindex=\\\"-1\\\">列表的进入/离开过渡 <a class=\\\"header-anchor\\\" href=\\\"#列表的进入-离开过渡\\\" aria-label=\\\"Permalink to &quot;列表的进入/离开过渡&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<div class=\\\"language-html vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">html</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">&#x3C;</span><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">transition-group</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> tag</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"ul\\\"</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">> </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">&#x3C;!--tag转为ul--></span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">    &#x3C;</span><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">li</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> v-for</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"item in list\\\"</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> :key</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"item\\\"</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">>{{item}}&#x3C;/</span><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">li</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">> </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">&#x3C;!--子元素要有key--></span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">&#x3C;/</span><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">transition-group</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">></span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br></div></div><p><strong>注意</strong>：列表元素一定要有<code>key</code></p>\\n\",\"capture\":\"列表的进入/离开过渡\\n```html\\n&lt;transition-group tag=\\\"ul\\\"\\n    &lt;li v-for=\\\"item in list\\\" :key=\\\"item\\\"&gt;{{item}}&lt;/li&gt; &lt;!--子元素要有key--&gt;\\n&lt;/transition-group&gt;\\n```\\n注意：列表元素一定要有`key`\\n```css\\n.v-enter,.v-leave-to{\\n  opacity: 0;\\n  transform: translateX(30px);\\n}\\n.v-enter-active,.v-leave-active{\\n  tran\"},{\"url\":\"/《Vue》笔记/03.过渡&动画/110.transition过渡&动画.html\",\"relativePath\":\"/《Vue》笔记/03.过渡&动画/110.transition过渡&动画.html\",\"frontmatter\":{\"title\":\"transition过渡&动画\",\"date\":\"2020-02-04 13:16:19\",\"permalink\":\"/pages/184a96b493a97078\",\"categories\":[\"《Vue》笔记\",\"过渡&动画\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"transition过渡&动画\",\"date\":\"2020-02-04 13:16:19\",\"excerpt\":\"<h1 id=\\\"transition过渡-动画\\\" tabindex=\\\"-1\\\">transition过渡&amp;动画 <a class=\\\"header-anchor\\\" href=\\\"#transition过渡-动画\\\" aria-label=\\\"Permalink to &quot;transition过渡&amp;动画&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/transitions.html\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">API</a></p>\\n<h2 id=\\\"使用\\\" tabindex=\\\"-1\\\">使用 <a class=\\\"header-anchor\\\" href=\\\"#使用\\\" aria-label=\\\"Permalink to &quot;使用&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>需要设置动画的元素或组件要在外边包裹一个<code>&lt;transition&gt;</code>标签，设置自定义的<code>name</code>，vue会根据元素的切换（进入/离开）过程添加相应的css类名，你可以<strong>自由地使用css类名来设置css过渡&amp;动画</strong>。</p>\\n\",\"capture\":\"API\\n 使用\\n需要设置动画的元素或组件要在外边包裹一个`&lt;transition\\n 过渡的类名\\n在进入/离开的过渡中，会有 6 个 class 切换。\\n各类名的生命周期\\n* 进入\\n  * `v-enter` 只存在于第一帧\\n  * `v-enter-active` 第一帧到最后一帧，结束后移除\\n  * `v-enter-to` 第二帧到最后一帧，结束后移除\\n* 离开\\n  * `v-leave` 只存在于第一帧\\n  * `v-leave-active` 第一帧到最后一帧，结束后移除\\n  * `v-leave-to` 第二帧到最后一帧，结束后移除\\n如果你使用一个没有`name`的`&lt;t\"},{\"url\":\"/《Vue》笔记/06.规模化/100.vuex操作相关.html\",\"relativePath\":\"/《Vue》笔记/06.规模化/100.vuex操作相关.html\",\"frontmatter\":{\"title\":\"vuex操作相关\",\"date\":\"2020-02-04 13:15:19\",\"permalink\":\"/pages/d9d62d6ab8ff99a6\",\"categories\":[\"《Vue》笔记\",\"规模化\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"vuex操作相关\",\"date\":\"2020-02-04 13:15:19\",\"capture\":\"```js\\nimport { mapActions, mapMutations, mapGetters } from 'vuex'\\ncomputed: {\\n    ...mapGetters([ // 获取数据，内部为数组\\n        'searchHistory' // 相当于在data插入searchHistory和获取到的数据\\n    ])\\n},\\nmethods: {\\n\\t某方法(){\\n\\t  this.saveSearchHistory(传入值)\\n\\t},\\n\\t...mapActions([ // 提交actions修改数据，内部为数组 因为actions文件已对方法进行了封装所有是数组类\"},{\"url\":\"/《Vue》笔记/99.其他/90.操作本地缓存.html\",\"relativePath\":\"/《Vue》笔记/99.其他/90.操作本地缓存.html\",\"frontmatter\":{\"title\":\"操作本地缓存\",\"date\":\"2020-02-04 13:14:19\",\"permalink\":\"/pages/30a94dbe96873b33\",\"categories\":[\"《Vue》笔记\",\"其他\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"操作本地缓存\",\"date\":\"2020-02-04 13:14:19\",\"capture\":\"&lt;https://github.com/ustbhuangyi/storage\\n操作 sessionStorage 和 localStorage 。\"},{\"url\":\"/《Vue》笔记/99.其他/80.Vue中的防抖函数封装和使用.html\",\"relativePath\":\"/《Vue》笔记/99.其他/80.Vue中的防抖函数封装和使用.html\",\"frontmatter\":{\"title\":\"Vue中的防抖函数封装和使用\",\"date\":\"2020-02-04 13:10:19\",\"permalink\":\"/pages/fb08e252dfd8fdfd\",\"categories\":[\"《Vue》笔记\",\"其他\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Vue中的防抖函数封装和使用\",\"date\":\"2020-02-04 13:10:19\",\"capture\":\"Vue中的防抖函数封装和使用\\n如搜索框中，每改变一个数值就请求一次搜索接口，当快速的改变数值时并不需要多次请求接口，这就需要一个防抖函数：\\n```js\\n// 防抖函数\\nexport function debounce(func, delay) { // func 函数 delay间隔时间\\n  let timer\\n  return function (...args) {\\n    if (timer) {\\n      clearTimeout(timer)\\n    }\\n    timer = setTimeout(() =\\n      func.apply(this, args)\\n    }, \"},{\"url\":\"/《Vue》笔记/02.组件/70.父组件调用子组件方法并传入值.html\",\"relativePath\":\"/《Vue》笔记/02.组件/70.父组件调用子组件方法并传入值.html\",\"frontmatter\":{\"title\":\"父组件调用子组件方法并传入值\",\"date\":\"2020-02-04 13:06:37\",\"permalink\":\"/pages/2e24dab728769e0c\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"父组件调用子组件方法并传入值\",\"date\":\"2020-02-04 13:06:37\",\"capture\":\"通过`ref`引用调用子组件内的方法并传入参数\\n父组件：\\n```js\\n&lt;子组件标签  ref=\\\"refName\\\"\\nmethods: {\\n    fnX(x) {\\n      this.$refs.refName.fnY(x) // 调用子组件方法并传入值\\n    }\\n}\\n```\\n子组件：\\n```js\\nmethods: {\\n    fnY(x) {\\n      this.x = x\\n    }\\n  }\\n}\\n```\"},{\"url\":\"/《Vue》笔记/02.组件/60.兄弟组件传值.html\",\"relativePath\":\"/《Vue》笔记/02.组件/60.兄弟组件传值.html\",\"frontmatter\":{\"title\":\"兄弟组件传值\",\"date\":\"2020-02-04 13:04:32\",\"permalink\":\"/pages/809f4582d9ca9552\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"兄弟组件传值\",\"date\":\"2020-02-04 13:04:32\",\"capture\":\"子组件1中把值传到父组件,父组件获取值传入子组件2\\n父组件：\\n```js\\n&lt;子组件1 @方法名x=\\\"方法名y\\\"\\n&lt;子组件2 :值名称x=\\\"值x\\\"&gt;&lt;/子组件2 &gt;\\ndata() {\\n\\treturn {\\n\\t 值x: ''\\n\\t}\\n},\\nmethods: {\\n\\t方法名y(值) {\\n\\t\\tthis.值x = 值\\n\\t}\\n}\\n```\\n子组件1：\\n```js\\nthis.$emit('方法名x', 值) // 传出值\\n```\\n子组件2：\\n```js\\nprops: {\\n    值名称x: { // 接收父组件传入值\\n        type: String,\\n        defa\"},{\"url\":\"/《Vue》笔记/02.组件/50.子组件派发事件和值给父组件.html\",\"relativePath\":\"/《Vue》笔记/02.组件/50.子组件派发事件和值给父组件.html\",\"frontmatter\":{\"title\":\"子组件派发事件和值给父组件\",\"date\":\"2020-02-04 12:56:51\",\"permalink\":\"/pages/0f19a1bcac14fd41\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"子组件派发事件和值给父组件\",\"date\":\"2020-02-04 12:56:51\",\"excerpt\":\"<h1 id=\\\"子组件派发事件和值给父组件\\\" tabindex=\\\"-1\\\">子组件派发事件和值给父组件 <a class=\\\"header-anchor\\\" href=\\\"#子组件派发事件和值给父组件\\\" aria-label=\\\"Permalink to &quot;子组件派发事件和值给父组件&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/components.html#%E7%9B%91%E5%90%AC%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">API</a></p>\\n<p>子组件通过<code>$emit</code>派发事件和值给父组件（值可以有多个）</p>\\n<div class=\\\"language-js vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">js</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">this</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">$emit</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'fnX'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, value)</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br></div></div>\",\"capture\":\"API\\n子组件通过`$emit`派发事件和值给父组件（值可以有多个）\\n```js\\nthis.$emit('fnX', value)\\n```\\n父组件通过`v-on`绑定子组件派发的事件，并触发一个新的事件，新的事件内可以接收传来的值\\n```js\\n&lt;ComponentName @fnX=\\\"fnY\\\"\\nmethods: {\\n\\tfnY(value) {\\n\\t\\tconsole.log(value)\\n\\t}\\n}\\n```\\n 父子组件间传递数据 demo\\n&lt;p class=\\\"codepen\\\" data-height=\\\"400\\\" data-theme-id=\\\"light\\\" data-default-tab\"},{\"url\":\"/《Vue》笔记/02.组件/40.父组件给子组件传值.html\",\"relativePath\":\"/《Vue》笔记/02.组件/40.父组件给子组件传值.html\",\"frontmatter\":{\"title\":\"父组件给子组件传值\",\"date\":\"2020-02-04 12:45:30\",\"permalink\":\"/pages/07b384c2e6232e07\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"父组件给子组件传值\",\"date\":\"2020-02-04 12:45:30\",\"excerpt\":\"<h1 id=\\\"父组件给子组件传值\\\" tabindex=\\\"-1\\\">父组件给子组件传值 <a class=\\\"header-anchor\\\" href=\\\"#父组件给子组件传值\\\" aria-label=\\\"Permalink to &quot;父组件给子组件传值&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>父组件中，通过给子组件标签v-bind绑定属性的方式传入值</p>\\n<div class=\\\"language-html vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">html</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">&#x3C;</span><span style=\\\"--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic\\\">ComponentName</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> v-bind:name</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"value\\\"</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">>&#x3C;/</span><span style=\\\"--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic\\\">ComponentName</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">></span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br></div></div><blockquote>\\n<p>如果不使用v-bind传入的值为字符串，使用v-bind绑定传入的值为表达式。</p>\\n</blockquote>\\n\",\"capture\":\"父组件中，通过给子组件标签v-bind绑定属性的方式传入值\\n```html\\n&lt;ComponentName v-bind:name=\\\"value\\\"\\n```\\n&gt; 如果不使用v-bind传入的值为字符串，使用v-bind绑定传入的值为表达式。\\n子组件中，通过props对象接收值\\n```js\\n props: {\\n    name: { // 接收父组件传入值\\n        type: String || ...,\\n        default: ''\\n    }\\n }\\n```\\n 单向数据流\\n所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向\"},{\"url\":\"/《Vue》笔记/01.基础/00.MVVM模式.html\",\"relativePath\":\"/《Vue》笔记/01.基础/00.MVVM模式.html\",\"frontmatter\":{\"title\":\"MVVM模式\",\"date\":\"2020-02-04 12:19:00\",\"permalink\":\"/pages/114158caa9e96df0\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"MVVM模式\",\"date\":\"2020-02-04 12:19:00\",\"excerpt\":\"<div class=\\\"tip custom-block\\\"><p class=\\\"custom-block-title\\\">TIP</p>\\n<p>说明：本章内容是博主的Vue学习笔记，以<a href=\\\"https://cn.vuejs.org/v2/guide/\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">官方文档</a>为准。</p>\\n</div>\\n<h1 id=\\\"mvvm模式\\\" tabindex=\\\"-1\\\">MVVM模式 <a class=\\\"header-anchor\\\" href=\\\"#mvvm模式\\\" aria-label=\\\"Permalink to &quot;MVVM模式&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>MVVM模式，<code>M</code>即 model，数据模型；<code>V</code>即 view，视图；<code>VM</code>即 view-model，视图模型。</p>\\n\",\"capture\":\"说明：本章内容是博主的Vue学习笔记，以官方文档为准。\\n MVVM模式\\nMVVM模式，`M`即 model，数据模型；`V`即 view，视图；`VM`即 view-model，视图模型。\\n理解\\n首先，数据Model通过Data Bindings把数据绑定在View视图上，\\n当View视图有交互（有改变）的时候，Dom listeners会自动监听，然后更新数据Model。\\nQ：什么是MVVM模式？\\nA：MVVM模式，第一个M代表数据模型，V代表视图，VM代表视图模型；\\n它的实际操作原理是：后台数据通过视图模型来渲染视图，就是页面。当用户在页面上进行操作的时候，\\n视图模型会自动监听到用户的操作\"},{\"url\":\"/《ES6 教程》笔记/01.ECMAScript 6 简介.html\",\"relativePath\":\"/《ES6 教程》笔记/01.ECMAScript 6 简介.html\",\"frontmatter\":{\"title\":\"ECMAScript 6 简介\",\"date\":\"2020-01-12 15:45:35\",\"permalink\":\"/pages/f344d070a1031ef7\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"ECMAScript 6 简介\",\"date\":\"2020-01-12 15:45:35\",\"excerpt\":\"<blockquote>\\n<p>说明：本章内容为博主在原教程基础上添加自己的学习笔记，来源<a href=\\\"http://es6.ruanyifeng.com/\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">http://es6.ruanyifeng.com/</a>，教程版权归原作者所有。</p>\\n</blockquote>\\n<h1 id=\\\"ecmascript-6-简介\\\" tabindex=\\\"-1\\\">ECMAScript 6 简介 <a class=\\\"header-anchor\\\" href=\\\"#ecmascript-6-简介\\\" aria-label=\\\"Permalink to &quot;ECMAScript 6 简介&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p>\\n\",\"capture\":\"ECMAScript 6 简介\\nECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。\\n ECMAScript 和 JavaScript 的关系\\n一个常见的问题是，ECMAScript 和 JavaScript 到底是什么关系？\\n要讲清楚这个问题，需要回顾历史。1996 年 11 月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给标准化组织 ECMA，希望这种语言能够成为国际标\"},{\"url\":\"/《JavaScript教程》笔记/01.基础.html\",\"relativePath\":\"/《JavaScript教程》笔记/01.基础.html\",\"frontmatter\":{\"title\":\"基础\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/0796ba76b4b55368\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"基础\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"基础篇\\n 一、JS的一些名词概念\\n 什么是作用域？\\n变量存在的范围。\\n可分为全局作用域和函数作用域，ES6新增块级作用域。\\n 什么是闭包？\\n闭包就是能够读取其他函数内部变量的函数。\\n* 闭包的形式：函数内部定义函数\\n* 本质上闭包就是将函数内部和外部连接起来的一座桥梁\\n闭包的作用：\\n* 可以读取函数内部变量\\n* 让这些变量始终保持在内存中，即闭包可以使得它诞生的环境一直存在。\\n*  封装对象的私有属性和私有方法\\n 什么是构造函数？\\n用于构造(生成)实例的一个函数，使实例拥有构造函数内定于的属性和方法。\\n 什么是实例对象？\\n实例对象就是通过new 构造函数生成的，拥有构造函数内定于的属性和方法的\"},{\"url\":\"/《JavaScript教程》笔记/02.内置对象.html\",\"relativePath\":\"/《JavaScript教程》笔记/02.内置对象.html\",\"frontmatter\":{\"title\":\"内置对象\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/74d2ab3fbfeaaa68\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"内置对象\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"内置对象篇\\n 一、Object对象\\n 1、概述\\nJavaScript 原生提供`Object`对象（注意起首的`O`是大写），本章介绍该对象原生的各种方法。\\nJavaScript 的所有其他对象都继承自`Object`对象，即那些对象都是`Object`的实例。\\n`Object`对象的原生方法分成两类：`Object`本身的方法与`Object`的实例方法。\\n（1）Object对象本身的方法\\n所谓“本身的方法”就是直接定义在`Object`对象的方法。\\n```js\\nObject.print = function (o) { console.log(o) };\\n```\\n上面代码中，`print`\"},{\"url\":\"/《JavaScript教程》笔记/03.面向对象.html\",\"relativePath\":\"/《JavaScript教程》笔记/03.面向对象.html\",\"frontmatter\":{\"title\":\"面向对象\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/659b5af5e2e704e0\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"面向对象\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"面向对象编程\\n 一、实例对象与new命令\\n 1、对象是什么\\n面向对象编程（Object Oriented Programming，缩写为 OOP）是目前主流的编程范式。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。\\n每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务。对象可以复用，通过继承机制还可以定制。因此，面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程（procedural programming），更适合多人合作的大型软件项目。\\n那么，“对象”\"},{\"url\":\"/《JavaScript教程》笔记/04.异步操作.html\",\"relativePath\":\"/《JavaScript教程》笔记/04.异步操作.html\",\"frontmatter\":{\"title\":\"异步操作\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/d61b1cb4cdac1f63\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"异步操作\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"异步操作\\n 一、异步操作概述\\n 1、单线程模型\\n单线程模型指的是，JavaScript 只在一个线程上运行。也就是说，JavaScript 同时只能执行一个任务，其他任务都必须在后面排队等待。\\n注意，JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合。\\nJavaScript 之所以采用单线程，而不是多线程，跟历史有关系。JavaScript 从诞生起就是单线程，原因是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对\"},{\"url\":\"/《JavaScript教程》笔记/05.DOM.html\",\"relativePath\":\"/《JavaScript教程》笔记/05.DOM.html\",\"frontmatter\":{\"title\":\"DOM\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/7d961b8030c6099e\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"DOM\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"DOM\\n 一、概述\\n 1、DOM\\nDOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。\\n浏览器会根据 DOM 模型，将结构化文档（比如 HTML 和 XML）解析成一系列的节点，再由这些节点组成一个树状结构（DOM Tree）。所有的节点和最终的树状结构，都有规范的对外接口。\\nDOM 只是一个接口规范，可以用各种语言实现。所以严格地说，DOM 不是 JavaScript 语法的一部分，但是 DOM 操作是 JavaScript 最\"},{\"url\":\"/《JavaScript教程》笔记/06.事件.html\",\"relativePath\":\"/《JavaScript教程》笔记/06.事件.html\",\"frontmatter\":{\"title\":\"事件\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/10b2761db5a8e089\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"事件\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"事件\\n 一、EventTarget 接口\\n 事件的本质是程序各个组成部分之间的一种通信方式，也是异步编程的一种实现。DOM 支持大量的事件，本章开始介绍 DOM 的事件编程。\\n 1、概述\\nDOM 的事件操作（监听和触发），都定义在`EventTarget`接口。所有节点对象都部署了这个接口，其他一些需要事件通信的浏览器内置对象（比如，`XMLHttpRequest`、`AudioNode`、`AudioContext`）也部署了这个接口。\\n该接口主要提供三个实例方法。\\n- `addEventListener`：绑定事件的监听函数\\n- `removeEventListener`：移除事件的监听函\"},{\"url\":\"/《JavaScript教程》笔记/07.浏览器模型.html\",\"relativePath\":\"/《JavaScript教程》笔记/07.浏览器模型.html\",\"frontmatter\":{\"title\":\"浏览器模型\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/bab4930124ad2c10\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"浏览器模型\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"一、浏览器环境概述\\nJavaScript 是浏览器的内置脚本语言。也就是说，浏览器内置了 JavaScript 引擎，并且提供各种接口，让 JavaScript 脚本可以控制浏览器的各种功能。一旦网页内嵌了 JavaScript 脚本，浏览器加载网页，就会去执行脚本，从而达到操作浏览器的目的，实现网页的各种动态效果。\\n本章开始介绍浏览器提供的各种 JavaScript 接口。首先，介绍 JavaScript 代码嵌入网页的方法。\\n 1、代码嵌入网页的方法\\n网页中嵌入 JavaScript 代码，主要有三种方法。\\n- `  &lt;script\\n- `  &lt;script&gt;  `标签加\"},{\"url\":\"/01.前端/25.JavaScript文章/08.判断是否为移动端浏览器.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/08.判断是否为移动端浏览器.html\",\"frontmatter\":{\"title\":\"判断是否为移动端浏览器\",\"date\":\"2020-01-04 15:25:11\",\"permalink\":\"/pages/40f623be692cf8bc\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"判断是否为移动端浏览器\",\"date\":\"2020-01-04 15:25:11\",\"capture\":\"```js\\nconst flag = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);\\nif(flag){\\n    // 移动端\\n} else {\\n    // PC端\\n}\\n```\"},{\"url\":\"/04.更多/01.学习/03.提高记忆的技巧.html\",\"relativePath\":\"/04.更多/01.学习/03.提高记忆的技巧.html\",\"frontmatter\":{\"title\":\"提高记忆的技巧\",\"date\":\"2020-01-03 14:34:48\",\"permalink\":\"/pages/996822b2a2ca6e3b\",\"categories\":[\"更多\",\"学习\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"提高记忆的技巧\",\"date\":\"2020-01-03 14:34:48\",\"excerpt\":\"<h1 id=\\\"提高记忆的技巧\\\" tabindex=\\\"-1\\\">提高记忆的技巧 <a class=\\\"header-anchor\\\" href=\\\"#提高记忆的技巧\\\" aria-label=\\\"Permalink to &quot;提高记忆的技巧&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<ol>\\n<li><strong>多个感官并用</strong>\\n记忆时调用一切感官。没人的话可以大声阅读，有人的话可以默念，轻微摇晃手指等，有助于保持专注。</li>\\n</ol>\\n\",\"capture\":\"1. 多个感官并用\\n   记忆时调用一切感官。没人的话可以大声阅读，有人的话可以默念，轻微摇晃手指等，有助于保持专注。\\n   \\n2. 重复记忆\\n   每天留出半个到一个小时，梳理总结今天所学的内容。每一章复习完成后做系统的知识整理。\\n   \\n3. 建立关联\\n   把你所学的新知识与已有的认知建立联系，对于记忆事半功倍。\\n   \\n4. 场景记忆\\n   把知识具象化为一个场景，想象自己在何时何地能用这些知识，与自身发生联系。\\n   \\n5. 提出问题\\n   每学习一个知识点，试着提问，然后给出答案。用了就记住了。\"},{\"url\":\"/03.技术/03.博客搭建/03.GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床.html\",\"relativePath\":\"/03.技术/03.博客搭建/03.GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床.html\",\"frontmatter\":{\"title\":\"GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床\",\"date\":\"2020-01-03 12:55:43\",\"permalink\":\"/pages/a5f73af5185fdf0a\",\"categories\":[\"技术\",\"博客搭建\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床\",\"date\":\"2020-01-03 12:55:43\",\"excerpt\":\"<h1 id=\\\"github-jsdelivr-tinypng-picgo-打造稳定快速、高效免费图床\\\" tabindex=\\\"-1\\\">GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床 <a class=\\\"header-anchor\\\" href=\\\"#github-jsdelivr-tinypng-picgo-打造稳定快速、高效免费图床\\\" aria-label=\\\"Permalink to &quot;GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"前言\\\" tabindex=\\\"-1\\\">前言 <a class=\\\"header-anchor\\\" href=\\\"#前言\\\" aria-label=\\\"Permalink to &quot;前言&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p><strong>Q：为什么要使用图床呢？什么是图床？</strong></p>\\n<p>A：写博客文章时，图片的上传和存放是一个问题，有的朋友可能会把图片放到和博客同一个仓库当中，使用相对路径来引用，这样后期维护起来会比较麻烦。还有的朋友会在不同的平台发布同一篇文章，这样一来每个平台都要上传图片，为了解决这些问题，比较推荐的做法是把图片统一上传到一个在线的第三方静态资源库中，我们把这个资源库称为图床，其返回一个图片的URL，使用<code>markdown+图片url</code>的方式写作文章，一次编写，到处使用~</p>\\n\",\"capture\":\"前言\\nQ：为什么要使用图床呢？什么是图床？\\nA：写博客文章时，图片的上传和存放是一个问题，有的朋友可能会把图片放到和博客同一个仓库当中，使用相对路径来引用，这样后期维护起来会比较麻烦。还有的朋友会在不同的平台发布同一篇文章，这样一来每个平台都要上传图片，为了解决这些问题，比较推荐的做法是把图片统一上传到一个在线的第三方静态资源库中，我们把这个资源库称为图床，其返回一个图片的URL，使用`markdown+图片url`的方式写作文章，一次编写，到处使用~\\n以下内容是比较旧的，现在我发现一个更好用，配置更方便的图床工具：&lt;https://picx.xpoet.cn/\\n使用方法看一下他网站的使\"}],\"2019 \":[{\"url\":\"/03.技术/02.Nodejs/01.nodejs递归读取所有文件.html\",\"relativePath\":\"/03.技术/02.Nodejs/01.nodejs递归读取所有文件.html\",\"frontmatter\":{\"title\":\"nodejs递归读取所有文件\",\"date\":\"2019-12-26 15:57:32\",\"permalink\":\"/pages/117708e0af7f0bd9\",\"categories\":[\"技术\",\"Nodejs\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"nodejs递归读取所有文件\",\"date\":\"2019-12-26 15:57:32\",\"capture\":\"```js\\nvar fs = require('fs');\\nvar path = require('path');\\n \\nfunction readFileList(dir, filesList = []) {\\n    const files = fs.readdirSync(dir);\\n    console.log(files);\\n    files.forEach((item, index) =\\n        var fullPath = path.join(dir, item);\\n        const stat = fs.statSync(fullPath);\\n        i\"},{\"url\":\"/01.前端/25.JavaScript文章/02.new命令原理.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/02.new命令原理.html\",\"frontmatter\":{\"title\":\"new命令原理\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/8143cc480faf9a11\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"new命令原理\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"new命令原理\\\" tabindex=\\\"-1\\\">new命令原理 <a class=\\\"header-anchor\\\" href=\\\"#new命令原理\\\" aria-label=\\\"Permalink to &quot;new命令原理&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>使用new命令时，它后面的函数依次执行下面的步骤：</p>\\n<ol>\\n<li>创建一个空对象，作为将要返回的实例对象。</li>\\n<li>将这个空对象的原型，指向构造函数的prototype属性。</li>\\n<li>将这个空对象赋值给函数内部的this关键字。</li>\\n<li>开始执行构造函数内部的代码。</li>\\n<li>如果构造函数内有返回值且为对象类型，则返回该对象，否则返回上面创建的实例对象。</li>\\n</ol>\\n\",\"capture\":\"使用new命令时，它后面的函数依次执行下面的步骤：\\n1. 创建一个空对象，作为将要返回的实例对象。\\n2. 将这个空对象的原型，指向构造函数的prototype属性。\\n3. 将这个空对象赋值给函数内部的this关键字。\\n4. 开始执行构造函数内部的代码。\\n5. 如果构造函数内有返回值且为对象类型，则返回该对象，否则返回上面创建的实例对象。\\n```js\\n// 构造函数\\nfunction Person(name,age){\\n    this.name = name\\n    this.age = age\\n}\\n// 自定义_new\\nfunction _new() {\\n  // 将 arguments 对\"},{\"url\":\"/01.前端/25.JavaScript文章/04.ES6面向对象.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/04.ES6面向对象.html\",\"frontmatter\":{\"title\":\"ES6面向对象\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/1f4123be6f45abcd\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"ES6面向对象\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```js\\n//面向对象封装\\nclass Student{ //定义类 (尊从首字母大写的约定)\\n    constructor(props){  // 构造函数 （构造函数内定于属性）\\n        this.name = props.name || '匿名'; // 默认'匿名'\\n      this.grade = props.grade || 1;\\n    }\\n    hello(){ // 在构造函数的原型上定义方法\\n        console.log(`你好,${this.name}同学，你在${this.grade}年级`);\\n    }\\n}\\n//使用\\nfunction c\"},{\"url\":\"/01.前端/25.JavaScript文章/06.多种数组去重性能对比.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/06.多种数组去重性能对比.html\",\"frontmatter\":{\"title\":\"多种数组去重性能对比\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/e808fba1fa8fbab2\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"多种数组去重性能对比\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"测试模板\\n```js\\n// 创建一个 1 ~ 10w 的数组，Array.from为ES6语法\\nlet arr1 = Array.from(new Array(1000000), (x, index) =\\n  return index\\n})\\nlet arr2 = Array.from(new Array(500000), (x, index) =&gt; {\\n  return index + index\\n})\\nlet start = new Date().getTime()\\nconsole.log('开始数组去重')\\n// 数组去重\\nfunction distinct(a, b) {\\n  le\"},{\"url\":\"/01.前端/40.学习笔记/40.小程序笔记.html\",\"relativePath\":\"/01.前端/40.学习笔记/40.小程序笔记.html\",\"frontmatter\":{\"title\":\"小程序笔记\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/note/wx-miniprogram/\",\"tags\":[\"小程序\"],\"categories\":[\"前端\",\"学习笔记\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"小程序笔记\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"小程序笔记\\n 基础课程部分\\n 微信公众平台\\n&lt;https://mp.weixin.qq.com/\\n注册时可选择类型：订阅号、服务号、小程序、企业微信\\n每个邮箱仅能注册一个小程序。\\n个人类型小程序：无法使用微信支付、无法使用卡包功能\\n 小程序文档API\\n小程序开发文档\\n 微信开放社区\\n微信开发社区\\n 目录说明\\n默认目录\\npages-----------------------页面相关\\n​\\tindex  ----------------- 首页文件夹\\n​\\t\\tindex.js ------------首页js\\n​\\t\\tindex.json---------首页配置\\n​\\t\\tindex.wxml--\"},{\"url\":\"/02.页面/20.CSS/01.flex布局语法.html\",\"relativePath\":\"/02.页面/20.CSS/01.flex布局语法.html\",\"frontmatter\":{\"title\":\"flex布局语法\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/0a83b083bdf257cb\",\"author\":{\"name\":\"阮一峰\"},\"categories\":[\"页面\",\"CSS\"],\"tags\":[null]},\"author\":{\"name\":\"阮一峰\"},\"title\":\"flex布局语法\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"flex布局语法\\\" tabindex=\\\"-1\\\">flex布局语法 <a class=\\\"header-anchor\\\" href=\\\"#flex布局语法\\\" aria-label=\\\"Permalink to &quot;flex布局语法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"一、flex-布局是什么\\\" tabindex=\\\"-1\\\">一、flex 布局是什么？ <a class=\\\"header-anchor\\\" href=\\\"#一、flex-布局是什么\\\" aria-label=\\\"Permalink to &quot;一、flex 布局是什么？&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>Flex是 Flexible Box 的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性。</p>\\n<p><strong>任何一个容器</strong> 都可以指定为 Flex 布局。</p>\\n\",\"capture\":\"一、flex 布局是什么？\\nFlex是 Flexible Box 的缩写，意为\\\"弹性布局\\\"，用来为盒状模型提供最大的灵活性。\\n任何一个容器 都可以指定为 Flex 布局。\\n```css\\n.box{\\n  display: flex;\\n}\\n```\\n行内元素 也可以使用 Flex 布局。\\n```css\\n.box{\\n  display: inline-flex;\\n}\\n```\\nWebkit 内核的浏览器，必须加上`-webkit`前缀。\\n```css\\n.box{\\n  display: -webkit-flex; /* Safari */\\n  display: flex;\\n}\\n```\\n注意，设为 Flex\"},{\"url\":\"/02.页面/20.CSS/02.flex布局案例-基础.html\",\"relativePath\":\"/02.页面/20.CSS/02.flex布局案例-基础.html\",\"frontmatter\":{\"title\":\"flex布局案例-基础\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/ea6db1530c42ad51\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"flex布局案例-基础\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"``` html\\n&lt;html&gt;\\n  &lt;div class=\\\"box\\\"&gt;\\n    &lt;span&gt;1&lt;/span&gt;\\n    &lt;span&gt;2&lt;/span&gt;\\n    &lt;span&gt;3&lt;/span&gt;\\n    &lt;span&gt;4&lt;/span&gt;\\n    &lt;span&gt;5&lt;/span&gt;\\n    &lt;span&gt;6&lt;/span&gt;\\n    &lt;span&gt;7&lt;/span&gt;\\n  &lt;/div&gt;\\n&lt;/html&gt;\\n&lt;st\"},{\"url\":\"/02.页面/20.CSS/03.flex布局案例-骰子.html\",\"relativePath\":\"/02.页面/20.CSS/03.flex布局案例-骰子.html\",\"frontmatter\":{\"title\":\"flex布局案例-骰子\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/eff61bc8b4f4695d\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"flex布局案例-骰子\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```html\\n&lt;html&gt;\\n  &lt;div class=\\\"box2\\\"&gt;\\n    &lt;div class=\\\"first-face\\\"&gt;\\n      &lt;span class=\\\"pip\\\"&gt;&lt;/span&gt;\\n    &lt;/div&gt;\\n    &lt;div class=\\\"second-face\\\"&gt;\\n      &lt;span class=\\\"pip\\\"&gt;&lt;/span&gt;\\n      &lt;span class=\\\"pip\\\"&gt;&lt;/span&gt;\\n    &lt;/div&gt;\\n    &lt;div cla\"},{\"url\":\"/02.页面/20.CSS/04.flex布局案例-圣杯布局.html\",\"relativePath\":\"/02.页面/20.CSS/04.flex布局案例-圣杯布局.html\",\"frontmatter\":{\"title\":\"flex布局案例-圣杯布局\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/df9e7c7214fa5046\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"flex布局案例-圣杯布局\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```html\\n&lt;html&gt;\\n  &lt;div class=\\\"HolyGrail\\\"&gt;\\n    &lt;header&gt;header&lt;/header&gt;\\n    &lt;div class=\\\"wrap\\\"&gt;\\n      &lt;nav class=\\\"left\\\"&gt;left 宽度固定200px&lt;/nav&gt;\\n      &lt;main class=\\\"content\\\"&gt;center 宽度自适应&lt;/main&gt;\\n      &lt;aside class=\\\"right\\\"&gt;right 宽度固定200px&lt;/aside&gt\"},{\"url\":\"/02.页面/20.CSS/05.flex布局案例-网格布局.html\",\"relativePath\":\"/02.页面/20.CSS/05.flex布局案例-网格布局.html\",\"frontmatter\":{\"title\":\"flex布局案例-网格布局\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/85b5a3fe218a34b7\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"flex布局案例-网格布局\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```html\\n&lt;html&gt;\\n  &lt;div class=\\\"grid\\\"&gt;\\n    &lt;div class=\\\"grid-cell\\\"&gt;1/2&lt;/div&gt;\\n    &lt;div class=\\\"grid-cell\\\"&gt;1/2&lt;/div&gt;\\n  &lt;/div&gt;\\n  &lt;div class=\\\"grid\\\"&gt;\\n    &lt;div class=\\\"grid-cell\\\"&gt;1/3&lt;/div&gt;\\n    &lt;div class=\\\"grid-cell\\\"&gt;1/3&lt;/div&gt;\\n    &lt;div cl\"},{\"url\":\"/02.页面/20.CSS/06.flex布局案例-输入框布局.html\",\"relativePath\":\"/02.页面/20.CSS/06.flex布局案例-输入框布局.html\",\"frontmatter\":{\"title\":\"flex布局案例-输入框布局\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/05cc577fb51c7998\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"flex布局案例-输入框布局\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```html\\n&lt;html&gt;\\n  &lt;div class=\\\"InputAddOn\\\"&gt;\\n    &lt;span class=\\\"InputAddOn-item\\\"&gt;icon&lt;/span&gt;\\n    &lt;input class=\\\"InputAddOn-field\\\" placeholder=\\\"input宽度自适应\\\"&gt;\\n    &lt;button class=\\\"InputAddOn-item\\\"&gt;提交&lt;/button&gt;\\n  &lt;/div&gt;\\n  &lt;br/&gt;\\n  &lt;div class=\\\"Media\\\"&gt;\\n   \"},{\"url\":\"/02.页面/20.CSS/07.CSS3之transition过渡.html\",\"relativePath\":\"/02.页面/20.CSS/07.CSS3之transition过渡.html\",\"frontmatter\":{\"title\":\"CSS3之transition过渡\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/02d7f59d98d87409\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"CSS3之transition过渡\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"html结构\\n```html\\n&lt;div class=\\\"box1\\\"\\n  &lt;div class=\\\"div1\\\"&gt;&lt;/div&gt;\\n  &lt;div class=\\\"div2\\\"&gt;&lt;/div&gt;\\n  &lt;div class=\\\"div3\\\"&gt;&lt;/div&gt;\\n&lt;/div&gt;\\n```\\n先给元素设置transition过渡，指定样式和时间，这里设置all全部样式都采用0.3s的过渡\\n```css\\n.box1&gt;div{\\n  /* 给元素所有变化都添加过渡动画, 也可以指定唯一的过渡样式属性*/\\n  transition: all .3s;\"},{\"url\":\"/02.页面/20.CSS/08.CSS3之animation动画.html\",\"relativePath\":\"/02.页面/20.CSS/08.CSS3之animation动画.html\",\"frontmatter\":{\"title\":\"CSS3之animation动画\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/c2c0432138f6e042\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"CSS3之animation动画\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```html\\n&lt;html&gt;\\n  &lt;div class=\\\"animationBox\\\"&gt;\\n    &lt;div class=\\\"rotate\\\"&gt;旋转动画1&lt;/div&gt;\\n    &lt;div class=\\\"play\\\"&gt;\\n      &lt;div class=\\\"img\\\"&gt;旋转动画2&lt;/div&gt;\\n      &lt;span&gt;&lt;p class=\\\"p2\\\"&gt;&lt;/p&gt;&lt;/span&gt;\\n      &lt;span&gt;&lt;p&gt;&lt;/p&gt;&lt;/span&gt;\\n      &\"},{\"url\":\"/03.技术/01.技术文档/01.Git使用手册.html\",\"relativePath\":\"/03.技术/01.技术文档/01.Git使用手册.html\",\"frontmatter\":{\"title\":\"Git使用手册\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/9a7ee40fc232253e\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git使用手册\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"git使用手册\\\" tabindex=\\\"-1\\\">Git使用手册 <a class=\\\"header-anchor\\\" href=\\\"#git使用手册\\\" aria-label=\\\"Permalink to &quot;Git使用手册&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"安装\\\" tabindex=\\\"-1\\\">安装 <a class=\\\"header-anchor\\\" href=\\\"#安装\\\" aria-label=\\\"Permalink to &quot;安装&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>官网下载：<a href=\\\"https://git-scm.com/downloads\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">https://git-scm.com/downloads</a> 下载完成后使用默认进行安装。</p>\\n<p>安装完成后，在开始菜单里找到 <code>Git</code> -&gt; <code>Git Bash</code>，蹦出一个类似命令行窗口的东西，就说明Git安装成功！\\n还需要最后一步设置，在命令行输入：</p>\\n<div class=\\\"language-bash vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">bash</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">git</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> config</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> --global</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> user.name</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> \\\"Your Name\\\"</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">git</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> config</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> --global</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> user.email</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> \\\"email@example.com\\\"</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br></div></div><p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。</p>\\n\",\"capture\":\"Git使用手册\\n 安装\\n官网下载：&lt;https://git-scm.com/downloads\\n安装完成后，在开始菜单里找到 `Git` -&gt; `Git Bash`，蹦出一个类似命令行窗口的东西，就说明Git安装成功！\\n还需要最后一步设置，在命令行输入：\\n```bash\\ngit config --global user.name \\\"Your Name\\\"\\ngit config --global user.email \\\"email@example.com\\\"\\n```\\n因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。\\n 创建版本库（仓库）\\n```ba\"},{\"url\":\"/03.技术/01.技术文档/02.Markdown使用教程.html\",\"relativePath\":\"/03.技术/01.技术文档/02.Markdown使用教程.html\",\"frontmatter\":{\"title\":\"Markdown使用教程\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/ad247c4332211551\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Markdown使用教程\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"markdown使用教程\\\" tabindex=\\\"-1\\\">Markdown使用教程 <a class=\\\"header-anchor\\\" href=\\\"#markdown使用教程\\\" aria-label=\\\"Permalink to &quot;Markdown使用教程&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"一、markdown\\\" tabindex=\\\"-1\\\">一、Markdown <a class=\\\"header-anchor\\\" href=\\\"#一、markdown\\\" aria-label=\\\"Permalink to &quot;一、Markdown&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p><img src=\\\"https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/md_logo.png\\\" alt=\\\"logo\\\"></p>\\n<p><code>Markdown</code> 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>\\n\",\"capture\":\"一、Markdown\\n 简介\\n`Markdown` 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。\\n  应用\\n当前许多网站都广泛使用 `Markdown` 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、知乎等\\n 编辑器\\n推荐使用`Typora`，官网：&lt;https://typora.io/\\n 二、徽章\\n 什么是徽章\\n徽章是一种小巧精美的小图标，一般配有相关文字进行辅助说明，可对数据进行监控，链接跳转等，富有表现力。\\n常见于`github`项目主页，但其不仅出现于 `github` 项目主页，凡是能够表现图片的地方都可以出现徽章。\\n 徽章的使用\\n* 在\"},{\"url\":\"/03.技术/01.技术文档/03.npm常用命令.html\",\"relativePath\":\"/03.技术/01.技术文档/03.npm常用命令.html\",\"frontmatter\":{\"title\":\"npm常用命令\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/61f2f95fd7da14fd\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"npm常用命令\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"npm常用命令\\\" tabindex=\\\"-1\\\">npm常用命令 <a class=\\\"header-anchor\\\" href=\\\"#npm常用命令\\\" aria-label=\\\"Permalink to &quot;npm常用命令&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>npm是跟随node一起安装的包（模块）管理器。常见的使用场景有以下几种：</p>\\n<ul>\\n<li>允许用户从npm服务器下载别人编写的第三方包到本地使用。</li>\\n<li>允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用。</li>\\n<li>允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。</li>\\n</ul>\\n\",\"capture\":\"简介\\nnpm是跟随node一起安装的包（模块）管理器。常见的使用场景有以下几种：\\n* 允许用户从npm服务器下载别人编写的第三方包到本地使用。\\n* 允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用。\\n* 允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。\\n 常用命令\\n 检测是否安装及版本\\n```sh\\nnpm -v  显示版本号说明已经安装相应的版本\\n```\\n 生成package.json文件\\n```sh\\nnpm init\\n```\\n\\n 安装模块\\n```sh\\nnpm install  安装package.json定义好的模块，简写 npm i\\n 安装包指定模块\\nnpm \"},{\"url\":\"/03.技术/01.技术文档/15.yaml语言教程.html\",\"relativePath\":\"/03.技术/01.技术文档/15.yaml语言教程.html\",\"frontmatter\":{\"title\":\"yaml语言教程\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/4e8444e2d534d14f\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"yaml语言教程\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"yaml语言教程\\\" tabindex=\\\"-1\\\">yaml语言教程 <a class=\\\"header-anchor\\\" href=\\\"#yaml语言教程\\\" aria-label=\\\"Permalink to &quot;yaml语言教程&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>YAML 是 &quot;YAML Ain't a Markup Language&quot;（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：&quot;Yet Another Markup Language&quot;（仍是一种标记语言）。</p>\\n\",\"capture\":\"简介\\nYAML 是 \\\"YAML Ain't a Markup Language\\\"（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：\\\"Yet Another Markup Language\\\"（仍是一种标记语言）。\\nYAML 的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲（例如：许多电子邮件标题格式和YAML非常接近）。\\nYAML 的配置文件后缀为 .yml，如：runoob.yml 。\\n\\n 基本语法\\n- 大小写敏感\\n- 使用缩进\"},{\"url\":\"/03.技术/03.博客搭建/01.解决百度无法收录搭建在GitHub上的个人博客的问题.html\",\"relativePath\":\"/03.技术/03.博客搭建/01.解决百度无法收录搭建在GitHub上的个人博客的问题.html\",\"frontmatter\":{\"title\":\"解决百度无法收录搭建在GitHub上的个人博客的问题\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/41f87d890d0a02af\",\"categories\":[\"技术\",\"博客搭建\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"解决百度无法收录搭建在GitHub上的个人博客的问题\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"解决百度无法收录搭建在github上的静态博客的问题\\\" tabindex=\\\"-1\\\">解决百度无法收录搭建在GitHub上的静态博客的问题 <a class=\\\"header-anchor\\\" href=\\\"#解决百度无法收录搭建在github上的静态博客的问题\\\" aria-label=\\\"Permalink to &quot;解决百度无法收录搭建在GitHub上的静态博客的问题&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<div class=\\\"warning custom-block\\\"><p class=\\\"custom-block-title\\\">WARNING</p>\\n<p>如果你正在寻找本博客的搭建文档，博主建议您查看这个仓库的<a href=\\\"https://github.com/xugaoyi/vuepress-theme-vdoing\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">README</a>。</p>\\n</div>\\n<h2 id=\\\"背景\\\" tabindex=\\\"-1\\\">背景 <a class=\\\"header-anchor\\\" href=\\\"#背景\\\" aria-label=\\\"Permalink to &quot;背景&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>由于GitHub禁止百度爬虫访问，造成托管在GitHub Pages上的博客无法被百度收录。相关问题可以通过百度站长平台的<code>抓取诊断</code>再现，每次都是403 Forbidden的错误。</p>\\n\",\"capture\":\"如果你正在寻找本博客的搭建文档，博主建议您查看这个仓库的README。\\n 背景\\n由于GitHub禁止百度爬虫访问，造成托管在GitHub Pages上的博客无法被百度收录。相关问题可以通过百度站长平台的`抓取诊断`再现，每次都是403 Forbidden的错误。\\n 解决方案\\n同时将博客同时同步托管到GitHub Pages和coding pages上，解决百度不收录问题。最后发现在国内使用coding pages打开速度特别快，而且还会被百度收录，因此我把coding pages的站点作为主站点，原本在github pages的作为分站点。\\n步骤：\\n1、注册coding账号，创建仓库，把代码推\"},{\"url\":\"/03.技术/03.博客搭建/02.使用Gitalk实现静态博客无后台评论系统.html\",\"relativePath\":\"/03.技术/03.博客搭建/02.使用Gitalk实现静态博客无后台评论系统.html\",\"frontmatter\":{\"title\":\"使用Gitalk实现静态博客无后台评论系统\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/1da0bf9a988eafe5\",\"categories\":[\"技术\",\"博客搭建\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"使用Gitalk实现静态博客无后台评论系统\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"使用gitalk实现静态博客无后台评论系统\\\" tabindex=\\\"-1\\\">使用Gitalk实现静态博客无后台评论系统 <a class=\\\"header-anchor\\\" href=\\\"#使用gitalk实现静态博客无后台评论系统\\\" aria-label=\\\"Permalink to &quot;使用Gitalk实现静态博客无后台评论系统&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"前言\\\" tabindex=\\\"-1\\\">前言 <a class=\\\"header-anchor\\\" href=\\\"#前言\\\" aria-label=\\\"Permalink to &quot;前言&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>Gitalk，一个基于 Github Issue 和 Preact 开发的评论插件。</p>\\n<p>下面我们来用它在vuepress搭建的博客中搭建评论区吧</p>\\n\",\"capture\":\"前言\\nGitalk，一个基于 Github Issue 和 Preact 开发的评论插件。\\n下面我们来用它在vuepress搭建的博客中搭建评论区吧\\n 准备\\n使用一个新的东西首先当然是要了解它\\nGitalk demo：&lt;https://gitalk.github.io/\\nGitalk github：&lt;https://github.com/gitalk/gitalk&gt;\\n 实现\\n如何实现？最好的方法我认为是看官方文档，这里我只是记录一下实现的步骤。\\n使用一个别人已经开发好的 vuepress-plugin-comment 插件来帮助我们把Gitalk应用到vuepress搭建的静\"},{\"url\":\"/04.更多/03.面试/01.面试问题集锦.html\",\"relativePath\":\"/04.更多/03.面试/01.面试问题集锦.html\",\"frontmatter\":{\"title\":\"面试问题集锦\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/aea6571b7a8bae86\",\"categories\":[\"更多\",\"面试\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"面试问题集锦\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"请做一下自我介绍\\n回答提示： 一般人回答这个问题过于平常，只说姓名、年龄、工作经验，这些在简历上都有。其实，企业最希望知道的是求职者能否胜任工作，包括：最强的技能、最深入研究的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，要突出积极的个性和做事的能力，说的合情合理企业才会相信。\\n 你最大的优点是什么？\\n回答提示： 沉着冷静、条理清楚、立场坚定、乐于助人等，加上例子如：我在XX经过一到两年的培训及项目实战，加上实习工作，我想我适合这份工作。\\n 说说你最大的缺点？\\n回答提示： 这个问题企业问的概率很大，通常不希望听到直接回答的缺点是什么等，如果求职者说自己小心眼、非常懒、工作效率低\"}]},\"groupPostsByYearMonth\":{\"2026 \":{\"02\":[{\"url\":\"/04.更多/05.AI随笔/01.当珍妮机学会了写代码.html\",\"relativePath\":\"/04.更多/05.AI随笔/01.当珍妮机学会了写代码.html\",\"frontmatter\":{\"title\":\"当珍妮机学会了写代码\",\"date\":\"2026-02-26 20:00:00\",\"permalink\":\"/pages/ai-coding-revolution/\",\"categories\":[\"更多\",\"AI随笔\"],\"tags\":[\"AI\",\"思考\",\"编程\"],\"author\":{\"name\":\"刘志伟;AI\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟;AI\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"当珍妮机学会了写代码\",\"date\":\"2026-02-26 20:00:00\",\"capture\":\"当珍妮机学会了写代码\\n\\n 一、从一台纺纱机说起\\n1764 年的某个夜晚，英国兰开夏郡的织工詹姆斯·哈格里夫斯看着妻子的纺车被踢倒后仍在旋转，灵光一闪——如果把纱锭竖起来，一个轮子就能同时驱动八个纱锭。\\n珍妮纺纱机就这样诞生了。一个人能干八个人的活，效率提升 800%。\\n262 年后的 2026 年，我坐在屏幕前，让一个叫 Claude 的 AI 帮我重构整个博客系统。它用 Three.js 写了一个极光 Shader 背景，用 Vue 3 搭了全屏滚动首页，让它设计了五套可切换的艺术风格主题——赛博朋克、梵高、水墨、古典雕塑、现代。它还帮我写了一篇博客，就是现在你正在看的这篇。\\n如果哈格里夫斯\"}]},\"2024 \":{\"03\":[{\"url\":\"/《JavaScript教程》笔记/14.JS实现扫码登录.html\",\"relativePath\":\"/《JavaScript教程》笔记/14.JS实现扫码登录.html\",\"frontmatter\":{\"title\":\"JS实现扫码登录\",\"date\":\"2024-03-30 15:32:39\",\"permalink\":\"/pages/bdbdb8/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"JS实现扫码登录\",\"date\":\"2024-03-30 15:32:39\",\"capture\":\"JS实现扫码登录\\r\\n\\r\\n扫码登录是一种方便快捷的登录方式，用户可以通过扫描二维码来登录网站或应用程序。在本文中，我们将使用JavaScript实现一个简单的扫码登录功能。\\r\\n\\r\\n 步骤一：生成二维码\\r\\n\\r\\n首先，我们需要生成一个二维码，用于展示给用户扫描。我们可以使用第三方库 qrcode.js 来生成二维码。以下是使用qrcode.js生成二维码的示例代码：\\r\\n\\r\\n```html\\r\\n&lt;!-- 在HTML中引入qrcode.js库 --\\r\\n&lt;script src=\\\"https://cdn.bootcdn.net/ajax/libs/qrcodejs/1.0.0/qrcode.min\"},{\"url\":\"/《JavaScript教程》笔记/13.JS继承.html\",\"relativePath\":\"/《JavaScript教程》笔记/13.JS继承.html\",\"frontmatter\":{\"title\":\"JS继承\",\"date\":\"2024-03-30 15:32:05\",\"permalink\":\"/pages/b17c09/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"JS继承\",\"date\":\"2024-03-30 15:32:05\",\"capture\":\"在JavaScript中，继承是实现面向对象编程的重要方式之一。\\r\\n\\r\\n 原型继承\\r\\n\\r\\n原型继承是JavaScript中最常用的继承方式之一。在原型继承中，子类通过继承父类的原型对象来实现继承。\\r\\n\\r\\n```javascript\\r\\nfunction Parent() {\\r\\n  this.name = 'parent';\\r\\n}\\r\\n\\r\\nParent.prototype.sayHello = function() {\\r\\n  console.log('Hello from ' + this.name);\\r\\n}\\r\\n\\r\\nfunction Child() {\\r\\n  this.name = 'child';\"},{\"url\":\"/《JavaScript教程》笔记/12.console实用调试方法.html\",\"relativePath\":\"/《JavaScript教程》笔记/12.console实用调试方法.html\",\"frontmatter\":{\"title\":\"console实用调试方法\",\"date\":\"2024-03-30 15:31:48\",\"permalink\":\"/pages/602ffc/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"console实用调试方法\",\"date\":\"2024-03-30 15:31:48\",\"capture\":\"在JavaScript中，console是一个非常有用的工具，可以帮助我们在开发和调试过程中更好地了解代码的执行情况。本文将介绍console中一些常用的方法，并提供示例代码。\\r\\n console.time() & console.timeEnd()\\r\\nconsole.time()方法用于开始计时器，console.timeEnd()方法用于结束计时器并输出所花费的时间。这对于测试代码执行时间非常有用。\\r\\n```javascript\\r\\nconsole.time('myTimer');\\r\\nfor (let i = 0; i &lt; 1000000; i++) {\\r\\n  // do someth\"},{\"url\":\"/《Git》学习笔记/Git常用命令速查表.html\",\"relativePath\":\"/《Git》学习笔记/Git常用命令速查表.html\",\"frontmatter\":{\"title\":\"Git常用命令速查表\",\"date\":\"2024-03-30 15:26:32\",\"permalink\":\"/pages/3aa4fd/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git常用命令速查表\",\"date\":\"2024-03-30 15:26:32\",\"capture\":\"\"},{\"url\":\"/《JavaScript教程》笔记/11.`import`、`require`、`export`、`module.exports` 的区别和使用详解.html\",\"relativePath\":\"/《JavaScript教程》笔记/11.`import`、`require`、`export`、`module.exports` 的区别和使用详解.html\",\"frontmatter\":{\"title\":\"exports` 的区别和使用详解\",\"date\":\"2024-03-30 15:23:12\",\"permalink\":\"/pages/ff5679/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"exports` 的区别和使用详解\",\"date\":\"2024-03-30 15:23:12\",\"capture\":\"在 Node.js 和现代的 JavaScript 中，有多种方式可以导入和导出模块。其中最常见的是使用 `import` 和 `export`，但在 Node.js 中，也可以使用 `require` 和 `module.exports`。本篇文章将介绍这些不同的方式，以及它们之间的区别。\\r\\n\\r\\n `import` 和 `export`\\r\\n\\r\\n`import` 和 `export` 是 ES6 中引入的模块系统。它们允许我们将代码拆分成多个文件，并在不同的文件中共享代码。以下是一个简单的例子：\\r\\n\\r\\n```javascript\\r\\n// math.js\\r\\nexport const add = \"},{\"url\":\"/《JavaScript教程》笔记/10.JS中的？.和？？区别.html\",\"relativePath\":\"/《JavaScript教程》笔记/10.JS中的？.和？？区别.html\",\"frontmatter\":{\"title\":\"和？？区别\",\"date\":\"2024-03-30 15:22:03\",\"permalink\":\"/pages/176ae0/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"和？？区别\",\"date\":\"2024-03-30 15:22:03\",\"capture\":\"`??` 运算符\\r\\n\\r\\n`??` 运算符是 ES2020 中新增的空值合并运算符。它用于判断一个值是否为 `null` 或 `undefined`，如果是，则使用默认值。其语法如下：\\r\\n\\r\\n```javascript\\r\\ndefaultValue ?? value;\\r\\n```\\r\\n\\r\\n如果 `value` 不为 `null` 或 `undefined`，则 `??` 运算符返回 `value`；否则返回 `defaultValue`。\\r\\n\\r\\n```javascript\\r\\nconst a = null;\\r\\nconst b = 5;\\r\\n\\r\\nconsole.log(a ?? 10); // 10\\r\\nco\"},{\"url\":\"/《JavaScript教程》笔记/09.js 使用postMessage iframe跨域通信.html\",\"relativePath\":\"/《JavaScript教程》笔记/09.js 使用postMessage iframe跨域通信.html\",\"frontmatter\":{\"title\":\"js 使用postMessage iframe跨域通信\",\"date\":\"2024-03-30 15:21:11\",\"permalink\":\"/pages/d67bac/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"js 使用postMessage iframe跨域通信\",\"date\":\"2024-03-30 15:21:11\",\"capture\":\"在 Web 应用程序中，由于同源策略的限制，如果我们需要在一个页面中嵌入来自不同域的资源（例如图片、脚本或 iframe），那么就会出现跨域问题。在这种情况下，我们需要使用一些技术来实现跨域通信。\\r\\n\\r\\n其中一种解决方案是使用 HTML5 中引入的 postMessage API。postMessage 允许我们在不同窗口或 iframe 之间发送消息，这使得我们可以实现跨域通信，而不违反同源策略。\\r\\n\\r\\n postMessage 简介\\r\\n\\r\\npostMessage 是 HTML5 中引入的一种跨窗口通信机制。它允许我们在不同窗口之间发送消息，并且这些窗口可以来自不同的域。postMessag\"},{\"url\":\"/《uniapp》笔记/使用uniapp对接蓝牙设备.html\",\"relativePath\":\"/《uniapp》笔记/使用uniapp对接蓝牙设备.html\",\"frontmatter\":{\"title\":\"使用uniapp对接蓝牙设备\",\"date\":\"2024-03-30 15:20:23\",\"permalink\":\"/pages/35c361/\",\"categories\":[\"《uniapp》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"使用uniapp对接蓝牙设备\",\"date\":\"2024-03-30 15:20:23\",\"capture\":\"低功耗蓝牙 API 平台差异说明\\r\\n\\r\\n| App | H5  | 微信小程序 | 支付宝小程序 | 百度小程序 | 字节跳动小程序 | 飞书小程序 | QQ 小程序 | 快手小程序 | 京东小程序 |\\r\\n| :-: | :-: | :--------: | :----------: | :--------: | :------------: | :--------: | :-------: | :--------: | :--------: |\\r\\n|  √  |  x  |     √      |      √       |     x      |       x        |  \"}]},\"2023 \":{\"09\":[{\"url\":\"/《Vue》笔记/99.其他/79.Vue中编辑word文档以及预览word .html\",\"relativePath\":\"/《Vue》笔记/99.其他/79.Vue中编辑word文档以及预览word .html\",\"frontmatter\":{\"title\":\"Vue中编辑word文档以及预览word\",\"date\":\"2023-09-13 10:25:00\",\"permalink\":\"/pages/1ebccd/\",\"categories\":[\"《Vue》笔记\",\"其他\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Vue中编辑word文档以及预览word\",\"date\":\"2023-09-13 10:25:00\",\"capture\":\"首先通过XMLHttpRequest发送一个GET请求到指定的URL，获取Word文件的内容并将其转换为HTML格式。其中使用mammoth库的convertToHtml方法将二进制数组转换为HTML格式的文本。（mammoth我用了一个修改版本样式还原度要比官方好@shy1118/mammoth）编辑用到的是ckeditor5富文本编辑器,最后通过html-docx-js将html转换为docx在进行保存**\\n 安装主要依赖\\n```bash\\nnpm install --save @ckeditor/ckeditor5-build-decoupled-document @shy1118/mam\"},{\"url\":\"/《Electron》笔记/02.electron下使用puppeteer模拟用户操作,数据获取.html\",\"relativePath\":\"/《Electron》笔记/02.electron下使用puppeteer模拟用户操作,数据获取.html\",\"frontmatter\":{\"title\":\"electron下使用puppeteer模拟用户操作,数据获取\",\"date\":\"2023-09-09 15:15:18\",\"permalink\":\"/pages/56ebf1/\",\"categories\":[\"《Electron》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"electron下使用puppeteer模拟用户操作,数据获取\",\"date\":\"2023-09-09 15:15:18\",\"capture\":\"Puppeteer是一个由Google开发的Node.js库，它提供了一组用于控制和自动化Chrome或Chromium浏览器的API。它可以用于执行各种与浏览器相关的任务，如网页截图、生成PDF、模拟用户交互、爬取网页数据等。Puppeteer通过WebSocket连接与浏览器建立通信，并通过DevTools协议发送命令和接收浏览器的响应。\\n什么是 Chrome DevTool Protocol\\n- CDP 基于 WebSocket，利用 WebSocket 实现与浏览器内核的快速数据通道\\n- CDP 分为多个域（DOM，Debugger，Network，Profiler，Console..\"},{\"url\":\"/《Electron》笔记/01.electron记录.html\",\"relativePath\":\"/《Electron》笔记/01.electron记录.html\",\"frontmatter\":{\"title\":\"electron记录\",\"date\":\"2023-09-09 14:23:20\",\"permalink\":\"/pages/8e9a16/\",\"categories\":[\"《Electron》笔记\"],\"tags\":[\"electron\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"electron记录\",\"date\":\"2023-09-09 14:23:20\",\"capture\":\"事件周期\\n electron常用事件统计\\n主进程常用事件可以分为以下几类：\\n1. 应用程序生命周期事件：\\n    - `ready`: 当 Electron 应用程序初始化完成且准备好显示窗口时触发。\\n    - `window-all-closed`: 当所有窗口都关闭后触发，在 macOS 上通常不会退出应用程序。\\n    - `activate`: 在 macOS 上，当用户点击应用程序的 Dock 图标并且没有其他窗口打开时触发，用于重新创建新窗口。\\n2. 窗口相关事件：\\n    - `closed`: 窗口关闭时触发。\\n    - `dom-ready`: 窗口加载完毕并且 DOM \"},{\"url\":\"/《JavaScript教程》笔记/08.事件循环(evenloop).html\",\"relativePath\":\"/《JavaScript教程》笔记/08.事件循环(evenloop).html\",\"frontmatter\":{\"title\":\"事件循环(evenloop)\",\"date\":\"2023-09-08 16:20:58\",\"permalink\":\"/pages/eaf565/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"事件循环(evenloop)\",\"date\":\"2023-09-08 16:20:58\",\"capture\":\"JavaScript 是一门单线程的语言，它的异步和多线程的实现是通过 Event Loop 事件循环机制来实现的\\nEvent Loop 的机制\\n大体三个部分组成\\n1、调用栈 Stack\\n2、消息队列 Message Queue\\n3、微任务队列 Microtask Queue\\n Event Loop 开始的时候会从全局栈开始逐行执行，遇到函数调用，会把函数压入到调用栈中，当函数返回后，会从调用栈中弹出\\n```javascript\\nfunction func1(){\\n    console.log(1);\\n }\\n function func2(){\\n    console.log(2);\\n   \"},{\"url\":\"/《ES6 教程》笔记/35.了解ES6中的Map和Set.html\",\"relativePath\":\"/《ES6 教程》笔记/35.了解ES6中的Map和Set.html\",\"frontmatter\":{\"title\":\"了解ES6中的Map和Set\",\"date\":\"2023-09-08 16:10:10\",\"permalink\":\"/pages/bfde72/\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"了解ES6中的Map和Set\",\"date\":\"2023-09-08 16:10:10\",\"capture\":\"Map对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。构造函数Map可以接受一个数组作为参数。\\nMap对象的方法\\nset(key, val): 向Map中添加新元素\\nget(key): 通过键值查找特定的数值并返回\\nhas(key): 判断Map对象中是否有Key所对应的值，有返回true,否则返回false\\ndelete(key): 通过键值从Map中移除对应的数据\\nclear(): 将这个Map中的所有元素删除\\n```jsx\\nconst m1 = new Map([['a', 111], ['b', 222]])\\nconsole.log(m1) // {\\\"a\\\" =\\nm1\"},{\"url\":\"/《Vue》笔记/99.其他/91.vue2与vue3生命周期对照表.html\",\"relativePath\":\"/《Vue》笔记/99.其他/91.vue2与vue3生命周期对照表.html\",\"frontmatter\":{\"title\":\"vue2与vue3生命周期对照表\",\"date\":\"2023-09-08 14:57:40\",\"permalink\":\"/pages/e866b9/\",\"categories\":[\"《Vue》笔记\",\"其他\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"vue2与vue3生命周期对照表\",\"date\":\"2023-09-08 14:57:40\",\"capture\":\"\"},{\"url\":\"/01.前端/25.JavaScript文章/15.js实现深度优先遍历和广度优先遍历.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/15.js实现深度优先遍历和广度优先遍历.html\",\"frontmatter\":{\"title\":\"js实现深度优先遍历和广度优先遍历\",\"date\":\"2023-09-08 14:16:56\",\"permalink\":\"/pages/690414/\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"js实现深度优先遍历和广度优先遍历\",\"date\":\"2023-09-08 14:16:56\",\"capture\":\"什么是深度优先和广度优先\\n深度优先遍历用的是栈，而广度优先遍历要用队列来实现,深度优先就是自上而下的遍历搜索 广度优先则是逐层遍历, 如下图所示(图左深度优先遍历,图右广度)\\n 深度优先遍历\\n 广度优先遍历\\n 两者的区别\\n对于算法来说 无非就是时间换空间 空间换时间\\n1. 深度优先不需要记住所有的节点, 所以占用空间小, 而广度优先需要先记录所有的节点占用空间大\\n2. 深度优先有回溯的操作(没有路走了需要回头)所以相对而言时间会长一点\\n深度优先采用的是堆栈的形式, 即先进后出\\n广度优先则采用的是队列的形式, 即先进先出\\n```jsx\\nconst data = [\\n  {\\n      name:\"},{\"url\":\"/01.前端/25.JavaScript文章/14.js获取当前URL,域名,端口号.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/14.js获取当前URL,域名,端口号.html\",\"frontmatter\":{\"title\":\"js获取当前URL,域名,端口号\",\"date\":\"2023-09-08 13:57:22\",\"permalink\":\"/pages/c81259/\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"js获取当前URL,域名,端口号\",\"date\":\"2023-09-08 13:57:22\",\"capture\":\"| href | 完整的 URL | https://www.baidu.com:200/s?wd=1 |\\n| --- | --- | --- |\\n| protocol | 协议 | https: |\\n| hostname | 主机名 | www.baidu.com |\\n| port | 端口号 | 200 |\\n| host | 主机名+端口号 | www.baidu.com:200 |\\n```javascript\\nlet protocol = window.location.protocol,host = window.location.host;\\nlet url = `${protocol\"},{\"url\":\"/01.前端/25.JavaScript文章/13.javascript常用类型数值比较图.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/13.javascript常用类型数值比较图.html\",\"frontmatter\":{\"title\":\"javascript常用类型数值比较图\",\"date\":\"2023-09-08 13:34:43\",\"permalink\":\"/pages/360851/\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"javascript常用类型数值比较图\",\"date\":\"2023-09-08 13:34:43\",\"capture\":\"\"},{\"url\":\"/02.页面/20.CSS/16.css calc()使用.html\",\"relativePath\":\"/02.页面/20.CSS/16.css calc()使用.html\",\"frontmatter\":{\"title\":\"css calc()使用\",\"date\":\"2023-09-08 11:40:43\",\"permalink\":\"/pages/2ecc26/\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"css calc()使用\",\"date\":\"2023-09-08 11:40:43\",\"capture\":\"1.什么是 CSS calc() 函数？\\ncalc() 函数允许在指定 CSS 属性值时执行计算。它对于计算 length、 percentage、 time、 numbers、integers、frequencies 和 angles 等特别有用。 CSS calc() 函数的一个强大功能是能够组合不同的单位。这个函数可以执行预处理器不能执行的数学计算。\\nCSS 中的预处理器只能组合具有固定关系的单位，如角度单位、时间单位、频率单位、分辨率单位和特定长度单位。\\ncalc( Expression)\\ncalc() 函数接受一个表达式作为参数。然后将表达式的结果用作值。它可以采用任何形式并使用以下\"}],\"08\":[{\"url\":\"/04.更多/99.友情链接.html\",\"relativePath\":\"/04.更多/99.友情链接.html\",\"frontmatter\":{\"title\":\"友情链接\",\"date\":\"2023-08-29 15:43:33\",\"permalink\":\"/pages/1bf946/\",\"categories\":[\"更多\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"友情链接\",\"date\":\"2023-08-29 15:43:33\",\"capture\":\"\"},{\"url\":\"/\",\"relativePath\":\"/\",\"frontmatter\":{\"layout\":\"page\",\"title\":\"首页\"},\"title\":\"首页\",\"date\":\"2023-08-29 07:43:33\",\"capture\":\"&lt;HomePage /\"}]},\"2022 \":{\"08\":[{\"url\":\"/03.技术/01.技术文档/20.Git修改分支名.html\",\"relativePath\":\"/03.技术/01.技术文档/20.Git修改分支名.html\",\"frontmatter\":{\"title\":\"Git修改分支名\",\"date\":\"2022-08-11 10:51:18\",\"permalink\":\"/pages/922650/\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git修改分支名\",\"date\":\"2022-08-11 10:51:18\",\"capture\":\"同时修改本地分支名和对应的远程分支名\\n修改前要确保本地分支的代码是最新的，并且修改后不会影响到同事的代码。\\n1. 修改本地分支名\\n```sh\\ngit branch -m oldBranchName newBranchName\\n```\\n2. 删除远程分支\\n```sh\\ngit push origin :oldBranchName\\n 或者 git push origin --delete oldBranchName\\n```\\n3. 改名后的本地分支推送到远程\\n```sh\\ngit push --set-upstream origin newBranchName\\n```\"}],\"06\":[{\"url\":\"/02.页面/20.CSS/15.CSS给table的tbody添加滚动条.html\",\"relativePath\":\"/02.页面/20.CSS/15.CSS给table的tbody添加滚动条.html\",\"frontmatter\":{\"title\":\"CSS给table的tbody添加滚动条\",\"date\":\"2022-06-29 09:34:23\",\"permalink\":\"/pages/55f894/\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"CSS给table的tbody添加滚动条\",\"date\":\"2022-06-29 09:34:23\",\"capture\":\"```css\\ntable tbody {\\n  height: 200px;\\n  overflow-y: auto;\\n  display: block;\\n}\\ntable thead,\\ntbody tr {\\n  display: table;\\n  width: 100%;\\n}\\n```\"}]},\"2021 \":{\"11\":[{\"url\":\"/01.前端/25.JavaScript文章/01.33个非常实用的JavaScript一行代码.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/01.33个非常实用的JavaScript一行代码.html\",\"frontmatter\":{\"title\":\"33个非常实用的JavaScript一行代码\",\"date\":\"2021-11-02 09:51:37\",\"permalink\":\"/pages/a61298/\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[\"JavaScript\"],\"author\":\"CUGGZ\"},\"author\":\"CUGGZ\",\"title\":\"33个非常实用的JavaScript一行代码\",\"date\":\"2021-11-02 09:51:37\",\"capture\":\"一、日期处理\\n 1. 检察日期是否有效\\n该方法用于检测给出的日期是否有效：\\n```javascript\\nconst isDateValid = (...val) =\\nisDateValid(\\\"December 17, 1995 03:24:00\\\");  // true\\n复制代码\\n```\\n 2. 计算两个日期之间的间隔\\n该方法用于计算两个日期之间的间隔时间：\\n```javascript\\nconst dayDif = (date1, date2) =&gt; Math.ceil(Math.abs(date1.getTime() - date2.getTime()) / 86400000)\\ndayD\"}],\"02\":[{\"url\":\"/01.前端/40.学习笔记/50.JS设计模式总结笔记.html\",\"relativePath\":\"/01.前端/40.学习笔记/50.JS设计模式总结笔记.html\",\"frontmatter\":{\"title\":\"JS设计模式总结笔记\",\"date\":\"2021-02-27 20:01:18\",\"permalink\":\"/pages/4643cd/\",\"categories\":[\"前端\",\"学习笔记\"],\"tags\":[\"设计模式\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"JS设计模式总结笔记\",\"date\":\"2021-02-27 20:01:18\",\"capture\":\"开篇：前端工程师的成长论\\n能够决定一个前端工程师的本质的，不是那些瞬息万变的技术点，而是那些不变的东西。\\n所谓“不变的东西”，就是驾驭技术的能力。\\n具体来说，它分为以下三个层次：\\n- 能用健壮的代码去解决具体的问题；\\n- 能用抽象的思维去应对复杂的系统；\\n- 能用工程化的思想去规划更大规模的业务。\\n\\n 设计模式之“道”\\n- 设计模式是“拿来主义”。如使用数学公式，不会从头推导一个公式。\\n  核心思想\\n- 设计模式的核心思想——封装变化\\n- 保证可维护性、可扩展性。\\n- 将变与不变分离，确保变化的部分灵活，不变的部分稳定。——这就是所谓的“健壮”的代码。\\n 设计模式之“术”\\n即最经典的23种设计\"}]},\"2020 \":{\"10\":[{\"url\":\"/01.前端/40.学习笔记/35.TypeScript笔记.html\",\"relativePath\":\"/01.前端/40.学习笔记/35.TypeScript笔记.html\",\"frontmatter\":{\"title\":\"TypeScript笔记\",\"date\":\"2020-10-08 13:02:48\",\"permalink\":\"/pages/51afd6/\",\"categories\":[\"前端\",\"学习笔记\"],\"tags\":[\"TypeScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"TypeScript笔记\",\"date\":\"2020-10-08 13:02:48\",\"capture\":\"TypeScript 的类型校验是给程序员看的，在编译后不会存在TS代码。\\n 类型注解\\n```typescript\\nfunction fn(person: string):void{ // 参数类型是字符串，没有返回值\\n    ///...\\n}\\nfn('str') // 如传递参数非字符串，vscode编辑器中或在编译时将给出错误提示\\nconst test:number = 1\\n```\\n 有哪些基础类型注解？\\n```typescript\\n// 基础类型\\n:string\\n:number\\n:boolean\\n:null  // 只能是null值\\n:undefined // 只能是undefined值\"}],\"11\":[{\"url\":\"/《Git》学习笔记/10.手册/00.常用Git命令清单.html\",\"relativePath\":\"/《Git》学习笔记/10.手册/00.常用Git命令清单.html\",\"frontmatter\":{\"title\":\"常用Git命令清单\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/8292d8/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"常用Git命令清单\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。\\n下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。\\n\\n&gt; - Index / Stage：暂存区\\n&gt; - Repository：仓库区（或本地仓库）\\n&gt; - Remote：远程仓库\\n 一、新建代码库\\n```bash\\n 在当前目录新建一个Git代码库\\n$ git init\\n 新建一个目录，将其初始化为Git代码库\\n$ git init [project-name]\\n 下载一个项目和它的整个代码历史\\n$ git clone [url]\\n```\\n 二、配置\\nGit的设置文件为\"},{\"url\":\"/《Git》学习笔记/10.手册/01.Git变基合并.html\",\"relativePath\":\"/《Git》学习笔记/10.手册/01.Git变基合并.html\",\"frontmatter\":{\"title\":\"Git变基合并\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/c10281/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git变基合并\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"说明\\n以下 `v2` 是某个需求的开发分支， `dev`是总的开发分支，`v2` 是基于`dev`分支签出的。\\n当完成`v2`的开发后，需要把代码合并到`dev`，我们可以使用`rebase`进行合并：\\n```sh\\n 首先将 v2 push到远程仓库\\ngit add .\\ngit commit -m 'xxx'\\ngit push origin v2\\n 切换到 dev 拉取最新代码\\ngit checkout dev\\ngit pull origin dev\\n 切换到 v2\\ngit checkout v2\\ngit rebase dev  将 v2 的所有[commit] 变基到(应用到) dev\\n 切\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/10.Git基础与命令.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/10.Git基础与命令.html\",\"frontmatter\":{\"title\":\"Git基础与命令\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/635088/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git基础与命令\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"官方文档（中文）：https://git-scm.com/book/zh/v2\\n\\n Git基础\\n 全局配置\\n```bash\\ngit config --global user.name 'your name'\\ngit config --global user.email 'xxx@xx.com'\\n```\\n自报家门\\n 检查配置信息\\n```sh\\ngit config --list\\n```\\n 获取帮助\\n```sh\\n 获取全局帮助手册\\ngit help\\n 获取特定命令的详细版帮助手册 (两个命令是等价的)\\ngit help &lt;某个命令&gt;\\ngit &lt;某个命令&gt; --help  两个\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/100.Git工具-重写历史.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/100.Git工具-重写历史.html\",\"frontmatter\":{\"title\":\"Git工具-重写历史\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/1832fe/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git工具-重写历史\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"许多时候，在使用 Git 时，你可能想要修订提交历史。 Git 很棒的一点是它允许你在最后时刻做决定。 你可以在将暂存区内容提交前决定哪些文件进入提交，可以通过 `git stash` 来决定不与某些内容工作， 也可以重写已经发生的提交就像它们以另一种方式发生的一样。 这可能涉及改变提交的顺序，改变提交中的信息或修改文件，将提交压缩或是拆分， 或完全地移除提交——在将你的工作成果与他人共享之前。\\n在本节中，你可以学到如何完成这些工作，这样在与他人分享你的工作成果时你的提交历史将如你所愿地展示出来。\\n| Note | 在满意之前不要推送你的工作Git 的基本原则之一是，由于克隆中有很多工作是本地\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/110.Git工具-重置揭密.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/110.Git工具-重置揭密.html\",\"frontmatter\":{\"title\":\"Git工具-重置揭密\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/d9e9c6/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git工具-重置揭密\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"在继续了解更专业的工具前，我们先探讨一下 Git 的 `reset` 和 `checkout` 命令。 在初遇的 Git 命令中，这两个是最让人困惑的。 它们能做很多事情，所以看起来我们很难真正地理解并恰当地运用它们。 针对这一点，我们先来做一个简单的比喻。\\n 三棵树\\n理解 `reset` 和 `checkout` 的最简方法，就是以 Git 的思维框架（将其作为内容管理器）来管理三棵不同的树。 “树” 在我们这里的实际意思是 “文件的集合”，而不是指特定的数据结构。 （在某些情况下索引看起来并不像一棵树，不过我们现在的目的是用简单的方式思考它。）\\nGit 作为一个系统，是以它的一般操作来管理\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/20.Git分支-分支原理.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/20.Git分支-分支原理.html\",\"frontmatter\":{\"title\":\"Git分支-分支原理\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/4bef1a/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支-分支原理\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。\\n 首次提交\\n在进行提交操作时，Git 会保存一个提交对象（commit object）。\\n假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 暂存操作会为每一个文件计算校验和（使用 SHA-1 哈希算法），然后会把当前版本的文件快照保存到 Git 仓库中 （Git 使用 *blob* 对象来保存它们），最终将校验和加入到暂存区域等待提交：\\n```sh\\n$ git\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/30.Git分支的新建与合并-分支操作.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/30.Git分支的新建与合并-分支操作.html\",\"frontmatter\":{\"title\":\"Git分支的新建与合并-分支操作\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/ea5a8c/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支的新建与合并-分支操作\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"文档：Git 分支 - 分支的新建与合并\\n 创建分支并切换\\n此时有一个需求需要在新的分支`iss53`上工作：\\n```sh\\n$ git checkout -b iss53   b表示branch\\n```\\n它是下面两条命令的简写：\\n```sh\\n$ git branch iss53\\n$ git checkout iss53\\n```\\n 切换分支\\n突然有一个紧急问题要解决，需要在原来的`master`分支进行修复：\\n```sh\\n$ git checkout master\\n```\\n在切换到`master`之前，需要`iss53`分支保持好一个干净的状态（修改都已提交）。\\n注意：切换分支Git 会重置你的\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/40.Git分支管理-查看分支.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/40.Git分支管理-查看分支.html\",\"frontmatter\":{\"title\":\"Git分支管理-查看分支\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/a399b3/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支管理-查看分支\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"查看分支\\n```sh\\n$ git branch\\n  iss53\\n* master   带星号*表示当前所在分支\\n  testing\\n```\\n`git branch` 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表。\\n 查看每个分支的最后提交\\n```sh\\n$ git branch -v\\n  iss53   93b412c fix javascript issue\\n* master  7a98805 Merge branch 'iss53'\\n  testing 782fd34 test\\n```\\n 查看已(未)合并的分支\\n`--merged` 与 `--no-m\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/50.Git分支开发工作流.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/50.Git分支开发工作流.html\",\"frontmatter\":{\"title\":\"Git分支开发工作流\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/49ee30/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支开发工作流\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"文档：Git分支开发工作流\\n 长期分支\\n因为 Git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。 也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些主题分支合并入其他分支中。\\n许多使用 Git 的开发者都喜欢使用这种方式来工作，比如只在 `master` 分支上保留完全稳定的代码，开发过程在`dev`分支，开发完成后并入`test`分支进行测试，通过测试的稳定代码才并入`master`分支中。\\n`dev`和`test`分支不需要保持绝对稳定，但在`test`通过测试达到稳定状态，就可以被合并入`mast\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/60.Git分支-远程分支.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/60.Git分支-远程分支.html\",\"frontmatter\":{\"title\":\"Git分支-远程分支\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/574d62/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支-远程分支\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"远程引用是对远程仓库的引用（指针），包括分支、标签等等。\\n\\n 查看远程引用列表与信息\\n```sh\\ngit ls-remote &lt;remote&gt;  远程引用的完整列表\\ngit remote show &lt;remote&gt;  远程分支的更多信息\\n```\\n上面两行命令比较少用，更常见的做法是利用远程跟踪分支。\\n 远程跟踪分支\\n远程跟踪分支是远程分支状态的引用。它们是你无法移动的本地引用。一旦你进行了网络通信， Git 就会为你移动它们以精确反映远程仓库的状态。请将它们看做书签， 这样可以提醒你该分支在远程仓库中的位置就是你最后一次连接到它们的位置。\\n它们以 `&lt;remote\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/70.Git分支-变基.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/70.Git分支-变基.html\",\"frontmatter\":{\"title\":\"Git分支-变基\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/3a3247/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支-变基\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"在 Git 中整合来自不同分支的修改主要有两种方法：`merge` 以及 `rebase`。 在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。\\n 变基的基本操作\\n请回顾之前在 分支的合并 中的一个例子，你会看到开发任务分叉到两个不同分支，又各自提交了更新。\\n&lt;p align=\\\"center\\\"\\n之前介绍过，整合分支最容易的方法是 `merge` 命令。 它会把两个分支的最新快照（`C3` 和 `C4`）以及二者最近的共同祖先（`C2`）进行三方合并，合并的结果是生成一个新的快照（并提交）。\\n &lt;p align=\\\"cen\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/80.Git工具-查看修订版本.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/80.Git工具-查看修订版本.html\",\"frontmatter\":{\"title\":\"Git工具-查看修订版本\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/c984d1/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git工具-查看修订版本\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"Git 能够以多种方式来指定单个提交、一组提交、或者一定范围内的提交。 了解它们并不是必需的，但是了解一下总没坏处。\\n修订版本指的是：提交\\n 单个修订版本\\n你可以通过任意一个提交的 40 个字符的完整 SHA-1 散列值来指定它， 不过还有很多更人性化的方式来做同样的事情。本节将会介绍获取单个提交的多种方法。\\n 简短的 SHA-1\\nGit 十分智能，你只需要提供 SHA-1 的前几个字符就可以获得对应的那次提交， 当然你提供的 SHA-1 字符数量不得少于 4 个，并且没有歧义——也就是说， 当前对象数据库中没有其它对象以这段 SHA-1 开头。\\n例如，要查看你知道其中添加了某个功能的提交，首\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/90.Git工具-交互式暂存.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/90.Git工具-交互式暂存.html\",\"frontmatter\":{\"title\":\"Git工具-交互式暂存\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/76d859/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git工具-交互式暂存\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"本节中的几个交互式 Git 命令可以帮助你将文件的特定部分组合成提交。 当你在修改了大量文件后，希望这些改动能拆分为若干提交而不是混杂在一起成为一个提交时，这几个工具会非常有用。 通过这种方式，可以确保提交是逻辑上独立的变更集，同时也会使其他开发者在与你工作时很容易地审核。 如果运行 `git add` 时使用 `-i` 或者 `--interactive` 选项，Git 将会进入一个交互式终端模式，显示类似下面的东西：\\n```sh\\n$ git add -i\\n           staged     unstaged path\\n  1:    unchanged        +0/-1 T\"}],\"12\":[{\"url\":\"/01.前端/25.JavaScript文章/1110.三级目录/00.四级文件.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/1110.三级目录/00.四级文件.html\",\"frontmatter\":{\"title\":\"四级文件(测试)\",\"date\":\"2020-12-11 11:15:53\",\"permalink\":\"/pages/8481d1/\",\"categories\":[\"前端\",\"JavaScript文章\",\"三级目录\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"四级文件(测试)\",\"date\":\"2020-12-11 11:15:53\",\"capture\":\"测试文件\\nTest Test\\n&lt;code-group\\n  &lt;code-block title=\\\"YARN\\\" active&gt;\\n  ```bash\\n  yarn create vuepress-site [optionalDirectoryName]\\n   OR npx create-vuepress-site [optionalDirectoryName]\\n  ```\\n  &lt;/code-block&gt;\\n  &lt;code-block title=\\\"NPM\\\"&gt;\\n  ```bash\\n  npx create-vuepress-site [optionalDirec\"}],\"08\":[{\"url\":\"/02.页面/20.CSS/00.CSS教程和技巧收藏.html\",\"relativePath\":\"/02.页面/20.CSS/00.CSS教程和技巧收藏.html\",\"frontmatter\":{\"title\":\"CSS教程和技巧收藏\",\"date\":\"2020-08-11 17:13:52\",\"permalink\":\"/pages/c8f128/\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"CSS教程和技巧收藏\",\"date\":\"2020-08-11 17:13:52\",\"capture\":\"Flex 布局教程：语法篇\\n&lt;http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\\n CSS Grid 网格布局教程\\n&lt;http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html&gt;\\n 只要一行代码，实现五种 CSS 经典布局\\n&lt;http://www.ruanyifeng.com/blog/2020/08/five-css-layouts-in-one-line.html&gt;\\n* 空间居中布局\\n  &gt; 不管容器的大小，项目总是占据中心\"},{\"url\":\"/《Vue》笔记/10.Vuex/01.Vuex.html\",\"relativePath\":\"/《Vue》笔记/10.Vuex/01.Vuex.html\",\"frontmatter\":{\"title\":\"Vuex\",\"date\":\"2020-08-08 10:38:33\",\"permalink\":\"/pages/b30620/\",\"categories\":[\"《Vue》笔记\",\"Vuex\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Vuex\",\"date\":\"2020-08-08 10:38:33\",\"capture\":\"Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。\\n Vuex使用过程演示\\n以`vue-cli3`新创建出来的项目为例，演示Vuex的使用过程。\\n创建项目:\\n```sh\\nvue create vuex-test\\ncd vuex-test\\nnpm run serve\\n```\\n安装`vuex`:\\n```bash\\nnpm i vuex -S\\n```\\n进入项目的`src/`下新建一个文件`store/index.js`，并写入：\\n```js\\n// store/index.js\\nimport Vue from 'vue'\\nimport Vuex from 'vuex'\\nVue.use(Vu\"}],\"07\":[{\"url\":\"/04.更多/01.学习/00.费曼学习法.html\",\"relativePath\":\"/04.更多/01.学习/00.费曼学习法.html\",\"frontmatter\":{\"title\":\"费曼学习法\",\"date\":\"2020-07-16 10:04:14\",\"permalink\":\"/pages/f2a556/\",\"categories\":[\"更多\",\"学习\"],\"tags\":[\"学习方法\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"费曼学习法\",\"date\":\"2020-07-16 10:04:14\",\"capture\":\"步骤\\n费曼学习法分为4个步骤:\\n1. 确定学习目标\\n你想学习的概念、内容、主题是什么。\\n2. 模拟教学学习法\\n你要模拟自己是一位老师，面对完全不懂这个领域的人，用自己的话，尽可能具体形象地讲诉。这样的讲诉有助于你活学活用，触类旁通，联系生活具体情境。\\n3. 回顾\\n反思第2步遇到的问题，哪些地方卡壳了，哪些地方对方没有真正听懂。找出问题的要害，把握关键环节。\\n4. 简化\\n把这些遇到问题的地方，重新梳理理解，尽可能了解更多背景和相关知识，再用尽可能简化的方式重新表达，设法看穿本质。然后，返回第2步。\\n\\n&gt; \\n&gt; 《费曼学习法：为何被称为史上最牛的学习法，它的本质究竟是什么？》\\n&gt;\"}],\"06\":[{\"url\":\"/01.前端/40.学习笔记/05.《JavaScript高级程序设计》笔记.html\",\"relativePath\":\"/01.前端/40.学习笔记/05.《JavaScript高级程序设计》笔记.html\",\"frontmatter\":{\"title\":\"《JavaScript高级程序设计》笔记\",\"date\":\"2020-06-12 12:39:01\",\"permalink\":\"/note/js/\",\"categories\":[\"笔记\"],\"tags\":[\"笔记\",\"红宝书\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"《JavaScript高级程序设计》笔记\",\"date\":\"2020-06-12 12:39:01\",\"capture\":\"第1章  JavaScript简介\\n* JavaScript诞生于1995年\\n* 一个完整的JavaScript由这三部分组成：\\n  * ECMAScript (核心)\\n  * DOM (文档对象模型)\\n  * BOM (浏览器对象模型)\\n* ECMAScript的 宿主环境 包含 ：\\n  * 浏览器\\n  * Node\\n  * flash\\n* ECMAScript大致规定了下列组成部分：\\n  * 语法\\n  * 类型\\n  * 语句\\n  * 关键字\\n  * 保留字\\n  * 操作符\\n  * 对象\\n 第2章 在HTML中使用JavaScript\\n* `&lt;script\\n  * async 表示立即\"}],\"05\":[{\"url\":\"/04.更多/01.学习/10.搜索引擎使用技巧.html\",\"relativePath\":\"/04.更多/01.学习/10.搜索引擎使用技巧.html\",\"frontmatter\":{\"title\":\"搜索引擎使用技巧\",\"date\":\"2020-05-24 11:44:19\",\"permalink\":\"/pages/ce818a\",\"categories\":[\"更多\",\"学习\"],\"tags\":[\"搜索技巧\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"搜索引擎使用技巧\",\"date\":\"2020-05-24 11:44:19\",\"capture\":\"搜索引擎相信大家经常在使用，但是有时候想搜某个信息时却搜出来一大堆不相关的（百度：你们都在看我干什么？）。下面我们来介绍几种搜索技巧，可以提升搜索效率，助你快速查资料，妈妈再也不担心我的学习了（'妈~我真的是在找学习资料'）\\n 技巧1：排除干扰项\\n方式：关键词1+空格+减号+关键词2，即 `关键词1 -关键词2`\\n功能：排除一些不想要的关键词\\n示例：\\n```\\n锤子 -锤子手机\\n```\\n示例中将在搜索结果排除与`锤子手机`相关的，只显示`锤子`本来的样子。\\n\\n 技巧2：精确搜索\\n方式：给关键词加双引号，`\\\"关键词\\\"`\\n功能：只搜索引号里的字，少一个字或者把字拆开都不行\\n示例：\\n```\\n\\\"达拉不崩\"},{\"url\":\"/02.页面/20.CSS/14.CSS-function汇总.html\",\"relativePath\":\"/02.页面/20.CSS/14.CSS-function汇总.html\",\"frontmatter\":{\"title\":\"CSS-function汇总\",\"date\":\"2020-05-12 09:36:44\",\"permalink\":\"/pages/3da0d7\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"CSS-function汇总\",\"date\":\"2020-05-12 09:36:44\",\"capture\":\"\"}],\"04\":[{\"url\":\"/01.前端/25.JavaScript文章/12.比typeof运算符更准确的类型判断.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/12.比typeof运算符更准确的类型判断.html\",\"frontmatter\":{\"title\":\"比typeof运算符更准确的类型判断\",\"date\":\"2020-04-13 15:56:54\",\"permalink\":\"/pages/fd4a16d56b83c1bc\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"比typeof运算符更准确的类型判断\",\"date\":\"2020-04-13 15:56:54\",\"capture\":\"不同数据类型的`Object.prototype.toString`方法返回值如下。\\n- 数值：返回`[object Number]`。\\n- 字符串：返回`[object String]`。\\n- 布尔值：返回`[object Boolean]`。\\n- undefined：返回`[object Undefined]`。\\n- null：返回`[object Null]`。\\n- 数组：返回`[object Array]`。\\n- arguments 对象：返回`[object Arguments]`。\\n- 函数：返回`[object Function]`。\\n- Error 对象：返回`[object \"},{\"url\":\"/03.技术/01.技术文档/10.npm packageJson属性详解.html\",\"relativePath\":\"/03.技术/01.技术文档/10.npm packageJson属性详解.html\",\"frontmatter\":{\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"npm packageJson属性详解\",\"date\":\"2020-04-08 17:16:38\",\"permalink\":\"/pages/dec4f3f00e71a312\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null]},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"npm packageJson属性详解\",\"date\":\"2020-04-08 17:16:38\",\"excerpt\":\"<h1 id=\\\"npm-package-json属性详解\\\" tabindex=\\\"-1\\\">npm package.json属性详解 <a class=\\\"header-anchor\\\" href=\\\"#npm-package-json属性详解\\\" aria-label=\\\"Permalink to &quot;npm package.json属性详解&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<blockquote>\\n<p>本文转自<a href=\\\"https://www.cnblogs.com/tzyy/p/5193811.html\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">https://www.cnblogs.com/tzyy/p/5193811.html</a>，作者：TZYY</p>\\n</blockquote>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p><code>package.json</code>必须是一个严格的json文件，而不仅仅是js里边的一个对象。其中很多属性可以通过<code>npm-config</code>来生成</p>\\n\",\"capture\":\"npm package.json属性详解\\n\\n 概述\\n`package.json`必须是一个严格的json文件，而不仅仅是js里边的一个对象。其中很多属性可以通过`npm-config`来生成\\n name\\n`package.json`中最重要的属性是`name`和`version`两个属性，这两个属性是必须要有的，否则模块就无法被安装，这两个属性一起形成了一个npm模块的唯一标识符。模块中内容变更的同时，模块版本也应该一起变化。\\n`name`属性就是你的模块名称，下面是一些命名规则:\\n- `name`必须小于等于214个字节，包括前缀名称在内（如 xxx/xxxmodule）。\\n- `name`\"}],\"03\":[{\"url\":\"/02.页面/20.CSS/13.如何根据系统主题自动响应CSS深色模式.html\",\"relativePath\":\"/02.页面/20.CSS/13.如何根据系统主题自动响应CSS深色模式.html\",\"frontmatter\":{\"title\":\"如何根据系统主题自动响应CSS深色模式\",\"date\":\"2020-03-31 14:06:26\",\"permalink\":\"/pages/5dde351274f1e39d\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[\"css\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"如何根据系统主题自动响应CSS深色模式\",\"date\":\"2020-03-31 14:06:26\",\"excerpt\":\"<h1 id=\\\"如何根据系统主题自动响应css深色模式\\\" tabindex=\\\"-1\\\">如何根据系统主题自动响应CSS深色模式 <a class=\\\"header-anchor\\\" href=\\\"#如何根据系统主题自动响应css深色模式\\\" aria-label=\\\"Permalink to &quot;如何根据系统主题自动响应CSS深色模式&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p align=\\\"center\\\">\\n  <img src=\\\"https://cdn.staticaly.com/gh/xugaoyi/image_store/blog/20200427163531.jpg\\\" width=\\\"500\\\">\\n</p>\\n<p>很多人喜欢选择APP或网站中的深色模式，也许他们更喜欢这样的外观，或者他们想让自己的眼睛免受疲劳。这篇文章将告诉你如何在网站中实现一个自动的CSS深色模式，根据访客的系统主题来自动响应。</p>\\n\",\"capture\":\"如何根据系统主题自动响应CSS深色模式\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"https://cdn.staticaly.com/gh/xugaoyi/image_store/blog/20200427163531.jpg\\\" width=\\\"500\\\"&gt;\\n&lt;/p&gt;\\n很多人喜欢选择APP或网站中的深色模式，也许他们更喜欢这样的外观，或者他们想让自己的眼睛免受疲劳。这篇文章将告诉你如何在网站中实现一个自动的CSS深色模式，根据访客的系统主题来自动响应。\\n CSS 深色模式 (Dark Mode)\\n在`:root`根元素中定义变量来设置主题的颜色。我建\"},{\"url\":\"/02.页面/20.CSS/12.水平垂直居中的几种方式-案例.html\",\"relativePath\":\"/02.页面/20.CSS/12.水平垂直居中的几种方式-案例.html\",\"frontmatter\":{\"title\":\"水平垂直居中的几种方式-案例\",\"date\":\"2020-03-13 16:13:43\",\"permalink\":\"/pages/cb7cb251adba4bf7\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"水平垂直居中的几种方式-案例\",\"date\":\"2020-03-13 16:13:43\",\"capture\":\"&lt;iframe height=\\\"880\\\" style=\\\"width: 100%;\\\" scrolling=\\\"no\\\" title=\\\"水平垂直居中的几种方式\\\" src=\\\"https://codepen.io/xugaoyi/embed/poJLeYv?height=880&theme-id=light&default-tab=result\\\" frameborder=\\\"no\\\" allowtransparency=\\\"true\\\" allowfullscreen=\\\"true\\\"\\n  See the Pen &lt;a href='https://codepen.io/xugaoyi/pen/poJLeY\"},{\"url\":\"/01.前端/25.JavaScript文章/11.JS获取和修改url参数.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/11.JS获取和修改url参数.html\",\"frontmatter\":{\"title\":\"JS获取和修改url参数\",\"date\":\"2020-03-05 12:45:37\",\"permalink\":\"/pages/7a91be2d502346ce\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"JS获取和修改url参数\",\"date\":\"2020-03-05 12:45:37\",\"capture\":\"获取url参数\\n```js\\n/**\\n * 获取url里的参数\\n * @param arg 参数名\\n * @returns\\n */\\nfunction getURLString(arg) {\\n    var reg = new RegExp(\\\"(^|&)\\\" + arg + \\\"=([^&]*)(&|$)\\\", \\\"i\\\");\\n    var r = window.location.search.substr(1).match(reg);\\n    if (r != null)\\n        return unescape(r[2]);\\n    return null;\\n}\\n```\\n 修改url参数\\n```\"}],\"02\":[{\"url\":\"/01.前端/25.JavaScript文章/10.防抖与节流函数.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/10.防抖与节流函数.html\",\"frontmatter\":{\"title\":\"防抖与节流函数\",\"date\":\"2020-02-29 15:07:47\",\"permalink\":\"/pages/0f6a0ac99b62ede5\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"防抖与节流函数\",\"date\":\"2020-02-29 15:07:47\",\"excerpt\":\"<h1 id=\\\"防抖与节流函数\\\" tabindex=\\\"-1\\\">防抖与节流函数 <a class=\\\"header-anchor\\\" href=\\\"#防抖与节流函数\\\" aria-label=\\\"Permalink to &quot;防抖与节流函数&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>防抖和节流的作用都是在高频事件中防止函数被多次调用，是一种性能优化的方案。</p>\\n<p>区别在于，防抖函数只会在高频事件结束后n毫秒调用一次函数，节流函数会在高频事件触发过程当中每隔n毫秒调用一次函数。</p>\\n\",\"capture\":\"防抖和节流的作用都是在高频事件中防止函数被多次调用，是一种性能优化的方案。\\n区别在于，防抖函数只会在高频事件结束后n毫秒调用一次函数，节流函数会在高频事件触发过程当中每隔n毫秒调用一次函数。\\n 防抖函数\\n触发高频事件后一段时间（wait）只会执行一次函数，如果指定时间（wait）内高频事件再次被触发，则重新计算时间。\\n 封装\\n```js\\n// 防抖函数\\nfunction debounce(func, wait) {\\n    let timeout = null;\\n    return function () {\\n        let context = this;\\n        let a\"},{\"url\":\"/02.页面/20.CSS/11.从box-sizing属性入手，了解盒子模型.html\",\"relativePath\":\"/02.页面/20.CSS/11.从box-sizing属性入手，了解盒子模型.html\",\"frontmatter\":{\"title\":\"从box-sizing属性入手，了解盒子模型\",\"date\":\"2020-02-27 17:08:48\",\"permalink\":\"/pages/20a978023139589d\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"从box-sizing属性入手，了解盒子模型\",\"date\":\"2020-02-27 17:08:48\",\"excerpt\":\"<h1 id=\\\"从box-sizing属性入手-了解盒子模型\\\" tabindex=\\\"-1\\\">从box-sizing属性入手，了解盒子模型 <a class=\\\"header-anchor\\\" href=\\\"#从box-sizing属性入手-了解盒子模型\\\" aria-label=\\\"Permalink to &quot;从box-sizing属性入手，了解盒子模型&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"背景\\\" tabindex=\\\"-1\\\">背景 <a class=\\\"header-anchor\\\" href=\\\"#背景\\\" aria-label=\\\"Permalink to &quot;背景&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>先声明一下运用的场景，假如项目布局使用的是<strong>自适应</strong>的布局方式，div给出的宽度是<strong>百分比</strong>的形式，即占窗口宽度的100%，但边框<code>border</code>和内边距<code>padding</code>是用像素来表示的，此时就会造成一个问题是div总宽度超过窗口宽度。为了避免这种问题，可以使用属性<code>box-sizing:border-box</code>来把 <strong>标准盒模型</strong> 变成 <strong>代替(IE)盒模型</strong> ，从而使div的总宽度依然是100%</p>\\n\",\"capture\":\"背景\\n先声明一下运用的场景，假如项目布局使用的是自适应的布局方式，div给出的宽度是百分比的形式，即占窗口宽度的100%，但边框`border`和内边距`padding`是用像素来表示的，此时就会造成一个问题是div总宽度超过窗口宽度。为了避免这种问题，可以使用属性`box-sizing:border-box`来把 标准盒模型 变成 代替(IE)盒模型 ，从而使div的总宽度依然是100%\\n 什么是CSS 盒模型?\\n页面布局中，一个元素的外边距（margin）、 边框（border）、内边距（padding）、内容（content）组成一个盒模型。盒模型可分为标准盒模型 和 代替（IE）盒模型\"},{\"url\":\"/02.页面/20.CSS/10.文字在一行或多行时超出显示省略号.html\",\"relativePath\":\"/02.页面/20.CSS/10.文字在一行或多行时超出显示省略号.html\",\"frontmatter\":{\"title\":\"文字在一行或多行时超出显示省略号\",\"date\":\"2020-02-23 15:07:08\",\"permalink\":\"/pages/42b66999cc27dc25\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"文字在一行或多行时超出显示省略号\",\"date\":\"2020-02-23 15:07:08\",\"excerpt\":\"<h1 id=\\\"文字在一行或多行时超出显示省略号\\\" tabindex=\\\"-1\\\">文字在一行或多行时超出显示省略号 <a class=\\\"header-anchor\\\" href=\\\"#文字在一行或多行时超出显示省略号\\\" aria-label=\\\"Permalink to &quot;文字在一行或多行时超出显示省略号&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"一行超出显示省略\\\" tabindex=\\\"-1\\\">一行超出显示省略 <a class=\\\"header-anchor\\\" href=\\\"#一行超出显示省略\\\" aria-label=\\\"Permalink to &quot;一行超出显示省略&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<div class=\\\"language-css vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">css</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">overflow: hidden;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">white-space</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">: nowrap;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">text-overflow</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">: ellipsis;</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br></div></div>\",\"capture\":\"一行超出显示省略\\n```css\\noverflow: hidden;\\nwhite-space: nowrap;\\ntext-overflow: ellipsis;\\n```\\n```html\\n&lt;html\\n   &lt;div class=\\\"box-42b6\\\"&gt;演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字&lt;/div&gt;\\n&lt;/html&gt;\\n&lt;style&gt;\\n    .box-42b6{\\n        border: 1px solid 999;\\n        width\"},{\"url\":\"/01.前端/25.JavaScript文章/09.将一维数组按指定长度转为二维数组.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/09.将一维数组按指定长度转为二维数组.html\",\"frontmatter\":{\"title\":\"将一维数组按指定长度转为二维数组\",\"date\":\"2020-02-23 13:49:31\",\"permalink\":\"/pages/f1acb712033ac8da\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"将一维数组按指定长度转为二维数组\",\"date\":\"2020-02-23 13:49:31\",\"capture\":\"将一维数组按指定长度转为二维数组\\n```js\\nfunction pages(arr, len) {\\n    const pages = []\\n    arr.forEach((item, index) =\\n        const page = Math.floor(index / len)\\n        if (!pages[page]) {\\n            pages[page] = []\\n        }\\n        pages[page].push(item)\\n    })\\n    return pages\\n}\\n// 使用\\nconst arr = [1, 2, 3, \"},{\"url\":\"/02.页面/20.CSS/09.「布局技巧」图片未加载前自动撑开元素高度.html\",\"relativePath\":\"/02.页面/20.CSS/09.「布局技巧」图片未加载前自动撑开元素高度.html\",\"frontmatter\":{\"title\":\"「布局技巧」图片未加载前自动撑开元素高度\",\"date\":\"2020-02-22 16:37:10\",\"permalink\":\"/pages/3d52574260725aea\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"「布局技巧」图片未加载前自动撑开元素高度\",\"date\":\"2020-02-22 16:37:10\",\"excerpt\":\"<h1 id=\\\"「布局技巧」图片未加载前自动撑开元素高度\\\" tabindex=\\\"-1\\\">「布局技巧」图片未加载前自动撑开元素高度 <a class=\\\"header-anchor\\\" href=\\\"#「布局技巧」图片未加载前自动撑开元素高度\\\" aria-label=\\\"Permalink to &quot;「布局技巧」图片未加载前自动撑开元素高度&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>在移动端开发中，有一些元素是根据图片高度来自动撑开的 ，高度不能写死（如轮播图的外层元素）。在网络较慢的情况下，图片加载需要一些时间，此时该元素的高度没有被撑开，在网页布局上会有一些不想看到的效果。</p>\\n\",\"capture\":\"在移动端开发中，有一些元素是根据图片高度来自动撑开的 ，高度不能写死（如轮播图的外层元素）。在网络较慢的情况下，图片加载需要一些时间，此时该元素的高度没有被撑开，在网页布局上会有一些不想看到的效果。\\n这种情况我们可以设置如下样式来设置该元素的高度：\\n```stylus\\n.wrapper\\n  overflow hidden\\n  width 100%\\n  height 0\\n  padding-bottom 26.66% // 这个数值是图片的高宽比，即 高/宽\\n  background eee\\n```\\n上面代码中，`padding-bottom` 的取值是图片的高宽比（即，高/宽），它会根据 `w\"},{\"url\":\"/01.前端/25.JavaScript文章/03.ES5面向对象.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/03.ES5面向对象.html\",\"frontmatter\":{\"title\":\"ES5面向对象\",\"date\":\"2020-02-22 10:35:43\",\"permalink\":\"/pages/b1af5cb8996363c5\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"ES5面向对象\",\"date\":\"2020-02-22 10:35:43\",\"capture\":\"```js\\n//面向对象封装\\nfunction Student(props){ // 构造函数 （构造函数内定于属性。尊从首字母大写的约定）\\n  this.name = props.name || '匿名';  // 默认‘匿名’\\n  this.grade = props.grade || 1;\\n}\\nStudent.prototype.hello = function(){ // 在构造函数的原型上定义方法\\n  console.log('你好,'+ this.name +'同学，你在'+ this.grade+'年级');\\n}\\n//使用\\nfunction createStudent(props\"},{\"url\":\"/02.页面/10.HTML/10.常用meta整理.html\",\"relativePath\":\"/02.页面/10.HTML/10.常用meta整理.html\",\"frontmatter\":{\"title\":\"常用meta整理\",\"date\":\"2020-02-21 12:20:10\",\"permalink\":\"/pages/8309a5b876fc95e3\",\"categories\":[\"页面\",\"HTML\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"常用meta整理\",\"date\":\"2020-02-21 12:20:10\",\"excerpt\":\"<h1 id=\\\"常用meta整理\\\" tabindex=\\\"-1\\\">常用meta整理 <a class=\\\"header-anchor\\\" href=\\\"#常用meta整理\\\" aria-label=\\\"Permalink to &quot;常用meta整理&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"meta-元素\\\" tabindex=\\\"-1\\\">&lt;meta&gt; 元素 <a class=\\\"header-anchor\\\" href=\\\"#meta-元素\\\" aria-label=\\\"Permalink to &quot;&lt;meta\\\\&gt; 元素&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"概要\\\" tabindex=\\\"-1\\\">概要 <a class=\\\"header-anchor\\\" href=\\\"#概要\\\" aria-label=\\\"Permalink to &quot;概要&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>meta标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。</p>\\n\",\"capture\":\"&lt;meta\\\\\\n 概要\\nmeta标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。\\n必要属性\\n| 属性    | 值        | 描述                                   |\\n| ------- | --------- | -------------------------------------- |\\n| content | some text | 定义与http-equiv或name属性相关的元信息 |\\n可选属性\\n| 属性     \"},{\"url\":\"/《Vue》笔记/05.工具/10.Vue CLi v3 创建项目使用记录.html\",\"relativePath\":\"/《Vue》笔记/05.工具/10.Vue CLi v3 创建项目使用记录.html\",\"frontmatter\":{\"title\":\"Vue CLi v3 创建项目使用记录\",\"date\":\"2020-02-20 17:24:29\",\"permalink\":\"/pages/d00311f8174119b2\",\"categories\":[\"《Vue》笔记\",\"工具\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Vue CLi v3 创建项目使用记录\",\"date\":\"2020-02-20 17:24:29\",\"capture\":\"官方文档\\n以下使用的CLi版本是 v3.11.0\\n vue create\\n1. 运行以下命令来创建一个新项目\\n```sh\\nvue create hello-world\\n```\\n2. 你会被提示选取一个 preset (预设)。你可以选默认的包含了基本的 Babel + ESLint 设置的 preset，也可以选“手动选择特性”来选取需要的特性。\\n```sh\\nVue CLI v3.11.0\\n? Please pick a preset: (Use arrow keys)\\n\\n  Manually select features (手动选择特性)\\n```\\n默认预设只包含Babel + ESLint\"},{\"url\":\"/《Vue》笔记/04.可复用性&组合/01.Mixin混入.html\",\"relativePath\":\"/《Vue》笔记/04.可复用性&组合/01.Mixin混入.html\",\"frontmatter\":{\"title\":\"Mixin混入\",\"date\":\"2020-02-19 15:22:41\",\"permalink\":\"/pages/bd36a3c1bc3e0821\",\"categories\":[\"《Vue》笔记\",\"可复用性&组合\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Mixin混入\",\"date\":\"2020-02-19 15:22:41\",\"excerpt\":\"<h1 id=\\\"mixin混入\\\" tabindex=\\\"-1\\\">Mixin混入 <a class=\\\"header-anchor\\\" href=\\\"#mixin混入\\\" aria-label=\\\"Permalink to &quot;Mixin混入&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"基础\\\" tabindex=\\\"-1\\\">基础 <a class=\\\"header-anchor\\\" href=\\\"#基础\\\" aria-label=\\\"Permalink to &quot;基础&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。</p>\\n\",\"capture\":\"基础\\n混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。\\n\\n&gt;\\n&gt; 可通过 `this.$options` 查看选项\\n例子：\\n```js\\n// 定义一个混入对象\\nvar myMixin = {\\n  created: function () {\\n    this.hello()\\n  },\\n  methods: {\\n    hello: function () {\\n      console.log('hello from mixin!')\\n  \"},{\"url\":\"/《Vue》笔记/02.组件/90.vue父子组件的生命周期顺序.html\",\"relativePath\":\"/《Vue》笔记/02.组件/90.vue父子组件的生命周期顺序.html\",\"frontmatter\":{\"title\":\"vue父子组件的生命周期顺序\",\"date\":\"2020-02-18 16:39:33\",\"permalink\":\"/pages/e6cec47efa42d7f1\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"vue父子组件的生命周期顺序\",\"date\":\"2020-02-18 16:39:33\",\"capture\":\"加载渲染过程\\n```\\n父beforeCreate -\\n```\\n父组件会先执行到beforeMount，接着会执行子组件钩子到挂载结束，再挂载父组件。\\n 子组件更新过程\\n```\\n父beforeUpdate -&gt; 子beforeUpdate -&gt; 子updated -&gt; 父updated\\n```\\n 父组件更新过程\\n```\\n父beforeUpdate -&gt; 父updated\\n```\\n 销毁过程\\n```\\n父beforeDestroy -&gt; 子beforeDestroy -&gt; 子destroyed -&gt; 父destroyed\\n```\"},{\"url\":\"/《Vue》笔记/03.过渡&动画/112.使用animate库.html\",\"relativePath\":\"/《Vue》笔记/03.过渡&动画/112.使用animate库.html\",\"frontmatter\":{\"title\":\"使用animate库\",\"date\":\"2020-02-17 16:05:52\",\"permalink\":\"/pages/3b0a20e70805fcea\",\"categories\":[\"《Vue》笔记\",\"过渡&动画\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"使用animate库\",\"date\":\"2020-02-17 16:05:52\",\"excerpt\":\"<h1 id=\\\"vue中使用animate-css库\\\" tabindex=\\\"-1\\\">vue中使用Animate.css库 <a class=\\\"header-anchor\\\" href=\\\"#vue中使用animate-css库\\\" aria-label=\\\"Permalink to &quot;vue中使用Animate.css库&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"自定义过渡类名\\\" tabindex=\\\"-1\\\">自定义过渡类名 <a class=\\\"header-anchor\\\" href=\\\"#自定义过渡类名\\\" aria-label=\\\"Permalink to &quot;自定义过渡类名&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>我们可以通过以下 attribute 来自定义过渡类名：</p>\\n<ul>\\n<li><code>enter-class</code></li>\\n<li><code>enter-active-class</code></li>\\n<li><code>enter-to-class</code> (2.1.8+)</li>\\n<li><code>leave-class</code></li>\\n<li><code>leave-active-class</code></li>\\n<li><code>leave-to-class</code> (2.1.8+)</li>\\n</ul>\\n\",\"capture\":\"自定义过渡类名\\n我们可以通过以下 attribute 来自定义过渡类名：\\n- `enter-class`\\n- `enter-active-class`\\n- `enter-to-class` (2.1.8+)\\n- `leave-class`\\n- `leave-active-class`\\n- `leave-to-class` (2.1.8+)\\n他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 Animate.css结合使用十分有用。\\n 使用Animate.css库\\n```html\\n&lt;transition\\n            name=\\\"custom-\"},{\"url\":\"/《Vue》笔记/02.组件/80.动态组件与 v-once 指令.html\",\"relativePath\":\"/《Vue》笔记/02.组件/80.动态组件与 v-once 指令.html\",\"frontmatter\":{\"title\":\"动态组件与 v-once 指令\",\"date\":\"2020-02-16 15:52:19\",\"permalink\":\"/pages/636ca33122e9a64b\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"动态组件与 v-once 指令\",\"date\":\"2020-02-16 15:52:19\",\"capture\":\"动态组件\\n```html\\n&lt;div id=\\\"root\\\"\\n\\t&lt;component :is=\\\"type\\\"&gt;&lt;/component&gt; &lt;!--其效果如同下面两行被注释的代码--&gt;\\n\\t&lt;!-- &lt;child-one v-if=\\\"type === 'child-one'\\\"&gt;&lt;/child-one&gt;\\n\\t    &lt;child-two v-if=\\\"type === 'child-two'\\\"&gt;&lt;/child-two&gt; --&gt;\\n\\t&lt;button @click=\\\"handleClick\\\"&gt;change&\"},{\"url\":\"/《Vue》笔记/02.组件/75.插槽slot.html\",\"relativePath\":\"/《Vue》笔记/02.组件/75.插槽slot.html\",\"frontmatter\":{\"title\":\"插槽slot\",\"date\":\"2020-02-16 11:46:27\",\"permalink\":\"/pages/055ecee9a4325386\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"插槽slot\",\"date\":\"2020-02-16 11:46:27\",\"capture\":\"API\\n 插槽\\n```html\\n&lt;div id=\\\"root\\\"\\n    &lt;child&gt; &lt;!-- 组件标签 --&gt;\\n        &lt;h1&gt;hello&lt;/h1&gt;\\n    &lt;/child&gt;\\n&lt;/div&gt;\\n&lt;script type=\\\"text/javascript\\\"&gt;\\n    Vue.component('child', { // 子组件\\n        template: '&lt;div&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;'\\n    })\\n    var vm \"},{\"url\":\"/《Vue》笔记/02.组件/65.非父子组件传值.html\",\"relativePath\":\"/《Vue》笔记/02.组件/65.非父子组件传值.html\",\"frontmatter\":{\"title\":\"非父子组件传值\",\"date\":\"2020-02-15 14:55:03\",\"permalink\":\"/pages/d408e64f666f146d\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"非父子组件传值\",\"date\":\"2020-02-15 14:55:03\",\"excerpt\":\"<h1 id=\\\"非父子组件间传值\\\" tabindex=\\\"-1\\\">非父子组件间传值 <a class=\\\"header-anchor\\\" href=\\\"#非父子组件间传值\\\" aria-label=\\\"Permalink to &quot;非父子组件间传值&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>当组件的嵌套多时，非父子组件间传值就显得复杂，除了使用<a href=\\\"https://vuex.vuejs.org/zh/\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">vuex</a>实现之外，还可以通过Bus（或者叫 总线/发布订阅模式/观察者模式）的方式实现非父子组件间传值。</p>\\n\",\"capture\":\"当组件的嵌套多时，非父子组件间传值就显得复杂，除了使用vuex实现之外，还可以通过Bus（或者叫 总线/发布订阅模式/观察者模式）的方式实现非父子组件间传值。\\n&lt;div id=\\\"root\\\"\\n\\t\\t&lt;child1 content=\\\"组件1：点我传出值\\\"&gt;&lt;/child1&gt;\\n\\t\\t&lt;child2 content=\\\"组件2\\\"&gt;&lt;/child2&gt;\\n\\t&lt;/div&gt;\\n```html\\n&lt;div id=\\\"root\\\"&gt;\\n    &lt;child1 content=\\\"组件1：点我传出值\\\"&gt;&lt;/child1&gt;\\n    &l\"},{\"url\":\"/《Vue》笔记/02.组件/55.自定义事件.html\",\"relativePath\":\"/《Vue》笔记/02.组件/55.自定义事件.html\",\"frontmatter\":{\"title\":\"自定义事件\",\"date\":\"2020-02-15 11:27:45\",\"permalink\":\"/pages/9651417d08d1779d\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"自定义事件\",\"date\":\"2020-02-15 11:27:45\",\"capture\":\"API\\n 在组件标签v-on绑定的事件是自定义事件\\n```html\\n&lt;div id=\\\"root\\\"\\n    &lt;child @click=\\\"handleClick\\\"&gt;&lt;/child&gt; &lt;!--这里click是自定义事件--&gt;\\n&lt;/div&gt;\\n&lt;script type=\\\"text/javascript\\\"&gt;\\n    Vue.component('child', {\\n        template: '&lt;button&gt;Child&lt;/button&gt;',\\n    })\\n    var vm = new Vue({\\n  \"},{\"url\":\"/《Vue》笔记/02.组件/52.Prop 验证 与 非 Prop 的 Attribute.html\",\"relativePath\":\"/《Vue》笔记/02.组件/52.Prop 验证 与 非 Prop 的 Attribute.html\",\"frontmatter\":{\"title\":\"Prop 验证 与 非 Prop 的 Attribute\",\"date\":\"2020-02-15 10:49:04\",\"permalink\":\"/pages/a3080f60f6596eb4\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Prop 验证 与 非 Prop 的 Attribute\",\"date\":\"2020-02-15 10:49:04\",\"capture\":\"Prop 验证\\nAPI\\n子组件对父组件传递来的参数进行校验\\n```js\\nVue.component('my-component', {\\n  props: {\\n    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)\\n    propA: Number,\\n    // 多个可能的类型\\n    propB: [String, Number],\\n    // 必填的字符串\\n    propC: {\\n      type: String,\\n      required: true\\n    },\\n    // 带有默认值的数字\\n    propD: {\\n      \"},{\"url\":\"/《Vue》笔记/02.组件/36.使用组件的细节点.html\",\"relativePath\":\"/《Vue》笔记/02.组件/36.使用组件的细节点.html\",\"frontmatter\":{\"title\":\"使用组件的细节点\",\"date\":\"2020-02-13 13:26:20\",\"permalink\":\"/pages/83a1ab785e7fd70c\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"使用组件的细节点\",\"date\":\"2020-02-13 13:26:20\",\"capture\":\"解析 DOM 模板时的注意事项\\n```html\\n&lt;div id=\\\"root\\\"\\n    &lt;table&gt;\\n        &lt;tbody&gt;\\n            &lt;row&gt;&lt;/row&gt;\\n            &lt;row&gt;&lt;/row&gt;\\n            &lt;row&gt;&lt;/row&gt;\\n        &lt;/tbody&gt;\\n    &lt;/table&gt;\\n&lt;/div&gt;\\n&lt;script type=\\\"text/javascript\\\"&gt;\\n    Vue.component\"},{\"url\":\"/《ES6 教程》笔记/29.最新提案.html\",\"relativePath\":\"/《ES6 教程》笔记/29.最新提案.html\",\"frontmatter\":{\"title\":\"最新提案\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/7188882b8d65af1b\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"最新提案\",\"date\":\"2020-02-09 16:00:30\",\"excerpt\":\"<h1 id=\\\"最新提案\\\" tabindex=\\\"-1\\\">最新提案 <a class=\\\"header-anchor\\\" href=\\\"#最新提案\\\" aria-label=\\\"Permalink to &quot;最新提案&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>本章介绍一些尚未进入标准、但很有希望的最新提案。</p>\\n<h2 id=\\\"do-表达式\\\" tabindex=\\\"-1\\\">do 表达式 <a class=\\\"header-anchor\\\" href=\\\"#do-表达式\\\" aria-label=\\\"Permalink to &quot;do 表达式&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">{</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">  let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> t </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> f</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">();</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">  t </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> t </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">*</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> t </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">+</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br></div></div>\",\"capture\":\"本章介绍一些尚未进入标准、但很有希望的最新提案。\\n do 表达式\\n本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。\\n```javascript\\n{\\n  let t = f();\\n  t = t * t + 1;\\n}\\n```\\n上面代码中，块级作用域将两个语句封装在一起。但是，在块级作用域以外，没有办法得到`t`的值，因为块级作用域不返回值，除非`t`是全局变量。\\n现在有一个提案，使得块级作用域可以变为表达式，也就是说可以返回值，办法就是在块级作用域之前加上`do`，使它变为`do`表达式，然后就会返回内部最后执行的表达式的值。\\n```javascript\\nlet x = do {\"},{\"url\":\"/《ES6 教程》笔记/30.装饰器.html\",\"relativePath\":\"/《ES6 教程》笔记/30.装饰器.html\",\"frontmatter\":{\"title\":\"装饰器\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/e97bc1e5626b082c\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"装饰器\",\"date\":\"2020-02-09 16:00:30\",\"excerpt\":\"<h1 id=\\\"装饰器\\\" tabindex=\\\"-1\\\">装饰器 <a class=\\\"header-anchor\\\" href=\\\"#装饰器\\\" aria-label=\\\"Permalink to &quot;装饰器&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>[说明] Decorator 提案经过了大幅修改，目前还没有定案，不知道语法会不会再变。下面的内容完全依据以前的提案，已经有点过时了。等待定案以后，需要完全重写。</p>\\n<p>装饰器（Decorator）是一种与类（class）相关的语法，用来注释或修改类和类方法。许多面向对象的语言都有这项功能，目前有一个<a href=\\\"https://github.com/tc39/proposal-decorators\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">提案</a>将其引入了 ECMAScript。</p>\\n\",\"capture\":\"[说明] Decorator 提案经过了大幅修改，目前还没有定案，不知道语法会不会再变。下面的内容完全依据以前的提案，已经有点过时了。等待定案以后，需要完全重写。\\n装饰器（Decorator）是一种与类（class）相关的语法，用来注释或修改类和类方法。许多面向对象的语言都有这项功能，目前有一个提案将其引入了 ECMAScript。\\n装饰器是一种函数，写成`@ + 函数名`。它可以放在类和类方法的定义前面。\\n```javascript\\n@frozen class Foo {\\n  @configurable(false)\\n  @enumerable(true)\\n  method() {}\\n  @\"},{\"url\":\"/《ES6 教程》笔记/31.函数式编程.html\",\"relativePath\":\"/《ES6 教程》笔记/31.函数式编程.html\",\"frontmatter\":{\"title\":\"函数式编程\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/1cf50330655efc69\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"函数式编程\",\"date\":\"2020-02-09 16:00:30\",\"excerpt\":\"<h1 id=\\\"函数式编程\\\" tabindex=\\\"-1\\\">函数式编程 <a class=\\\"header-anchor\\\" href=\\\"#函数式编程\\\" aria-label=\\\"Permalink to &quot;函数式编程&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>JavaScript 语言从一诞生，就具有函数式编程的烙印。它将函数作为一种独立的数据类型，与其他数据类型处于完全平等的地位。在 JavaScript 语言中，你可以采用面向对象编程，也可以采用函数式编程。有人甚至说，JavaScript 是有史以来第一种被大规模采用的函数式编程语言。</p>\\n\",\"capture\":\"JavaScript 语言从一诞生，就具有函数式编程的烙印。它将函数作为一种独立的数据类型，与其他数据类型处于完全平等的地位。在 JavaScript 语言中，你可以采用面向对象编程，也可以采用函数式编程。有人甚至说，JavaScript 是有史以来第一种被大规模采用的函数式编程语言。\\nES6 的种种新增功能，使得函数式编程变得更方便、更强大。本章介绍 ES6 如何进行函数式编程。\\n 柯里化\\n柯里化（currying）指的是将一个多参数的函数拆分成一系列函数，每个拆分后的函数都只接受一个参数（unary）。\\n```javascript\\nfunction add (a, b) {\\n  retur\"},{\"url\":\"/《ES6 教程》笔记/32.Mixin.html\",\"relativePath\":\"/《ES6 教程》笔记/32.Mixin.html\",\"frontmatter\":{\"title\":\"Mixin\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/6a8e2dc558da1b39\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Mixin\",\"date\":\"2020-02-09 16:00:30\",\"excerpt\":\"<h1 id=\\\"mixin\\\" tabindex=\\\"-1\\\">Mixin <a class=\\\"header-anchor\\\" href=\\\"#mixin\\\" aria-label=\\\"Permalink to &quot;Mixin&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>JavaScript 语言的设计是单一继承，即子类只能继承一个父类，不允许继承多个父类。这种设计保证了对象继承的层次结构是树状的，而不是复杂的<a href=\\\"https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">网状结构</a>。</p>\\n\",\"capture\":\"JavaScript 语言的设计是单一继承，即子类只能继承一个父类，不允许继承多个父类。这种设计保证了对象继承的层次结构是树状的，而不是复杂的网状结构。\\n但是，这大大降低了编程的灵活性。因为实际开发中，有时不可避免，子类需要继承多个父类。举例来说，“猫”可以继承“哺乳类动物”，也可以继承“宠物”。\\n各种单一继承的编程语言，有不同的多重继承解决方案。比如，Java 语言也是子类只能继承一个父类，但是还允许继承多个界面（interface），这样就间接实现了多重继承。Interface 与父类一样，也是一个类，只不过它只定义接口（method signature），不定义实现，因此又被称为“抽象类\"},{\"url\":\"/《ES6 教程》笔记/33.SIMD.html\",\"relativePath\":\"/《ES6 教程》笔记/33.SIMD.html\",\"frontmatter\":{\"title\":\"SIMD\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/8e8f80f69b775a56\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"SIMD\",\"date\":\"2020-02-09 16:00:30\",\"excerpt\":\"<h1 id=\\\"simd\\\" tabindex=\\\"-1\\\">SIMD <a class=\\\"header-anchor\\\" href=\\\"#simd\\\" aria-label=\\\"Permalink to &quot;SIMD&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>SIMD（发音<code>/sim-dee/</code>）是“Single Instruction/Multiple Data”的缩写，意为“单指令，多数据”。它是 JavaScript 操作 CPU 对应指令的接口，你可以看做这是一种不同的运算执行模式。与它相对的是 SISD（“Single Instruction/Single Data”），即“单指令，单数据”。</p>\\n\",\"capture\":\"概述\\nSIMD（发音`/sim-dee/`）是“Single Instruction/Multiple Data”的缩写，意为“单指令，多数据”。它是 JavaScript 操作 CPU 对应指令的接口，你可以看做这是一种不同的运算执行模式。与它相对的是 SISD（“Single Instruction/Single Data”），即“单指令，单数据”。\\nSIMD 的含义是使用一个指令，完成多个数据的运算；SISD 的含义是使用一个指令，完成单个数据的运算，这是 JavaScript 的默认运算模式。显而易见，SIMD 的执行效率要高于 SISD，所以被广泛用于 3D 图形运算、物理模拟等运算\"},{\"url\":\"/《ES6 教程》笔记/34.参考链接.html\",\"relativePath\":\"/《ES6 教程》笔记/34.参考链接.html\",\"frontmatter\":{\"title\":\"参考链接\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/ea6f3b870f6dab69\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"参考链接\",\"date\":\"2020-02-09 16:00:30\",\"capture\":\"官方文件\\n- ECMAScript® 2015 Language Specification: ECMAScript 2015 规格\\n- ECMAScript® 2016 Language Specification: ECMAScript 2016 规格\\n- ECMAScript® 2017 Language Specification：ECMAScript 2017 规格（草案）\\n- ECMAScript Current Proposals: ECMAScript 当前的所有提案\\n- ECMAScript Active Proposals: 已经进入正式流程的提案\\n- ECMAScript\"},{\"url\":\"/《ES6 教程》笔记/02.let 和 const 命令.html\",\"relativePath\":\"/《ES6 教程》笔记/02.let 和 const 命令.html\",\"frontmatter\":{\"title\":\"let 和 const 命令\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/c1edd70a6b7c7872\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"let 和 const 命令\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"let-和-const-命令\\\" tabindex=\\\"-1\\\">let 和 const 命令 <a class=\\\"header-anchor\\\" href=\\\"#let-和-const-命令\\\" aria-label=\\\"Permalink to &quot;let 和 const 命令&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"let-命令\\\" tabindex=\\\"-1\\\">let 命令 <a class=\\\"header-anchor\\\" href=\\\"#let-命令\\\" aria-label=\\\"Permalink to &quot;let 命令&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"基本用法\\\" tabindex=\\\"-1\\\">基本用法 <a class=\\\"header-anchor\\\" href=\\\"#基本用法\\\" aria-label=\\\"Permalink to &quot;基本用法&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>ES6 新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code>，但是所声明的变量，<strong>只在<code>let</code>命令所在的代码块内有效(块级作用域)</strong>。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">{</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">  let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> a </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 10</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">  var</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> b </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">a </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// ReferenceError: a is not defined.</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">b </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// 1</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br></div></div>\",\"capture\":\"let 命令\\n 基本用法\\nES6 新增了`let`命令，用来声明变量。它的用法类似于`var`，但是所声明的变量，只在`let`命令所在的代码块内有效(块级作用域)。\\n```javascript\\n{\\n  let a = 10;\\n  var b = 1;\\n}\\na // ReferenceError: a is not defined.\\nb // 1\\n```\\n上面代码在代码块之中，分别用`let`和`var`声明了两个变量。然后在代码块之外调用这两个变量，结果`let`声明的变量报错，`var`声明的变量返回了正确的值。这表明，`let`声明的变量只在它所在的代码块有效。\\n`for`循环的计数器，\"},{\"url\":\"/《ES6 教程》笔记/03.变量的解构赋值.html\",\"relativePath\":\"/《ES6 教程》笔记/03.变量的解构赋值.html\",\"frontmatter\":{\"title\":\"变量的解构赋值\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/b1ab10a62f7564da\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"变量的解构赋值\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"变量的解构赋值\\\" tabindex=\\\"-1\\\">变量的解构赋值 <a class=\\\"header-anchor\\\" href=\\\"#变量的解构赋值\\\" aria-label=\\\"Permalink to &quot;变量的解构赋值&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"数组的解构赋值\\\" tabindex=\\\"-1\\\">数组的解构赋值 <a class=\\\"header-anchor\\\" href=\\\"#数组的解构赋值\\\" aria-label=\\\"Permalink to &quot;数组的解构赋值&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"基本用法\\\" tabindex=\\\"-1\\\">基本用法 <a class=\\\"header-anchor\\\" href=\\\"#基本用法\\\" aria-label=\\\"Permalink to &quot;基本用法&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>ES6 允许按照一定模式，<strong>从数组和对象中提取值，对变量进行赋值，这被称为解构</strong>（Destructuring）。</p>\\n<p>以前，为变量赋值，只能直接指定值。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> a </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> b </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> c </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 3</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br></div></div>\",\"capture\":\"数组的解构赋值\\n 基本用法\\nES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。\\n以前，为变量赋值，只能直接指定值。\\n```javascript\\nlet a = 1;\\nlet b = 2;\\nlet c = 3;\\n```\\nES6 允许写成下面这样。\\n```javascript\\nlet [a, b, c] = [1, 2, 3];\\n```\\n上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。\\n本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。\\n```javas\"},{\"url\":\"/《ES6 教程》笔记/04.字符串的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/04.字符串的扩展.html\",\"frontmatter\":{\"title\":\"字符串的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/ca89eca8adeba5f4\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"字符串的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"字符串的扩展\\\" tabindex=\\\"-1\\\">字符串的扩展 <a class=\\\"header-anchor\\\" href=\\\"#字符串的扩展\\\" aria-label=\\\"Permalink to &quot;字符串的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>本章介绍 ES6 对字符串的改造和增强，下一章介绍字符串对象的新增方法。</p>\\n<h2 id=\\\"字符的-unicode-表示法\\\" tabindex=\\\"-1\\\">字符的 Unicode 表示法 <a class=\\\"header-anchor\\\" href=\\\"#字符的-unicode-表示法\\\" aria-label=\\\"Permalink to &quot;字符的 Unicode 表示法&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES6 加强了对 Unicode 的支持，允许采用<code>\\\\uxxxx</code>形式表示一个字符，其中<code>xxxx</code>表示字符的 Unicode 码点。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">\\\\u0061</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// \\\"a\\\"</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br></div></div>\",\"capture\":\"本章介绍 ES6 对字符串的改造和增强，下一章介绍字符串对象的新增方法。\\n 字符的 Unicode 表示法\\nES6 加强了对 Unicode 的支持，允许采用`\\\\uxxxx`形式表示一个字符，其中`xxxx`表示字符的 Unicode 码点。\\n```javascript\\n\\\"\\\\u0061\\\"\\n// \\\"a\\\"\\n```\\n但是，这种表示法只限于码点在`\\\\u0000`~`\\\\uFFFF`之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。\\n```javascript\\n\\\"\\\\uD842\\\\uDFB7\\\"\\n// \\\"𠮷\\\"\\n\\\"\\\\u20BB7\\\"\\n// \\\" 7\\\"\\n```\\n上面代码表示，如果直接在`\\\\u`后面跟上超过`\"},{\"url\":\"/《ES6 教程》笔记/05.字符串的新增方法.html\",\"relativePath\":\"/《ES6 教程》笔记/05.字符串的新增方法.html\",\"frontmatter\":{\"title\":\"字符串的新增方法\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/a650b4a0ebfc9350\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"字符串的新增方法\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"字符串的新增方法\\\" tabindex=\\\"-1\\\">字符串的新增方法 <a class=\\\"header-anchor\\\" href=\\\"#字符串的新增方法\\\" aria-label=\\\"Permalink to &quot;字符串的新增方法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>本章介绍字符串对象的新增方法。</p>\\n<h2 id=\\\"string-fromcodepoint\\\" tabindex=\\\"-1\\\">String.fromCodePoint() <a class=\\\"header-anchor\\\" href=\\\"#string-fromcodepoint\\\" aria-label=\\\"Permalink to &quot;String.fromCodePoint()&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES5 提供<code>String.fromCharCode()</code>方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于<code>0xFFFF</code>的字符。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">String.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">fromCharCode</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">0x20BB7</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">)</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// \\\"ஷ\\\"</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br></div></div>\",\"capture\":\"本章介绍字符串对象的新增方法。\\n String.fromCodePoint()\\nES5 提供`String.fromCharCode()`方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于`0xFFFF`的字符。\\n```javascript\\nString.fromCharCode(0x20BB7)\\n// \\\"ஷ\\\"\\n```\\n上面代码中，`String.fromCharCode()`不能识别大于`0xFFFF`的码点，所以`0x20BB7`就发生了溢出，最高位`2`被舍弃了，最后返回码点`U+0BB7`对应的字符，而不是码点`U+20BB7`对应的字符。\\nES6 提供了`S\"},{\"url\":\"/《ES6 教程》笔记/06.正则的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/06.正则的扩展.html\",\"frontmatter\":{\"title\":\"正则的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/0473261a6ab0ee8c\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"正则的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"正则的扩展\\\" tabindex=\\\"-1\\\">正则的扩展 <a class=\\\"header-anchor\\\" href=\\\"#正则的扩展\\\" aria-label=\\\"Permalink to &quot;正则的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"regexp-构造函数\\\" tabindex=\\\"-1\\\">RegExp 构造函数 <a class=\\\"header-anchor\\\" href=\\\"#regexp-构造函数\\\" aria-label=\\\"Permalink to &quot;RegExp 构造函数&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>在 ES5 中，<code>RegExp</code>构造函数的参数有两种情况。</p>\\n<p>第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">var</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> regex </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> new</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> RegExp</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'xyz'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'i'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">);</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// 等价于</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">var</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> regex </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> /</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#DBEDFF\\\">xyz</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">/</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">i</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br></div></div>\",\"capture\":\"RegExp 构造函数\\n在 ES5 中，`RegExp`构造函数的参数有两种情况。\\n第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。\\n```javascript\\nvar regex = new RegExp('xyz', 'i');\\n// 等价于\\nvar regex = /xyz/i;\\n```\\n第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。\\n```javascript\\nvar regex = new RegExp(/xyz/i);\\n// 等价于\\nvar regex = /xyz/i;\\n```\\n但是，ES5 不允许此时使用第二个参数添加修饰\"},{\"url\":\"/《ES6 教程》笔记/07.数值的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/07.数值的扩展.html\",\"frontmatter\":{\"title\":\"数值的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/5dfea9a0f2d1a392\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"数值的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"数值的扩展\\\" tabindex=\\\"-1\\\">数值的扩展 <a class=\\\"header-anchor\\\" href=\\\"#数值的扩展\\\" aria-label=\\\"Permalink to &quot;数值的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"二进制和八进制表示法\\\" tabindex=\\\"-1\\\">二进制和八进制表示法 <a class=\\\"header-anchor\\\" href=\\\"#二进制和八进制表示法\\\" aria-label=\\\"Permalink to &quot;二进制和八进制表示法&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES6 提供了二进制和八进制数值的新的写法，分别用前缀<code>0b</code>（或<code>0B</code>）和<code>0o</code>（或<code>0O</code>）表示。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">0b111110111</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> ===</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 503</span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\"> // true</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">0o767</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> ===</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 503</span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\"> // true</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br></div></div>\",\"capture\":\"二进制和八进制表示法\\nES6 提供了二进制和八进制数值的新的写法，分别用前缀`0b`（或`0B`）和`0o`（或`0O`）表示。\\n```javascript\\n0b111110111 === 503 // true\\n0o767 === 503 // true\\n```\\n从 ES5 开始，在严格模式之中，八进制就不再允许使用前缀`0`表示，ES6 进一步明确，要使用前缀`0o`表示。\\n```javascript\\n// 非严格模式\\n(function(){\\n  console.log(0o11 === 011);\\n})() // true\\n// 严格模式\\n(function(){\\n  'use str\"},{\"url\":\"/《ES6 教程》笔记/08.函数的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/08.函数的扩展.html\",\"frontmatter\":{\"title\":\"函数的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/8ed309d668b20264\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"函数的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"函数的扩展\\\" tabindex=\\\"-1\\\">函数的扩展 <a class=\\\"header-anchor\\\" href=\\\"#函数的扩展\\\" aria-label=\\\"Permalink to &quot;函数的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"函数参数的默认值\\\" tabindex=\\\"-1\\\">函数参数的默认值 <a class=\\\"header-anchor\\\" href=\\\"#函数参数的默认值\\\" aria-label=\\\"Permalink to &quot;函数参数的默认值&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"基本用法\\\" tabindex=\\\"-1\\\">基本用法 <a class=\\\"header-anchor\\\" href=\\\"#基本用法\\\" aria-label=\\\"Permalink to &quot;基本用法&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">function</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#E36209;--shiki-dark:#FFAB70\\\">x</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#E36209;--shiki-dark:#FFAB70\\\">y</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">) {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">  y </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> y </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">||</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> 'World'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">  console.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(x, y);</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'Hello'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">) </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// Hello World</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'Hello'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'China'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">) </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// Hello China</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'Hello'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">''</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">) </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// Hello World</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br><span class=\\\"line-number\\\">8</span><br></div></div>\",\"capture\":\"函数参数的默认值\\n 基本用法\\nES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。\\n```javascript\\nfunction log(x, y) {\\n  y = y || 'World';\\n  console.log(x, y);\\n}\\nlog('Hello') // Hello World\\nlog('Hello', 'China') // Hello China\\nlog('Hello', '') // Hello World\\n```\\n上面代码检查函数`log`的参数`y`有没有赋值，如果没有，则指定默认值为`World`。这种写法的缺点在于，如果参数`y`赋值了，但是对应的布\"},{\"url\":\"/《ES6 教程》笔记/09.数组的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/09.数组的扩展.html\",\"frontmatter\":{\"title\":\"数组的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/e34009d60d8bc4b2\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"数组的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"数组的扩展\\\" tabindex=\\\"-1\\\">数组的扩展 <a class=\\\"header-anchor\\\" href=\\\"#数组的扩展\\\" aria-label=\\\"Permalink to &quot;数组的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"扩展运算符\\\" tabindex=\\\"-1\\\">扩展运算符 <a class=\\\"header-anchor\\\" href=\\\"#扩展运算符\\\" aria-label=\\\"Permalink to &quot;扩展运算符&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"含义\\\" tabindex=\\\"-1\\\">含义 <a class=\\\"header-anchor\\\" href=\\\"#含义\\\" aria-label=\\\"Permalink to &quot;含义&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>扩展运算符（spread）是三个点（<code>...</code>）。它好比 rest 参数的逆运算，<strong>将一个数组转为用逗号分隔的参数序列</strong>。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">console.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">...</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">[</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">3</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">])</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// 1 2 3</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">console.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">...</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">[</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">3</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">4</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">], </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">5</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">)</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// 1 2 3 4 5</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">[</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">...</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">document.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">querySelectorAll</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'div'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">)]</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// [&#x3C;div>, &#x3C;div>, &#x3C;div>]</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br><span class=\\\"line-number\\\">8</span><br></div></div>\",\"capture\":\"扩展运算符\\n 含义\\n扩展运算符（spread）是三个点（`...`）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。\\n```javascript\\nconsole.log(...[1, 2, 3])\\n// 1 2 3\\nconsole.log(1, ...[2, 3, 4], 5)\\n// 1 2 3 4 5\\n[...document.querySelectorAll('div')]\\n// [&lt;div\\n```\\n该运算符主要用于函数调用。\\n```javascript\\nfunction push(array, ...items) {\\n  array.push(...items\"},{\"url\":\"/《ES6 教程》笔记/10.对象的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/10.对象的扩展.html\",\"frontmatter\":{\"title\":\"对象的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/b5e3e0a0ff6e9c25\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"对象的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"对象的扩展\\\" tabindex=\\\"-1\\\">对象的扩展 <a class=\\\"header-anchor\\\" href=\\\"#对象的扩展\\\" aria-label=\\\"Permalink to &quot;对象的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>对象（object）是 JavaScript 最重要的数据结构。ES6 对它进行了重大升级，本章介绍数据结构本身的改变，下一章介绍<code>Object</code>对象的新增方法。</p>\\n\",\"capture\":\"对象（object）是 JavaScript 最重要的数据结构。ES6 对它进行了重大升级，本章介绍数据结构本身的改变，下一章介绍`Object`对象的新增方法。\\n 属性的简洁表示法\\nES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。\\n```javascript\\nconst foo = 'bar';\\nconst baz = {foo};\\nbaz // {foo: \\\"bar\\\"}\\n// 等同于\\nconst baz = {foo: foo};\\n```\\n上面代码中，变量`foo`直接写在大括号里面。这时，属性名就是变量名, 属性值就是变量值。下面是另一个例子。\\n`\"},{\"url\":\"/《ES6 教程》笔记/11.对象的新增方法.html\",\"relativePath\":\"/《ES6 教程》笔记/11.对象的新增方法.html\",\"frontmatter\":{\"title\":\"对象的新增方法\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/e85e68947502cf90\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"对象的新增方法\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"对象的新增方法\\\" tabindex=\\\"-1\\\">对象的新增方法 <a class=\\\"header-anchor\\\" href=\\\"#对象的新增方法\\\" aria-label=\\\"Permalink to &quot;对象的新增方法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>本章介绍 Object 对象的新增方法。</p>\\n<h2 id=\\\"object-is\\\" tabindex=\\\"-1\\\">Object.is() <a class=\\\"header-anchor\\\" href=\\\"#object-is\\\" aria-label=\\\"Permalink to &quot;Object.is()&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES5 比较两个值是否相等，只有两个运算符：相等运算符（<code>==</code>）和严格相等运算符（<code>===</code>）。它们都有缺点，前者会自动转换数据类型，后者的<code>NaN</code>不等于自身，以及<code>+0</code>等于<code>-0</code>。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</p>\\n<p>ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。<code>Object.is</code>就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</p>\\n\",\"capture\":\"本章介绍 Object 对象的新增方法。\\n Object.is()\\nES5 比较两个值是否相等，只有两个运算符：相等运算符（`==`）和严格相等运算符（`===`）。它们都有缺点，前者会自动转换数据类型，后者的`NaN`不等于自身，以及`+0`等于`-0`。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。\\nES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。`Object.is`就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。\\n```javascript\\nObject.\"},{\"url\":\"/《ES6 教程》笔记/12.Symbol.html\",\"relativePath\":\"/《ES6 教程》笔记/12.Symbol.html\",\"frontmatter\":{\"title\":\"Symbol\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/02c86eb2792f3262\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Symbol\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"symbol\\\" tabindex=\\\"-1\\\">Symbol <a class=\\\"header-anchor\\\" href=\\\"#symbol\\\" aria-label=\\\"Permalink to &quot;Symbol&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，<strong>保证每个属性的名字都是独一无二</strong>的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入<code>Symbol</code>的原因。</p>\\n\",\"capture\":\"概述\\nES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入`Symbol`的原因。\\nES6 引入了一种新的原始数据类型`Symbol`，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：`undefined`、`null`、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。\\nSymbol 值\"},{\"url\":\"/《ES6 教程》笔记/13.Set 和 Map 数据结构.html\",\"relativePath\":\"/《ES6 教程》笔记/13.Set 和 Map 数据结构.html\",\"frontmatter\":{\"title\":\"Set 和 Map 数据结构\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/0c21dae358fca16b\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Set 和 Map 数据结构\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"set-和-map-数据结构\\\" tabindex=\\\"-1\\\">Set 和 Map 数据结构 <a class=\\\"header-anchor\\\" href=\\\"#set-和-map-数据结构\\\" aria-label=\\\"Permalink to &quot;Set 和 Map 数据结构&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"set\\\" tabindex=\\\"-1\\\">Set <a class=\\\"header-anchor\\\" href=\\\"#set\\\" aria-label=\\\"Permalink to &quot;Set&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"基本用法\\\" tabindex=\\\"-1\\\">基本用法 <a class=\\\"header-anchor\\\" href=\\\"#基本用法\\\" aria-label=\\\"Permalink to &quot;基本用法&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>ES6 提供了新的数据结构 Set。它<strong>类似于数组，但是成员的值都是唯一的，没有重复的值</strong>。</p>\\n<p><strong><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构</strong>。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">const</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> s</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> =</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> new</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> Set</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">();</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">[</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">3</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">5</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">4</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">5</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">].</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">forEach</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#E36209;--shiki-dark:#FFAB70\\\">x</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> =></span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> s.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">add</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(x));</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">for</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> (</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> i </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">of</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> s) {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">  console.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(i);</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// 2 3 5 4</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br><span class=\\\"line-number\\\">8</span><br></div></div>\",\"capture\":\"Set\\n 基本用法\\nES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。\\n`Set`本身是一个构造函数，用来生成 Set 数据结构。\\n```javascript\\nconst s = new Set();\\n[2, 3, 5, 4, 5, 2, 2].forEach(x =\\nfor (let i of s) {\\n  console.log(i);\\n}\\n// 2 3 5 4\\n```\\n上面代码通过`add()`方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。\\n`Set`函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参\"},{\"url\":\"/《ES6 教程》笔记/14.Proxy.html\",\"relativePath\":\"/《ES6 教程》笔记/14.Proxy.html\",\"frontmatter\":{\"title\":\"Proxy\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/f56ec2ab97d60483\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Proxy\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"proxy\\\" tabindex=\\\"-1\\\">Proxy <a class=\\\"header-anchor\\\" href=\\\"#proxy\\\" aria-label=\\\"Permalink to &quot;Proxy&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“<strong>元编程</strong>”（meta programming），即<strong>对编程语言进行编程</strong>。</p>\\n<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，<strong>外界对该对象的访问，都必须先通过这层拦截</strong>，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>\\n\",\"capture\":\"概述\\nProxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。\\nProxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。\\n```javascript\\nvar obj = new Proxy({}, {\\n  get: function (target, propKey, receiver) {\\n    console.log(\"},{\"url\":\"/《ES6 教程》笔记/15.Reflect.html\",\"relativePath\":\"/《ES6 教程》笔记/15.Reflect.html\",\"frontmatter\":{\"title\":\"Reflect\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/74de3e45e4491e95\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Reflect\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"reflect\\\" tabindex=\\\"-1\\\">Reflect <a class=\\\"header-anchor\\\" href=\\\"#reflect\\\" aria-label=\\\"Permalink to &quot;Reflect&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p><code>Reflect</code>对象与<code>Proxy</code>对象一样，也是 ES6 为了操作对象而提供的新 API。<code>Reflect</code>对象的设计目的有这样几个。</p>\\n<p>（1） **将<code>Object</code>对象的一些明显属于语言内部的方法（比如<code>Object.defineProperty</code>），放到<code>Reflect</code>对象上。**现阶段，某些方法同时在<code>Object</code>和<code>Reflect</code>对象上部署，未来的新方法将只部署在<code>Reflect</code>对象上。也就是说，从<code>Reflect</code>对象上可以拿到语言内部的方法。</p>\\n\",\"capture\":\"概述\\n`Reflect`对象与`Proxy`对象一样，也是 ES6 为了操作对象而提供的新 API。`Reflect`对象的设计目的有这样几个。\\n（1） 将`Object`对象的一些明显属于语言内部的方法（比如`Object.defineProperty`），放到`Reflect`对象上。现阶段，某些方法同时在`Object`和`Reflect`对象上部署，未来的新方法将只部署在`Reflect`对象上。也就是说，从`Reflect`对象上可以拿到语言内部的方法。\\n（2） 修改某些`Object`方法的返回结果，让其变得更合理。比如，`Object.defineProperty(obj, na\"},{\"url\":\"/《ES6 教程》笔记/16.Promise 对象.html\",\"relativePath\":\"/《ES6 教程》笔记/16.Promise 对象.html\",\"frontmatter\":{\"title\":\"Promise 对象\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/2810ae8985e9bd52\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Promise 对象\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"promise-对象\\\" tabindex=\\\"-1\\\">Promise 对象 <a class=\\\"header-anchor\\\" href=\\\"#promise-对象\\\" aria-label=\\\"Permalink to &quot;Promise 对象&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"promise-的含义\\\" tabindex=\\\"-1\\\">Promise 的含义 <a class=\\\"header-anchor\\\" href=\\\"#promise-的含义\\\" aria-label=\\\"Permalink to &quot;Promise 的含义&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了<code>Promise</code>对象。</p>\\n\",\"capture\":\"Promise 的含义\\nPromise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了`Promise`对象。\\n所谓`Promise`，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。\\n`Promise`对象有以下两个特点。\\n（1）对象的状态不受外界影响。`Promise`对象代表一个异步操作，有三种状态：`pe\"},{\"url\":\"/《ES6 教程》笔记/17.Iterator 和 for-of 循环.html\",\"relativePath\":\"/《ES6 教程》笔记/17.Iterator 和 for-of 循环.html\",\"frontmatter\":{\"title\":\"Iterator 和 for-of 循环\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/48df907ad3570f3d\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Iterator 和 for-of 循环\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"iterator-和-for-of-循环\\\" tabindex=\\\"-1\\\">Iterator 和 for...of 循环 <a class=\\\"header-anchor\\\" href=\\\"#iterator-和-for-of-循环\\\" aria-label=\\\"Permalink to &quot;Iterator 和 for...of 循环&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"iterator-遍历器-的概念\\\" tabindex=\\\"-1\\\">Iterator（遍历器）的概念 <a class=\\\"header-anchor\\\" href=\\\"#iterator-遍历器-的概念\\\" aria-label=\\\"Permalink to &quot;Iterator（遍历器）的概念&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>JavaScript 原有的表示“集合”的数据结构，主要是数组（<code>Array</code>）和对象（<code>Object</code>），ES6 又添加了<code>Map</code>和<code>Set</code>。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是<code>Map</code>，<code>Map</code>的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。</p>\\n\",\"capture\":\"Iterator（遍历器）的概念\\nJavaScript 原有的表示“集合”的数据结构，主要是数组（`Array`）和对象（`Object`），ES6 又添加了`Map`和`Set`。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是`Map`，`Map`的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。\\n遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。\\nIterator 的作用有三个：一是为各\"},{\"url\":\"/《ES6 教程》笔记/18.Generator 函数的语法.html\",\"relativePath\":\"/《ES6 教程》笔记/18.Generator 函数的语法.html\",\"frontmatter\":{\"title\":\"Generator 函数的语法\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/718b48ed9ce0adce\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Generator 函数的语法\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"generator-函数的语法\\\" tabindex=\\\"-1\\\">Generator 函数的语法 <a class=\\\"header-anchor\\\" href=\\\"#generator-函数的语法\\\" aria-label=\\\"Permalink to &quot;Generator 函数的语法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"基本概念\\\" tabindex=\\\"-1\\\">基本概念 <a class=\\\"header-anchor\\\" href=\\\"#基本概念\\\" aria-label=\\\"Permalink to &quot;基本概念&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>Generator 函数是 ES6 提供的一种<strong>异步编程解决方案</strong>，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《Generator 函数的异步应用》一章。</p>\\n\",\"capture\":\"简介\\n 基本概念\\nGenerator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《Generator 函数的异步应用》一章。\\nGenerator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。\\n执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。\\n形式上，Generator 函数是一个\"},{\"url\":\"/《ES6 教程》笔记/19.Generator 函数的异步应用.html\",\"relativePath\":\"/《ES6 教程》笔记/19.Generator 函数的异步应用.html\",\"frontmatter\":{\"title\":\"Generator 函数的异步应用\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/75af7031eb66847b\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Generator 函数的异步应用\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"generator-函数的异步应用\\\" tabindex=\\\"-1\\\">Generator 函数的异步应用 <a class=\\\"header-anchor\\\" href=\\\"#generator-函数的异步应用\\\" aria-label=\\\"Permalink to &quot;Generator 函数的异步应用&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>异步编程对 JavaScript 语言太重要。JavaScript 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。本章主要介绍 Generator 函数如何完成异步操作。</p>\\n\",\"capture\":\"异步编程对 JavaScript 语言太重要。JavaScript 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。本章主要介绍 Generator 函数如何完成异步操作。\\n 传统方法\\nES6 诞生以前，异步编程的方法，大概有下面四种。\\n- 回调函数\\n- 事件监听\\n- 发布/订阅\\n- Promise 对象\\nGenerator 函数将 JavaScript 异步编程带入了一个全新的阶段。\\n 基本概念\\n 异步\\n所谓\\\"异步\\\"，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。\\n比如，有一个任\"},{\"url\":\"/《ES6 教程》笔记/20.async 函数.html\",\"relativePath\":\"/《ES6 教程》笔记/20.async 函数.html\",\"frontmatter\":{\"title\":\"async 函数\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/3777253e65bac487\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"async 函数\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"async-函数\\\" tabindex=\\\"-1\\\">async 函数 <a class=\\\"header-anchor\\\" href=\\\"#async-函数\\\" aria-label=\\\"Permalink to &quot;async 函数&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"含义\\\" tabindex=\\\"-1\\\">含义 <a class=\\\"header-anchor\\\" href=\\\"#含义\\\" aria-label=\\\"Permalink to &quot;含义&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p>\\n<p>async 函数是什么？一句话，它就<strong>是 Generator 函数的语法糖</strong>。</p>\\n<p>前文有一个 Generator 函数，依次读取两个文件。</p>\\n\",\"capture\":\"含义\\nES2017 标准引入了 async 函数，使得异步操作变得更加方便。\\nasync 函数是什么？一句话，它就是 Generator 函数的语法糖。\\n前文有一个 Generator 函数，依次读取两个文件。\\n```javascript\\nconst fs = require('fs');\\nconst readFile = function (fileName) {\\n  return new Promise(function (resolve, reject) {\\n    fs.readFile(fileName, function(error, data) {\\n      if (error\"},{\"url\":\"/《ES6 教程》笔记/21.Class 的基本语法.html\",\"relativePath\":\"/《ES6 教程》笔记/21.Class 的基本语法.html\",\"frontmatter\":{\"title\":\"Class 的基本语法\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/e831e1593c82bbe0\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Class 的基本语法\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"class-的基本语法\\\" tabindex=\\\"-1\\\">Class 的基本语法 <a class=\\\"header-anchor\\\" href=\\\"#class-的基本语法\\\" aria-label=\\\"Permalink to &quot;Class 的基本语法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"类的由来\\\" tabindex=\\\"-1\\\">类的由来 <a class=\\\"header-anchor\\\" href=\\\"#类的由来\\\" aria-label=\\\"Permalink to &quot;类的由来&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">function</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> Point</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#E36209;--shiki-dark:#FFAB70\\\">x</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#E36209;--shiki-dark:#FFAB70\\\">y</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">) {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">  this</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.x </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> x;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">  this</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.y </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> y;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">Point</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">prototype</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">toString</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> =</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> function</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> () {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">  return</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> '('</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> +</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> this</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.x </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">+</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> ', '</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> +</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> this</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.y </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">+</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> ')'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">};</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">var</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> p </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> new</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> Point</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">);</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br><span class=\\\"line-number\\\">8</span><br><span class=\\\"line-number\\\">9</span><br><span class=\\\"line-number\\\">10</span><br></div></div>\",\"capture\":\"简介\\n 类的由来\\nJavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。\\n```javascript\\nfunction Point(x, y) {\\n  this.x = x;\\n  this.y = y;\\n}\\nPoint.prototype.toString = function () {\\n  return '(' + this.x + ', ' + this.y + ')';\\n};\\nvar p = new Point(1, 2);\\n```\\n上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。\\nES6 提供\"},{\"url\":\"/《ES6 教程》笔记/22.Class 的继承.html\",\"relativePath\":\"/《ES6 教程》笔记/22.Class 的继承.html\",\"frontmatter\":{\"title\":\"Class 的继承\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/83f8c3a0cd87dd83\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Class 的继承\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"class-的继承\\\" tabindex=\\\"-1\\\">Class 的继承 <a class=\\\"header-anchor\\\" href=\\\"#class-的继承\\\" aria-label=\\\"Permalink to &quot;Class 的继承&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>Class 可以通过<code>extends</code>关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">class</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> Point</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">class</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> ColorPoint</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> extends</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> Point</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br></div></div>\",\"capture\":\"简介\\nClass 可以通过`extends`关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。\\n```javascript\\nclass Point {\\n}\\nclass ColorPoint extends Point {\\n}\\n```\\n上面代码定义了一个`ColorPoint`类，该类通过`extends`关键字，继承了`Point`类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个`Point`类。下面，我们在`ColorPoint`内部加上代码。\\n```javascript\\nclass ColorPoint extends Point \"},{\"url\":\"/《ES6 教程》笔记/23.Module 的语法.html\",\"relativePath\":\"/《ES6 教程》笔记/23.Module 的语法.html\",\"frontmatter\":{\"title\":\"Module 的语法\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/efe2fb04eb8ac5fb\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Module 的语法\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"module-的语法\\\" tabindex=\\\"-1\\\">Module 的语法 <a class=\\\"header-anchor\\\" href=\\\"#module-的语法\\\" aria-label=\\\"Permalink to &quot;Module 的语法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的<code>require</code>、Python 的<code>import</code>，甚至就连 CSS 都有<code>@import</code>，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p>\\n\",\"capture\":\"概述\\n历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的`require`、Python 的`import`，甚至就连 CSS 都有`@import`，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。\\n在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD \"},{\"url\":\"/《ES6 教程》笔记/24.Module 的加载实现.html\",\"relativePath\":\"/《ES6 教程》笔记/24.Module 的加载实现.html\",\"frontmatter\":{\"title\":\"Module 的加载实现\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/a79ca2e64ceae213\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Module 的加载实现\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"module-的加载实现\\\" tabindex=\\\"-1\\\">Module 的加载实现 <a class=\\\"header-anchor\\\" href=\\\"#module-的加载实现\\\" aria-label=\\\"Permalink to &quot;Module 的加载实现&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>上一章介绍了模块的语法，本章介绍如何在浏览器和 Node.js 之中加载 ES6 模块，以及实际开发中经常遇到的一些问题（比如循环加载）。</p>\\n\",\"capture\":\"上一章介绍了模块的语法，本章介绍如何在浏览器和 Node.js 之中加载 ES6 模块，以及实际开发中经常遇到的一些问题（比如循环加载）。\\n 浏览器加载\\n 传统方法\\nHTML 网页中，浏览器通过`&lt;script\\n```html\\n&lt;!-- 页面内嵌的脚本 --&gt;\\n&lt;script type=\\\"application/javascript\\\"&gt;\\n  // module code\\n&lt;/script&gt;\\n&lt;!-- 外部脚本 --&gt;\\n&lt;script type=\\\"application/javascript\\\" src=\\\"path/to/myModule\"},{\"url\":\"/《ES6 教程》笔记/25.编程风格.html\",\"relativePath\":\"/《ES6 教程》笔记/25.编程风格.html\",\"frontmatter\":{\"title\":\"编程风格\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/984bf549204bb266\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"编程风格\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"编程风格\\\" tabindex=\\\"-1\\\">编程风格 <a class=\\\"header-anchor\\\" href=\\\"#编程风格\\\" aria-label=\\\"Permalink to &quot;编程风格&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>本章探讨如何将 ES6 的新语法，运用到编码实践之中，与传统的 JavaScript 语法结合在一起，写出合理的、易于阅读和维护的代码。</p>\\n<p>多家公司和组织已经公开了它们的风格规范，下面的内容主要参考了 <a href=\\\"https://github.com/airbnb/javascript\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">Airbnb</a> 公司的 JavaScript 风格规范。</p>\\n\",\"capture\":\"本章探讨如何将 ES6 的新语法，运用到编码实践之中，与传统的 JavaScript 语法结合在一起，写出合理的、易于阅读和维护的代码。\\n多家公司和组织已经公开了它们的风格规范，下面的内容主要参考了 Airbnb 公司的 JavaScript 风格规范。\\n 块级作用域\\n（1）let 取代 var\\nES6 提出了两个新的声明变量的命令：`let`和`const`。其中，`let`完全可以取代`var`，因为两者语义相同，而且`let`没有副作用。\\n```javascript\\n'use strict';\\nif (true) {\\n  let x = 'hello';\\n}\\nfor (let i = 0\"},{\"url\":\"/《ES6 教程》笔记/26.读懂 ECMAScript 规格.html\",\"relativePath\":\"/《ES6 教程》笔记/26.读懂 ECMAScript 规格.html\",\"frontmatter\":{\"title\":\"读懂 ECMAScript 规格\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/32c35f7651d6e58e\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"读懂 ECMAScript 规格\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"读懂-ecmascript-规格\\\" tabindex=\\\"-1\\\">读懂 ECMAScript 规格 <a class=\\\"header-anchor\\\" href=\\\"#读懂-ecmascript-规格\\\" aria-label=\\\"Permalink to &quot;读懂 ECMAScript 规格&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>规格文件是计算机语言的官方标准，详细描述语法规则和实现方法。</p>\\n<p>一般来说，没有必要阅读规格，除非你要写编译器。因为规格写得非常抽象和精炼，又缺乏实例，不容易理解，而且对于解决实际的应用问题，帮助不大。但是，如果你遇到疑难的语法问题，实在找不到答案，这时可以去查看规格文件，了解语言标准是怎么说的。规格是解决问题的“最后一招”。</p>\\n\",\"capture\":\"概述\\n规格文件是计算机语言的官方标准，详细描述语法规则和实现方法。\\n一般来说，没有必要阅读规格，除非你要写编译器。因为规格写得非常抽象和精炼，又缺乏实例，不容易理解，而且对于解决实际的应用问题，帮助不大。但是，如果你遇到疑难的语法问题，实在找不到答案，这时可以去查看规格文件，了解语言标准是怎么说的。规格是解决问题的“最后一招”。\\n这对 JavaScript 语言很有必要。因为它的使用场景复杂，语法规则不统一，例外很多，各种运行环境的行为不一致，导致奇怪的语法问题层出不穷，任何语法书都不可能囊括所有情况。查看规格，不失为一种解决语法问题的最可靠、最权威的终极方法。\\n本章介绍如何读懂 ECMASc\"},{\"url\":\"/《ES6 教程》笔记/27.异步遍历器.html\",\"relativePath\":\"/《ES6 教程》笔记/27.异步遍历器.html\",\"frontmatter\":{\"title\":\"异步遍历器\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/16121351be68691b\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"异步遍历器\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"异步遍历器\\\" tabindex=\\\"-1\\\">异步遍历器 <a class=\\\"header-anchor\\\" href=\\\"#异步遍历器\\\" aria-label=\\\"Permalink to &quot;异步遍历器&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"同步遍历器的问题\\\" tabindex=\\\"-1\\\">同步遍历器的问题 <a class=\\\"header-anchor\\\" href=\\\"#同步遍历器的问题\\\" aria-label=\\\"Permalink to &quot;同步遍历器的问题&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>《遍历器》一章说过，Iterator 接口是一种数据遍历的协议，只要调用遍历器对象的<code>next</code>方法，就会得到一个对象，表示当前遍历指针所在的那个位置的信息。<code>next</code>方法返回的对象的结构是<code>{value, done}</code>，其中<code>value</code>表示当前的数据的值，<code>done</code>是一个布尔值，表示遍历是否结束。</p>\\n\",\"capture\":\"同步遍历器的问题\\n《遍历器》一章说过，Iterator 接口是一种数据遍历的协议，只要调用遍历器对象的`next`方法，就会得到一个对象，表示当前遍历指针所在的那个位置的信息。`next`方法返回的对象的结构是`{value, done}`，其中`value`表示当前的数据的值，`done`是一个布尔值，表示遍历是否结束。\\n```javascript\\nfunction idMaker() {\\n  let index = 0;\\n  return {\\n    next: function() {\\n      return { value: index++, done: false };\\n    }\"},{\"url\":\"/《ES6 教程》笔记/28.ArrayBuffer.html\",\"relativePath\":\"/《ES6 教程》笔记/28.ArrayBuffer.html\",\"frontmatter\":{\"title\":\"ArrayBuffer\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/a2ba314746bfdbdd\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"ArrayBuffer\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"arraybuffer\\\" tabindex=\\\"-1\\\">ArrayBuffer <a class=\\\"header-anchor\\\" href=\\\"#arraybuffer\\\" aria-label=\\\"Permalink to &quot;ArrayBuffer&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><code>ArrayBuffer</code>对象、<code>TypedArray</code>视图和<code>DataView</code>视图是 JavaScript 操作二进制数据的一个接口。这些对象早就存在，属于独立的规格（2011 年 2 月发布），ES6 将它们纳入了 ECMAScript 规格，并且增加了新的方法。它们都是以数组的语法处理二进制数据，所以统称为二进制数组。</p>\\n\",\"capture\":\"`ArrayBuffer`对象、`TypedArray`视图和`DataView`视图是 JavaScript 操作二进制数据的一个接口。这些对象早就存在，属于独立的规格（2011 年 2 月发布），ES6 将它们纳入了 ECMAScript 规格，并且增加了新的方法。它们都是以数组的语法处理二进制数据，所以统称为二进制数组。\\n这个接口的原始设计目的，与 WebGL 项目有关。所谓 WebGL，就是指浏览器与显卡之间的通信接口，为了满足 JavaScript 与显卡之间大量的、实时的数据交换，它们之间的数据通信必须是二进制的，而不能是传统的文本格式。文本格式传递一个 32 位整数，两端的 Ja\"},{\"url\":\"/01.前端/25.JavaScript文章/07.js随机打乱数组.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/07.js随机打乱数组.html\",\"frontmatter\":{\"title\":\"JS随机打乱数组\",\"date\":\"2020-02-08 17:42:03\",\"permalink\":\"/pages/40b4db2d38ba85f2\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"JS随机打乱数组\",\"date\":\"2020-02-08 17:42:03\",\"capture\":\"```js\\nfunction shuffle(arr) { // 随机打乱数组\\n  let _arr = arr.slice() // 调用数组副本，不改变原数组\\n  for (let i = 0; i &lt; _arr.length; i++) {\\n    let j = getRandomInt(0, i)\\n    let t = _arr[i]\\n    _arr[i] = _arr[j]\\n    _arr[j] = t\\n  }\\n  return _arr\\n}\\nfunction getRandomInt(min, max) { // 获取min到max的一个随机数，包含min和max本身\"},{\"url\":\"/《Vue》笔记/01.基础/35.列表渲染之数组、对象更新检测.html\",\"relativePath\":\"/《Vue》笔记/01.基础/35.列表渲染之数组、对象更新检测.html\",\"frontmatter\":{\"title\":\"列表渲染之数组、对象更新检测\",\"date\":\"2020-02-05 13:09:06\",\"permalink\":\"/pages/04783a6691cc9d06\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"列表渲染之数组、对象更新检测\",\"date\":\"2020-02-05 13:09:06\",\"excerpt\":\"<h1 id=\\\"列表渲染之数组、对象更新检测\\\" tabindex=\\\"-1\\\">列表渲染之数组、对象更新检测 <a class=\\\"header-anchor\\\" href=\\\"#列表渲染之数组、对象更新检测\\\" aria-label=\\\"Permalink to &quot;列表渲染之数组、对象更新检测&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/list.html#%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">数组更新检测API</a> <a href=\\\"https://cn.vuejs.org/v2/guide/list.html#%E5%AF%B9%E8%B1%A1%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">对象更新检测API</a></p>\\n<h2 id=\\\"数组更新检测\\\" tabindex=\\\"-1\\\">数组更新检测 <a class=\\\"header-anchor\\\" href=\\\"#数组更新检测\\\" aria-label=\\\"Permalink to &quot;数组更新检测&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h4 id=\\\"变异方法-mutation-method\\\" tabindex=\\\"-1\\\">变异方法 (mutation method) <a class=\\\"header-anchor\\\" href=\\\"#变异方法-mutation-method\\\" aria-label=\\\"Permalink to &quot;变异方法 (mutation method)&quot;\\\">&ZeroWidthSpace;</a></h4>\\n<p>Vue 将被侦听的数组的变异方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：</p>\\n\",\"capture\":\"数组更新检测API 对象更新检测API\\n 数组更新检测\\n 变异方法 (mutation method)\\nVue 将被侦听的数组的变异方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：\\n- `push()`末尾添加\\n- `pop()`末尾删除\\n- `shift()` 首位删除\\n- `unshift() ` 首位添加\\n- `splice()` 拼合\\n- `sort()` 排序\\n- `reverse()` 反转\\n数组实例方法\\n 替换数组\\n变异方法，顾名思义，会改变调用了这些方法的原始数组。相比之下，也有非变异 (non-mutating method) 方法，例如 `filter(\"},{\"url\":\"/《Vue》笔记/01.基础/30.v-if vs v-show.html\",\"relativePath\":\"/《Vue》笔记/01.基础/30.v-if vs v-show.html\",\"frontmatter\":{\"title\":\"v-if vs v-show\",\"date\":\"2020-02-04 17:32:23\",\"permalink\":\"/pages/73e4064340277b05\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"v-if vs v-show\",\"date\":\"2020-02-04 17:32:23\",\"excerpt\":\"<h1 id=\\\"v-if-vs-v-show\\\" tabindex=\\\"-1\\\">v-if vs v-show <a class=\\\"header-anchor\\\" href=\\\"#v-if-vs-v-show\\\" aria-label=\\\"Permalink to &quot;v-if vs v-show&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/conditional.html#v-if-vs-v-show\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">API</a></p>\\n<p><code>v-if</code> 根据渲染条件决定是否把元素渲染到DOM页面，而<code>v-show</code>不管渲染条件是什么，都会把元素渲染到DOM页面，只是简单的切换CSS的显示隐藏。</p>\\n\",\"capture\":\"API\\n`v-if` 根据渲染条件决定是否把元素渲染到DOM页面，而`v-show`不管渲染条件是什么，都会把元素渲染到DOM页面，只是简单的切换CSS的显示隐藏。\\n如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好。\"},{\"url\":\"/《Vue》笔记/01.基础/20.计算属性 vs 方法 vs 侦听属性.html\",\"relativePath\":\"/《Vue》笔记/01.基础/20.计算属性 vs 方法 vs 侦听属性.html\",\"frontmatter\":{\"title\":\"计算属性 vs 方法 vs 侦听属性\",\"date\":\"2020-02-04 16:37:51\",\"permalink\":\"/pages/351f72ecd9c41129\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"计算属性 vs 方法 vs 侦听属性\",\"date\":\"2020-02-04 16:37:51\",\"excerpt\":\"<h1 id=\\\"计算属性-vs-方法-vs-侦听属性\\\" tabindex=\\\"-1\\\">计算属性 vs 方法 vs 侦听属性 <a class=\\\"header-anchor\\\" href=\\\"#计算属性-vs-方法-vs-侦听属性\\\" aria-label=\\\"Permalink to &quot;计算属性 vs 方法 vs 侦听属性&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/computed.html#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%BC%93%E5%AD%98-vs-%E6%96%B9%E6%B3%95\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">API</a></p>\\n<p>如果一个功能同时可以使用计算属性(computed)、方法(methods)、侦听属性(watch)来实现的时候推荐使用计算属性。</p>\\n\",\"capture\":\"API\\n如果一个功能同时可以使用计算属性(computed)、方法(methods)、侦听属性(watch)来实现的时候推荐使用计算属性。\\n| 计算属性                                 | 方法                                               | 侦听属性                                     |\\n| ---------------------------------------- | --------------------------------------------------\"},{\"url\":\"/《Vue》笔记/01.基础/10.生命周期.html\",\"relativePath\":\"/《Vue》笔记/01.基础/10.生命周期.html\",\"frontmatter\":{\"title\":\"生命周期\",\"date\":\"2020-02-04 15:06:59\",\"permalink\":\"/pages/176808a1b5f843b8\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"生命周期\",\"date\":\"2020-02-04 15:06:59\",\"excerpt\":\"<h1 id=\\\"实例生命周期钩子\\\" tabindex=\\\"-1\\\">实例生命周期钩子 <a class=\\\"header-anchor\\\" href=\\\"#实例生命周期钩子\\\" aria-label=\\\"Permalink to &quot;实例生命周期钩子&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/instance.html#%E5%AE%9E%E4%BE%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">实例生命周期钩子API</a></p>\\n<p>简单理解，生命周期钩子函数就是vue实例在某一个时间点会自动执行的函数。</p>\\n\",\"capture\":\"实例生命周期钩子API\\n简单理解，生命周期钩子函数就是vue实例在某一个时间点会自动执行的函数。\\n```html\\n&lt;div id=\\\"app\\\"\\n&lt;script src=\\\"https://cdn.bootcss.com/vue/2.4.2/vue.js\\\"&gt;&lt;/script&gt;\\n&lt;script&gt;\\n  var vm = new Vue({\\n    el: 'app',\\n    data: {\\n      msg: 'Vue的生命周期'\\n    },\\n    beforeCreate: function() {\\n      console.group('-----\"},{\"url\":\"/《Vue》笔记/06.规模化/140.路由懒加载.html\",\"relativePath\":\"/《Vue》笔记/06.规模化/140.路由懒加载.html\",\"frontmatter\":{\"title\":\"路由懒加载\",\"date\":\"2020-02-04 13:20:20\",\"permalink\":\"/pages/38ecac9a9b92f037\",\"categories\":[\"《Vue》笔记\",\"规模化\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"路由懒加载\",\"date\":\"2020-02-04 13:20:20\",\"capture\":\"```js\\n// 路由同步加载\\n// import Recommend from '@/components/recommend/recommend'\\n// import Singer from '@/components/singer/singer'\\n// import Rank from '@/components/rank/rank'\\n// import Search from '@/components/search/search'\\n// import SingerDetail from '@/components/singer-detail/singer-detail'\\n// imp\"},{\"url\":\"/《Vue》笔记/03.过渡&动画/120.transition-group列表过渡.html\",\"relativePath\":\"/《Vue》笔记/03.过渡&动画/120.transition-group列表过渡.html\",\"frontmatter\":{\"title\":\"transition-group列表过渡\",\"date\":\"2020-02-04 13:17:42\",\"permalink\":\"/pages/0aa92922ace6bb5e\",\"categories\":[\"《Vue》笔记\",\"过渡&动画\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"transition-group列表过渡\",\"date\":\"2020-02-04 13:17:42\",\"excerpt\":\"<h1 id=\\\"transition-group列表过渡\\\" tabindex=\\\"-1\\\">transition-group列表过渡 <a class=\\\"header-anchor\\\" href=\\\"#transition-group列表过渡\\\" aria-label=\\\"Permalink to &quot;transition-group列表过渡&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"列表的进入-离开过渡\\\" tabindex=\\\"-1\\\">列表的进入/离开过渡 <a class=\\\"header-anchor\\\" href=\\\"#列表的进入-离开过渡\\\" aria-label=\\\"Permalink to &quot;列表的进入/离开过渡&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<div class=\\\"language-html vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">html</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">&#x3C;</span><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">transition-group</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> tag</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"ul\\\"</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">> </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">&#x3C;!--tag转为ul--></span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">    &#x3C;</span><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">li</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> v-for</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"item in list\\\"</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> :key</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"item\\\"</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">>{{item}}&#x3C;/</span><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">li</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">> </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">&#x3C;!--子元素要有key--></span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">&#x3C;/</span><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">transition-group</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">></span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br></div></div><p><strong>注意</strong>：列表元素一定要有<code>key</code></p>\\n\",\"capture\":\"列表的进入/离开过渡\\n```html\\n&lt;transition-group tag=\\\"ul\\\"\\n    &lt;li v-for=\\\"item in list\\\" :key=\\\"item\\\"&gt;{{item}}&lt;/li&gt; &lt;!--子元素要有key--&gt;\\n&lt;/transition-group&gt;\\n```\\n注意：列表元素一定要有`key`\\n```css\\n.v-enter,.v-leave-to{\\n  opacity: 0;\\n  transform: translateX(30px);\\n}\\n.v-enter-active,.v-leave-active{\\n  tran\"},{\"url\":\"/《Vue》笔记/03.过渡&动画/110.transition过渡&动画.html\",\"relativePath\":\"/《Vue》笔记/03.过渡&动画/110.transition过渡&动画.html\",\"frontmatter\":{\"title\":\"transition过渡&动画\",\"date\":\"2020-02-04 13:16:19\",\"permalink\":\"/pages/184a96b493a97078\",\"categories\":[\"《Vue》笔记\",\"过渡&动画\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"transition过渡&动画\",\"date\":\"2020-02-04 13:16:19\",\"excerpt\":\"<h1 id=\\\"transition过渡-动画\\\" tabindex=\\\"-1\\\">transition过渡&amp;动画 <a class=\\\"header-anchor\\\" href=\\\"#transition过渡-动画\\\" aria-label=\\\"Permalink to &quot;transition过渡&amp;动画&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/transitions.html\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">API</a></p>\\n<h2 id=\\\"使用\\\" tabindex=\\\"-1\\\">使用 <a class=\\\"header-anchor\\\" href=\\\"#使用\\\" aria-label=\\\"Permalink to &quot;使用&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>需要设置动画的元素或组件要在外边包裹一个<code>&lt;transition&gt;</code>标签，设置自定义的<code>name</code>，vue会根据元素的切换（进入/离开）过程添加相应的css类名，你可以<strong>自由地使用css类名来设置css过渡&amp;动画</strong>。</p>\\n\",\"capture\":\"API\\n 使用\\n需要设置动画的元素或组件要在外边包裹一个`&lt;transition\\n 过渡的类名\\n在进入/离开的过渡中，会有 6 个 class 切换。\\n各类名的生命周期\\n* 进入\\n  * `v-enter` 只存在于第一帧\\n  * `v-enter-active` 第一帧到最后一帧，结束后移除\\n  * `v-enter-to` 第二帧到最后一帧，结束后移除\\n* 离开\\n  * `v-leave` 只存在于第一帧\\n  * `v-leave-active` 第一帧到最后一帧，结束后移除\\n  * `v-leave-to` 第二帧到最后一帧，结束后移除\\n如果你使用一个没有`name`的`&lt;t\"},{\"url\":\"/《Vue》笔记/06.规模化/100.vuex操作相关.html\",\"relativePath\":\"/《Vue》笔记/06.规模化/100.vuex操作相关.html\",\"frontmatter\":{\"title\":\"vuex操作相关\",\"date\":\"2020-02-04 13:15:19\",\"permalink\":\"/pages/d9d62d6ab8ff99a6\",\"categories\":[\"《Vue》笔记\",\"规模化\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"vuex操作相关\",\"date\":\"2020-02-04 13:15:19\",\"capture\":\"```js\\nimport { mapActions, mapMutations, mapGetters } from 'vuex'\\ncomputed: {\\n    ...mapGetters([ // 获取数据，内部为数组\\n        'searchHistory' // 相当于在data插入searchHistory和获取到的数据\\n    ])\\n},\\nmethods: {\\n\\t某方法(){\\n\\t  this.saveSearchHistory(传入值)\\n\\t},\\n\\t...mapActions([ // 提交actions修改数据，内部为数组 因为actions文件已对方法进行了封装所有是数组类\"},{\"url\":\"/《Vue》笔记/99.其他/90.操作本地缓存.html\",\"relativePath\":\"/《Vue》笔记/99.其他/90.操作本地缓存.html\",\"frontmatter\":{\"title\":\"操作本地缓存\",\"date\":\"2020-02-04 13:14:19\",\"permalink\":\"/pages/30a94dbe96873b33\",\"categories\":[\"《Vue》笔记\",\"其他\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"操作本地缓存\",\"date\":\"2020-02-04 13:14:19\",\"capture\":\"&lt;https://github.com/ustbhuangyi/storage\\n操作 sessionStorage 和 localStorage 。\"},{\"url\":\"/《Vue》笔记/99.其他/80.Vue中的防抖函数封装和使用.html\",\"relativePath\":\"/《Vue》笔记/99.其他/80.Vue中的防抖函数封装和使用.html\",\"frontmatter\":{\"title\":\"Vue中的防抖函数封装和使用\",\"date\":\"2020-02-04 13:10:19\",\"permalink\":\"/pages/fb08e252dfd8fdfd\",\"categories\":[\"《Vue》笔记\",\"其他\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Vue中的防抖函数封装和使用\",\"date\":\"2020-02-04 13:10:19\",\"capture\":\"Vue中的防抖函数封装和使用\\n如搜索框中，每改变一个数值就请求一次搜索接口，当快速的改变数值时并不需要多次请求接口，这就需要一个防抖函数：\\n```js\\n// 防抖函数\\nexport function debounce(func, delay) { // func 函数 delay间隔时间\\n  let timer\\n  return function (...args) {\\n    if (timer) {\\n      clearTimeout(timer)\\n    }\\n    timer = setTimeout(() =\\n      func.apply(this, args)\\n    }, \"},{\"url\":\"/《Vue》笔记/02.组件/70.父组件调用子组件方法并传入值.html\",\"relativePath\":\"/《Vue》笔记/02.组件/70.父组件调用子组件方法并传入值.html\",\"frontmatter\":{\"title\":\"父组件调用子组件方法并传入值\",\"date\":\"2020-02-04 13:06:37\",\"permalink\":\"/pages/2e24dab728769e0c\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"父组件调用子组件方法并传入值\",\"date\":\"2020-02-04 13:06:37\",\"capture\":\"通过`ref`引用调用子组件内的方法并传入参数\\n父组件：\\n```js\\n&lt;子组件标签  ref=\\\"refName\\\"\\nmethods: {\\n    fnX(x) {\\n      this.$refs.refName.fnY(x) // 调用子组件方法并传入值\\n    }\\n}\\n```\\n子组件：\\n```js\\nmethods: {\\n    fnY(x) {\\n      this.x = x\\n    }\\n  }\\n}\\n```\"},{\"url\":\"/《Vue》笔记/02.组件/60.兄弟组件传值.html\",\"relativePath\":\"/《Vue》笔记/02.组件/60.兄弟组件传值.html\",\"frontmatter\":{\"title\":\"兄弟组件传值\",\"date\":\"2020-02-04 13:04:32\",\"permalink\":\"/pages/809f4582d9ca9552\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"兄弟组件传值\",\"date\":\"2020-02-04 13:04:32\",\"capture\":\"子组件1中把值传到父组件,父组件获取值传入子组件2\\n父组件：\\n```js\\n&lt;子组件1 @方法名x=\\\"方法名y\\\"\\n&lt;子组件2 :值名称x=\\\"值x\\\"&gt;&lt;/子组件2 &gt;\\ndata() {\\n\\treturn {\\n\\t 值x: ''\\n\\t}\\n},\\nmethods: {\\n\\t方法名y(值) {\\n\\t\\tthis.值x = 值\\n\\t}\\n}\\n```\\n子组件1：\\n```js\\nthis.$emit('方法名x', 值) // 传出值\\n```\\n子组件2：\\n```js\\nprops: {\\n    值名称x: { // 接收父组件传入值\\n        type: String,\\n        defa\"},{\"url\":\"/《Vue》笔记/02.组件/50.子组件派发事件和值给父组件.html\",\"relativePath\":\"/《Vue》笔记/02.组件/50.子组件派发事件和值给父组件.html\",\"frontmatter\":{\"title\":\"子组件派发事件和值给父组件\",\"date\":\"2020-02-04 12:56:51\",\"permalink\":\"/pages/0f19a1bcac14fd41\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"子组件派发事件和值给父组件\",\"date\":\"2020-02-04 12:56:51\",\"excerpt\":\"<h1 id=\\\"子组件派发事件和值给父组件\\\" tabindex=\\\"-1\\\">子组件派发事件和值给父组件 <a class=\\\"header-anchor\\\" href=\\\"#子组件派发事件和值给父组件\\\" aria-label=\\\"Permalink to &quot;子组件派发事件和值给父组件&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/components.html#%E7%9B%91%E5%90%AC%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">API</a></p>\\n<p>子组件通过<code>$emit</code>派发事件和值给父组件（值可以有多个）</p>\\n<div class=\\\"language-js vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">js</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">this</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">$emit</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'fnX'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, value)</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br></div></div>\",\"capture\":\"API\\n子组件通过`$emit`派发事件和值给父组件（值可以有多个）\\n```js\\nthis.$emit('fnX', value)\\n```\\n父组件通过`v-on`绑定子组件派发的事件，并触发一个新的事件，新的事件内可以接收传来的值\\n```js\\n&lt;ComponentName @fnX=\\\"fnY\\\"\\nmethods: {\\n\\tfnY(value) {\\n\\t\\tconsole.log(value)\\n\\t}\\n}\\n```\\n 父子组件间传递数据 demo\\n&lt;p class=\\\"codepen\\\" data-height=\\\"400\\\" data-theme-id=\\\"light\\\" data-default-tab\"},{\"url\":\"/《Vue》笔记/02.组件/40.父组件给子组件传值.html\",\"relativePath\":\"/《Vue》笔记/02.组件/40.父组件给子组件传值.html\",\"frontmatter\":{\"title\":\"父组件给子组件传值\",\"date\":\"2020-02-04 12:45:30\",\"permalink\":\"/pages/07b384c2e6232e07\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"父组件给子组件传值\",\"date\":\"2020-02-04 12:45:30\",\"excerpt\":\"<h1 id=\\\"父组件给子组件传值\\\" tabindex=\\\"-1\\\">父组件给子组件传值 <a class=\\\"header-anchor\\\" href=\\\"#父组件给子组件传值\\\" aria-label=\\\"Permalink to &quot;父组件给子组件传值&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>父组件中，通过给子组件标签v-bind绑定属性的方式传入值</p>\\n<div class=\\\"language-html vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">html</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">&#x3C;</span><span style=\\\"--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic\\\">ComponentName</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> v-bind:name</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"value\\\"</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">>&#x3C;/</span><span style=\\\"--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic\\\">ComponentName</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">></span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br></div></div><blockquote>\\n<p>如果不使用v-bind传入的值为字符串，使用v-bind绑定传入的值为表达式。</p>\\n</blockquote>\\n\",\"capture\":\"父组件中，通过给子组件标签v-bind绑定属性的方式传入值\\n```html\\n&lt;ComponentName v-bind:name=\\\"value\\\"\\n```\\n&gt; 如果不使用v-bind传入的值为字符串，使用v-bind绑定传入的值为表达式。\\n子组件中，通过props对象接收值\\n```js\\n props: {\\n    name: { // 接收父组件传入值\\n        type: String || ...,\\n        default: ''\\n    }\\n }\\n```\\n 单向数据流\\n所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向\"},{\"url\":\"/《Vue》笔记/01.基础/00.MVVM模式.html\",\"relativePath\":\"/《Vue》笔记/01.基础/00.MVVM模式.html\",\"frontmatter\":{\"title\":\"MVVM模式\",\"date\":\"2020-02-04 12:19:00\",\"permalink\":\"/pages/114158caa9e96df0\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"MVVM模式\",\"date\":\"2020-02-04 12:19:00\",\"excerpt\":\"<div class=\\\"tip custom-block\\\"><p class=\\\"custom-block-title\\\">TIP</p>\\n<p>说明：本章内容是博主的Vue学习笔记，以<a href=\\\"https://cn.vuejs.org/v2/guide/\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">官方文档</a>为准。</p>\\n</div>\\n<h1 id=\\\"mvvm模式\\\" tabindex=\\\"-1\\\">MVVM模式 <a class=\\\"header-anchor\\\" href=\\\"#mvvm模式\\\" aria-label=\\\"Permalink to &quot;MVVM模式&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>MVVM模式，<code>M</code>即 model，数据模型；<code>V</code>即 view，视图；<code>VM</code>即 view-model，视图模型。</p>\\n\",\"capture\":\"说明：本章内容是博主的Vue学习笔记，以官方文档为准。\\n MVVM模式\\nMVVM模式，`M`即 model，数据模型；`V`即 view，视图；`VM`即 view-model，视图模型。\\n理解\\n首先，数据Model通过Data Bindings把数据绑定在View视图上，\\n当View视图有交互（有改变）的时候，Dom listeners会自动监听，然后更新数据Model。\\nQ：什么是MVVM模式？\\nA：MVVM模式，第一个M代表数据模型，V代表视图，VM代表视图模型；\\n它的实际操作原理是：后台数据通过视图模型来渲染视图，就是页面。当用户在页面上进行操作的时候，\\n视图模型会自动监听到用户的操作\"}],\"01\":[{\"url\":\"/《ES6 教程》笔记/01.ECMAScript 6 简介.html\",\"relativePath\":\"/《ES6 教程》笔记/01.ECMAScript 6 简介.html\",\"frontmatter\":{\"title\":\"ECMAScript 6 简介\",\"date\":\"2020-01-12 15:45:35\",\"permalink\":\"/pages/f344d070a1031ef7\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"ECMAScript 6 简介\",\"date\":\"2020-01-12 15:45:35\",\"excerpt\":\"<blockquote>\\n<p>说明：本章内容为博主在原教程基础上添加自己的学习笔记，来源<a href=\\\"http://es6.ruanyifeng.com/\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">http://es6.ruanyifeng.com/</a>，教程版权归原作者所有。</p>\\n</blockquote>\\n<h1 id=\\\"ecmascript-6-简介\\\" tabindex=\\\"-1\\\">ECMAScript 6 简介 <a class=\\\"header-anchor\\\" href=\\\"#ecmascript-6-简介\\\" aria-label=\\\"Permalink to &quot;ECMAScript 6 简介&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p>\\n\",\"capture\":\"ECMAScript 6 简介\\nECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。\\n ECMAScript 和 JavaScript 的关系\\n一个常见的问题是，ECMAScript 和 JavaScript 到底是什么关系？\\n要讲清楚这个问题，需要回顾历史。1996 年 11 月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给标准化组织 ECMA，希望这种语言能够成为国际标\"},{\"url\":\"/《JavaScript教程》笔记/01.基础.html\",\"relativePath\":\"/《JavaScript教程》笔记/01.基础.html\",\"frontmatter\":{\"title\":\"基础\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/0796ba76b4b55368\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"基础\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"基础篇\\n 一、JS的一些名词概念\\n 什么是作用域？\\n变量存在的范围。\\n可分为全局作用域和函数作用域，ES6新增块级作用域。\\n 什么是闭包？\\n闭包就是能够读取其他函数内部变量的函数。\\n* 闭包的形式：函数内部定义函数\\n* 本质上闭包就是将函数内部和外部连接起来的一座桥梁\\n闭包的作用：\\n* 可以读取函数内部变量\\n* 让这些变量始终保持在内存中，即闭包可以使得它诞生的环境一直存在。\\n*  封装对象的私有属性和私有方法\\n 什么是构造函数？\\n用于构造(生成)实例的一个函数，使实例拥有构造函数内定于的属性和方法。\\n 什么是实例对象？\\n实例对象就是通过new 构造函数生成的，拥有构造函数内定于的属性和方法的\"},{\"url\":\"/《JavaScript教程》笔记/02.内置对象.html\",\"relativePath\":\"/《JavaScript教程》笔记/02.内置对象.html\",\"frontmatter\":{\"title\":\"内置对象\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/74d2ab3fbfeaaa68\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"内置对象\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"内置对象篇\\n 一、Object对象\\n 1、概述\\nJavaScript 原生提供`Object`对象（注意起首的`O`是大写），本章介绍该对象原生的各种方法。\\nJavaScript 的所有其他对象都继承自`Object`对象，即那些对象都是`Object`的实例。\\n`Object`对象的原生方法分成两类：`Object`本身的方法与`Object`的实例方法。\\n（1）Object对象本身的方法\\n所谓“本身的方法”就是直接定义在`Object`对象的方法。\\n```js\\nObject.print = function (o) { console.log(o) };\\n```\\n上面代码中，`print`\"},{\"url\":\"/《JavaScript教程》笔记/03.面向对象.html\",\"relativePath\":\"/《JavaScript教程》笔记/03.面向对象.html\",\"frontmatter\":{\"title\":\"面向对象\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/659b5af5e2e704e0\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"面向对象\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"面向对象编程\\n 一、实例对象与new命令\\n 1、对象是什么\\n面向对象编程（Object Oriented Programming，缩写为 OOP）是目前主流的编程范式。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。\\n每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务。对象可以复用，通过继承机制还可以定制。因此，面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程（procedural programming），更适合多人合作的大型软件项目。\\n那么，“对象”\"},{\"url\":\"/《JavaScript教程》笔记/04.异步操作.html\",\"relativePath\":\"/《JavaScript教程》笔记/04.异步操作.html\",\"frontmatter\":{\"title\":\"异步操作\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/d61b1cb4cdac1f63\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"异步操作\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"异步操作\\n 一、异步操作概述\\n 1、单线程模型\\n单线程模型指的是，JavaScript 只在一个线程上运行。也就是说，JavaScript 同时只能执行一个任务，其他任务都必须在后面排队等待。\\n注意，JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合。\\nJavaScript 之所以采用单线程，而不是多线程，跟历史有关系。JavaScript 从诞生起就是单线程，原因是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对\"},{\"url\":\"/《JavaScript教程》笔记/05.DOM.html\",\"relativePath\":\"/《JavaScript教程》笔记/05.DOM.html\",\"frontmatter\":{\"title\":\"DOM\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/7d961b8030c6099e\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"DOM\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"DOM\\n 一、概述\\n 1、DOM\\nDOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。\\n浏览器会根据 DOM 模型，将结构化文档（比如 HTML 和 XML）解析成一系列的节点，再由这些节点组成一个树状结构（DOM Tree）。所有的节点和最终的树状结构，都有规范的对外接口。\\nDOM 只是一个接口规范，可以用各种语言实现。所以严格地说，DOM 不是 JavaScript 语法的一部分，但是 DOM 操作是 JavaScript 最\"},{\"url\":\"/《JavaScript教程》笔记/06.事件.html\",\"relativePath\":\"/《JavaScript教程》笔记/06.事件.html\",\"frontmatter\":{\"title\":\"事件\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/10b2761db5a8e089\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"事件\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"事件\\n 一、EventTarget 接口\\n 事件的本质是程序各个组成部分之间的一种通信方式，也是异步编程的一种实现。DOM 支持大量的事件，本章开始介绍 DOM 的事件编程。\\n 1、概述\\nDOM 的事件操作（监听和触发），都定义在`EventTarget`接口。所有节点对象都部署了这个接口，其他一些需要事件通信的浏览器内置对象（比如，`XMLHttpRequest`、`AudioNode`、`AudioContext`）也部署了这个接口。\\n该接口主要提供三个实例方法。\\n- `addEventListener`：绑定事件的监听函数\\n- `removeEventListener`：移除事件的监听函\"},{\"url\":\"/《JavaScript教程》笔记/07.浏览器模型.html\",\"relativePath\":\"/《JavaScript教程》笔记/07.浏览器模型.html\",\"frontmatter\":{\"title\":\"浏览器模型\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/bab4930124ad2c10\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"浏览器模型\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"一、浏览器环境概述\\nJavaScript 是浏览器的内置脚本语言。也就是说，浏览器内置了 JavaScript 引擎，并且提供各种接口，让 JavaScript 脚本可以控制浏览器的各种功能。一旦网页内嵌了 JavaScript 脚本，浏览器加载网页，就会去执行脚本，从而达到操作浏览器的目的，实现网页的各种动态效果。\\n本章开始介绍浏览器提供的各种 JavaScript 接口。首先，介绍 JavaScript 代码嵌入网页的方法。\\n 1、代码嵌入网页的方法\\n网页中嵌入 JavaScript 代码，主要有三种方法。\\n- `  &lt;script\\n- `  &lt;script&gt;  `标签加\"},{\"url\":\"/01.前端/25.JavaScript文章/08.判断是否为移动端浏览器.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/08.判断是否为移动端浏览器.html\",\"frontmatter\":{\"title\":\"判断是否为移动端浏览器\",\"date\":\"2020-01-04 15:25:11\",\"permalink\":\"/pages/40f623be692cf8bc\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"判断是否为移动端浏览器\",\"date\":\"2020-01-04 15:25:11\",\"capture\":\"```js\\nconst flag = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);\\nif(flag){\\n    // 移动端\\n} else {\\n    // PC端\\n}\\n```\"},{\"url\":\"/04.更多/01.学习/03.提高记忆的技巧.html\",\"relativePath\":\"/04.更多/01.学习/03.提高记忆的技巧.html\",\"frontmatter\":{\"title\":\"提高记忆的技巧\",\"date\":\"2020-01-03 14:34:48\",\"permalink\":\"/pages/996822b2a2ca6e3b\",\"categories\":[\"更多\",\"学习\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"提高记忆的技巧\",\"date\":\"2020-01-03 14:34:48\",\"excerpt\":\"<h1 id=\\\"提高记忆的技巧\\\" tabindex=\\\"-1\\\">提高记忆的技巧 <a class=\\\"header-anchor\\\" href=\\\"#提高记忆的技巧\\\" aria-label=\\\"Permalink to &quot;提高记忆的技巧&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<ol>\\n<li><strong>多个感官并用</strong>\\n记忆时调用一切感官。没人的话可以大声阅读，有人的话可以默念，轻微摇晃手指等，有助于保持专注。</li>\\n</ol>\\n\",\"capture\":\"1. 多个感官并用\\n   记忆时调用一切感官。没人的话可以大声阅读，有人的话可以默念，轻微摇晃手指等，有助于保持专注。\\n   \\n2. 重复记忆\\n   每天留出半个到一个小时，梳理总结今天所学的内容。每一章复习完成后做系统的知识整理。\\n   \\n3. 建立关联\\n   把你所学的新知识与已有的认知建立联系，对于记忆事半功倍。\\n   \\n4. 场景记忆\\n   把知识具象化为一个场景，想象自己在何时何地能用这些知识，与自身发生联系。\\n   \\n5. 提出问题\\n   每学习一个知识点，试着提问，然后给出答案。用了就记住了。\"},{\"url\":\"/03.技术/03.博客搭建/03.GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床.html\",\"relativePath\":\"/03.技术/03.博客搭建/03.GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床.html\",\"frontmatter\":{\"title\":\"GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床\",\"date\":\"2020-01-03 12:55:43\",\"permalink\":\"/pages/a5f73af5185fdf0a\",\"categories\":[\"技术\",\"博客搭建\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床\",\"date\":\"2020-01-03 12:55:43\",\"excerpt\":\"<h1 id=\\\"github-jsdelivr-tinypng-picgo-打造稳定快速、高效免费图床\\\" tabindex=\\\"-1\\\">GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床 <a class=\\\"header-anchor\\\" href=\\\"#github-jsdelivr-tinypng-picgo-打造稳定快速、高效免费图床\\\" aria-label=\\\"Permalink to &quot;GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"前言\\\" tabindex=\\\"-1\\\">前言 <a class=\\\"header-anchor\\\" href=\\\"#前言\\\" aria-label=\\\"Permalink to &quot;前言&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p><strong>Q：为什么要使用图床呢？什么是图床？</strong></p>\\n<p>A：写博客文章时，图片的上传和存放是一个问题，有的朋友可能会把图片放到和博客同一个仓库当中，使用相对路径来引用，这样后期维护起来会比较麻烦。还有的朋友会在不同的平台发布同一篇文章，这样一来每个平台都要上传图片，为了解决这些问题，比较推荐的做法是把图片统一上传到一个在线的第三方静态资源库中，我们把这个资源库称为图床，其返回一个图片的URL，使用<code>markdown+图片url</code>的方式写作文章，一次编写，到处使用~</p>\\n\",\"capture\":\"前言\\nQ：为什么要使用图床呢？什么是图床？\\nA：写博客文章时，图片的上传和存放是一个问题，有的朋友可能会把图片放到和博客同一个仓库当中，使用相对路径来引用，这样后期维护起来会比较麻烦。还有的朋友会在不同的平台发布同一篇文章，这样一来每个平台都要上传图片，为了解决这些问题，比较推荐的做法是把图片统一上传到一个在线的第三方静态资源库中，我们把这个资源库称为图床，其返回一个图片的URL，使用`markdown+图片url`的方式写作文章，一次编写，到处使用~\\n以下内容是比较旧的，现在我发现一个更好用，配置更方便的图床工具：&lt;https://picx.xpoet.cn/\\n使用方法看一下他网站的使\"}]},\"2019 \":{\"12\":[{\"url\":\"/03.技术/02.Nodejs/01.nodejs递归读取所有文件.html\",\"relativePath\":\"/03.技术/02.Nodejs/01.nodejs递归读取所有文件.html\",\"frontmatter\":{\"title\":\"nodejs递归读取所有文件\",\"date\":\"2019-12-26 15:57:32\",\"permalink\":\"/pages/117708e0af7f0bd9\",\"categories\":[\"技术\",\"Nodejs\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"nodejs递归读取所有文件\",\"date\":\"2019-12-26 15:57:32\",\"capture\":\"```js\\nvar fs = require('fs');\\nvar path = require('path');\\n \\nfunction readFileList(dir, filesList = []) {\\n    const files = fs.readdirSync(dir);\\n    console.log(files);\\n    files.forEach((item, index) =\\n        var fullPath = path.join(dir, item);\\n        const stat = fs.statSync(fullPath);\\n        i\"},{\"url\":\"/01.前端/25.JavaScript文章/02.new命令原理.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/02.new命令原理.html\",\"frontmatter\":{\"title\":\"new命令原理\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/8143cc480faf9a11\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"new命令原理\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"new命令原理\\\" tabindex=\\\"-1\\\">new命令原理 <a class=\\\"header-anchor\\\" href=\\\"#new命令原理\\\" aria-label=\\\"Permalink to &quot;new命令原理&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>使用new命令时，它后面的函数依次执行下面的步骤：</p>\\n<ol>\\n<li>创建一个空对象，作为将要返回的实例对象。</li>\\n<li>将这个空对象的原型，指向构造函数的prototype属性。</li>\\n<li>将这个空对象赋值给函数内部的this关键字。</li>\\n<li>开始执行构造函数内部的代码。</li>\\n<li>如果构造函数内有返回值且为对象类型，则返回该对象，否则返回上面创建的实例对象。</li>\\n</ol>\\n\",\"capture\":\"使用new命令时，它后面的函数依次执行下面的步骤：\\n1. 创建一个空对象，作为将要返回的实例对象。\\n2. 将这个空对象的原型，指向构造函数的prototype属性。\\n3. 将这个空对象赋值给函数内部的this关键字。\\n4. 开始执行构造函数内部的代码。\\n5. 如果构造函数内有返回值且为对象类型，则返回该对象，否则返回上面创建的实例对象。\\n```js\\n// 构造函数\\nfunction Person(name,age){\\n    this.name = name\\n    this.age = age\\n}\\n// 自定义_new\\nfunction _new() {\\n  // 将 arguments 对\"},{\"url\":\"/01.前端/25.JavaScript文章/04.ES6面向对象.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/04.ES6面向对象.html\",\"frontmatter\":{\"title\":\"ES6面向对象\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/1f4123be6f45abcd\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"ES6面向对象\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```js\\n//面向对象封装\\nclass Student{ //定义类 (尊从首字母大写的约定)\\n    constructor(props){  // 构造函数 （构造函数内定于属性）\\n        this.name = props.name || '匿名'; // 默认'匿名'\\n      this.grade = props.grade || 1;\\n    }\\n    hello(){ // 在构造函数的原型上定义方法\\n        console.log(`你好,${this.name}同学，你在${this.grade}年级`);\\n    }\\n}\\n//使用\\nfunction c\"},{\"url\":\"/01.前端/25.JavaScript文章/06.多种数组去重性能对比.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/06.多种数组去重性能对比.html\",\"frontmatter\":{\"title\":\"多种数组去重性能对比\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/e808fba1fa8fbab2\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"多种数组去重性能对比\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"测试模板\\n```js\\n// 创建一个 1 ~ 10w 的数组，Array.from为ES6语法\\nlet arr1 = Array.from(new Array(1000000), (x, index) =\\n  return index\\n})\\nlet arr2 = Array.from(new Array(500000), (x, index) =&gt; {\\n  return index + index\\n})\\nlet start = new Date().getTime()\\nconsole.log('开始数组去重')\\n// 数组去重\\nfunction distinct(a, b) {\\n  le\"},{\"url\":\"/01.前端/40.学习笔记/40.小程序笔记.html\",\"relativePath\":\"/01.前端/40.学习笔记/40.小程序笔记.html\",\"frontmatter\":{\"title\":\"小程序笔记\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/note/wx-miniprogram/\",\"tags\":[\"小程序\"],\"categories\":[\"前端\",\"学习笔记\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"小程序笔记\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"小程序笔记\\n 基础课程部分\\n 微信公众平台\\n&lt;https://mp.weixin.qq.com/\\n注册时可选择类型：订阅号、服务号、小程序、企业微信\\n每个邮箱仅能注册一个小程序。\\n个人类型小程序：无法使用微信支付、无法使用卡包功能\\n 小程序文档API\\n小程序开发文档\\n 微信开放社区\\n微信开发社区\\n 目录说明\\n默认目录\\npages-----------------------页面相关\\n​\\tindex  ----------------- 首页文件夹\\n​\\t\\tindex.js ------------首页js\\n​\\t\\tindex.json---------首页配置\\n​\\t\\tindex.wxml--\"},{\"url\":\"/02.页面/20.CSS/01.flex布局语法.html\",\"relativePath\":\"/02.页面/20.CSS/01.flex布局语法.html\",\"frontmatter\":{\"title\":\"flex布局语法\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/0a83b083bdf257cb\",\"author\":{\"name\":\"阮一峰\"},\"categories\":[\"页面\",\"CSS\"],\"tags\":[null]},\"author\":{\"name\":\"阮一峰\"},\"title\":\"flex布局语法\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"flex布局语法\\\" tabindex=\\\"-1\\\">flex布局语法 <a class=\\\"header-anchor\\\" href=\\\"#flex布局语法\\\" aria-label=\\\"Permalink to &quot;flex布局语法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"一、flex-布局是什么\\\" tabindex=\\\"-1\\\">一、flex 布局是什么？ <a class=\\\"header-anchor\\\" href=\\\"#一、flex-布局是什么\\\" aria-label=\\\"Permalink to &quot;一、flex 布局是什么？&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>Flex是 Flexible Box 的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性。</p>\\n<p><strong>任何一个容器</strong> 都可以指定为 Flex 布局。</p>\\n\",\"capture\":\"一、flex 布局是什么？\\nFlex是 Flexible Box 的缩写，意为\\\"弹性布局\\\"，用来为盒状模型提供最大的灵活性。\\n任何一个容器 都可以指定为 Flex 布局。\\n```css\\n.box{\\n  display: flex;\\n}\\n```\\n行内元素 也可以使用 Flex 布局。\\n```css\\n.box{\\n  display: inline-flex;\\n}\\n```\\nWebkit 内核的浏览器，必须加上`-webkit`前缀。\\n```css\\n.box{\\n  display: -webkit-flex; /* Safari */\\n  display: flex;\\n}\\n```\\n注意，设为 Flex\"},{\"url\":\"/02.页面/20.CSS/02.flex布局案例-基础.html\",\"relativePath\":\"/02.页面/20.CSS/02.flex布局案例-基础.html\",\"frontmatter\":{\"title\":\"flex布局案例-基础\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/ea6db1530c42ad51\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"flex布局案例-基础\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"``` html\\n&lt;html&gt;\\n  &lt;div class=\\\"box\\\"&gt;\\n    &lt;span&gt;1&lt;/span&gt;\\n    &lt;span&gt;2&lt;/span&gt;\\n    &lt;span&gt;3&lt;/span&gt;\\n    &lt;span&gt;4&lt;/span&gt;\\n    &lt;span&gt;5&lt;/span&gt;\\n    &lt;span&gt;6&lt;/span&gt;\\n    &lt;span&gt;7&lt;/span&gt;\\n  &lt;/div&gt;\\n&lt;/html&gt;\\n&lt;st\"},{\"url\":\"/02.页面/20.CSS/03.flex布局案例-骰子.html\",\"relativePath\":\"/02.页面/20.CSS/03.flex布局案例-骰子.html\",\"frontmatter\":{\"title\":\"flex布局案例-骰子\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/eff61bc8b4f4695d\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"flex布局案例-骰子\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```html\\n&lt;html&gt;\\n  &lt;div class=\\\"box2\\\"&gt;\\n    &lt;div class=\\\"first-face\\\"&gt;\\n      &lt;span class=\\\"pip\\\"&gt;&lt;/span&gt;\\n    &lt;/div&gt;\\n    &lt;div class=\\\"second-face\\\"&gt;\\n      &lt;span class=\\\"pip\\\"&gt;&lt;/span&gt;\\n      &lt;span class=\\\"pip\\\"&gt;&lt;/span&gt;\\n    &lt;/div&gt;\\n    &lt;div cla\"},{\"url\":\"/02.页面/20.CSS/04.flex布局案例-圣杯布局.html\",\"relativePath\":\"/02.页面/20.CSS/04.flex布局案例-圣杯布局.html\",\"frontmatter\":{\"title\":\"flex布局案例-圣杯布局\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/df9e7c7214fa5046\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"flex布局案例-圣杯布局\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```html\\n&lt;html&gt;\\n  &lt;div class=\\\"HolyGrail\\\"&gt;\\n    &lt;header&gt;header&lt;/header&gt;\\n    &lt;div class=\\\"wrap\\\"&gt;\\n      &lt;nav class=\\\"left\\\"&gt;left 宽度固定200px&lt;/nav&gt;\\n      &lt;main class=\\\"content\\\"&gt;center 宽度自适应&lt;/main&gt;\\n      &lt;aside class=\\\"right\\\"&gt;right 宽度固定200px&lt;/aside&gt\"},{\"url\":\"/02.页面/20.CSS/05.flex布局案例-网格布局.html\",\"relativePath\":\"/02.页面/20.CSS/05.flex布局案例-网格布局.html\",\"frontmatter\":{\"title\":\"flex布局案例-网格布局\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/85b5a3fe218a34b7\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"flex布局案例-网格布局\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```html\\n&lt;html&gt;\\n  &lt;div class=\\\"grid\\\"&gt;\\n    &lt;div class=\\\"grid-cell\\\"&gt;1/2&lt;/div&gt;\\n    &lt;div class=\\\"grid-cell\\\"&gt;1/2&lt;/div&gt;\\n  &lt;/div&gt;\\n  &lt;div class=\\\"grid\\\"&gt;\\n    &lt;div class=\\\"grid-cell\\\"&gt;1/3&lt;/div&gt;\\n    &lt;div class=\\\"grid-cell\\\"&gt;1/3&lt;/div&gt;\\n    &lt;div cl\"},{\"url\":\"/02.页面/20.CSS/06.flex布局案例-输入框布局.html\",\"relativePath\":\"/02.页面/20.CSS/06.flex布局案例-输入框布局.html\",\"frontmatter\":{\"title\":\"flex布局案例-输入框布局\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/05cc577fb51c7998\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"flex布局案例-输入框布局\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```html\\n&lt;html&gt;\\n  &lt;div class=\\\"InputAddOn\\\"&gt;\\n    &lt;span class=\\\"InputAddOn-item\\\"&gt;icon&lt;/span&gt;\\n    &lt;input class=\\\"InputAddOn-field\\\" placeholder=\\\"input宽度自适应\\\"&gt;\\n    &lt;button class=\\\"InputAddOn-item\\\"&gt;提交&lt;/button&gt;\\n  &lt;/div&gt;\\n  &lt;br/&gt;\\n  &lt;div class=\\\"Media\\\"&gt;\\n   \"},{\"url\":\"/02.页面/20.CSS/07.CSS3之transition过渡.html\",\"relativePath\":\"/02.页面/20.CSS/07.CSS3之transition过渡.html\",\"frontmatter\":{\"title\":\"CSS3之transition过渡\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/02d7f59d98d87409\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"CSS3之transition过渡\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"html结构\\n```html\\n&lt;div class=\\\"box1\\\"\\n  &lt;div class=\\\"div1\\\"&gt;&lt;/div&gt;\\n  &lt;div class=\\\"div2\\\"&gt;&lt;/div&gt;\\n  &lt;div class=\\\"div3\\\"&gt;&lt;/div&gt;\\n&lt;/div&gt;\\n```\\n先给元素设置transition过渡，指定样式和时间，这里设置all全部样式都采用0.3s的过渡\\n```css\\n.box1&gt;div{\\n  /* 给元素所有变化都添加过渡动画, 也可以指定唯一的过渡样式属性*/\\n  transition: all .3s;\"},{\"url\":\"/02.页面/20.CSS/08.CSS3之animation动画.html\",\"relativePath\":\"/02.页面/20.CSS/08.CSS3之animation动画.html\",\"frontmatter\":{\"title\":\"CSS3之animation动画\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/c2c0432138f6e042\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"CSS3之animation动画\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```html\\n&lt;html&gt;\\n  &lt;div class=\\\"animationBox\\\"&gt;\\n    &lt;div class=\\\"rotate\\\"&gt;旋转动画1&lt;/div&gt;\\n    &lt;div class=\\\"play\\\"&gt;\\n      &lt;div class=\\\"img\\\"&gt;旋转动画2&lt;/div&gt;\\n      &lt;span&gt;&lt;p class=\\\"p2\\\"&gt;&lt;/p&gt;&lt;/span&gt;\\n      &lt;span&gt;&lt;p&gt;&lt;/p&gt;&lt;/span&gt;\\n      &\"},{\"url\":\"/03.技术/01.技术文档/01.Git使用手册.html\",\"relativePath\":\"/03.技术/01.技术文档/01.Git使用手册.html\",\"frontmatter\":{\"title\":\"Git使用手册\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/9a7ee40fc232253e\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git使用手册\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"git使用手册\\\" tabindex=\\\"-1\\\">Git使用手册 <a class=\\\"header-anchor\\\" href=\\\"#git使用手册\\\" aria-label=\\\"Permalink to &quot;Git使用手册&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"安装\\\" tabindex=\\\"-1\\\">安装 <a class=\\\"header-anchor\\\" href=\\\"#安装\\\" aria-label=\\\"Permalink to &quot;安装&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>官网下载：<a href=\\\"https://git-scm.com/downloads\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">https://git-scm.com/downloads</a> 下载完成后使用默认进行安装。</p>\\n<p>安装完成后，在开始菜单里找到 <code>Git</code> -&gt; <code>Git Bash</code>，蹦出一个类似命令行窗口的东西，就说明Git安装成功！\\n还需要最后一步设置，在命令行输入：</p>\\n<div class=\\\"language-bash vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">bash</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">git</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> config</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> --global</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> user.name</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> \\\"Your Name\\\"</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">git</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> config</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> --global</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> user.email</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> \\\"email@example.com\\\"</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br></div></div><p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。</p>\\n\",\"capture\":\"Git使用手册\\n 安装\\n官网下载：&lt;https://git-scm.com/downloads\\n安装完成后，在开始菜单里找到 `Git` -&gt; `Git Bash`，蹦出一个类似命令行窗口的东西，就说明Git安装成功！\\n还需要最后一步设置，在命令行输入：\\n```bash\\ngit config --global user.name \\\"Your Name\\\"\\ngit config --global user.email \\\"email@example.com\\\"\\n```\\n因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。\\n 创建版本库（仓库）\\n```ba\"},{\"url\":\"/03.技术/01.技术文档/02.Markdown使用教程.html\",\"relativePath\":\"/03.技术/01.技术文档/02.Markdown使用教程.html\",\"frontmatter\":{\"title\":\"Markdown使用教程\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/ad247c4332211551\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Markdown使用教程\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"markdown使用教程\\\" tabindex=\\\"-1\\\">Markdown使用教程 <a class=\\\"header-anchor\\\" href=\\\"#markdown使用教程\\\" aria-label=\\\"Permalink to &quot;Markdown使用教程&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"一、markdown\\\" tabindex=\\\"-1\\\">一、Markdown <a class=\\\"header-anchor\\\" href=\\\"#一、markdown\\\" aria-label=\\\"Permalink to &quot;一、Markdown&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p><img src=\\\"https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/md_logo.png\\\" alt=\\\"logo\\\"></p>\\n<p><code>Markdown</code> 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>\\n\",\"capture\":\"一、Markdown\\n 简介\\n`Markdown` 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。\\n  应用\\n当前许多网站都广泛使用 `Markdown` 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、知乎等\\n 编辑器\\n推荐使用`Typora`，官网：&lt;https://typora.io/\\n 二、徽章\\n 什么是徽章\\n徽章是一种小巧精美的小图标，一般配有相关文字进行辅助说明，可对数据进行监控，链接跳转等，富有表现力。\\n常见于`github`项目主页，但其不仅出现于 `github` 项目主页，凡是能够表现图片的地方都可以出现徽章。\\n 徽章的使用\\n* 在\"},{\"url\":\"/03.技术/01.技术文档/03.npm常用命令.html\",\"relativePath\":\"/03.技术/01.技术文档/03.npm常用命令.html\",\"frontmatter\":{\"title\":\"npm常用命令\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/61f2f95fd7da14fd\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"npm常用命令\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"npm常用命令\\\" tabindex=\\\"-1\\\">npm常用命令 <a class=\\\"header-anchor\\\" href=\\\"#npm常用命令\\\" aria-label=\\\"Permalink to &quot;npm常用命令&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>npm是跟随node一起安装的包（模块）管理器。常见的使用场景有以下几种：</p>\\n<ul>\\n<li>允许用户从npm服务器下载别人编写的第三方包到本地使用。</li>\\n<li>允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用。</li>\\n<li>允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。</li>\\n</ul>\\n\",\"capture\":\"简介\\nnpm是跟随node一起安装的包（模块）管理器。常见的使用场景有以下几种：\\n* 允许用户从npm服务器下载别人编写的第三方包到本地使用。\\n* 允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用。\\n* 允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。\\n 常用命令\\n 检测是否安装及版本\\n```sh\\nnpm -v  显示版本号说明已经安装相应的版本\\n```\\n 生成package.json文件\\n```sh\\nnpm init\\n```\\n\\n 安装模块\\n```sh\\nnpm install  安装package.json定义好的模块，简写 npm i\\n 安装包指定模块\\nnpm \"},{\"url\":\"/03.技术/01.技术文档/15.yaml语言教程.html\",\"relativePath\":\"/03.技术/01.技术文档/15.yaml语言教程.html\",\"frontmatter\":{\"title\":\"yaml语言教程\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/4e8444e2d534d14f\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"yaml语言教程\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"yaml语言教程\\\" tabindex=\\\"-1\\\">yaml语言教程 <a class=\\\"header-anchor\\\" href=\\\"#yaml语言教程\\\" aria-label=\\\"Permalink to &quot;yaml语言教程&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>YAML 是 &quot;YAML Ain't a Markup Language&quot;（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：&quot;Yet Another Markup Language&quot;（仍是一种标记语言）。</p>\\n\",\"capture\":\"简介\\nYAML 是 \\\"YAML Ain't a Markup Language\\\"（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：\\\"Yet Another Markup Language\\\"（仍是一种标记语言）。\\nYAML 的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲（例如：许多电子邮件标题格式和YAML非常接近）。\\nYAML 的配置文件后缀为 .yml，如：runoob.yml 。\\n\\n 基本语法\\n- 大小写敏感\\n- 使用缩进\"},{\"url\":\"/03.技术/03.博客搭建/01.解决百度无法收录搭建在GitHub上的个人博客的问题.html\",\"relativePath\":\"/03.技术/03.博客搭建/01.解决百度无法收录搭建在GitHub上的个人博客的问题.html\",\"frontmatter\":{\"title\":\"解决百度无法收录搭建在GitHub上的个人博客的问题\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/41f87d890d0a02af\",\"categories\":[\"技术\",\"博客搭建\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"解决百度无法收录搭建在GitHub上的个人博客的问题\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"解决百度无法收录搭建在github上的静态博客的问题\\\" tabindex=\\\"-1\\\">解决百度无法收录搭建在GitHub上的静态博客的问题 <a class=\\\"header-anchor\\\" href=\\\"#解决百度无法收录搭建在github上的静态博客的问题\\\" aria-label=\\\"Permalink to &quot;解决百度无法收录搭建在GitHub上的静态博客的问题&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<div class=\\\"warning custom-block\\\"><p class=\\\"custom-block-title\\\">WARNING</p>\\n<p>如果你正在寻找本博客的搭建文档，博主建议您查看这个仓库的<a href=\\\"https://github.com/xugaoyi/vuepress-theme-vdoing\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">README</a>。</p>\\n</div>\\n<h2 id=\\\"背景\\\" tabindex=\\\"-1\\\">背景 <a class=\\\"header-anchor\\\" href=\\\"#背景\\\" aria-label=\\\"Permalink to &quot;背景&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>由于GitHub禁止百度爬虫访问，造成托管在GitHub Pages上的博客无法被百度收录。相关问题可以通过百度站长平台的<code>抓取诊断</code>再现，每次都是403 Forbidden的错误。</p>\\n\",\"capture\":\"如果你正在寻找本博客的搭建文档，博主建议您查看这个仓库的README。\\n 背景\\n由于GitHub禁止百度爬虫访问，造成托管在GitHub Pages上的博客无法被百度收录。相关问题可以通过百度站长平台的`抓取诊断`再现，每次都是403 Forbidden的错误。\\n 解决方案\\n同时将博客同时同步托管到GitHub Pages和coding pages上，解决百度不收录问题。最后发现在国内使用coding pages打开速度特别快，而且还会被百度收录，因此我把coding pages的站点作为主站点，原本在github pages的作为分站点。\\n步骤：\\n1、注册coding账号，创建仓库，把代码推\"},{\"url\":\"/03.技术/03.博客搭建/02.使用Gitalk实现静态博客无后台评论系统.html\",\"relativePath\":\"/03.技术/03.博客搭建/02.使用Gitalk实现静态博客无后台评论系统.html\",\"frontmatter\":{\"title\":\"使用Gitalk实现静态博客无后台评论系统\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/1da0bf9a988eafe5\",\"categories\":[\"技术\",\"博客搭建\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"使用Gitalk实现静态博客无后台评论系统\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"使用gitalk实现静态博客无后台评论系统\\\" tabindex=\\\"-1\\\">使用Gitalk实现静态博客无后台评论系统 <a class=\\\"header-anchor\\\" href=\\\"#使用gitalk实现静态博客无后台评论系统\\\" aria-label=\\\"Permalink to &quot;使用Gitalk实现静态博客无后台评论系统&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"前言\\\" tabindex=\\\"-1\\\">前言 <a class=\\\"header-anchor\\\" href=\\\"#前言\\\" aria-label=\\\"Permalink to &quot;前言&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>Gitalk，一个基于 Github Issue 和 Preact 开发的评论插件。</p>\\n<p>下面我们来用它在vuepress搭建的博客中搭建评论区吧</p>\\n\",\"capture\":\"前言\\nGitalk，一个基于 Github Issue 和 Preact 开发的评论插件。\\n下面我们来用它在vuepress搭建的博客中搭建评论区吧\\n 准备\\n使用一个新的东西首先当然是要了解它\\nGitalk demo：&lt;https://gitalk.github.io/\\nGitalk github：&lt;https://github.com/gitalk/gitalk&gt;\\n 实现\\n如何实现？最好的方法我认为是看官方文档，这里我只是记录一下实现的步骤。\\n使用一个别人已经开发好的 vuepress-plugin-comment 插件来帮助我们把Gitalk应用到vuepress搭建的静\"},{\"url\":\"/04.更多/03.面试/01.面试问题集锦.html\",\"relativePath\":\"/04.更多/03.面试/01.面试问题集锦.html\",\"frontmatter\":{\"title\":\"面试问题集锦\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/aea6571b7a8bae86\",\"categories\":[\"更多\",\"面试\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"面试问题集锦\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"请做一下自我介绍\\n回答提示： 一般人回答这个问题过于平常，只说姓名、年龄、工作经验，这些在简历上都有。其实，企业最希望知道的是求职者能否胜任工作，包括：最强的技能、最深入研究的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，要突出积极的个性和做事的能力，说的合情合理企业才会相信。\\n 你最大的优点是什么？\\n回答提示： 沉着冷静、条理清楚、立场坚定、乐于助人等，加上例子如：我在XX经过一到两年的培训及项目实战，加上实习工作，我想我适合这份工作。\\n 说说你最大的缺点？\\n回答提示： 这个问题企业问的概率很大，通常不希望听到直接回答的缺点是什么等，如果求职者说自己小心眼、非常懒、工作效率低\"}]}},\"groupPosts\":{\"categories\":{\"更多\":[{\"url\":\"/04.更多/05.AI随笔/01.当珍妮机学会了写代码.html\",\"relativePath\":\"/04.更多/05.AI随笔/01.当珍妮机学会了写代码.html\",\"frontmatter\":{\"title\":\"当珍妮机学会了写代码\",\"date\":\"2026-02-26 20:00:00\",\"permalink\":\"/pages/ai-coding-revolution/\",\"categories\":[\"更多\",\"AI随笔\"],\"tags\":[\"AI\",\"思考\",\"编程\"],\"author\":{\"name\":\"刘志伟;AI\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟;AI\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"当珍妮机学会了写代码\",\"date\":\"2026-02-26 20:00:00\",\"capture\":\"当珍妮机学会了写代码\\n\\n 一、从一台纺纱机说起\\n1764 年的某个夜晚，英国兰开夏郡的织工詹姆斯·哈格里夫斯看着妻子的纺车被踢倒后仍在旋转，灵光一闪——如果把纱锭竖起来，一个轮子就能同时驱动八个纱锭。\\n珍妮纺纱机就这样诞生了。一个人能干八个人的活，效率提升 800%。\\n262 年后的 2026 年，我坐在屏幕前，让一个叫 Claude 的 AI 帮我重构整个博客系统。它用 Three.js 写了一个极光 Shader 背景，用 Vue 3 搭了全屏滚动首页，让它设计了五套可切换的艺术风格主题——赛博朋克、梵高、水墨、古典雕塑、现代。它还帮我写了一篇博客，就是现在你正在看的这篇。\\n如果哈格里夫斯\"},{\"url\":\"/04.更多/99.友情链接.html\",\"relativePath\":\"/04.更多/99.友情链接.html\",\"frontmatter\":{\"title\":\"友情链接\",\"date\":\"2023-08-29 15:43:33\",\"permalink\":\"/pages/1bf946/\",\"categories\":[\"更多\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"友情链接\",\"date\":\"2023-08-29 15:43:33\",\"capture\":\"\"},{\"url\":\"/04.更多/01.学习/00.费曼学习法.html\",\"relativePath\":\"/04.更多/01.学习/00.费曼学习法.html\",\"frontmatter\":{\"title\":\"费曼学习法\",\"date\":\"2020-07-16 10:04:14\",\"permalink\":\"/pages/f2a556/\",\"categories\":[\"更多\",\"学习\"],\"tags\":[\"学习方法\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"费曼学习法\",\"date\":\"2020-07-16 10:04:14\",\"capture\":\"步骤\\n费曼学习法分为4个步骤:\\n1. 确定学习目标\\n你想学习的概念、内容、主题是什么。\\n2. 模拟教学学习法\\n你要模拟自己是一位老师，面对完全不懂这个领域的人，用自己的话，尽可能具体形象地讲诉。这样的讲诉有助于你活学活用，触类旁通，联系生活具体情境。\\n3. 回顾\\n反思第2步遇到的问题，哪些地方卡壳了，哪些地方对方没有真正听懂。找出问题的要害，把握关键环节。\\n4. 简化\\n把这些遇到问题的地方，重新梳理理解，尽可能了解更多背景和相关知识，再用尽可能简化的方式重新表达，设法看穿本质。然后，返回第2步。\\n\\n&gt; \\n&gt; 《费曼学习法：为何被称为史上最牛的学习法，它的本质究竟是什么？》\\n&gt;\"},{\"url\":\"/04.更多/01.学习/10.搜索引擎使用技巧.html\",\"relativePath\":\"/04.更多/01.学习/10.搜索引擎使用技巧.html\",\"frontmatter\":{\"title\":\"搜索引擎使用技巧\",\"date\":\"2020-05-24 11:44:19\",\"permalink\":\"/pages/ce818a\",\"categories\":[\"更多\",\"学习\"],\"tags\":[\"搜索技巧\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"搜索引擎使用技巧\",\"date\":\"2020-05-24 11:44:19\",\"capture\":\"搜索引擎相信大家经常在使用，但是有时候想搜某个信息时却搜出来一大堆不相关的（百度：你们都在看我干什么？）。下面我们来介绍几种搜索技巧，可以提升搜索效率，助你快速查资料，妈妈再也不担心我的学习了（'妈~我真的是在找学习资料'）\\n 技巧1：排除干扰项\\n方式：关键词1+空格+减号+关键词2，即 `关键词1 -关键词2`\\n功能：排除一些不想要的关键词\\n示例：\\n```\\n锤子 -锤子手机\\n```\\n示例中将在搜索结果排除与`锤子手机`相关的，只显示`锤子`本来的样子。\\n\\n 技巧2：精确搜索\\n方式：给关键词加双引号，`\\\"关键词\\\"`\\n功能：只搜索引号里的字，少一个字或者把字拆开都不行\\n示例：\\n```\\n\\\"达拉不崩\"},{\"url\":\"/04.更多/01.学习/03.提高记忆的技巧.html\",\"relativePath\":\"/04.更多/01.学习/03.提高记忆的技巧.html\",\"frontmatter\":{\"title\":\"提高记忆的技巧\",\"date\":\"2020-01-03 14:34:48\",\"permalink\":\"/pages/996822b2a2ca6e3b\",\"categories\":[\"更多\",\"学习\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"提高记忆的技巧\",\"date\":\"2020-01-03 14:34:48\",\"excerpt\":\"<h1 id=\\\"提高记忆的技巧\\\" tabindex=\\\"-1\\\">提高记忆的技巧 <a class=\\\"header-anchor\\\" href=\\\"#提高记忆的技巧\\\" aria-label=\\\"Permalink to &quot;提高记忆的技巧&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<ol>\\n<li><strong>多个感官并用</strong>\\n记忆时调用一切感官。没人的话可以大声阅读，有人的话可以默念，轻微摇晃手指等，有助于保持专注。</li>\\n</ol>\\n\",\"capture\":\"1. 多个感官并用\\n   记忆时调用一切感官。没人的话可以大声阅读，有人的话可以默念，轻微摇晃手指等，有助于保持专注。\\n   \\n2. 重复记忆\\n   每天留出半个到一个小时，梳理总结今天所学的内容。每一章复习完成后做系统的知识整理。\\n   \\n3. 建立关联\\n   把你所学的新知识与已有的认知建立联系，对于记忆事半功倍。\\n   \\n4. 场景记忆\\n   把知识具象化为一个场景，想象自己在何时何地能用这些知识，与自身发生联系。\\n   \\n5. 提出问题\\n   每学习一个知识点，试着提问，然后给出答案。用了就记住了。\"},{\"url\":\"/04.更多/03.面试/01.面试问题集锦.html\",\"relativePath\":\"/04.更多/03.面试/01.面试问题集锦.html\",\"frontmatter\":{\"title\":\"面试问题集锦\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/aea6571b7a8bae86\",\"categories\":[\"更多\",\"面试\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"面试问题集锦\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"请做一下自我介绍\\n回答提示： 一般人回答这个问题过于平常，只说姓名、年龄、工作经验，这些在简历上都有。其实，企业最希望知道的是求职者能否胜任工作，包括：最强的技能、最深入研究的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，要突出积极的个性和做事的能力，说的合情合理企业才会相信。\\n 你最大的优点是什么？\\n回答提示： 沉着冷静、条理清楚、立场坚定、乐于助人等，加上例子如：我在XX经过一到两年的培训及项目实战，加上实习工作，我想我适合这份工作。\\n 说说你最大的缺点？\\n回答提示： 这个问题企业问的概率很大，通常不希望听到直接回答的缺点是什么等，如果求职者说自己小心眼、非常懒、工作效率低\"}],\"AI随笔\":[{\"url\":\"/04.更多/05.AI随笔/01.当珍妮机学会了写代码.html\",\"relativePath\":\"/04.更多/05.AI随笔/01.当珍妮机学会了写代码.html\",\"frontmatter\":{\"title\":\"当珍妮机学会了写代码\",\"date\":\"2026-02-26 20:00:00\",\"permalink\":\"/pages/ai-coding-revolution/\",\"categories\":[\"更多\",\"AI随笔\"],\"tags\":[\"AI\",\"思考\",\"编程\"],\"author\":{\"name\":\"刘志伟;AI\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟;AI\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"当珍妮机学会了写代码\",\"date\":\"2026-02-26 20:00:00\",\"capture\":\"当珍妮机学会了写代码\\n\\n 一、从一台纺纱机说起\\n1764 年的某个夜晚，英国兰开夏郡的织工詹姆斯·哈格里夫斯看着妻子的纺车被踢倒后仍在旋转，灵光一闪——如果把纱锭竖起来，一个轮子就能同时驱动八个纱锭。\\n珍妮纺纱机就这样诞生了。一个人能干八个人的活，效率提升 800%。\\n262 年后的 2026 年，我坐在屏幕前，让一个叫 Claude 的 AI 帮我重构整个博客系统。它用 Three.js 写了一个极光 Shader 背景，用 Vue 3 搭了全屏滚动首页，让它设计了五套可切换的艺术风格主题——赛博朋克、梵高、水墨、古典雕塑、现代。它还帮我写了一篇博客，就是现在你正在看的这篇。\\n如果哈格里夫斯\"}],\"《JavaScript教程》笔记\":[{\"url\":\"/《JavaScript教程》笔记/14.JS实现扫码登录.html\",\"relativePath\":\"/《JavaScript教程》笔记/14.JS实现扫码登录.html\",\"frontmatter\":{\"title\":\"JS实现扫码登录\",\"date\":\"2024-03-30 15:32:39\",\"permalink\":\"/pages/bdbdb8/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"JS实现扫码登录\",\"date\":\"2024-03-30 15:32:39\",\"capture\":\"JS实现扫码登录\\r\\n\\r\\n扫码登录是一种方便快捷的登录方式，用户可以通过扫描二维码来登录网站或应用程序。在本文中，我们将使用JavaScript实现一个简单的扫码登录功能。\\r\\n\\r\\n 步骤一：生成二维码\\r\\n\\r\\n首先，我们需要生成一个二维码，用于展示给用户扫描。我们可以使用第三方库 qrcode.js 来生成二维码。以下是使用qrcode.js生成二维码的示例代码：\\r\\n\\r\\n```html\\r\\n&lt;!-- 在HTML中引入qrcode.js库 --\\r\\n&lt;script src=\\\"https://cdn.bootcdn.net/ajax/libs/qrcodejs/1.0.0/qrcode.min\"},{\"url\":\"/《JavaScript教程》笔记/13.JS继承.html\",\"relativePath\":\"/《JavaScript教程》笔记/13.JS继承.html\",\"frontmatter\":{\"title\":\"JS继承\",\"date\":\"2024-03-30 15:32:05\",\"permalink\":\"/pages/b17c09/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"JS继承\",\"date\":\"2024-03-30 15:32:05\",\"capture\":\"在JavaScript中，继承是实现面向对象编程的重要方式之一。\\r\\n\\r\\n 原型继承\\r\\n\\r\\n原型继承是JavaScript中最常用的继承方式之一。在原型继承中，子类通过继承父类的原型对象来实现继承。\\r\\n\\r\\n```javascript\\r\\nfunction Parent() {\\r\\n  this.name = 'parent';\\r\\n}\\r\\n\\r\\nParent.prototype.sayHello = function() {\\r\\n  console.log('Hello from ' + this.name);\\r\\n}\\r\\n\\r\\nfunction Child() {\\r\\n  this.name = 'child';\"},{\"url\":\"/《JavaScript教程》笔记/12.console实用调试方法.html\",\"relativePath\":\"/《JavaScript教程》笔记/12.console实用调试方法.html\",\"frontmatter\":{\"title\":\"console实用调试方法\",\"date\":\"2024-03-30 15:31:48\",\"permalink\":\"/pages/602ffc/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"console实用调试方法\",\"date\":\"2024-03-30 15:31:48\",\"capture\":\"在JavaScript中，console是一个非常有用的工具，可以帮助我们在开发和调试过程中更好地了解代码的执行情况。本文将介绍console中一些常用的方法，并提供示例代码。\\r\\n console.time() & console.timeEnd()\\r\\nconsole.time()方法用于开始计时器，console.timeEnd()方法用于结束计时器并输出所花费的时间。这对于测试代码执行时间非常有用。\\r\\n```javascript\\r\\nconsole.time('myTimer');\\r\\nfor (let i = 0; i &lt; 1000000; i++) {\\r\\n  // do someth\"},{\"url\":\"/《JavaScript教程》笔记/11.`import`、`require`、`export`、`module.exports` 的区别和使用详解.html\",\"relativePath\":\"/《JavaScript教程》笔记/11.`import`、`require`、`export`、`module.exports` 的区别和使用详解.html\",\"frontmatter\":{\"title\":\"exports` 的区别和使用详解\",\"date\":\"2024-03-30 15:23:12\",\"permalink\":\"/pages/ff5679/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"exports` 的区别和使用详解\",\"date\":\"2024-03-30 15:23:12\",\"capture\":\"在 Node.js 和现代的 JavaScript 中，有多种方式可以导入和导出模块。其中最常见的是使用 `import` 和 `export`，但在 Node.js 中，也可以使用 `require` 和 `module.exports`。本篇文章将介绍这些不同的方式，以及它们之间的区别。\\r\\n\\r\\n `import` 和 `export`\\r\\n\\r\\n`import` 和 `export` 是 ES6 中引入的模块系统。它们允许我们将代码拆分成多个文件，并在不同的文件中共享代码。以下是一个简单的例子：\\r\\n\\r\\n```javascript\\r\\n// math.js\\r\\nexport const add = \"},{\"url\":\"/《JavaScript教程》笔记/10.JS中的？.和？？区别.html\",\"relativePath\":\"/《JavaScript教程》笔记/10.JS中的？.和？？区别.html\",\"frontmatter\":{\"title\":\"和？？区别\",\"date\":\"2024-03-30 15:22:03\",\"permalink\":\"/pages/176ae0/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"和？？区别\",\"date\":\"2024-03-30 15:22:03\",\"capture\":\"`??` 运算符\\r\\n\\r\\n`??` 运算符是 ES2020 中新增的空值合并运算符。它用于判断一个值是否为 `null` 或 `undefined`，如果是，则使用默认值。其语法如下：\\r\\n\\r\\n```javascript\\r\\ndefaultValue ?? value;\\r\\n```\\r\\n\\r\\n如果 `value` 不为 `null` 或 `undefined`，则 `??` 运算符返回 `value`；否则返回 `defaultValue`。\\r\\n\\r\\n```javascript\\r\\nconst a = null;\\r\\nconst b = 5;\\r\\n\\r\\nconsole.log(a ?? 10); // 10\\r\\nco\"},{\"url\":\"/《JavaScript教程》笔记/09.js 使用postMessage iframe跨域通信.html\",\"relativePath\":\"/《JavaScript教程》笔记/09.js 使用postMessage iframe跨域通信.html\",\"frontmatter\":{\"title\":\"js 使用postMessage iframe跨域通信\",\"date\":\"2024-03-30 15:21:11\",\"permalink\":\"/pages/d67bac/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"js 使用postMessage iframe跨域通信\",\"date\":\"2024-03-30 15:21:11\",\"capture\":\"在 Web 应用程序中，由于同源策略的限制，如果我们需要在一个页面中嵌入来自不同域的资源（例如图片、脚本或 iframe），那么就会出现跨域问题。在这种情况下，我们需要使用一些技术来实现跨域通信。\\r\\n\\r\\n其中一种解决方案是使用 HTML5 中引入的 postMessage API。postMessage 允许我们在不同窗口或 iframe 之间发送消息，这使得我们可以实现跨域通信，而不违反同源策略。\\r\\n\\r\\n postMessage 简介\\r\\n\\r\\npostMessage 是 HTML5 中引入的一种跨窗口通信机制。它允许我们在不同窗口之间发送消息，并且这些窗口可以来自不同的域。postMessag\"},{\"url\":\"/《JavaScript教程》笔记/08.事件循环(evenloop).html\",\"relativePath\":\"/《JavaScript教程》笔记/08.事件循环(evenloop).html\",\"frontmatter\":{\"title\":\"事件循环(evenloop)\",\"date\":\"2023-09-08 16:20:58\",\"permalink\":\"/pages/eaf565/\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"事件循环(evenloop)\",\"date\":\"2023-09-08 16:20:58\",\"capture\":\"JavaScript 是一门单线程的语言，它的异步和多线程的实现是通过 Event Loop 事件循环机制来实现的\\nEvent Loop 的机制\\n大体三个部分组成\\n1、调用栈 Stack\\n2、消息队列 Message Queue\\n3、微任务队列 Microtask Queue\\n Event Loop 开始的时候会从全局栈开始逐行执行，遇到函数调用，会把函数压入到调用栈中，当函数返回后，会从调用栈中弹出\\n```javascript\\nfunction func1(){\\n    console.log(1);\\n }\\n function func2(){\\n    console.log(2);\\n   \"},{\"url\":\"/《JavaScript教程》笔记/01.基础.html\",\"relativePath\":\"/《JavaScript教程》笔记/01.基础.html\",\"frontmatter\":{\"title\":\"基础\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/0796ba76b4b55368\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"基础\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"基础篇\\n 一、JS的一些名词概念\\n 什么是作用域？\\n变量存在的范围。\\n可分为全局作用域和函数作用域，ES6新增块级作用域。\\n 什么是闭包？\\n闭包就是能够读取其他函数内部变量的函数。\\n* 闭包的形式：函数内部定义函数\\n* 本质上闭包就是将函数内部和外部连接起来的一座桥梁\\n闭包的作用：\\n* 可以读取函数内部变量\\n* 让这些变量始终保持在内存中，即闭包可以使得它诞生的环境一直存在。\\n*  封装对象的私有属性和私有方法\\n 什么是构造函数？\\n用于构造(生成)实例的一个函数，使实例拥有构造函数内定于的属性和方法。\\n 什么是实例对象？\\n实例对象就是通过new 构造函数生成的，拥有构造函数内定于的属性和方法的\"},{\"url\":\"/《JavaScript教程》笔记/02.内置对象.html\",\"relativePath\":\"/《JavaScript教程》笔记/02.内置对象.html\",\"frontmatter\":{\"title\":\"内置对象\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/74d2ab3fbfeaaa68\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"内置对象\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"内置对象篇\\n 一、Object对象\\n 1、概述\\nJavaScript 原生提供`Object`对象（注意起首的`O`是大写），本章介绍该对象原生的各种方法。\\nJavaScript 的所有其他对象都继承自`Object`对象，即那些对象都是`Object`的实例。\\n`Object`对象的原生方法分成两类：`Object`本身的方法与`Object`的实例方法。\\n（1）Object对象本身的方法\\n所谓“本身的方法”就是直接定义在`Object`对象的方法。\\n```js\\nObject.print = function (o) { console.log(o) };\\n```\\n上面代码中，`print`\"},{\"url\":\"/《JavaScript教程》笔记/03.面向对象.html\",\"relativePath\":\"/《JavaScript教程》笔记/03.面向对象.html\",\"frontmatter\":{\"title\":\"面向对象\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/659b5af5e2e704e0\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"面向对象\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"面向对象编程\\n 一、实例对象与new命令\\n 1、对象是什么\\n面向对象编程（Object Oriented Programming，缩写为 OOP）是目前主流的编程范式。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。\\n每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务。对象可以复用，通过继承机制还可以定制。因此，面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程（procedural programming），更适合多人合作的大型软件项目。\\n那么，“对象”\"},{\"url\":\"/《JavaScript教程》笔记/04.异步操作.html\",\"relativePath\":\"/《JavaScript教程》笔记/04.异步操作.html\",\"frontmatter\":{\"title\":\"异步操作\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/d61b1cb4cdac1f63\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"异步操作\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"异步操作\\n 一、异步操作概述\\n 1、单线程模型\\n单线程模型指的是，JavaScript 只在一个线程上运行。也就是说，JavaScript 同时只能执行一个任务，其他任务都必须在后面排队等待。\\n注意，JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合。\\nJavaScript 之所以采用单线程，而不是多线程，跟历史有关系。JavaScript 从诞生起就是单线程，原因是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对\"},{\"url\":\"/《JavaScript教程》笔记/05.DOM.html\",\"relativePath\":\"/《JavaScript教程》笔记/05.DOM.html\",\"frontmatter\":{\"title\":\"DOM\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/7d961b8030c6099e\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"DOM\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"DOM\\n 一、概述\\n 1、DOM\\nDOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。\\n浏览器会根据 DOM 模型，将结构化文档（比如 HTML 和 XML）解析成一系列的节点，再由这些节点组成一个树状结构（DOM Tree）。所有的节点和最终的树状结构，都有规范的对外接口。\\nDOM 只是一个接口规范，可以用各种语言实现。所以严格地说，DOM 不是 JavaScript 语法的一部分，但是 DOM 操作是 JavaScript 最\"},{\"url\":\"/《JavaScript教程》笔记/06.事件.html\",\"relativePath\":\"/《JavaScript教程》笔记/06.事件.html\",\"frontmatter\":{\"title\":\"事件\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/10b2761db5a8e089\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"事件\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"事件\\n 一、EventTarget 接口\\n 事件的本质是程序各个组成部分之间的一种通信方式，也是异步编程的一种实现。DOM 支持大量的事件，本章开始介绍 DOM 的事件编程。\\n 1、概述\\nDOM 的事件操作（监听和触发），都定义在`EventTarget`接口。所有节点对象都部署了这个接口，其他一些需要事件通信的浏览器内置对象（比如，`XMLHttpRequest`、`AudioNode`、`AudioContext`）也部署了这个接口。\\n该接口主要提供三个实例方法。\\n- `addEventListener`：绑定事件的监听函数\\n- `removeEventListener`：移除事件的监听函\"},{\"url\":\"/《JavaScript教程》笔记/07.浏览器模型.html\",\"relativePath\":\"/《JavaScript教程》笔记/07.浏览器模型.html\",\"frontmatter\":{\"title\":\"浏览器模型\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/bab4930124ad2c10\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"浏览器模型\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"一、浏览器环境概述\\nJavaScript 是浏览器的内置脚本语言。也就是说，浏览器内置了 JavaScript 引擎，并且提供各种接口，让 JavaScript 脚本可以控制浏览器的各种功能。一旦网页内嵌了 JavaScript 脚本，浏览器加载网页，就会去执行脚本，从而达到操作浏览器的目的，实现网页的各种动态效果。\\n本章开始介绍浏览器提供的各种 JavaScript 接口。首先，介绍 JavaScript 代码嵌入网页的方法。\\n 1、代码嵌入网页的方法\\n网页中嵌入 JavaScript 代码，主要有三种方法。\\n- `  &lt;script\\n- `  &lt;script&gt;  `标签加\"}],\"《Git》学习笔记\":[{\"url\":\"/《Git》学习笔记/Git常用命令速查表.html\",\"relativePath\":\"/《Git》学习笔记/Git常用命令速查表.html\",\"frontmatter\":{\"title\":\"Git常用命令速查表\",\"date\":\"2024-03-30 15:26:32\",\"permalink\":\"/pages/3aa4fd/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git常用命令速查表\",\"date\":\"2024-03-30 15:26:32\",\"capture\":\"\"},{\"url\":\"/《Git》学习笔记/10.手册/00.常用Git命令清单.html\",\"relativePath\":\"/《Git》学习笔记/10.手册/00.常用Git命令清单.html\",\"frontmatter\":{\"title\":\"常用Git命令清单\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/8292d8/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"常用Git命令清单\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。\\n下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。\\n\\n&gt; - Index / Stage：暂存区\\n&gt; - Repository：仓库区（或本地仓库）\\n&gt; - Remote：远程仓库\\n 一、新建代码库\\n```bash\\n 在当前目录新建一个Git代码库\\n$ git init\\n 新建一个目录，将其初始化为Git代码库\\n$ git init [project-name]\\n 下载一个项目和它的整个代码历史\\n$ git clone [url]\\n```\\n 二、配置\\nGit的设置文件为\"},{\"url\":\"/《Git》学习笔记/10.手册/01.Git变基合并.html\",\"relativePath\":\"/《Git》学习笔记/10.手册/01.Git变基合并.html\",\"frontmatter\":{\"title\":\"Git变基合并\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/c10281/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git变基合并\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"说明\\n以下 `v2` 是某个需求的开发分支， `dev`是总的开发分支，`v2` 是基于`dev`分支签出的。\\n当完成`v2`的开发后，需要把代码合并到`dev`，我们可以使用`rebase`进行合并：\\n```sh\\n 首先将 v2 push到远程仓库\\ngit add .\\ngit commit -m 'xxx'\\ngit push origin v2\\n 切换到 dev 拉取最新代码\\ngit checkout dev\\ngit pull origin dev\\n 切换到 v2\\ngit checkout v2\\ngit rebase dev  将 v2 的所有[commit] 变基到(应用到) dev\\n 切\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/10.Git基础与命令.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/10.Git基础与命令.html\",\"frontmatter\":{\"title\":\"Git基础与命令\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/635088/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git基础与命令\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"官方文档（中文）：https://git-scm.com/book/zh/v2\\n\\n Git基础\\n 全局配置\\n```bash\\ngit config --global user.name 'your name'\\ngit config --global user.email 'xxx@xx.com'\\n```\\n自报家门\\n 检查配置信息\\n```sh\\ngit config --list\\n```\\n 获取帮助\\n```sh\\n 获取全局帮助手册\\ngit help\\n 获取特定命令的详细版帮助手册 (两个命令是等价的)\\ngit help &lt;某个命令&gt;\\ngit &lt;某个命令&gt; --help  两个\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/100.Git工具-重写历史.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/100.Git工具-重写历史.html\",\"frontmatter\":{\"title\":\"Git工具-重写历史\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/1832fe/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git工具-重写历史\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"许多时候，在使用 Git 时，你可能想要修订提交历史。 Git 很棒的一点是它允许你在最后时刻做决定。 你可以在将暂存区内容提交前决定哪些文件进入提交，可以通过 `git stash` 来决定不与某些内容工作， 也可以重写已经发生的提交就像它们以另一种方式发生的一样。 这可能涉及改变提交的顺序，改变提交中的信息或修改文件，将提交压缩或是拆分， 或完全地移除提交——在将你的工作成果与他人共享之前。\\n在本节中，你可以学到如何完成这些工作，这样在与他人分享你的工作成果时你的提交历史将如你所愿地展示出来。\\n| Note | 在满意之前不要推送你的工作Git 的基本原则之一是，由于克隆中有很多工作是本地\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/110.Git工具-重置揭密.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/110.Git工具-重置揭密.html\",\"frontmatter\":{\"title\":\"Git工具-重置揭密\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/d9e9c6/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git工具-重置揭密\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"在继续了解更专业的工具前，我们先探讨一下 Git 的 `reset` 和 `checkout` 命令。 在初遇的 Git 命令中，这两个是最让人困惑的。 它们能做很多事情，所以看起来我们很难真正地理解并恰当地运用它们。 针对这一点，我们先来做一个简单的比喻。\\n 三棵树\\n理解 `reset` 和 `checkout` 的最简方法，就是以 Git 的思维框架（将其作为内容管理器）来管理三棵不同的树。 “树” 在我们这里的实际意思是 “文件的集合”，而不是指特定的数据结构。 （在某些情况下索引看起来并不像一棵树，不过我们现在的目的是用简单的方式思考它。）\\nGit 作为一个系统，是以它的一般操作来管理\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/20.Git分支-分支原理.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/20.Git分支-分支原理.html\",\"frontmatter\":{\"title\":\"Git分支-分支原理\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/4bef1a/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支-分支原理\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。\\n 首次提交\\n在进行提交操作时，Git 会保存一个提交对象（commit object）。\\n假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 暂存操作会为每一个文件计算校验和（使用 SHA-1 哈希算法），然后会把当前版本的文件快照保存到 Git 仓库中 （Git 使用 *blob* 对象来保存它们），最终将校验和加入到暂存区域等待提交：\\n```sh\\n$ git\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/30.Git分支的新建与合并-分支操作.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/30.Git分支的新建与合并-分支操作.html\",\"frontmatter\":{\"title\":\"Git分支的新建与合并-分支操作\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/ea5a8c/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支的新建与合并-分支操作\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"文档：Git 分支 - 分支的新建与合并\\n 创建分支并切换\\n此时有一个需求需要在新的分支`iss53`上工作：\\n```sh\\n$ git checkout -b iss53   b表示branch\\n```\\n它是下面两条命令的简写：\\n```sh\\n$ git branch iss53\\n$ git checkout iss53\\n```\\n 切换分支\\n突然有一个紧急问题要解决，需要在原来的`master`分支进行修复：\\n```sh\\n$ git checkout master\\n```\\n在切换到`master`之前，需要`iss53`分支保持好一个干净的状态（修改都已提交）。\\n注意：切换分支Git 会重置你的\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/40.Git分支管理-查看分支.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/40.Git分支管理-查看分支.html\",\"frontmatter\":{\"title\":\"Git分支管理-查看分支\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/a399b3/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支管理-查看分支\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"查看分支\\n```sh\\n$ git branch\\n  iss53\\n* master   带星号*表示当前所在分支\\n  testing\\n```\\n`git branch` 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表。\\n 查看每个分支的最后提交\\n```sh\\n$ git branch -v\\n  iss53   93b412c fix javascript issue\\n* master  7a98805 Merge branch 'iss53'\\n  testing 782fd34 test\\n```\\n 查看已(未)合并的分支\\n`--merged` 与 `--no-m\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/50.Git分支开发工作流.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/50.Git分支开发工作流.html\",\"frontmatter\":{\"title\":\"Git分支开发工作流\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/49ee30/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支开发工作流\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"文档：Git分支开发工作流\\n 长期分支\\n因为 Git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。 也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些主题分支合并入其他分支中。\\n许多使用 Git 的开发者都喜欢使用这种方式来工作，比如只在 `master` 分支上保留完全稳定的代码，开发过程在`dev`分支，开发完成后并入`test`分支进行测试，通过测试的稳定代码才并入`master`分支中。\\n`dev`和`test`分支不需要保持绝对稳定，但在`test`通过测试达到稳定状态，就可以被合并入`mast\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/60.Git分支-远程分支.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/60.Git分支-远程分支.html\",\"frontmatter\":{\"title\":\"Git分支-远程分支\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/574d62/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支-远程分支\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"远程引用是对远程仓库的引用（指针），包括分支、标签等等。\\n\\n 查看远程引用列表与信息\\n```sh\\ngit ls-remote &lt;remote&gt;  远程引用的完整列表\\ngit remote show &lt;remote&gt;  远程分支的更多信息\\n```\\n上面两行命令比较少用，更常见的做法是利用远程跟踪分支。\\n 远程跟踪分支\\n远程跟踪分支是远程分支状态的引用。它们是你无法移动的本地引用。一旦你进行了网络通信， Git 就会为你移动它们以精确反映远程仓库的状态。请将它们看做书签， 这样可以提醒你该分支在远程仓库中的位置就是你最后一次连接到它们的位置。\\n它们以 `&lt;remote\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/70.Git分支-变基.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/70.Git分支-变基.html\",\"frontmatter\":{\"title\":\"Git分支-变基\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/3a3247/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支-变基\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"在 Git 中整合来自不同分支的修改主要有两种方法：`merge` 以及 `rebase`。 在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。\\n 变基的基本操作\\n请回顾之前在 分支的合并 中的一个例子，你会看到开发任务分叉到两个不同分支，又各自提交了更新。\\n&lt;p align=\\\"center\\\"\\n之前介绍过，整合分支最容易的方法是 `merge` 命令。 它会把两个分支的最新快照（`C3` 和 `C4`）以及二者最近的共同祖先（`C2`）进行三方合并，合并的结果是生成一个新的快照（并提交）。\\n &lt;p align=\\\"cen\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/80.Git工具-查看修订版本.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/80.Git工具-查看修订版本.html\",\"frontmatter\":{\"title\":\"Git工具-查看修订版本\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/c984d1/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git工具-查看修订版本\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"Git 能够以多种方式来指定单个提交、一组提交、或者一定范围内的提交。 了解它们并不是必需的，但是了解一下总没坏处。\\n修订版本指的是：提交\\n 单个修订版本\\n你可以通过任意一个提交的 40 个字符的完整 SHA-1 散列值来指定它， 不过还有很多更人性化的方式来做同样的事情。本节将会介绍获取单个提交的多种方法。\\n 简短的 SHA-1\\nGit 十分智能，你只需要提供 SHA-1 的前几个字符就可以获得对应的那次提交， 当然你提供的 SHA-1 字符数量不得少于 4 个，并且没有歧义——也就是说， 当前对象数据库中没有其它对象以这段 SHA-1 开头。\\n例如，要查看你知道其中添加了某个功能的提交，首\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/90.Git工具-交互式暂存.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/90.Git工具-交互式暂存.html\",\"frontmatter\":{\"title\":\"Git工具-交互式暂存\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/76d859/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git工具-交互式暂存\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"本节中的几个交互式 Git 命令可以帮助你将文件的特定部分组合成提交。 当你在修改了大量文件后，希望这些改动能拆分为若干提交而不是混杂在一起成为一个提交时，这几个工具会非常有用。 通过这种方式，可以确保提交是逻辑上独立的变更集，同时也会使其他开发者在与你工作时很容易地审核。 如果运行 `git add` 时使用 `-i` 或者 `--interactive` 选项，Git 将会进入一个交互式终端模式，显示类似下面的东西：\\n```sh\\n$ git add -i\\n           staged     unstaged path\\n  1:    unchanged        +0/-1 T\"}],\"《uniapp》笔记\":[{\"url\":\"/《uniapp》笔记/使用uniapp对接蓝牙设备.html\",\"relativePath\":\"/《uniapp》笔记/使用uniapp对接蓝牙设备.html\",\"frontmatter\":{\"title\":\"使用uniapp对接蓝牙设备\",\"date\":\"2024-03-30 15:20:23\",\"permalink\":\"/pages/35c361/\",\"categories\":[\"《uniapp》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"使用uniapp对接蓝牙设备\",\"date\":\"2024-03-30 15:20:23\",\"capture\":\"低功耗蓝牙 API 平台差异说明\\r\\n\\r\\n| App | H5  | 微信小程序 | 支付宝小程序 | 百度小程序 | 字节跳动小程序 | 飞书小程序 | QQ 小程序 | 快手小程序 | 京东小程序 |\\r\\n| :-: | :-: | :--------: | :----------: | :--------: | :------------: | :--------: | :-------: | :--------: | :--------: |\\r\\n|  √  |  x  |     √      |      √       |     x      |       x        |  \"}],\"《Vue》笔记\":[{\"url\":\"/《Vue》笔记/99.其他/79.Vue中编辑word文档以及预览word .html\",\"relativePath\":\"/《Vue》笔记/99.其他/79.Vue中编辑word文档以及预览word .html\",\"frontmatter\":{\"title\":\"Vue中编辑word文档以及预览word\",\"date\":\"2023-09-13 10:25:00\",\"permalink\":\"/pages/1ebccd/\",\"categories\":[\"《Vue》笔记\",\"其他\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Vue中编辑word文档以及预览word\",\"date\":\"2023-09-13 10:25:00\",\"capture\":\"首先通过XMLHttpRequest发送一个GET请求到指定的URL，获取Word文件的内容并将其转换为HTML格式。其中使用mammoth库的convertToHtml方法将二进制数组转换为HTML格式的文本。（mammoth我用了一个修改版本样式还原度要比官方好@shy1118/mammoth）编辑用到的是ckeditor5富文本编辑器,最后通过html-docx-js将html转换为docx在进行保存**\\n 安装主要依赖\\n```bash\\nnpm install --save @ckeditor/ckeditor5-build-decoupled-document @shy1118/mam\"},{\"url\":\"/《Vue》笔记/99.其他/91.vue2与vue3生命周期对照表.html\",\"relativePath\":\"/《Vue》笔记/99.其他/91.vue2与vue3生命周期对照表.html\",\"frontmatter\":{\"title\":\"vue2与vue3生命周期对照表\",\"date\":\"2023-09-08 14:57:40\",\"permalink\":\"/pages/e866b9/\",\"categories\":[\"《Vue》笔记\",\"其他\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"vue2与vue3生命周期对照表\",\"date\":\"2023-09-08 14:57:40\",\"capture\":\"\"},{\"url\":\"/《Vue》笔记/10.Vuex/01.Vuex.html\",\"relativePath\":\"/《Vue》笔记/10.Vuex/01.Vuex.html\",\"frontmatter\":{\"title\":\"Vuex\",\"date\":\"2020-08-08 10:38:33\",\"permalink\":\"/pages/b30620/\",\"categories\":[\"《Vue》笔记\",\"Vuex\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Vuex\",\"date\":\"2020-08-08 10:38:33\",\"capture\":\"Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。\\n Vuex使用过程演示\\n以`vue-cli3`新创建出来的项目为例，演示Vuex的使用过程。\\n创建项目:\\n```sh\\nvue create vuex-test\\ncd vuex-test\\nnpm run serve\\n```\\n安装`vuex`:\\n```bash\\nnpm i vuex -S\\n```\\n进入项目的`src/`下新建一个文件`store/index.js`，并写入：\\n```js\\n// store/index.js\\nimport Vue from 'vue'\\nimport Vuex from 'vuex'\\nVue.use(Vu\"},{\"url\":\"/《Vue》笔记/05.工具/10.Vue CLi v3 创建项目使用记录.html\",\"relativePath\":\"/《Vue》笔记/05.工具/10.Vue CLi v3 创建项目使用记录.html\",\"frontmatter\":{\"title\":\"Vue CLi v3 创建项目使用记录\",\"date\":\"2020-02-20 17:24:29\",\"permalink\":\"/pages/d00311f8174119b2\",\"categories\":[\"《Vue》笔记\",\"工具\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Vue CLi v3 创建项目使用记录\",\"date\":\"2020-02-20 17:24:29\",\"capture\":\"官方文档\\n以下使用的CLi版本是 v3.11.0\\n vue create\\n1. 运行以下命令来创建一个新项目\\n```sh\\nvue create hello-world\\n```\\n2. 你会被提示选取一个 preset (预设)。你可以选默认的包含了基本的 Babel + ESLint 设置的 preset，也可以选“手动选择特性”来选取需要的特性。\\n```sh\\nVue CLI v3.11.0\\n? Please pick a preset: (Use arrow keys)\\n\\n  Manually select features (手动选择特性)\\n```\\n默认预设只包含Babel + ESLint\"},{\"url\":\"/《Vue》笔记/04.可复用性&组合/01.Mixin混入.html\",\"relativePath\":\"/《Vue》笔记/04.可复用性&组合/01.Mixin混入.html\",\"frontmatter\":{\"title\":\"Mixin混入\",\"date\":\"2020-02-19 15:22:41\",\"permalink\":\"/pages/bd36a3c1bc3e0821\",\"categories\":[\"《Vue》笔记\",\"可复用性&组合\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Mixin混入\",\"date\":\"2020-02-19 15:22:41\",\"excerpt\":\"<h1 id=\\\"mixin混入\\\" tabindex=\\\"-1\\\">Mixin混入 <a class=\\\"header-anchor\\\" href=\\\"#mixin混入\\\" aria-label=\\\"Permalink to &quot;Mixin混入&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"基础\\\" tabindex=\\\"-1\\\">基础 <a class=\\\"header-anchor\\\" href=\\\"#基础\\\" aria-label=\\\"Permalink to &quot;基础&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。</p>\\n\",\"capture\":\"基础\\n混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。\\n\\n&gt;\\n&gt; 可通过 `this.$options` 查看选项\\n例子：\\n```js\\n// 定义一个混入对象\\nvar myMixin = {\\n  created: function () {\\n    this.hello()\\n  },\\n  methods: {\\n    hello: function () {\\n      console.log('hello from mixin!')\\n  \"},{\"url\":\"/《Vue》笔记/02.组件/90.vue父子组件的生命周期顺序.html\",\"relativePath\":\"/《Vue》笔记/02.组件/90.vue父子组件的生命周期顺序.html\",\"frontmatter\":{\"title\":\"vue父子组件的生命周期顺序\",\"date\":\"2020-02-18 16:39:33\",\"permalink\":\"/pages/e6cec47efa42d7f1\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"vue父子组件的生命周期顺序\",\"date\":\"2020-02-18 16:39:33\",\"capture\":\"加载渲染过程\\n```\\n父beforeCreate -\\n```\\n父组件会先执行到beforeMount，接着会执行子组件钩子到挂载结束，再挂载父组件。\\n 子组件更新过程\\n```\\n父beforeUpdate -&gt; 子beforeUpdate -&gt; 子updated -&gt; 父updated\\n```\\n 父组件更新过程\\n```\\n父beforeUpdate -&gt; 父updated\\n```\\n 销毁过程\\n```\\n父beforeDestroy -&gt; 子beforeDestroy -&gt; 子destroyed -&gt; 父destroyed\\n```\"},{\"url\":\"/《Vue》笔记/03.过渡&动画/112.使用animate库.html\",\"relativePath\":\"/《Vue》笔记/03.过渡&动画/112.使用animate库.html\",\"frontmatter\":{\"title\":\"使用animate库\",\"date\":\"2020-02-17 16:05:52\",\"permalink\":\"/pages/3b0a20e70805fcea\",\"categories\":[\"《Vue》笔记\",\"过渡&动画\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"使用animate库\",\"date\":\"2020-02-17 16:05:52\",\"excerpt\":\"<h1 id=\\\"vue中使用animate-css库\\\" tabindex=\\\"-1\\\">vue中使用Animate.css库 <a class=\\\"header-anchor\\\" href=\\\"#vue中使用animate-css库\\\" aria-label=\\\"Permalink to &quot;vue中使用Animate.css库&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"自定义过渡类名\\\" tabindex=\\\"-1\\\">自定义过渡类名 <a class=\\\"header-anchor\\\" href=\\\"#自定义过渡类名\\\" aria-label=\\\"Permalink to &quot;自定义过渡类名&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>我们可以通过以下 attribute 来自定义过渡类名：</p>\\n<ul>\\n<li><code>enter-class</code></li>\\n<li><code>enter-active-class</code></li>\\n<li><code>enter-to-class</code> (2.1.8+)</li>\\n<li><code>leave-class</code></li>\\n<li><code>leave-active-class</code></li>\\n<li><code>leave-to-class</code> (2.1.8+)</li>\\n</ul>\\n\",\"capture\":\"自定义过渡类名\\n我们可以通过以下 attribute 来自定义过渡类名：\\n- `enter-class`\\n- `enter-active-class`\\n- `enter-to-class` (2.1.8+)\\n- `leave-class`\\n- `leave-active-class`\\n- `leave-to-class` (2.1.8+)\\n他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 Animate.css结合使用十分有用。\\n 使用Animate.css库\\n```html\\n&lt;transition\\n            name=\\\"custom-\"},{\"url\":\"/《Vue》笔记/02.组件/80.动态组件与 v-once 指令.html\",\"relativePath\":\"/《Vue》笔记/02.组件/80.动态组件与 v-once 指令.html\",\"frontmatter\":{\"title\":\"动态组件与 v-once 指令\",\"date\":\"2020-02-16 15:52:19\",\"permalink\":\"/pages/636ca33122e9a64b\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"动态组件与 v-once 指令\",\"date\":\"2020-02-16 15:52:19\",\"capture\":\"动态组件\\n```html\\n&lt;div id=\\\"root\\\"\\n\\t&lt;component :is=\\\"type\\\"&gt;&lt;/component&gt; &lt;!--其效果如同下面两行被注释的代码--&gt;\\n\\t&lt;!-- &lt;child-one v-if=\\\"type === 'child-one'\\\"&gt;&lt;/child-one&gt;\\n\\t    &lt;child-two v-if=\\\"type === 'child-two'\\\"&gt;&lt;/child-two&gt; --&gt;\\n\\t&lt;button @click=\\\"handleClick\\\"&gt;change&\"},{\"url\":\"/《Vue》笔记/02.组件/75.插槽slot.html\",\"relativePath\":\"/《Vue》笔记/02.组件/75.插槽slot.html\",\"frontmatter\":{\"title\":\"插槽slot\",\"date\":\"2020-02-16 11:46:27\",\"permalink\":\"/pages/055ecee9a4325386\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"插槽slot\",\"date\":\"2020-02-16 11:46:27\",\"capture\":\"API\\n 插槽\\n```html\\n&lt;div id=\\\"root\\\"\\n    &lt;child&gt; &lt;!-- 组件标签 --&gt;\\n        &lt;h1&gt;hello&lt;/h1&gt;\\n    &lt;/child&gt;\\n&lt;/div&gt;\\n&lt;script type=\\\"text/javascript\\\"&gt;\\n    Vue.component('child', { // 子组件\\n        template: '&lt;div&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;'\\n    })\\n    var vm \"},{\"url\":\"/《Vue》笔记/02.组件/65.非父子组件传值.html\",\"relativePath\":\"/《Vue》笔记/02.组件/65.非父子组件传值.html\",\"frontmatter\":{\"title\":\"非父子组件传值\",\"date\":\"2020-02-15 14:55:03\",\"permalink\":\"/pages/d408e64f666f146d\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"非父子组件传值\",\"date\":\"2020-02-15 14:55:03\",\"excerpt\":\"<h1 id=\\\"非父子组件间传值\\\" tabindex=\\\"-1\\\">非父子组件间传值 <a class=\\\"header-anchor\\\" href=\\\"#非父子组件间传值\\\" aria-label=\\\"Permalink to &quot;非父子组件间传值&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>当组件的嵌套多时，非父子组件间传值就显得复杂，除了使用<a href=\\\"https://vuex.vuejs.org/zh/\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">vuex</a>实现之外，还可以通过Bus（或者叫 总线/发布订阅模式/观察者模式）的方式实现非父子组件间传值。</p>\\n\",\"capture\":\"当组件的嵌套多时，非父子组件间传值就显得复杂，除了使用vuex实现之外，还可以通过Bus（或者叫 总线/发布订阅模式/观察者模式）的方式实现非父子组件间传值。\\n&lt;div id=\\\"root\\\"\\n\\t\\t&lt;child1 content=\\\"组件1：点我传出值\\\"&gt;&lt;/child1&gt;\\n\\t\\t&lt;child2 content=\\\"组件2\\\"&gt;&lt;/child2&gt;\\n\\t&lt;/div&gt;\\n```html\\n&lt;div id=\\\"root\\\"&gt;\\n    &lt;child1 content=\\\"组件1：点我传出值\\\"&gt;&lt;/child1&gt;\\n    &l\"},{\"url\":\"/《Vue》笔记/02.组件/55.自定义事件.html\",\"relativePath\":\"/《Vue》笔记/02.组件/55.自定义事件.html\",\"frontmatter\":{\"title\":\"自定义事件\",\"date\":\"2020-02-15 11:27:45\",\"permalink\":\"/pages/9651417d08d1779d\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"自定义事件\",\"date\":\"2020-02-15 11:27:45\",\"capture\":\"API\\n 在组件标签v-on绑定的事件是自定义事件\\n```html\\n&lt;div id=\\\"root\\\"\\n    &lt;child @click=\\\"handleClick\\\"&gt;&lt;/child&gt; &lt;!--这里click是自定义事件--&gt;\\n&lt;/div&gt;\\n&lt;script type=\\\"text/javascript\\\"&gt;\\n    Vue.component('child', {\\n        template: '&lt;button&gt;Child&lt;/button&gt;',\\n    })\\n    var vm = new Vue({\\n  \"},{\"url\":\"/《Vue》笔记/02.组件/52.Prop 验证 与 非 Prop 的 Attribute.html\",\"relativePath\":\"/《Vue》笔记/02.组件/52.Prop 验证 与 非 Prop 的 Attribute.html\",\"frontmatter\":{\"title\":\"Prop 验证 与 非 Prop 的 Attribute\",\"date\":\"2020-02-15 10:49:04\",\"permalink\":\"/pages/a3080f60f6596eb4\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Prop 验证 与 非 Prop 的 Attribute\",\"date\":\"2020-02-15 10:49:04\",\"capture\":\"Prop 验证\\nAPI\\n子组件对父组件传递来的参数进行校验\\n```js\\nVue.component('my-component', {\\n  props: {\\n    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)\\n    propA: Number,\\n    // 多个可能的类型\\n    propB: [String, Number],\\n    // 必填的字符串\\n    propC: {\\n      type: String,\\n      required: true\\n    },\\n    // 带有默认值的数字\\n    propD: {\\n      \"},{\"url\":\"/《Vue》笔记/02.组件/36.使用组件的细节点.html\",\"relativePath\":\"/《Vue》笔记/02.组件/36.使用组件的细节点.html\",\"frontmatter\":{\"title\":\"使用组件的细节点\",\"date\":\"2020-02-13 13:26:20\",\"permalink\":\"/pages/83a1ab785e7fd70c\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"使用组件的细节点\",\"date\":\"2020-02-13 13:26:20\",\"capture\":\"解析 DOM 模板时的注意事项\\n```html\\n&lt;div id=\\\"root\\\"\\n    &lt;table&gt;\\n        &lt;tbody&gt;\\n            &lt;row&gt;&lt;/row&gt;\\n            &lt;row&gt;&lt;/row&gt;\\n            &lt;row&gt;&lt;/row&gt;\\n        &lt;/tbody&gt;\\n    &lt;/table&gt;\\n&lt;/div&gt;\\n&lt;script type=\\\"text/javascript\\\"&gt;\\n    Vue.component\"},{\"url\":\"/《Vue》笔记/01.基础/35.列表渲染之数组、对象更新检测.html\",\"relativePath\":\"/《Vue》笔记/01.基础/35.列表渲染之数组、对象更新检测.html\",\"frontmatter\":{\"title\":\"列表渲染之数组、对象更新检测\",\"date\":\"2020-02-05 13:09:06\",\"permalink\":\"/pages/04783a6691cc9d06\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"列表渲染之数组、对象更新检测\",\"date\":\"2020-02-05 13:09:06\",\"excerpt\":\"<h1 id=\\\"列表渲染之数组、对象更新检测\\\" tabindex=\\\"-1\\\">列表渲染之数组、对象更新检测 <a class=\\\"header-anchor\\\" href=\\\"#列表渲染之数组、对象更新检测\\\" aria-label=\\\"Permalink to &quot;列表渲染之数组、对象更新检测&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/list.html#%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">数组更新检测API</a> <a href=\\\"https://cn.vuejs.org/v2/guide/list.html#%E5%AF%B9%E8%B1%A1%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">对象更新检测API</a></p>\\n<h2 id=\\\"数组更新检测\\\" tabindex=\\\"-1\\\">数组更新检测 <a class=\\\"header-anchor\\\" href=\\\"#数组更新检测\\\" aria-label=\\\"Permalink to &quot;数组更新检测&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h4 id=\\\"变异方法-mutation-method\\\" tabindex=\\\"-1\\\">变异方法 (mutation method) <a class=\\\"header-anchor\\\" href=\\\"#变异方法-mutation-method\\\" aria-label=\\\"Permalink to &quot;变异方法 (mutation method)&quot;\\\">&ZeroWidthSpace;</a></h4>\\n<p>Vue 将被侦听的数组的变异方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：</p>\\n\",\"capture\":\"数组更新检测API 对象更新检测API\\n 数组更新检测\\n 变异方法 (mutation method)\\nVue 将被侦听的数组的变异方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：\\n- `push()`末尾添加\\n- `pop()`末尾删除\\n- `shift()` 首位删除\\n- `unshift() ` 首位添加\\n- `splice()` 拼合\\n- `sort()` 排序\\n- `reverse()` 反转\\n数组实例方法\\n 替换数组\\n变异方法，顾名思义，会改变调用了这些方法的原始数组。相比之下，也有非变异 (non-mutating method) 方法，例如 `filter(\"},{\"url\":\"/《Vue》笔记/01.基础/30.v-if vs v-show.html\",\"relativePath\":\"/《Vue》笔记/01.基础/30.v-if vs v-show.html\",\"frontmatter\":{\"title\":\"v-if vs v-show\",\"date\":\"2020-02-04 17:32:23\",\"permalink\":\"/pages/73e4064340277b05\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"v-if vs v-show\",\"date\":\"2020-02-04 17:32:23\",\"excerpt\":\"<h1 id=\\\"v-if-vs-v-show\\\" tabindex=\\\"-1\\\">v-if vs v-show <a class=\\\"header-anchor\\\" href=\\\"#v-if-vs-v-show\\\" aria-label=\\\"Permalink to &quot;v-if vs v-show&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/conditional.html#v-if-vs-v-show\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">API</a></p>\\n<p><code>v-if</code> 根据渲染条件决定是否把元素渲染到DOM页面，而<code>v-show</code>不管渲染条件是什么，都会把元素渲染到DOM页面，只是简单的切换CSS的显示隐藏。</p>\\n\",\"capture\":\"API\\n`v-if` 根据渲染条件决定是否把元素渲染到DOM页面，而`v-show`不管渲染条件是什么，都会把元素渲染到DOM页面，只是简单的切换CSS的显示隐藏。\\n如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好。\"},{\"url\":\"/《Vue》笔记/01.基础/20.计算属性 vs 方法 vs 侦听属性.html\",\"relativePath\":\"/《Vue》笔记/01.基础/20.计算属性 vs 方法 vs 侦听属性.html\",\"frontmatter\":{\"title\":\"计算属性 vs 方法 vs 侦听属性\",\"date\":\"2020-02-04 16:37:51\",\"permalink\":\"/pages/351f72ecd9c41129\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"计算属性 vs 方法 vs 侦听属性\",\"date\":\"2020-02-04 16:37:51\",\"excerpt\":\"<h1 id=\\\"计算属性-vs-方法-vs-侦听属性\\\" tabindex=\\\"-1\\\">计算属性 vs 方法 vs 侦听属性 <a class=\\\"header-anchor\\\" href=\\\"#计算属性-vs-方法-vs-侦听属性\\\" aria-label=\\\"Permalink to &quot;计算属性 vs 方法 vs 侦听属性&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/computed.html#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%BC%93%E5%AD%98-vs-%E6%96%B9%E6%B3%95\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">API</a></p>\\n<p>如果一个功能同时可以使用计算属性(computed)、方法(methods)、侦听属性(watch)来实现的时候推荐使用计算属性。</p>\\n\",\"capture\":\"API\\n如果一个功能同时可以使用计算属性(computed)、方法(methods)、侦听属性(watch)来实现的时候推荐使用计算属性。\\n| 计算属性                                 | 方法                                               | 侦听属性                                     |\\n| ---------------------------------------- | --------------------------------------------------\"},{\"url\":\"/《Vue》笔记/01.基础/10.生命周期.html\",\"relativePath\":\"/《Vue》笔记/01.基础/10.生命周期.html\",\"frontmatter\":{\"title\":\"生命周期\",\"date\":\"2020-02-04 15:06:59\",\"permalink\":\"/pages/176808a1b5f843b8\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"生命周期\",\"date\":\"2020-02-04 15:06:59\",\"excerpt\":\"<h1 id=\\\"实例生命周期钩子\\\" tabindex=\\\"-1\\\">实例生命周期钩子 <a class=\\\"header-anchor\\\" href=\\\"#实例生命周期钩子\\\" aria-label=\\\"Permalink to &quot;实例生命周期钩子&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/instance.html#%E5%AE%9E%E4%BE%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">实例生命周期钩子API</a></p>\\n<p>简单理解，生命周期钩子函数就是vue实例在某一个时间点会自动执行的函数。</p>\\n\",\"capture\":\"实例生命周期钩子API\\n简单理解，生命周期钩子函数就是vue实例在某一个时间点会自动执行的函数。\\n```html\\n&lt;div id=\\\"app\\\"\\n&lt;script src=\\\"https://cdn.bootcss.com/vue/2.4.2/vue.js\\\"&gt;&lt;/script&gt;\\n&lt;script&gt;\\n  var vm = new Vue({\\n    el: 'app',\\n    data: {\\n      msg: 'Vue的生命周期'\\n    },\\n    beforeCreate: function() {\\n      console.group('-----\"},{\"url\":\"/《Vue》笔记/06.规模化/140.路由懒加载.html\",\"relativePath\":\"/《Vue》笔记/06.规模化/140.路由懒加载.html\",\"frontmatter\":{\"title\":\"路由懒加载\",\"date\":\"2020-02-04 13:20:20\",\"permalink\":\"/pages/38ecac9a9b92f037\",\"categories\":[\"《Vue》笔记\",\"规模化\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"路由懒加载\",\"date\":\"2020-02-04 13:20:20\",\"capture\":\"```js\\n// 路由同步加载\\n// import Recommend from '@/components/recommend/recommend'\\n// import Singer from '@/components/singer/singer'\\n// import Rank from '@/components/rank/rank'\\n// import Search from '@/components/search/search'\\n// import SingerDetail from '@/components/singer-detail/singer-detail'\\n// imp\"},{\"url\":\"/《Vue》笔记/03.过渡&动画/120.transition-group列表过渡.html\",\"relativePath\":\"/《Vue》笔记/03.过渡&动画/120.transition-group列表过渡.html\",\"frontmatter\":{\"title\":\"transition-group列表过渡\",\"date\":\"2020-02-04 13:17:42\",\"permalink\":\"/pages/0aa92922ace6bb5e\",\"categories\":[\"《Vue》笔记\",\"过渡&动画\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"transition-group列表过渡\",\"date\":\"2020-02-04 13:17:42\",\"excerpt\":\"<h1 id=\\\"transition-group列表过渡\\\" tabindex=\\\"-1\\\">transition-group列表过渡 <a class=\\\"header-anchor\\\" href=\\\"#transition-group列表过渡\\\" aria-label=\\\"Permalink to &quot;transition-group列表过渡&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"列表的进入-离开过渡\\\" tabindex=\\\"-1\\\">列表的进入/离开过渡 <a class=\\\"header-anchor\\\" href=\\\"#列表的进入-离开过渡\\\" aria-label=\\\"Permalink to &quot;列表的进入/离开过渡&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<div class=\\\"language-html vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">html</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">&#x3C;</span><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">transition-group</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> tag</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"ul\\\"</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">> </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">&#x3C;!--tag转为ul--></span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">    &#x3C;</span><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">li</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> v-for</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"item in list\\\"</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> :key</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"item\\\"</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">>{{item}}&#x3C;/</span><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">li</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">> </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">&#x3C;!--子元素要有key--></span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">&#x3C;/</span><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">transition-group</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">></span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br></div></div><p><strong>注意</strong>：列表元素一定要有<code>key</code></p>\\n\",\"capture\":\"列表的进入/离开过渡\\n```html\\n&lt;transition-group tag=\\\"ul\\\"\\n    &lt;li v-for=\\\"item in list\\\" :key=\\\"item\\\"&gt;{{item}}&lt;/li&gt; &lt;!--子元素要有key--&gt;\\n&lt;/transition-group&gt;\\n```\\n注意：列表元素一定要有`key`\\n```css\\n.v-enter,.v-leave-to{\\n  opacity: 0;\\n  transform: translateX(30px);\\n}\\n.v-enter-active,.v-leave-active{\\n  tran\"},{\"url\":\"/《Vue》笔记/03.过渡&动画/110.transition过渡&动画.html\",\"relativePath\":\"/《Vue》笔记/03.过渡&动画/110.transition过渡&动画.html\",\"frontmatter\":{\"title\":\"transition过渡&动画\",\"date\":\"2020-02-04 13:16:19\",\"permalink\":\"/pages/184a96b493a97078\",\"categories\":[\"《Vue》笔记\",\"过渡&动画\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"transition过渡&动画\",\"date\":\"2020-02-04 13:16:19\",\"excerpt\":\"<h1 id=\\\"transition过渡-动画\\\" tabindex=\\\"-1\\\">transition过渡&amp;动画 <a class=\\\"header-anchor\\\" href=\\\"#transition过渡-动画\\\" aria-label=\\\"Permalink to &quot;transition过渡&amp;动画&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/transitions.html\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">API</a></p>\\n<h2 id=\\\"使用\\\" tabindex=\\\"-1\\\">使用 <a class=\\\"header-anchor\\\" href=\\\"#使用\\\" aria-label=\\\"Permalink to &quot;使用&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>需要设置动画的元素或组件要在外边包裹一个<code>&lt;transition&gt;</code>标签，设置自定义的<code>name</code>，vue会根据元素的切换（进入/离开）过程添加相应的css类名，你可以<strong>自由地使用css类名来设置css过渡&amp;动画</strong>。</p>\\n\",\"capture\":\"API\\n 使用\\n需要设置动画的元素或组件要在外边包裹一个`&lt;transition\\n 过渡的类名\\n在进入/离开的过渡中，会有 6 个 class 切换。\\n各类名的生命周期\\n* 进入\\n  * `v-enter` 只存在于第一帧\\n  * `v-enter-active` 第一帧到最后一帧，结束后移除\\n  * `v-enter-to` 第二帧到最后一帧，结束后移除\\n* 离开\\n  * `v-leave` 只存在于第一帧\\n  * `v-leave-active` 第一帧到最后一帧，结束后移除\\n  * `v-leave-to` 第二帧到最后一帧，结束后移除\\n如果你使用一个没有`name`的`&lt;t\"},{\"url\":\"/《Vue》笔记/06.规模化/100.vuex操作相关.html\",\"relativePath\":\"/《Vue》笔记/06.规模化/100.vuex操作相关.html\",\"frontmatter\":{\"title\":\"vuex操作相关\",\"date\":\"2020-02-04 13:15:19\",\"permalink\":\"/pages/d9d62d6ab8ff99a6\",\"categories\":[\"《Vue》笔记\",\"规模化\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"vuex操作相关\",\"date\":\"2020-02-04 13:15:19\",\"capture\":\"```js\\nimport { mapActions, mapMutations, mapGetters } from 'vuex'\\ncomputed: {\\n    ...mapGetters([ // 获取数据，内部为数组\\n        'searchHistory' // 相当于在data插入searchHistory和获取到的数据\\n    ])\\n},\\nmethods: {\\n\\t某方法(){\\n\\t  this.saveSearchHistory(传入值)\\n\\t},\\n\\t...mapActions([ // 提交actions修改数据，内部为数组 因为actions文件已对方法进行了封装所有是数组类\"},{\"url\":\"/《Vue》笔记/99.其他/90.操作本地缓存.html\",\"relativePath\":\"/《Vue》笔记/99.其他/90.操作本地缓存.html\",\"frontmatter\":{\"title\":\"操作本地缓存\",\"date\":\"2020-02-04 13:14:19\",\"permalink\":\"/pages/30a94dbe96873b33\",\"categories\":[\"《Vue》笔记\",\"其他\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"操作本地缓存\",\"date\":\"2020-02-04 13:14:19\",\"capture\":\"&lt;https://github.com/ustbhuangyi/storage\\n操作 sessionStorage 和 localStorage 。\"},{\"url\":\"/《Vue》笔记/99.其他/80.Vue中的防抖函数封装和使用.html\",\"relativePath\":\"/《Vue》笔记/99.其他/80.Vue中的防抖函数封装和使用.html\",\"frontmatter\":{\"title\":\"Vue中的防抖函数封装和使用\",\"date\":\"2020-02-04 13:10:19\",\"permalink\":\"/pages/fb08e252dfd8fdfd\",\"categories\":[\"《Vue》笔记\",\"其他\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Vue中的防抖函数封装和使用\",\"date\":\"2020-02-04 13:10:19\",\"capture\":\"Vue中的防抖函数封装和使用\\n如搜索框中，每改变一个数值就请求一次搜索接口，当快速的改变数值时并不需要多次请求接口，这就需要一个防抖函数：\\n```js\\n// 防抖函数\\nexport function debounce(func, delay) { // func 函数 delay间隔时间\\n  let timer\\n  return function (...args) {\\n    if (timer) {\\n      clearTimeout(timer)\\n    }\\n    timer = setTimeout(() =\\n      func.apply(this, args)\\n    }, \"},{\"url\":\"/《Vue》笔记/02.组件/70.父组件调用子组件方法并传入值.html\",\"relativePath\":\"/《Vue》笔记/02.组件/70.父组件调用子组件方法并传入值.html\",\"frontmatter\":{\"title\":\"父组件调用子组件方法并传入值\",\"date\":\"2020-02-04 13:06:37\",\"permalink\":\"/pages/2e24dab728769e0c\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"父组件调用子组件方法并传入值\",\"date\":\"2020-02-04 13:06:37\",\"capture\":\"通过`ref`引用调用子组件内的方法并传入参数\\n父组件：\\n```js\\n&lt;子组件标签  ref=\\\"refName\\\"\\nmethods: {\\n    fnX(x) {\\n      this.$refs.refName.fnY(x) // 调用子组件方法并传入值\\n    }\\n}\\n```\\n子组件：\\n```js\\nmethods: {\\n    fnY(x) {\\n      this.x = x\\n    }\\n  }\\n}\\n```\"},{\"url\":\"/《Vue》笔记/02.组件/60.兄弟组件传值.html\",\"relativePath\":\"/《Vue》笔记/02.组件/60.兄弟组件传值.html\",\"frontmatter\":{\"title\":\"兄弟组件传值\",\"date\":\"2020-02-04 13:04:32\",\"permalink\":\"/pages/809f4582d9ca9552\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"兄弟组件传值\",\"date\":\"2020-02-04 13:04:32\",\"capture\":\"子组件1中把值传到父组件,父组件获取值传入子组件2\\n父组件：\\n```js\\n&lt;子组件1 @方法名x=\\\"方法名y\\\"\\n&lt;子组件2 :值名称x=\\\"值x\\\"&gt;&lt;/子组件2 &gt;\\ndata() {\\n\\treturn {\\n\\t 值x: ''\\n\\t}\\n},\\nmethods: {\\n\\t方法名y(值) {\\n\\t\\tthis.值x = 值\\n\\t}\\n}\\n```\\n子组件1：\\n```js\\nthis.$emit('方法名x', 值) // 传出值\\n```\\n子组件2：\\n```js\\nprops: {\\n    值名称x: { // 接收父组件传入值\\n        type: String,\\n        defa\"},{\"url\":\"/《Vue》笔记/02.组件/50.子组件派发事件和值给父组件.html\",\"relativePath\":\"/《Vue》笔记/02.组件/50.子组件派发事件和值给父组件.html\",\"frontmatter\":{\"title\":\"子组件派发事件和值给父组件\",\"date\":\"2020-02-04 12:56:51\",\"permalink\":\"/pages/0f19a1bcac14fd41\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"子组件派发事件和值给父组件\",\"date\":\"2020-02-04 12:56:51\",\"excerpt\":\"<h1 id=\\\"子组件派发事件和值给父组件\\\" tabindex=\\\"-1\\\">子组件派发事件和值给父组件 <a class=\\\"header-anchor\\\" href=\\\"#子组件派发事件和值给父组件\\\" aria-label=\\\"Permalink to &quot;子组件派发事件和值给父组件&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/components.html#%E7%9B%91%E5%90%AC%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">API</a></p>\\n<p>子组件通过<code>$emit</code>派发事件和值给父组件（值可以有多个）</p>\\n<div class=\\\"language-js vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">js</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">this</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">$emit</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'fnX'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, value)</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br></div></div>\",\"capture\":\"API\\n子组件通过`$emit`派发事件和值给父组件（值可以有多个）\\n```js\\nthis.$emit('fnX', value)\\n```\\n父组件通过`v-on`绑定子组件派发的事件，并触发一个新的事件，新的事件内可以接收传来的值\\n```js\\n&lt;ComponentName @fnX=\\\"fnY\\\"\\nmethods: {\\n\\tfnY(value) {\\n\\t\\tconsole.log(value)\\n\\t}\\n}\\n```\\n 父子组件间传递数据 demo\\n&lt;p class=\\\"codepen\\\" data-height=\\\"400\\\" data-theme-id=\\\"light\\\" data-default-tab\"},{\"url\":\"/《Vue》笔记/02.组件/40.父组件给子组件传值.html\",\"relativePath\":\"/《Vue》笔记/02.组件/40.父组件给子组件传值.html\",\"frontmatter\":{\"title\":\"父组件给子组件传值\",\"date\":\"2020-02-04 12:45:30\",\"permalink\":\"/pages/07b384c2e6232e07\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"父组件给子组件传值\",\"date\":\"2020-02-04 12:45:30\",\"excerpt\":\"<h1 id=\\\"父组件给子组件传值\\\" tabindex=\\\"-1\\\">父组件给子组件传值 <a class=\\\"header-anchor\\\" href=\\\"#父组件给子组件传值\\\" aria-label=\\\"Permalink to &quot;父组件给子组件传值&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>父组件中，通过给子组件标签v-bind绑定属性的方式传入值</p>\\n<div class=\\\"language-html vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">html</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">&#x3C;</span><span style=\\\"--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic\\\">ComponentName</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> v-bind:name</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"value\\\"</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">>&#x3C;/</span><span style=\\\"--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic\\\">ComponentName</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">></span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br></div></div><blockquote>\\n<p>如果不使用v-bind传入的值为字符串，使用v-bind绑定传入的值为表达式。</p>\\n</blockquote>\\n\",\"capture\":\"父组件中，通过给子组件标签v-bind绑定属性的方式传入值\\n```html\\n&lt;ComponentName v-bind:name=\\\"value\\\"\\n```\\n&gt; 如果不使用v-bind传入的值为字符串，使用v-bind绑定传入的值为表达式。\\n子组件中，通过props对象接收值\\n```js\\n props: {\\n    name: { // 接收父组件传入值\\n        type: String || ...,\\n        default: ''\\n    }\\n }\\n```\\n 单向数据流\\n所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向\"},{\"url\":\"/《Vue》笔记/01.基础/00.MVVM模式.html\",\"relativePath\":\"/《Vue》笔记/01.基础/00.MVVM模式.html\",\"frontmatter\":{\"title\":\"MVVM模式\",\"date\":\"2020-02-04 12:19:00\",\"permalink\":\"/pages/114158caa9e96df0\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"MVVM模式\",\"date\":\"2020-02-04 12:19:00\",\"excerpt\":\"<div class=\\\"tip custom-block\\\"><p class=\\\"custom-block-title\\\">TIP</p>\\n<p>说明：本章内容是博主的Vue学习笔记，以<a href=\\\"https://cn.vuejs.org/v2/guide/\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">官方文档</a>为准。</p>\\n</div>\\n<h1 id=\\\"mvvm模式\\\" tabindex=\\\"-1\\\">MVVM模式 <a class=\\\"header-anchor\\\" href=\\\"#mvvm模式\\\" aria-label=\\\"Permalink to &quot;MVVM模式&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>MVVM模式，<code>M</code>即 model，数据模型；<code>V</code>即 view，视图；<code>VM</code>即 view-model，视图模型。</p>\\n\",\"capture\":\"说明：本章内容是博主的Vue学习笔记，以官方文档为准。\\n MVVM模式\\nMVVM模式，`M`即 model，数据模型；`V`即 view，视图；`VM`即 view-model，视图模型。\\n理解\\n首先，数据Model通过Data Bindings把数据绑定在View视图上，\\n当View视图有交互（有改变）的时候，Dom listeners会自动监听，然后更新数据Model。\\nQ：什么是MVVM模式？\\nA：MVVM模式，第一个M代表数据模型，V代表视图，VM代表视图模型；\\n它的实际操作原理是：后台数据通过视图模型来渲染视图，就是页面。当用户在页面上进行操作的时候，\\n视图模型会自动监听到用户的操作\"}],\"其他\":[{\"url\":\"/《Vue》笔记/99.其他/79.Vue中编辑word文档以及预览word .html\",\"relativePath\":\"/《Vue》笔记/99.其他/79.Vue中编辑word文档以及预览word .html\",\"frontmatter\":{\"title\":\"Vue中编辑word文档以及预览word\",\"date\":\"2023-09-13 10:25:00\",\"permalink\":\"/pages/1ebccd/\",\"categories\":[\"《Vue》笔记\",\"其他\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Vue中编辑word文档以及预览word\",\"date\":\"2023-09-13 10:25:00\",\"capture\":\"首先通过XMLHttpRequest发送一个GET请求到指定的URL，获取Word文件的内容并将其转换为HTML格式。其中使用mammoth库的convertToHtml方法将二进制数组转换为HTML格式的文本。（mammoth我用了一个修改版本样式还原度要比官方好@shy1118/mammoth）编辑用到的是ckeditor5富文本编辑器,最后通过html-docx-js将html转换为docx在进行保存**\\n 安装主要依赖\\n```bash\\nnpm install --save @ckeditor/ckeditor5-build-decoupled-document @shy1118/mam\"},{\"url\":\"/《Vue》笔记/99.其他/91.vue2与vue3生命周期对照表.html\",\"relativePath\":\"/《Vue》笔记/99.其他/91.vue2与vue3生命周期对照表.html\",\"frontmatter\":{\"title\":\"vue2与vue3生命周期对照表\",\"date\":\"2023-09-08 14:57:40\",\"permalink\":\"/pages/e866b9/\",\"categories\":[\"《Vue》笔记\",\"其他\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"vue2与vue3生命周期对照表\",\"date\":\"2023-09-08 14:57:40\",\"capture\":\"\"},{\"url\":\"/《Vue》笔记/99.其他/90.操作本地缓存.html\",\"relativePath\":\"/《Vue》笔记/99.其他/90.操作本地缓存.html\",\"frontmatter\":{\"title\":\"操作本地缓存\",\"date\":\"2020-02-04 13:14:19\",\"permalink\":\"/pages/30a94dbe96873b33\",\"categories\":[\"《Vue》笔记\",\"其他\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"操作本地缓存\",\"date\":\"2020-02-04 13:14:19\",\"capture\":\"&lt;https://github.com/ustbhuangyi/storage\\n操作 sessionStorage 和 localStorage 。\"},{\"url\":\"/《Vue》笔记/99.其他/80.Vue中的防抖函数封装和使用.html\",\"relativePath\":\"/《Vue》笔记/99.其他/80.Vue中的防抖函数封装和使用.html\",\"frontmatter\":{\"title\":\"Vue中的防抖函数封装和使用\",\"date\":\"2020-02-04 13:10:19\",\"permalink\":\"/pages/fb08e252dfd8fdfd\",\"categories\":[\"《Vue》笔记\",\"其他\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Vue中的防抖函数封装和使用\",\"date\":\"2020-02-04 13:10:19\",\"capture\":\"Vue中的防抖函数封装和使用\\n如搜索框中，每改变一个数值就请求一次搜索接口，当快速的改变数值时并不需要多次请求接口，这就需要一个防抖函数：\\n```js\\n// 防抖函数\\nexport function debounce(func, delay) { // func 函数 delay间隔时间\\n  let timer\\n  return function (...args) {\\n    if (timer) {\\n      clearTimeout(timer)\\n    }\\n    timer = setTimeout(() =\\n      func.apply(this, args)\\n    }, \"}],\"《Electron》笔记\":[{\"url\":\"/《Electron》笔记/02.electron下使用puppeteer模拟用户操作,数据获取.html\",\"relativePath\":\"/《Electron》笔记/02.electron下使用puppeteer模拟用户操作,数据获取.html\",\"frontmatter\":{\"title\":\"electron下使用puppeteer模拟用户操作,数据获取\",\"date\":\"2023-09-09 15:15:18\",\"permalink\":\"/pages/56ebf1/\",\"categories\":[\"《Electron》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"electron下使用puppeteer模拟用户操作,数据获取\",\"date\":\"2023-09-09 15:15:18\",\"capture\":\"Puppeteer是一个由Google开发的Node.js库，它提供了一组用于控制和自动化Chrome或Chromium浏览器的API。它可以用于执行各种与浏览器相关的任务，如网页截图、生成PDF、模拟用户交互、爬取网页数据等。Puppeteer通过WebSocket连接与浏览器建立通信，并通过DevTools协议发送命令和接收浏览器的响应。\\n什么是 Chrome DevTool Protocol\\n- CDP 基于 WebSocket，利用 WebSocket 实现与浏览器内核的快速数据通道\\n- CDP 分为多个域（DOM，Debugger，Network，Profiler，Console..\"},{\"url\":\"/《Electron》笔记/01.electron记录.html\",\"relativePath\":\"/《Electron》笔记/01.electron记录.html\",\"frontmatter\":{\"title\":\"electron记录\",\"date\":\"2023-09-09 14:23:20\",\"permalink\":\"/pages/8e9a16/\",\"categories\":[\"《Electron》笔记\"],\"tags\":[\"electron\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"electron记录\",\"date\":\"2023-09-09 14:23:20\",\"capture\":\"事件周期\\n electron常用事件统计\\n主进程常用事件可以分为以下几类：\\n1. 应用程序生命周期事件：\\n    - `ready`: 当 Electron 应用程序初始化完成且准备好显示窗口时触发。\\n    - `window-all-closed`: 当所有窗口都关闭后触发，在 macOS 上通常不会退出应用程序。\\n    - `activate`: 在 macOS 上，当用户点击应用程序的 Dock 图标并且没有其他窗口打开时触发，用于重新创建新窗口。\\n2. 窗口相关事件：\\n    - `closed`: 窗口关闭时触发。\\n    - `dom-ready`: 窗口加载完毕并且 DOM \"}],\"《ES6 教程》笔记\":[{\"url\":\"/《ES6 教程》笔记/35.了解ES6中的Map和Set.html\",\"relativePath\":\"/《ES6 教程》笔记/35.了解ES6中的Map和Set.html\",\"frontmatter\":{\"title\":\"了解ES6中的Map和Set\",\"date\":\"2023-09-08 16:10:10\",\"permalink\":\"/pages/bfde72/\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"了解ES6中的Map和Set\",\"date\":\"2023-09-08 16:10:10\",\"capture\":\"Map对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。构造函数Map可以接受一个数组作为参数。\\nMap对象的方法\\nset(key, val): 向Map中添加新元素\\nget(key): 通过键值查找特定的数值并返回\\nhas(key): 判断Map对象中是否有Key所对应的值，有返回true,否则返回false\\ndelete(key): 通过键值从Map中移除对应的数据\\nclear(): 将这个Map中的所有元素删除\\n```jsx\\nconst m1 = new Map([['a', 111], ['b', 222]])\\nconsole.log(m1) // {\\\"a\\\" =\\nm1\"},{\"url\":\"/《ES6 教程》笔记/29.最新提案.html\",\"relativePath\":\"/《ES6 教程》笔记/29.最新提案.html\",\"frontmatter\":{\"title\":\"最新提案\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/7188882b8d65af1b\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"最新提案\",\"date\":\"2020-02-09 16:00:30\",\"excerpt\":\"<h1 id=\\\"最新提案\\\" tabindex=\\\"-1\\\">最新提案 <a class=\\\"header-anchor\\\" href=\\\"#最新提案\\\" aria-label=\\\"Permalink to &quot;最新提案&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>本章介绍一些尚未进入标准、但很有希望的最新提案。</p>\\n<h2 id=\\\"do-表达式\\\" tabindex=\\\"-1\\\">do 表达式 <a class=\\\"header-anchor\\\" href=\\\"#do-表达式\\\" aria-label=\\\"Permalink to &quot;do 表达式&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">{</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">  let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> t </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> f</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">();</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">  t </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> t </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">*</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> t </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">+</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br></div></div>\",\"capture\":\"本章介绍一些尚未进入标准、但很有希望的最新提案。\\n do 表达式\\n本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。\\n```javascript\\n{\\n  let t = f();\\n  t = t * t + 1;\\n}\\n```\\n上面代码中，块级作用域将两个语句封装在一起。但是，在块级作用域以外，没有办法得到`t`的值，因为块级作用域不返回值，除非`t`是全局变量。\\n现在有一个提案，使得块级作用域可以变为表达式，也就是说可以返回值，办法就是在块级作用域之前加上`do`，使它变为`do`表达式，然后就会返回内部最后执行的表达式的值。\\n```javascript\\nlet x = do {\"},{\"url\":\"/《ES6 教程》笔记/30.装饰器.html\",\"relativePath\":\"/《ES6 教程》笔记/30.装饰器.html\",\"frontmatter\":{\"title\":\"装饰器\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/e97bc1e5626b082c\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"装饰器\",\"date\":\"2020-02-09 16:00:30\",\"excerpt\":\"<h1 id=\\\"装饰器\\\" tabindex=\\\"-1\\\">装饰器 <a class=\\\"header-anchor\\\" href=\\\"#装饰器\\\" aria-label=\\\"Permalink to &quot;装饰器&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>[说明] Decorator 提案经过了大幅修改，目前还没有定案，不知道语法会不会再变。下面的内容完全依据以前的提案，已经有点过时了。等待定案以后，需要完全重写。</p>\\n<p>装饰器（Decorator）是一种与类（class）相关的语法，用来注释或修改类和类方法。许多面向对象的语言都有这项功能，目前有一个<a href=\\\"https://github.com/tc39/proposal-decorators\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">提案</a>将其引入了 ECMAScript。</p>\\n\",\"capture\":\"[说明] Decorator 提案经过了大幅修改，目前还没有定案，不知道语法会不会再变。下面的内容完全依据以前的提案，已经有点过时了。等待定案以后，需要完全重写。\\n装饰器（Decorator）是一种与类（class）相关的语法，用来注释或修改类和类方法。许多面向对象的语言都有这项功能，目前有一个提案将其引入了 ECMAScript。\\n装饰器是一种函数，写成`@ + 函数名`。它可以放在类和类方法的定义前面。\\n```javascript\\n@frozen class Foo {\\n  @configurable(false)\\n  @enumerable(true)\\n  method() {}\\n  @\"},{\"url\":\"/《ES6 教程》笔记/31.函数式编程.html\",\"relativePath\":\"/《ES6 教程》笔记/31.函数式编程.html\",\"frontmatter\":{\"title\":\"函数式编程\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/1cf50330655efc69\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"函数式编程\",\"date\":\"2020-02-09 16:00:30\",\"excerpt\":\"<h1 id=\\\"函数式编程\\\" tabindex=\\\"-1\\\">函数式编程 <a class=\\\"header-anchor\\\" href=\\\"#函数式编程\\\" aria-label=\\\"Permalink to &quot;函数式编程&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>JavaScript 语言从一诞生，就具有函数式编程的烙印。它将函数作为一种独立的数据类型，与其他数据类型处于完全平等的地位。在 JavaScript 语言中，你可以采用面向对象编程，也可以采用函数式编程。有人甚至说，JavaScript 是有史以来第一种被大规模采用的函数式编程语言。</p>\\n\",\"capture\":\"JavaScript 语言从一诞生，就具有函数式编程的烙印。它将函数作为一种独立的数据类型，与其他数据类型处于完全平等的地位。在 JavaScript 语言中，你可以采用面向对象编程，也可以采用函数式编程。有人甚至说，JavaScript 是有史以来第一种被大规模采用的函数式编程语言。\\nES6 的种种新增功能，使得函数式编程变得更方便、更强大。本章介绍 ES6 如何进行函数式编程。\\n 柯里化\\n柯里化（currying）指的是将一个多参数的函数拆分成一系列函数，每个拆分后的函数都只接受一个参数（unary）。\\n```javascript\\nfunction add (a, b) {\\n  retur\"},{\"url\":\"/《ES6 教程》笔记/32.Mixin.html\",\"relativePath\":\"/《ES6 教程》笔记/32.Mixin.html\",\"frontmatter\":{\"title\":\"Mixin\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/6a8e2dc558da1b39\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Mixin\",\"date\":\"2020-02-09 16:00:30\",\"excerpt\":\"<h1 id=\\\"mixin\\\" tabindex=\\\"-1\\\">Mixin <a class=\\\"header-anchor\\\" href=\\\"#mixin\\\" aria-label=\\\"Permalink to &quot;Mixin&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>JavaScript 语言的设计是单一继承，即子类只能继承一个父类，不允许继承多个父类。这种设计保证了对象继承的层次结构是树状的，而不是复杂的<a href=\\\"https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">网状结构</a>。</p>\\n\",\"capture\":\"JavaScript 语言的设计是单一继承，即子类只能继承一个父类，不允许继承多个父类。这种设计保证了对象继承的层次结构是树状的，而不是复杂的网状结构。\\n但是，这大大降低了编程的灵活性。因为实际开发中，有时不可避免，子类需要继承多个父类。举例来说，“猫”可以继承“哺乳类动物”，也可以继承“宠物”。\\n各种单一继承的编程语言，有不同的多重继承解决方案。比如，Java 语言也是子类只能继承一个父类，但是还允许继承多个界面（interface），这样就间接实现了多重继承。Interface 与父类一样，也是一个类，只不过它只定义接口（method signature），不定义实现，因此又被称为“抽象类\"},{\"url\":\"/《ES6 教程》笔记/33.SIMD.html\",\"relativePath\":\"/《ES6 教程》笔记/33.SIMD.html\",\"frontmatter\":{\"title\":\"SIMD\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/8e8f80f69b775a56\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"SIMD\",\"date\":\"2020-02-09 16:00:30\",\"excerpt\":\"<h1 id=\\\"simd\\\" tabindex=\\\"-1\\\">SIMD <a class=\\\"header-anchor\\\" href=\\\"#simd\\\" aria-label=\\\"Permalink to &quot;SIMD&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>SIMD（发音<code>/sim-dee/</code>）是“Single Instruction/Multiple Data”的缩写，意为“单指令，多数据”。它是 JavaScript 操作 CPU 对应指令的接口，你可以看做这是一种不同的运算执行模式。与它相对的是 SISD（“Single Instruction/Single Data”），即“单指令，单数据”。</p>\\n\",\"capture\":\"概述\\nSIMD（发音`/sim-dee/`）是“Single Instruction/Multiple Data”的缩写，意为“单指令，多数据”。它是 JavaScript 操作 CPU 对应指令的接口，你可以看做这是一种不同的运算执行模式。与它相对的是 SISD（“Single Instruction/Single Data”），即“单指令，单数据”。\\nSIMD 的含义是使用一个指令，完成多个数据的运算；SISD 的含义是使用一个指令，完成单个数据的运算，这是 JavaScript 的默认运算模式。显而易见，SIMD 的执行效率要高于 SISD，所以被广泛用于 3D 图形运算、物理模拟等运算\"},{\"url\":\"/《ES6 教程》笔记/34.参考链接.html\",\"relativePath\":\"/《ES6 教程》笔记/34.参考链接.html\",\"frontmatter\":{\"title\":\"参考链接\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/ea6f3b870f6dab69\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"参考链接\",\"date\":\"2020-02-09 16:00:30\",\"capture\":\"官方文件\\n- ECMAScript® 2015 Language Specification: ECMAScript 2015 规格\\n- ECMAScript® 2016 Language Specification: ECMAScript 2016 规格\\n- ECMAScript® 2017 Language Specification：ECMAScript 2017 规格（草案）\\n- ECMAScript Current Proposals: ECMAScript 当前的所有提案\\n- ECMAScript Active Proposals: 已经进入正式流程的提案\\n- ECMAScript\"},{\"url\":\"/《ES6 教程》笔记/02.let 和 const 命令.html\",\"relativePath\":\"/《ES6 教程》笔记/02.let 和 const 命令.html\",\"frontmatter\":{\"title\":\"let 和 const 命令\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/c1edd70a6b7c7872\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"let 和 const 命令\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"let-和-const-命令\\\" tabindex=\\\"-1\\\">let 和 const 命令 <a class=\\\"header-anchor\\\" href=\\\"#let-和-const-命令\\\" aria-label=\\\"Permalink to &quot;let 和 const 命令&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"let-命令\\\" tabindex=\\\"-1\\\">let 命令 <a class=\\\"header-anchor\\\" href=\\\"#let-命令\\\" aria-label=\\\"Permalink to &quot;let 命令&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"基本用法\\\" tabindex=\\\"-1\\\">基本用法 <a class=\\\"header-anchor\\\" href=\\\"#基本用法\\\" aria-label=\\\"Permalink to &quot;基本用法&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>ES6 新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code>，但是所声明的变量，<strong>只在<code>let</code>命令所在的代码块内有效(块级作用域)</strong>。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">{</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">  let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> a </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 10</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">  var</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> b </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">a </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// ReferenceError: a is not defined.</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">b </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// 1</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br></div></div>\",\"capture\":\"let 命令\\n 基本用法\\nES6 新增了`let`命令，用来声明变量。它的用法类似于`var`，但是所声明的变量，只在`let`命令所在的代码块内有效(块级作用域)。\\n```javascript\\n{\\n  let a = 10;\\n  var b = 1;\\n}\\na // ReferenceError: a is not defined.\\nb // 1\\n```\\n上面代码在代码块之中，分别用`let`和`var`声明了两个变量。然后在代码块之外调用这两个变量，结果`let`声明的变量报错，`var`声明的变量返回了正确的值。这表明，`let`声明的变量只在它所在的代码块有效。\\n`for`循环的计数器，\"},{\"url\":\"/《ES6 教程》笔记/03.变量的解构赋值.html\",\"relativePath\":\"/《ES6 教程》笔记/03.变量的解构赋值.html\",\"frontmatter\":{\"title\":\"变量的解构赋值\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/b1ab10a62f7564da\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"变量的解构赋值\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"变量的解构赋值\\\" tabindex=\\\"-1\\\">变量的解构赋值 <a class=\\\"header-anchor\\\" href=\\\"#变量的解构赋值\\\" aria-label=\\\"Permalink to &quot;变量的解构赋值&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"数组的解构赋值\\\" tabindex=\\\"-1\\\">数组的解构赋值 <a class=\\\"header-anchor\\\" href=\\\"#数组的解构赋值\\\" aria-label=\\\"Permalink to &quot;数组的解构赋值&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"基本用法\\\" tabindex=\\\"-1\\\">基本用法 <a class=\\\"header-anchor\\\" href=\\\"#基本用法\\\" aria-label=\\\"Permalink to &quot;基本用法&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>ES6 允许按照一定模式，<strong>从数组和对象中提取值，对变量进行赋值，这被称为解构</strong>（Destructuring）。</p>\\n<p>以前，为变量赋值，只能直接指定值。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> a </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> b </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> c </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 3</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br></div></div>\",\"capture\":\"数组的解构赋值\\n 基本用法\\nES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。\\n以前，为变量赋值，只能直接指定值。\\n```javascript\\nlet a = 1;\\nlet b = 2;\\nlet c = 3;\\n```\\nES6 允许写成下面这样。\\n```javascript\\nlet [a, b, c] = [1, 2, 3];\\n```\\n上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。\\n本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。\\n```javas\"},{\"url\":\"/《ES6 教程》笔记/04.字符串的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/04.字符串的扩展.html\",\"frontmatter\":{\"title\":\"字符串的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/ca89eca8adeba5f4\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"字符串的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"字符串的扩展\\\" tabindex=\\\"-1\\\">字符串的扩展 <a class=\\\"header-anchor\\\" href=\\\"#字符串的扩展\\\" aria-label=\\\"Permalink to &quot;字符串的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>本章介绍 ES6 对字符串的改造和增强，下一章介绍字符串对象的新增方法。</p>\\n<h2 id=\\\"字符的-unicode-表示法\\\" tabindex=\\\"-1\\\">字符的 Unicode 表示法 <a class=\\\"header-anchor\\\" href=\\\"#字符的-unicode-表示法\\\" aria-label=\\\"Permalink to &quot;字符的 Unicode 表示法&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES6 加强了对 Unicode 的支持，允许采用<code>\\\\uxxxx</code>形式表示一个字符，其中<code>xxxx</code>表示字符的 Unicode 码点。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">\\\\u0061</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// \\\"a\\\"</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br></div></div>\",\"capture\":\"本章介绍 ES6 对字符串的改造和增强，下一章介绍字符串对象的新增方法。\\n 字符的 Unicode 表示法\\nES6 加强了对 Unicode 的支持，允许采用`\\\\uxxxx`形式表示一个字符，其中`xxxx`表示字符的 Unicode 码点。\\n```javascript\\n\\\"\\\\u0061\\\"\\n// \\\"a\\\"\\n```\\n但是，这种表示法只限于码点在`\\\\u0000`~`\\\\uFFFF`之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。\\n```javascript\\n\\\"\\\\uD842\\\\uDFB7\\\"\\n// \\\"𠮷\\\"\\n\\\"\\\\u20BB7\\\"\\n// \\\" 7\\\"\\n```\\n上面代码表示，如果直接在`\\\\u`后面跟上超过`\"},{\"url\":\"/《ES6 教程》笔记/05.字符串的新增方法.html\",\"relativePath\":\"/《ES6 教程》笔记/05.字符串的新增方法.html\",\"frontmatter\":{\"title\":\"字符串的新增方法\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/a650b4a0ebfc9350\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"字符串的新增方法\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"字符串的新增方法\\\" tabindex=\\\"-1\\\">字符串的新增方法 <a class=\\\"header-anchor\\\" href=\\\"#字符串的新增方法\\\" aria-label=\\\"Permalink to &quot;字符串的新增方法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>本章介绍字符串对象的新增方法。</p>\\n<h2 id=\\\"string-fromcodepoint\\\" tabindex=\\\"-1\\\">String.fromCodePoint() <a class=\\\"header-anchor\\\" href=\\\"#string-fromcodepoint\\\" aria-label=\\\"Permalink to &quot;String.fromCodePoint()&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES5 提供<code>String.fromCharCode()</code>方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于<code>0xFFFF</code>的字符。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">String.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">fromCharCode</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">0x20BB7</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">)</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// \\\"ஷ\\\"</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br></div></div>\",\"capture\":\"本章介绍字符串对象的新增方法。\\n String.fromCodePoint()\\nES5 提供`String.fromCharCode()`方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于`0xFFFF`的字符。\\n```javascript\\nString.fromCharCode(0x20BB7)\\n// \\\"ஷ\\\"\\n```\\n上面代码中，`String.fromCharCode()`不能识别大于`0xFFFF`的码点，所以`0x20BB7`就发生了溢出，最高位`2`被舍弃了，最后返回码点`U+0BB7`对应的字符，而不是码点`U+20BB7`对应的字符。\\nES6 提供了`S\"},{\"url\":\"/《ES6 教程》笔记/06.正则的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/06.正则的扩展.html\",\"frontmatter\":{\"title\":\"正则的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/0473261a6ab0ee8c\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"正则的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"正则的扩展\\\" tabindex=\\\"-1\\\">正则的扩展 <a class=\\\"header-anchor\\\" href=\\\"#正则的扩展\\\" aria-label=\\\"Permalink to &quot;正则的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"regexp-构造函数\\\" tabindex=\\\"-1\\\">RegExp 构造函数 <a class=\\\"header-anchor\\\" href=\\\"#regexp-构造函数\\\" aria-label=\\\"Permalink to &quot;RegExp 构造函数&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>在 ES5 中，<code>RegExp</code>构造函数的参数有两种情况。</p>\\n<p>第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">var</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> regex </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> new</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> RegExp</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'xyz'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'i'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">);</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// 等价于</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">var</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> regex </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> /</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#DBEDFF\\\">xyz</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">/</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">i</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br></div></div>\",\"capture\":\"RegExp 构造函数\\n在 ES5 中，`RegExp`构造函数的参数有两种情况。\\n第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。\\n```javascript\\nvar regex = new RegExp('xyz', 'i');\\n// 等价于\\nvar regex = /xyz/i;\\n```\\n第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。\\n```javascript\\nvar regex = new RegExp(/xyz/i);\\n// 等价于\\nvar regex = /xyz/i;\\n```\\n但是，ES5 不允许此时使用第二个参数添加修饰\"},{\"url\":\"/《ES6 教程》笔记/07.数值的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/07.数值的扩展.html\",\"frontmatter\":{\"title\":\"数值的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/5dfea9a0f2d1a392\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"数值的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"数值的扩展\\\" tabindex=\\\"-1\\\">数值的扩展 <a class=\\\"header-anchor\\\" href=\\\"#数值的扩展\\\" aria-label=\\\"Permalink to &quot;数值的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"二进制和八进制表示法\\\" tabindex=\\\"-1\\\">二进制和八进制表示法 <a class=\\\"header-anchor\\\" href=\\\"#二进制和八进制表示法\\\" aria-label=\\\"Permalink to &quot;二进制和八进制表示法&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES6 提供了二进制和八进制数值的新的写法，分别用前缀<code>0b</code>（或<code>0B</code>）和<code>0o</code>（或<code>0O</code>）表示。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">0b111110111</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> ===</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 503</span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\"> // true</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">0o767</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> ===</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 503</span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\"> // true</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br></div></div>\",\"capture\":\"二进制和八进制表示法\\nES6 提供了二进制和八进制数值的新的写法，分别用前缀`0b`（或`0B`）和`0o`（或`0O`）表示。\\n```javascript\\n0b111110111 === 503 // true\\n0o767 === 503 // true\\n```\\n从 ES5 开始，在严格模式之中，八进制就不再允许使用前缀`0`表示，ES6 进一步明确，要使用前缀`0o`表示。\\n```javascript\\n// 非严格模式\\n(function(){\\n  console.log(0o11 === 011);\\n})() // true\\n// 严格模式\\n(function(){\\n  'use str\"},{\"url\":\"/《ES6 教程》笔记/08.函数的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/08.函数的扩展.html\",\"frontmatter\":{\"title\":\"函数的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/8ed309d668b20264\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"函数的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"函数的扩展\\\" tabindex=\\\"-1\\\">函数的扩展 <a class=\\\"header-anchor\\\" href=\\\"#函数的扩展\\\" aria-label=\\\"Permalink to &quot;函数的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"函数参数的默认值\\\" tabindex=\\\"-1\\\">函数参数的默认值 <a class=\\\"header-anchor\\\" href=\\\"#函数参数的默认值\\\" aria-label=\\\"Permalink to &quot;函数参数的默认值&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"基本用法\\\" tabindex=\\\"-1\\\">基本用法 <a class=\\\"header-anchor\\\" href=\\\"#基本用法\\\" aria-label=\\\"Permalink to &quot;基本用法&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">function</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#E36209;--shiki-dark:#FFAB70\\\">x</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#E36209;--shiki-dark:#FFAB70\\\">y</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">) {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">  y </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> y </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">||</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> 'World'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">  console.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(x, y);</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'Hello'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">) </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// Hello World</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'Hello'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'China'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">) </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// Hello China</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'Hello'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">''</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">) </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// Hello World</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br><span class=\\\"line-number\\\">8</span><br></div></div>\",\"capture\":\"函数参数的默认值\\n 基本用法\\nES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。\\n```javascript\\nfunction log(x, y) {\\n  y = y || 'World';\\n  console.log(x, y);\\n}\\nlog('Hello') // Hello World\\nlog('Hello', 'China') // Hello China\\nlog('Hello', '') // Hello World\\n```\\n上面代码检查函数`log`的参数`y`有没有赋值，如果没有，则指定默认值为`World`。这种写法的缺点在于，如果参数`y`赋值了，但是对应的布\"},{\"url\":\"/《ES6 教程》笔记/09.数组的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/09.数组的扩展.html\",\"frontmatter\":{\"title\":\"数组的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/e34009d60d8bc4b2\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"数组的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"数组的扩展\\\" tabindex=\\\"-1\\\">数组的扩展 <a class=\\\"header-anchor\\\" href=\\\"#数组的扩展\\\" aria-label=\\\"Permalink to &quot;数组的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"扩展运算符\\\" tabindex=\\\"-1\\\">扩展运算符 <a class=\\\"header-anchor\\\" href=\\\"#扩展运算符\\\" aria-label=\\\"Permalink to &quot;扩展运算符&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"含义\\\" tabindex=\\\"-1\\\">含义 <a class=\\\"header-anchor\\\" href=\\\"#含义\\\" aria-label=\\\"Permalink to &quot;含义&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>扩展运算符（spread）是三个点（<code>...</code>）。它好比 rest 参数的逆运算，<strong>将一个数组转为用逗号分隔的参数序列</strong>。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">console.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">...</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">[</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">3</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">])</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// 1 2 3</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">console.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">...</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">[</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">3</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">4</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">], </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">5</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">)</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// 1 2 3 4 5</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">[</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">...</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">document.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">querySelectorAll</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'div'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">)]</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// [&#x3C;div>, &#x3C;div>, &#x3C;div>]</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br><span class=\\\"line-number\\\">8</span><br></div></div>\",\"capture\":\"扩展运算符\\n 含义\\n扩展运算符（spread）是三个点（`...`）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。\\n```javascript\\nconsole.log(...[1, 2, 3])\\n// 1 2 3\\nconsole.log(1, ...[2, 3, 4], 5)\\n// 1 2 3 4 5\\n[...document.querySelectorAll('div')]\\n// [&lt;div\\n```\\n该运算符主要用于函数调用。\\n```javascript\\nfunction push(array, ...items) {\\n  array.push(...items\"},{\"url\":\"/《ES6 教程》笔记/10.对象的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/10.对象的扩展.html\",\"frontmatter\":{\"title\":\"对象的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/b5e3e0a0ff6e9c25\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"对象的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"对象的扩展\\\" tabindex=\\\"-1\\\">对象的扩展 <a class=\\\"header-anchor\\\" href=\\\"#对象的扩展\\\" aria-label=\\\"Permalink to &quot;对象的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>对象（object）是 JavaScript 最重要的数据结构。ES6 对它进行了重大升级，本章介绍数据结构本身的改变，下一章介绍<code>Object</code>对象的新增方法。</p>\\n\",\"capture\":\"对象（object）是 JavaScript 最重要的数据结构。ES6 对它进行了重大升级，本章介绍数据结构本身的改变，下一章介绍`Object`对象的新增方法。\\n 属性的简洁表示法\\nES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。\\n```javascript\\nconst foo = 'bar';\\nconst baz = {foo};\\nbaz // {foo: \\\"bar\\\"}\\n// 等同于\\nconst baz = {foo: foo};\\n```\\n上面代码中，变量`foo`直接写在大括号里面。这时，属性名就是变量名, 属性值就是变量值。下面是另一个例子。\\n`\"},{\"url\":\"/《ES6 教程》笔记/11.对象的新增方法.html\",\"relativePath\":\"/《ES6 教程》笔记/11.对象的新增方法.html\",\"frontmatter\":{\"title\":\"对象的新增方法\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/e85e68947502cf90\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"对象的新增方法\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"对象的新增方法\\\" tabindex=\\\"-1\\\">对象的新增方法 <a class=\\\"header-anchor\\\" href=\\\"#对象的新增方法\\\" aria-label=\\\"Permalink to &quot;对象的新增方法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>本章介绍 Object 对象的新增方法。</p>\\n<h2 id=\\\"object-is\\\" tabindex=\\\"-1\\\">Object.is() <a class=\\\"header-anchor\\\" href=\\\"#object-is\\\" aria-label=\\\"Permalink to &quot;Object.is()&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES5 比较两个值是否相等，只有两个运算符：相等运算符（<code>==</code>）和严格相等运算符（<code>===</code>）。它们都有缺点，前者会自动转换数据类型，后者的<code>NaN</code>不等于自身，以及<code>+0</code>等于<code>-0</code>。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</p>\\n<p>ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。<code>Object.is</code>就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</p>\\n\",\"capture\":\"本章介绍 Object 对象的新增方法。\\n Object.is()\\nES5 比较两个值是否相等，只有两个运算符：相等运算符（`==`）和严格相等运算符（`===`）。它们都有缺点，前者会自动转换数据类型，后者的`NaN`不等于自身，以及`+0`等于`-0`。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。\\nES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。`Object.is`就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。\\n```javascript\\nObject.\"},{\"url\":\"/《ES6 教程》笔记/12.Symbol.html\",\"relativePath\":\"/《ES6 教程》笔记/12.Symbol.html\",\"frontmatter\":{\"title\":\"Symbol\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/02c86eb2792f3262\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Symbol\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"symbol\\\" tabindex=\\\"-1\\\">Symbol <a class=\\\"header-anchor\\\" href=\\\"#symbol\\\" aria-label=\\\"Permalink to &quot;Symbol&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，<strong>保证每个属性的名字都是独一无二</strong>的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入<code>Symbol</code>的原因。</p>\\n\",\"capture\":\"概述\\nES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入`Symbol`的原因。\\nES6 引入了一种新的原始数据类型`Symbol`，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：`undefined`、`null`、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。\\nSymbol 值\"},{\"url\":\"/《ES6 教程》笔记/13.Set 和 Map 数据结构.html\",\"relativePath\":\"/《ES6 教程》笔记/13.Set 和 Map 数据结构.html\",\"frontmatter\":{\"title\":\"Set 和 Map 数据结构\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/0c21dae358fca16b\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Set 和 Map 数据结构\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"set-和-map-数据结构\\\" tabindex=\\\"-1\\\">Set 和 Map 数据结构 <a class=\\\"header-anchor\\\" href=\\\"#set-和-map-数据结构\\\" aria-label=\\\"Permalink to &quot;Set 和 Map 数据结构&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"set\\\" tabindex=\\\"-1\\\">Set <a class=\\\"header-anchor\\\" href=\\\"#set\\\" aria-label=\\\"Permalink to &quot;Set&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"基本用法\\\" tabindex=\\\"-1\\\">基本用法 <a class=\\\"header-anchor\\\" href=\\\"#基本用法\\\" aria-label=\\\"Permalink to &quot;基本用法&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>ES6 提供了新的数据结构 Set。它<strong>类似于数组，但是成员的值都是唯一的，没有重复的值</strong>。</p>\\n<p><strong><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构</strong>。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">const</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> s</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> =</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> new</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> Set</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">();</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">[</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">3</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">5</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">4</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">5</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">].</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">forEach</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#E36209;--shiki-dark:#FFAB70\\\">x</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> =></span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> s.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">add</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(x));</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">for</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> (</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> i </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">of</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> s) {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">  console.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(i);</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// 2 3 5 4</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br><span class=\\\"line-number\\\">8</span><br></div></div>\",\"capture\":\"Set\\n 基本用法\\nES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。\\n`Set`本身是一个构造函数，用来生成 Set 数据结构。\\n```javascript\\nconst s = new Set();\\n[2, 3, 5, 4, 5, 2, 2].forEach(x =\\nfor (let i of s) {\\n  console.log(i);\\n}\\n// 2 3 5 4\\n```\\n上面代码通过`add()`方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。\\n`Set`函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参\"},{\"url\":\"/《ES6 教程》笔记/14.Proxy.html\",\"relativePath\":\"/《ES6 教程》笔记/14.Proxy.html\",\"frontmatter\":{\"title\":\"Proxy\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/f56ec2ab97d60483\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Proxy\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"proxy\\\" tabindex=\\\"-1\\\">Proxy <a class=\\\"header-anchor\\\" href=\\\"#proxy\\\" aria-label=\\\"Permalink to &quot;Proxy&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“<strong>元编程</strong>”（meta programming），即<strong>对编程语言进行编程</strong>。</p>\\n<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，<strong>外界对该对象的访问，都必须先通过这层拦截</strong>，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>\\n\",\"capture\":\"概述\\nProxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。\\nProxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。\\n```javascript\\nvar obj = new Proxy({}, {\\n  get: function (target, propKey, receiver) {\\n    console.log(\"},{\"url\":\"/《ES6 教程》笔记/15.Reflect.html\",\"relativePath\":\"/《ES6 教程》笔记/15.Reflect.html\",\"frontmatter\":{\"title\":\"Reflect\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/74de3e45e4491e95\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Reflect\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"reflect\\\" tabindex=\\\"-1\\\">Reflect <a class=\\\"header-anchor\\\" href=\\\"#reflect\\\" aria-label=\\\"Permalink to &quot;Reflect&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p><code>Reflect</code>对象与<code>Proxy</code>对象一样，也是 ES6 为了操作对象而提供的新 API。<code>Reflect</code>对象的设计目的有这样几个。</p>\\n<p>（1） **将<code>Object</code>对象的一些明显属于语言内部的方法（比如<code>Object.defineProperty</code>），放到<code>Reflect</code>对象上。**现阶段，某些方法同时在<code>Object</code>和<code>Reflect</code>对象上部署，未来的新方法将只部署在<code>Reflect</code>对象上。也就是说，从<code>Reflect</code>对象上可以拿到语言内部的方法。</p>\\n\",\"capture\":\"概述\\n`Reflect`对象与`Proxy`对象一样，也是 ES6 为了操作对象而提供的新 API。`Reflect`对象的设计目的有这样几个。\\n（1） 将`Object`对象的一些明显属于语言内部的方法（比如`Object.defineProperty`），放到`Reflect`对象上。现阶段，某些方法同时在`Object`和`Reflect`对象上部署，未来的新方法将只部署在`Reflect`对象上。也就是说，从`Reflect`对象上可以拿到语言内部的方法。\\n（2） 修改某些`Object`方法的返回结果，让其变得更合理。比如，`Object.defineProperty(obj, na\"},{\"url\":\"/《ES6 教程》笔记/16.Promise 对象.html\",\"relativePath\":\"/《ES6 教程》笔记/16.Promise 对象.html\",\"frontmatter\":{\"title\":\"Promise 对象\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/2810ae8985e9bd52\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Promise 对象\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"promise-对象\\\" tabindex=\\\"-1\\\">Promise 对象 <a class=\\\"header-anchor\\\" href=\\\"#promise-对象\\\" aria-label=\\\"Permalink to &quot;Promise 对象&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"promise-的含义\\\" tabindex=\\\"-1\\\">Promise 的含义 <a class=\\\"header-anchor\\\" href=\\\"#promise-的含义\\\" aria-label=\\\"Permalink to &quot;Promise 的含义&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了<code>Promise</code>对象。</p>\\n\",\"capture\":\"Promise 的含义\\nPromise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了`Promise`对象。\\n所谓`Promise`，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。\\n`Promise`对象有以下两个特点。\\n（1）对象的状态不受外界影响。`Promise`对象代表一个异步操作，有三种状态：`pe\"},{\"url\":\"/《ES6 教程》笔记/17.Iterator 和 for-of 循环.html\",\"relativePath\":\"/《ES6 教程》笔记/17.Iterator 和 for-of 循环.html\",\"frontmatter\":{\"title\":\"Iterator 和 for-of 循环\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/48df907ad3570f3d\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Iterator 和 for-of 循环\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"iterator-和-for-of-循环\\\" tabindex=\\\"-1\\\">Iterator 和 for...of 循环 <a class=\\\"header-anchor\\\" href=\\\"#iterator-和-for-of-循环\\\" aria-label=\\\"Permalink to &quot;Iterator 和 for...of 循环&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"iterator-遍历器-的概念\\\" tabindex=\\\"-1\\\">Iterator（遍历器）的概念 <a class=\\\"header-anchor\\\" href=\\\"#iterator-遍历器-的概念\\\" aria-label=\\\"Permalink to &quot;Iterator（遍历器）的概念&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>JavaScript 原有的表示“集合”的数据结构，主要是数组（<code>Array</code>）和对象（<code>Object</code>），ES6 又添加了<code>Map</code>和<code>Set</code>。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是<code>Map</code>，<code>Map</code>的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。</p>\\n\",\"capture\":\"Iterator（遍历器）的概念\\nJavaScript 原有的表示“集合”的数据结构，主要是数组（`Array`）和对象（`Object`），ES6 又添加了`Map`和`Set`。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是`Map`，`Map`的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。\\n遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。\\nIterator 的作用有三个：一是为各\"},{\"url\":\"/《ES6 教程》笔记/18.Generator 函数的语法.html\",\"relativePath\":\"/《ES6 教程》笔记/18.Generator 函数的语法.html\",\"frontmatter\":{\"title\":\"Generator 函数的语法\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/718b48ed9ce0adce\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Generator 函数的语法\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"generator-函数的语法\\\" tabindex=\\\"-1\\\">Generator 函数的语法 <a class=\\\"header-anchor\\\" href=\\\"#generator-函数的语法\\\" aria-label=\\\"Permalink to &quot;Generator 函数的语法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"基本概念\\\" tabindex=\\\"-1\\\">基本概念 <a class=\\\"header-anchor\\\" href=\\\"#基本概念\\\" aria-label=\\\"Permalink to &quot;基本概念&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>Generator 函数是 ES6 提供的一种<strong>异步编程解决方案</strong>，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《Generator 函数的异步应用》一章。</p>\\n\",\"capture\":\"简介\\n 基本概念\\nGenerator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《Generator 函数的异步应用》一章。\\nGenerator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。\\n执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。\\n形式上，Generator 函数是一个\"},{\"url\":\"/《ES6 教程》笔记/19.Generator 函数的异步应用.html\",\"relativePath\":\"/《ES6 教程》笔记/19.Generator 函数的异步应用.html\",\"frontmatter\":{\"title\":\"Generator 函数的异步应用\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/75af7031eb66847b\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Generator 函数的异步应用\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"generator-函数的异步应用\\\" tabindex=\\\"-1\\\">Generator 函数的异步应用 <a class=\\\"header-anchor\\\" href=\\\"#generator-函数的异步应用\\\" aria-label=\\\"Permalink to &quot;Generator 函数的异步应用&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>异步编程对 JavaScript 语言太重要。JavaScript 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。本章主要介绍 Generator 函数如何完成异步操作。</p>\\n\",\"capture\":\"异步编程对 JavaScript 语言太重要。JavaScript 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。本章主要介绍 Generator 函数如何完成异步操作。\\n 传统方法\\nES6 诞生以前，异步编程的方法，大概有下面四种。\\n- 回调函数\\n- 事件监听\\n- 发布/订阅\\n- Promise 对象\\nGenerator 函数将 JavaScript 异步编程带入了一个全新的阶段。\\n 基本概念\\n 异步\\n所谓\\\"异步\\\"，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。\\n比如，有一个任\"},{\"url\":\"/《ES6 教程》笔记/20.async 函数.html\",\"relativePath\":\"/《ES6 教程》笔记/20.async 函数.html\",\"frontmatter\":{\"title\":\"async 函数\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/3777253e65bac487\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"async 函数\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"async-函数\\\" tabindex=\\\"-1\\\">async 函数 <a class=\\\"header-anchor\\\" href=\\\"#async-函数\\\" aria-label=\\\"Permalink to &quot;async 函数&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"含义\\\" tabindex=\\\"-1\\\">含义 <a class=\\\"header-anchor\\\" href=\\\"#含义\\\" aria-label=\\\"Permalink to &quot;含义&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p>\\n<p>async 函数是什么？一句话，它就<strong>是 Generator 函数的语法糖</strong>。</p>\\n<p>前文有一个 Generator 函数，依次读取两个文件。</p>\\n\",\"capture\":\"含义\\nES2017 标准引入了 async 函数，使得异步操作变得更加方便。\\nasync 函数是什么？一句话，它就是 Generator 函数的语法糖。\\n前文有一个 Generator 函数，依次读取两个文件。\\n```javascript\\nconst fs = require('fs');\\nconst readFile = function (fileName) {\\n  return new Promise(function (resolve, reject) {\\n    fs.readFile(fileName, function(error, data) {\\n      if (error\"},{\"url\":\"/《ES6 教程》笔记/21.Class 的基本语法.html\",\"relativePath\":\"/《ES6 教程》笔记/21.Class 的基本语法.html\",\"frontmatter\":{\"title\":\"Class 的基本语法\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/e831e1593c82bbe0\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Class 的基本语法\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"class-的基本语法\\\" tabindex=\\\"-1\\\">Class 的基本语法 <a class=\\\"header-anchor\\\" href=\\\"#class-的基本语法\\\" aria-label=\\\"Permalink to &quot;Class 的基本语法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"类的由来\\\" tabindex=\\\"-1\\\">类的由来 <a class=\\\"header-anchor\\\" href=\\\"#类的由来\\\" aria-label=\\\"Permalink to &quot;类的由来&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">function</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> Point</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#E36209;--shiki-dark:#FFAB70\\\">x</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#E36209;--shiki-dark:#FFAB70\\\">y</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">) {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">  this</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.x </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> x;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">  this</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.y </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> y;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">Point</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">prototype</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">toString</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> =</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> function</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> () {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">  return</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> '('</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> +</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> this</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.x </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">+</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> ', '</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> +</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> this</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.y </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">+</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> ')'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">};</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">var</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> p </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> new</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> Point</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">);</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br><span class=\\\"line-number\\\">8</span><br><span class=\\\"line-number\\\">9</span><br><span class=\\\"line-number\\\">10</span><br></div></div>\",\"capture\":\"简介\\n 类的由来\\nJavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。\\n```javascript\\nfunction Point(x, y) {\\n  this.x = x;\\n  this.y = y;\\n}\\nPoint.prototype.toString = function () {\\n  return '(' + this.x + ', ' + this.y + ')';\\n};\\nvar p = new Point(1, 2);\\n```\\n上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。\\nES6 提供\"},{\"url\":\"/《ES6 教程》笔记/22.Class 的继承.html\",\"relativePath\":\"/《ES6 教程》笔记/22.Class 的继承.html\",\"frontmatter\":{\"title\":\"Class 的继承\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/83f8c3a0cd87dd83\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Class 的继承\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"class-的继承\\\" tabindex=\\\"-1\\\">Class 的继承 <a class=\\\"header-anchor\\\" href=\\\"#class-的继承\\\" aria-label=\\\"Permalink to &quot;Class 的继承&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>Class 可以通过<code>extends</code>关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">class</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> Point</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">class</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> ColorPoint</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> extends</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> Point</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br></div></div>\",\"capture\":\"简介\\nClass 可以通过`extends`关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。\\n```javascript\\nclass Point {\\n}\\nclass ColorPoint extends Point {\\n}\\n```\\n上面代码定义了一个`ColorPoint`类，该类通过`extends`关键字，继承了`Point`类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个`Point`类。下面，我们在`ColorPoint`内部加上代码。\\n```javascript\\nclass ColorPoint extends Point \"},{\"url\":\"/《ES6 教程》笔记/23.Module 的语法.html\",\"relativePath\":\"/《ES6 教程》笔记/23.Module 的语法.html\",\"frontmatter\":{\"title\":\"Module 的语法\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/efe2fb04eb8ac5fb\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Module 的语法\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"module-的语法\\\" tabindex=\\\"-1\\\">Module 的语法 <a class=\\\"header-anchor\\\" href=\\\"#module-的语法\\\" aria-label=\\\"Permalink to &quot;Module 的语法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的<code>require</code>、Python 的<code>import</code>，甚至就连 CSS 都有<code>@import</code>，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p>\\n\",\"capture\":\"概述\\n历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的`require`、Python 的`import`，甚至就连 CSS 都有`@import`，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。\\n在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD \"},{\"url\":\"/《ES6 教程》笔记/24.Module 的加载实现.html\",\"relativePath\":\"/《ES6 教程》笔记/24.Module 的加载实现.html\",\"frontmatter\":{\"title\":\"Module 的加载实现\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/a79ca2e64ceae213\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Module 的加载实现\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"module-的加载实现\\\" tabindex=\\\"-1\\\">Module 的加载实现 <a class=\\\"header-anchor\\\" href=\\\"#module-的加载实现\\\" aria-label=\\\"Permalink to &quot;Module 的加载实现&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>上一章介绍了模块的语法，本章介绍如何在浏览器和 Node.js 之中加载 ES6 模块，以及实际开发中经常遇到的一些问题（比如循环加载）。</p>\\n\",\"capture\":\"上一章介绍了模块的语法，本章介绍如何在浏览器和 Node.js 之中加载 ES6 模块，以及实际开发中经常遇到的一些问题（比如循环加载）。\\n 浏览器加载\\n 传统方法\\nHTML 网页中，浏览器通过`&lt;script\\n```html\\n&lt;!-- 页面内嵌的脚本 --&gt;\\n&lt;script type=\\\"application/javascript\\\"&gt;\\n  // module code\\n&lt;/script&gt;\\n&lt;!-- 外部脚本 --&gt;\\n&lt;script type=\\\"application/javascript\\\" src=\\\"path/to/myModule\"},{\"url\":\"/《ES6 教程》笔记/25.编程风格.html\",\"relativePath\":\"/《ES6 教程》笔记/25.编程风格.html\",\"frontmatter\":{\"title\":\"编程风格\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/984bf549204bb266\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"编程风格\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"编程风格\\\" tabindex=\\\"-1\\\">编程风格 <a class=\\\"header-anchor\\\" href=\\\"#编程风格\\\" aria-label=\\\"Permalink to &quot;编程风格&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>本章探讨如何将 ES6 的新语法，运用到编码实践之中，与传统的 JavaScript 语法结合在一起，写出合理的、易于阅读和维护的代码。</p>\\n<p>多家公司和组织已经公开了它们的风格规范，下面的内容主要参考了 <a href=\\\"https://github.com/airbnb/javascript\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">Airbnb</a> 公司的 JavaScript 风格规范。</p>\\n\",\"capture\":\"本章探讨如何将 ES6 的新语法，运用到编码实践之中，与传统的 JavaScript 语法结合在一起，写出合理的、易于阅读和维护的代码。\\n多家公司和组织已经公开了它们的风格规范，下面的内容主要参考了 Airbnb 公司的 JavaScript 风格规范。\\n 块级作用域\\n（1）let 取代 var\\nES6 提出了两个新的声明变量的命令：`let`和`const`。其中，`let`完全可以取代`var`，因为两者语义相同，而且`let`没有副作用。\\n```javascript\\n'use strict';\\nif (true) {\\n  let x = 'hello';\\n}\\nfor (let i = 0\"},{\"url\":\"/《ES6 教程》笔记/26.读懂 ECMAScript 规格.html\",\"relativePath\":\"/《ES6 教程》笔记/26.读懂 ECMAScript 规格.html\",\"frontmatter\":{\"title\":\"读懂 ECMAScript 规格\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/32c35f7651d6e58e\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"读懂 ECMAScript 规格\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"读懂-ecmascript-规格\\\" tabindex=\\\"-1\\\">读懂 ECMAScript 规格 <a class=\\\"header-anchor\\\" href=\\\"#读懂-ecmascript-规格\\\" aria-label=\\\"Permalink to &quot;读懂 ECMAScript 规格&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>规格文件是计算机语言的官方标准，详细描述语法规则和实现方法。</p>\\n<p>一般来说，没有必要阅读规格，除非你要写编译器。因为规格写得非常抽象和精炼，又缺乏实例，不容易理解，而且对于解决实际的应用问题，帮助不大。但是，如果你遇到疑难的语法问题，实在找不到答案，这时可以去查看规格文件，了解语言标准是怎么说的。规格是解决问题的“最后一招”。</p>\\n\",\"capture\":\"概述\\n规格文件是计算机语言的官方标准，详细描述语法规则和实现方法。\\n一般来说，没有必要阅读规格，除非你要写编译器。因为规格写得非常抽象和精炼，又缺乏实例，不容易理解，而且对于解决实际的应用问题，帮助不大。但是，如果你遇到疑难的语法问题，实在找不到答案，这时可以去查看规格文件，了解语言标准是怎么说的。规格是解决问题的“最后一招”。\\n这对 JavaScript 语言很有必要。因为它的使用场景复杂，语法规则不统一，例外很多，各种运行环境的行为不一致，导致奇怪的语法问题层出不穷，任何语法书都不可能囊括所有情况。查看规格，不失为一种解决语法问题的最可靠、最权威的终极方法。\\n本章介绍如何读懂 ECMASc\"},{\"url\":\"/《ES6 教程》笔记/27.异步遍历器.html\",\"relativePath\":\"/《ES6 教程》笔记/27.异步遍历器.html\",\"frontmatter\":{\"title\":\"异步遍历器\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/16121351be68691b\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"异步遍历器\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"异步遍历器\\\" tabindex=\\\"-1\\\">异步遍历器 <a class=\\\"header-anchor\\\" href=\\\"#异步遍历器\\\" aria-label=\\\"Permalink to &quot;异步遍历器&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"同步遍历器的问题\\\" tabindex=\\\"-1\\\">同步遍历器的问题 <a class=\\\"header-anchor\\\" href=\\\"#同步遍历器的问题\\\" aria-label=\\\"Permalink to &quot;同步遍历器的问题&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>《遍历器》一章说过，Iterator 接口是一种数据遍历的协议，只要调用遍历器对象的<code>next</code>方法，就会得到一个对象，表示当前遍历指针所在的那个位置的信息。<code>next</code>方法返回的对象的结构是<code>{value, done}</code>，其中<code>value</code>表示当前的数据的值，<code>done</code>是一个布尔值，表示遍历是否结束。</p>\\n\",\"capture\":\"同步遍历器的问题\\n《遍历器》一章说过，Iterator 接口是一种数据遍历的协议，只要调用遍历器对象的`next`方法，就会得到一个对象，表示当前遍历指针所在的那个位置的信息。`next`方法返回的对象的结构是`{value, done}`，其中`value`表示当前的数据的值，`done`是一个布尔值，表示遍历是否结束。\\n```javascript\\nfunction idMaker() {\\n  let index = 0;\\n  return {\\n    next: function() {\\n      return { value: index++, done: false };\\n    }\"},{\"url\":\"/《ES6 教程》笔记/28.ArrayBuffer.html\",\"relativePath\":\"/《ES6 教程》笔记/28.ArrayBuffer.html\",\"frontmatter\":{\"title\":\"ArrayBuffer\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/a2ba314746bfdbdd\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"ArrayBuffer\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"arraybuffer\\\" tabindex=\\\"-1\\\">ArrayBuffer <a class=\\\"header-anchor\\\" href=\\\"#arraybuffer\\\" aria-label=\\\"Permalink to &quot;ArrayBuffer&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><code>ArrayBuffer</code>对象、<code>TypedArray</code>视图和<code>DataView</code>视图是 JavaScript 操作二进制数据的一个接口。这些对象早就存在，属于独立的规格（2011 年 2 月发布），ES6 将它们纳入了 ECMAScript 规格，并且增加了新的方法。它们都是以数组的语法处理二进制数据，所以统称为二进制数组。</p>\\n\",\"capture\":\"`ArrayBuffer`对象、`TypedArray`视图和`DataView`视图是 JavaScript 操作二进制数据的一个接口。这些对象早就存在，属于独立的规格（2011 年 2 月发布），ES6 将它们纳入了 ECMAScript 规格，并且增加了新的方法。它们都是以数组的语法处理二进制数据，所以统称为二进制数组。\\n这个接口的原始设计目的，与 WebGL 项目有关。所谓 WebGL，就是指浏览器与显卡之间的通信接口，为了满足 JavaScript 与显卡之间大量的、实时的数据交换，它们之间的数据通信必须是二进制的，而不能是传统的文本格式。文本格式传递一个 32 位整数，两端的 Ja\"},{\"url\":\"/《ES6 教程》笔记/01.ECMAScript 6 简介.html\",\"relativePath\":\"/《ES6 教程》笔记/01.ECMAScript 6 简介.html\",\"frontmatter\":{\"title\":\"ECMAScript 6 简介\",\"date\":\"2020-01-12 15:45:35\",\"permalink\":\"/pages/f344d070a1031ef7\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"ECMAScript 6 简介\",\"date\":\"2020-01-12 15:45:35\",\"excerpt\":\"<blockquote>\\n<p>说明：本章内容为博主在原教程基础上添加自己的学习笔记，来源<a href=\\\"http://es6.ruanyifeng.com/\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">http://es6.ruanyifeng.com/</a>，教程版权归原作者所有。</p>\\n</blockquote>\\n<h1 id=\\\"ecmascript-6-简介\\\" tabindex=\\\"-1\\\">ECMAScript 6 简介 <a class=\\\"header-anchor\\\" href=\\\"#ecmascript-6-简介\\\" aria-label=\\\"Permalink to &quot;ECMAScript 6 简介&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p>\\n\",\"capture\":\"ECMAScript 6 简介\\nECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。\\n ECMAScript 和 JavaScript 的关系\\n一个常见的问题是，ECMAScript 和 JavaScript 到底是什么关系？\\n要讲清楚这个问题，需要回顾历史。1996 年 11 月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给标准化组织 ECMA，希望这种语言能够成为国际标\"}],\"前端\":[{\"url\":\"/01.前端/25.JavaScript文章/15.js实现深度优先遍历和广度优先遍历.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/15.js实现深度优先遍历和广度优先遍历.html\",\"frontmatter\":{\"title\":\"js实现深度优先遍历和广度优先遍历\",\"date\":\"2023-09-08 14:16:56\",\"permalink\":\"/pages/690414/\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"js实现深度优先遍历和广度优先遍历\",\"date\":\"2023-09-08 14:16:56\",\"capture\":\"什么是深度优先和广度优先\\n深度优先遍历用的是栈，而广度优先遍历要用队列来实现,深度优先就是自上而下的遍历搜索 广度优先则是逐层遍历, 如下图所示(图左深度优先遍历,图右广度)\\n 深度优先遍历\\n 广度优先遍历\\n 两者的区别\\n对于算法来说 无非就是时间换空间 空间换时间\\n1. 深度优先不需要记住所有的节点, 所以占用空间小, 而广度优先需要先记录所有的节点占用空间大\\n2. 深度优先有回溯的操作(没有路走了需要回头)所以相对而言时间会长一点\\n深度优先采用的是堆栈的形式, 即先进后出\\n广度优先则采用的是队列的形式, 即先进先出\\n```jsx\\nconst data = [\\n  {\\n      name:\"},{\"url\":\"/01.前端/25.JavaScript文章/14.js获取当前URL,域名,端口号.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/14.js获取当前URL,域名,端口号.html\",\"frontmatter\":{\"title\":\"js获取当前URL,域名,端口号\",\"date\":\"2023-09-08 13:57:22\",\"permalink\":\"/pages/c81259/\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"js获取当前URL,域名,端口号\",\"date\":\"2023-09-08 13:57:22\",\"capture\":\"| href | 完整的 URL | https://www.baidu.com:200/s?wd=1 |\\n| --- | --- | --- |\\n| protocol | 协议 | https: |\\n| hostname | 主机名 | www.baidu.com |\\n| port | 端口号 | 200 |\\n| host | 主机名+端口号 | www.baidu.com:200 |\\n```javascript\\nlet protocol = window.location.protocol,host = window.location.host;\\nlet url = `${protocol\"},{\"url\":\"/01.前端/25.JavaScript文章/13.javascript常用类型数值比较图.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/13.javascript常用类型数值比较图.html\",\"frontmatter\":{\"title\":\"javascript常用类型数值比较图\",\"date\":\"2023-09-08 13:34:43\",\"permalink\":\"/pages/360851/\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"javascript常用类型数值比较图\",\"date\":\"2023-09-08 13:34:43\",\"capture\":\"\"},{\"url\":\"/01.前端/25.JavaScript文章/01.33个非常实用的JavaScript一行代码.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/01.33个非常实用的JavaScript一行代码.html\",\"frontmatter\":{\"title\":\"33个非常实用的JavaScript一行代码\",\"date\":\"2021-11-02 09:51:37\",\"permalink\":\"/pages/a61298/\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[\"JavaScript\"],\"author\":\"CUGGZ\"},\"author\":\"CUGGZ\",\"title\":\"33个非常实用的JavaScript一行代码\",\"date\":\"2021-11-02 09:51:37\",\"capture\":\"一、日期处理\\n 1. 检察日期是否有效\\n该方法用于检测给出的日期是否有效：\\n```javascript\\nconst isDateValid = (...val) =\\nisDateValid(\\\"December 17, 1995 03:24:00\\\");  // true\\n复制代码\\n```\\n 2. 计算两个日期之间的间隔\\n该方法用于计算两个日期之间的间隔时间：\\n```javascript\\nconst dayDif = (date1, date2) =&gt; Math.ceil(Math.abs(date1.getTime() - date2.getTime()) / 86400000)\\ndayD\"},{\"url\":\"/01.前端/40.学习笔记/50.JS设计模式总结笔记.html\",\"relativePath\":\"/01.前端/40.学习笔记/50.JS设计模式总结笔记.html\",\"frontmatter\":{\"title\":\"JS设计模式总结笔记\",\"date\":\"2021-02-27 20:01:18\",\"permalink\":\"/pages/4643cd/\",\"categories\":[\"前端\",\"学习笔记\"],\"tags\":[\"设计模式\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"JS设计模式总结笔记\",\"date\":\"2021-02-27 20:01:18\",\"capture\":\"开篇：前端工程师的成长论\\n能够决定一个前端工程师的本质的，不是那些瞬息万变的技术点，而是那些不变的东西。\\n所谓“不变的东西”，就是驾驭技术的能力。\\n具体来说，它分为以下三个层次：\\n- 能用健壮的代码去解决具体的问题；\\n- 能用抽象的思维去应对复杂的系统；\\n- 能用工程化的思想去规划更大规模的业务。\\n\\n 设计模式之“道”\\n- 设计模式是“拿来主义”。如使用数学公式，不会从头推导一个公式。\\n  核心思想\\n- 设计模式的核心思想——封装变化\\n- 保证可维护性、可扩展性。\\n- 将变与不变分离，确保变化的部分灵活，不变的部分稳定。——这就是所谓的“健壮”的代码。\\n 设计模式之“术”\\n即最经典的23种设计\"},{\"url\":\"/01.前端/25.JavaScript文章/1110.三级目录/00.四级文件.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/1110.三级目录/00.四级文件.html\",\"frontmatter\":{\"title\":\"四级文件(测试)\",\"date\":\"2020-12-11 11:15:53\",\"permalink\":\"/pages/8481d1/\",\"categories\":[\"前端\",\"JavaScript文章\",\"三级目录\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"四级文件(测试)\",\"date\":\"2020-12-11 11:15:53\",\"capture\":\"测试文件\\nTest Test\\n&lt;code-group\\n  &lt;code-block title=\\\"YARN\\\" active&gt;\\n  ```bash\\n  yarn create vuepress-site [optionalDirectoryName]\\n   OR npx create-vuepress-site [optionalDirectoryName]\\n  ```\\n  &lt;/code-block&gt;\\n  &lt;code-block title=\\\"NPM\\\"&gt;\\n  ```bash\\n  npx create-vuepress-site [optionalDirec\"},{\"url\":\"/01.前端/40.学习笔记/35.TypeScript笔记.html\",\"relativePath\":\"/01.前端/40.学习笔记/35.TypeScript笔记.html\",\"frontmatter\":{\"title\":\"TypeScript笔记\",\"date\":\"2020-10-08 13:02:48\",\"permalink\":\"/pages/51afd6/\",\"categories\":[\"前端\",\"学习笔记\"],\"tags\":[\"TypeScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"TypeScript笔记\",\"date\":\"2020-10-08 13:02:48\",\"capture\":\"TypeScript 的类型校验是给程序员看的，在编译后不会存在TS代码。\\n 类型注解\\n```typescript\\nfunction fn(person: string):void{ // 参数类型是字符串，没有返回值\\n    ///...\\n}\\nfn('str') // 如传递参数非字符串，vscode编辑器中或在编译时将给出错误提示\\nconst test:number = 1\\n```\\n 有哪些基础类型注解？\\n```typescript\\n// 基础类型\\n:string\\n:number\\n:boolean\\n:null  // 只能是null值\\n:undefined // 只能是undefined值\"},{\"url\":\"/01.前端/25.JavaScript文章/12.比typeof运算符更准确的类型判断.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/12.比typeof运算符更准确的类型判断.html\",\"frontmatter\":{\"title\":\"比typeof运算符更准确的类型判断\",\"date\":\"2020-04-13 15:56:54\",\"permalink\":\"/pages/fd4a16d56b83c1bc\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"比typeof运算符更准确的类型判断\",\"date\":\"2020-04-13 15:56:54\",\"capture\":\"不同数据类型的`Object.prototype.toString`方法返回值如下。\\n- 数值：返回`[object Number]`。\\n- 字符串：返回`[object String]`。\\n- 布尔值：返回`[object Boolean]`。\\n- undefined：返回`[object Undefined]`。\\n- null：返回`[object Null]`。\\n- 数组：返回`[object Array]`。\\n- arguments 对象：返回`[object Arguments]`。\\n- 函数：返回`[object Function]`。\\n- Error 对象：返回`[object \"},{\"url\":\"/01.前端/25.JavaScript文章/11.JS获取和修改url参数.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/11.JS获取和修改url参数.html\",\"frontmatter\":{\"title\":\"JS获取和修改url参数\",\"date\":\"2020-03-05 12:45:37\",\"permalink\":\"/pages/7a91be2d502346ce\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"JS获取和修改url参数\",\"date\":\"2020-03-05 12:45:37\",\"capture\":\"获取url参数\\n```js\\n/**\\n * 获取url里的参数\\n * @param arg 参数名\\n * @returns\\n */\\nfunction getURLString(arg) {\\n    var reg = new RegExp(\\\"(^|&)\\\" + arg + \\\"=([^&]*)(&|$)\\\", \\\"i\\\");\\n    var r = window.location.search.substr(1).match(reg);\\n    if (r != null)\\n        return unescape(r[2]);\\n    return null;\\n}\\n```\\n 修改url参数\\n```\"},{\"url\":\"/01.前端/25.JavaScript文章/10.防抖与节流函数.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/10.防抖与节流函数.html\",\"frontmatter\":{\"title\":\"防抖与节流函数\",\"date\":\"2020-02-29 15:07:47\",\"permalink\":\"/pages/0f6a0ac99b62ede5\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"防抖与节流函数\",\"date\":\"2020-02-29 15:07:47\",\"excerpt\":\"<h1 id=\\\"防抖与节流函数\\\" tabindex=\\\"-1\\\">防抖与节流函数 <a class=\\\"header-anchor\\\" href=\\\"#防抖与节流函数\\\" aria-label=\\\"Permalink to &quot;防抖与节流函数&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>防抖和节流的作用都是在高频事件中防止函数被多次调用，是一种性能优化的方案。</p>\\n<p>区别在于，防抖函数只会在高频事件结束后n毫秒调用一次函数，节流函数会在高频事件触发过程当中每隔n毫秒调用一次函数。</p>\\n\",\"capture\":\"防抖和节流的作用都是在高频事件中防止函数被多次调用，是一种性能优化的方案。\\n区别在于，防抖函数只会在高频事件结束后n毫秒调用一次函数，节流函数会在高频事件触发过程当中每隔n毫秒调用一次函数。\\n 防抖函数\\n触发高频事件后一段时间（wait）只会执行一次函数，如果指定时间（wait）内高频事件再次被触发，则重新计算时间。\\n 封装\\n```js\\n// 防抖函数\\nfunction debounce(func, wait) {\\n    let timeout = null;\\n    return function () {\\n        let context = this;\\n        let a\"},{\"url\":\"/01.前端/25.JavaScript文章/09.将一维数组按指定长度转为二维数组.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/09.将一维数组按指定长度转为二维数组.html\",\"frontmatter\":{\"title\":\"将一维数组按指定长度转为二维数组\",\"date\":\"2020-02-23 13:49:31\",\"permalink\":\"/pages/f1acb712033ac8da\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"将一维数组按指定长度转为二维数组\",\"date\":\"2020-02-23 13:49:31\",\"capture\":\"将一维数组按指定长度转为二维数组\\n```js\\nfunction pages(arr, len) {\\n    const pages = []\\n    arr.forEach((item, index) =\\n        const page = Math.floor(index / len)\\n        if (!pages[page]) {\\n            pages[page] = []\\n        }\\n        pages[page].push(item)\\n    })\\n    return pages\\n}\\n// 使用\\nconst arr = [1, 2, 3, \"},{\"url\":\"/01.前端/25.JavaScript文章/03.ES5面向对象.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/03.ES5面向对象.html\",\"frontmatter\":{\"title\":\"ES5面向对象\",\"date\":\"2020-02-22 10:35:43\",\"permalink\":\"/pages/b1af5cb8996363c5\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"ES5面向对象\",\"date\":\"2020-02-22 10:35:43\",\"capture\":\"```js\\n//面向对象封装\\nfunction Student(props){ // 构造函数 （构造函数内定于属性。尊从首字母大写的约定）\\n  this.name = props.name || '匿名';  // 默认‘匿名’\\n  this.grade = props.grade || 1;\\n}\\nStudent.prototype.hello = function(){ // 在构造函数的原型上定义方法\\n  console.log('你好,'+ this.name +'同学，你在'+ this.grade+'年级');\\n}\\n//使用\\nfunction createStudent(props\"},{\"url\":\"/01.前端/25.JavaScript文章/07.js随机打乱数组.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/07.js随机打乱数组.html\",\"frontmatter\":{\"title\":\"JS随机打乱数组\",\"date\":\"2020-02-08 17:42:03\",\"permalink\":\"/pages/40b4db2d38ba85f2\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"JS随机打乱数组\",\"date\":\"2020-02-08 17:42:03\",\"capture\":\"```js\\nfunction shuffle(arr) { // 随机打乱数组\\n  let _arr = arr.slice() // 调用数组副本，不改变原数组\\n  for (let i = 0; i &lt; _arr.length; i++) {\\n    let j = getRandomInt(0, i)\\n    let t = _arr[i]\\n    _arr[i] = _arr[j]\\n    _arr[j] = t\\n  }\\n  return _arr\\n}\\nfunction getRandomInt(min, max) { // 获取min到max的一个随机数，包含min和max本身\"},{\"url\":\"/01.前端/25.JavaScript文章/08.判断是否为移动端浏览器.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/08.判断是否为移动端浏览器.html\",\"frontmatter\":{\"title\":\"判断是否为移动端浏览器\",\"date\":\"2020-01-04 15:25:11\",\"permalink\":\"/pages/40f623be692cf8bc\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"判断是否为移动端浏览器\",\"date\":\"2020-01-04 15:25:11\",\"capture\":\"```js\\nconst flag = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);\\nif(flag){\\n    // 移动端\\n} else {\\n    // PC端\\n}\\n```\"},{\"url\":\"/01.前端/25.JavaScript文章/02.new命令原理.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/02.new命令原理.html\",\"frontmatter\":{\"title\":\"new命令原理\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/8143cc480faf9a11\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"new命令原理\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"new命令原理\\\" tabindex=\\\"-1\\\">new命令原理 <a class=\\\"header-anchor\\\" href=\\\"#new命令原理\\\" aria-label=\\\"Permalink to &quot;new命令原理&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>使用new命令时，它后面的函数依次执行下面的步骤：</p>\\n<ol>\\n<li>创建一个空对象，作为将要返回的实例对象。</li>\\n<li>将这个空对象的原型，指向构造函数的prototype属性。</li>\\n<li>将这个空对象赋值给函数内部的this关键字。</li>\\n<li>开始执行构造函数内部的代码。</li>\\n<li>如果构造函数内有返回值且为对象类型，则返回该对象，否则返回上面创建的实例对象。</li>\\n</ol>\\n\",\"capture\":\"使用new命令时，它后面的函数依次执行下面的步骤：\\n1. 创建一个空对象，作为将要返回的实例对象。\\n2. 将这个空对象的原型，指向构造函数的prototype属性。\\n3. 将这个空对象赋值给函数内部的this关键字。\\n4. 开始执行构造函数内部的代码。\\n5. 如果构造函数内有返回值且为对象类型，则返回该对象，否则返回上面创建的实例对象。\\n```js\\n// 构造函数\\nfunction Person(name,age){\\n    this.name = name\\n    this.age = age\\n}\\n// 自定义_new\\nfunction _new() {\\n  // 将 arguments 对\"},{\"url\":\"/01.前端/25.JavaScript文章/04.ES6面向对象.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/04.ES6面向对象.html\",\"frontmatter\":{\"title\":\"ES6面向对象\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/1f4123be6f45abcd\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"ES6面向对象\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```js\\n//面向对象封装\\nclass Student{ //定义类 (尊从首字母大写的约定)\\n    constructor(props){  // 构造函数 （构造函数内定于属性）\\n        this.name = props.name || '匿名'; // 默认'匿名'\\n      this.grade = props.grade || 1;\\n    }\\n    hello(){ // 在构造函数的原型上定义方法\\n        console.log(`你好,${this.name}同学，你在${this.grade}年级`);\\n    }\\n}\\n//使用\\nfunction c\"},{\"url\":\"/01.前端/25.JavaScript文章/06.多种数组去重性能对比.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/06.多种数组去重性能对比.html\",\"frontmatter\":{\"title\":\"多种数组去重性能对比\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/e808fba1fa8fbab2\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"多种数组去重性能对比\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"测试模板\\n```js\\n// 创建一个 1 ~ 10w 的数组，Array.from为ES6语法\\nlet arr1 = Array.from(new Array(1000000), (x, index) =\\n  return index\\n})\\nlet arr2 = Array.from(new Array(500000), (x, index) =&gt; {\\n  return index + index\\n})\\nlet start = new Date().getTime()\\nconsole.log('开始数组去重')\\n// 数组去重\\nfunction distinct(a, b) {\\n  le\"},{\"url\":\"/01.前端/40.学习笔记/40.小程序笔记.html\",\"relativePath\":\"/01.前端/40.学习笔记/40.小程序笔记.html\",\"frontmatter\":{\"title\":\"小程序笔记\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/note/wx-miniprogram/\",\"tags\":[\"小程序\"],\"categories\":[\"前端\",\"学习笔记\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"小程序笔记\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"小程序笔记\\n 基础课程部分\\n 微信公众平台\\n&lt;https://mp.weixin.qq.com/\\n注册时可选择类型：订阅号、服务号、小程序、企业微信\\n每个邮箱仅能注册一个小程序。\\n个人类型小程序：无法使用微信支付、无法使用卡包功能\\n 小程序文档API\\n小程序开发文档\\n 微信开放社区\\n微信开发社区\\n 目录说明\\n默认目录\\npages-----------------------页面相关\\n​\\tindex  ----------------- 首页文件夹\\n​\\t\\tindex.js ------------首页js\\n​\\t\\tindex.json---------首页配置\\n​\\t\\tindex.wxml--\"}],\"JavaScript文章\":[{\"url\":\"/01.前端/25.JavaScript文章/15.js实现深度优先遍历和广度优先遍历.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/15.js实现深度优先遍历和广度优先遍历.html\",\"frontmatter\":{\"title\":\"js实现深度优先遍历和广度优先遍历\",\"date\":\"2023-09-08 14:16:56\",\"permalink\":\"/pages/690414/\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"js实现深度优先遍历和广度优先遍历\",\"date\":\"2023-09-08 14:16:56\",\"capture\":\"什么是深度优先和广度优先\\n深度优先遍历用的是栈，而广度优先遍历要用队列来实现,深度优先就是自上而下的遍历搜索 广度优先则是逐层遍历, 如下图所示(图左深度优先遍历,图右广度)\\n 深度优先遍历\\n 广度优先遍历\\n 两者的区别\\n对于算法来说 无非就是时间换空间 空间换时间\\n1. 深度优先不需要记住所有的节点, 所以占用空间小, 而广度优先需要先记录所有的节点占用空间大\\n2. 深度优先有回溯的操作(没有路走了需要回头)所以相对而言时间会长一点\\n深度优先采用的是堆栈的形式, 即先进后出\\n广度优先则采用的是队列的形式, 即先进先出\\n```jsx\\nconst data = [\\n  {\\n      name:\"},{\"url\":\"/01.前端/25.JavaScript文章/14.js获取当前URL,域名,端口号.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/14.js获取当前URL,域名,端口号.html\",\"frontmatter\":{\"title\":\"js获取当前URL,域名,端口号\",\"date\":\"2023-09-08 13:57:22\",\"permalink\":\"/pages/c81259/\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"js获取当前URL,域名,端口号\",\"date\":\"2023-09-08 13:57:22\",\"capture\":\"| href | 完整的 URL | https://www.baidu.com:200/s?wd=1 |\\n| --- | --- | --- |\\n| protocol | 协议 | https: |\\n| hostname | 主机名 | www.baidu.com |\\n| port | 端口号 | 200 |\\n| host | 主机名+端口号 | www.baidu.com:200 |\\n```javascript\\nlet protocol = window.location.protocol,host = window.location.host;\\nlet url = `${protocol\"},{\"url\":\"/01.前端/25.JavaScript文章/13.javascript常用类型数值比较图.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/13.javascript常用类型数值比较图.html\",\"frontmatter\":{\"title\":\"javascript常用类型数值比较图\",\"date\":\"2023-09-08 13:34:43\",\"permalink\":\"/pages/360851/\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"javascript常用类型数值比较图\",\"date\":\"2023-09-08 13:34:43\",\"capture\":\"\"},{\"url\":\"/01.前端/25.JavaScript文章/01.33个非常实用的JavaScript一行代码.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/01.33个非常实用的JavaScript一行代码.html\",\"frontmatter\":{\"title\":\"33个非常实用的JavaScript一行代码\",\"date\":\"2021-11-02 09:51:37\",\"permalink\":\"/pages/a61298/\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[\"JavaScript\"],\"author\":\"CUGGZ\"},\"author\":\"CUGGZ\",\"title\":\"33个非常实用的JavaScript一行代码\",\"date\":\"2021-11-02 09:51:37\",\"capture\":\"一、日期处理\\n 1. 检察日期是否有效\\n该方法用于检测给出的日期是否有效：\\n```javascript\\nconst isDateValid = (...val) =\\nisDateValid(\\\"December 17, 1995 03:24:00\\\");  // true\\n复制代码\\n```\\n 2. 计算两个日期之间的间隔\\n该方法用于计算两个日期之间的间隔时间：\\n```javascript\\nconst dayDif = (date1, date2) =&gt; Math.ceil(Math.abs(date1.getTime() - date2.getTime()) / 86400000)\\ndayD\"},{\"url\":\"/01.前端/25.JavaScript文章/1110.三级目录/00.四级文件.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/1110.三级目录/00.四级文件.html\",\"frontmatter\":{\"title\":\"四级文件(测试)\",\"date\":\"2020-12-11 11:15:53\",\"permalink\":\"/pages/8481d1/\",\"categories\":[\"前端\",\"JavaScript文章\",\"三级目录\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"四级文件(测试)\",\"date\":\"2020-12-11 11:15:53\",\"capture\":\"测试文件\\nTest Test\\n&lt;code-group\\n  &lt;code-block title=\\\"YARN\\\" active&gt;\\n  ```bash\\n  yarn create vuepress-site [optionalDirectoryName]\\n   OR npx create-vuepress-site [optionalDirectoryName]\\n  ```\\n  &lt;/code-block&gt;\\n  &lt;code-block title=\\\"NPM\\\"&gt;\\n  ```bash\\n  npx create-vuepress-site [optionalDirec\"},{\"url\":\"/01.前端/25.JavaScript文章/12.比typeof运算符更准确的类型判断.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/12.比typeof运算符更准确的类型判断.html\",\"frontmatter\":{\"title\":\"比typeof运算符更准确的类型判断\",\"date\":\"2020-04-13 15:56:54\",\"permalink\":\"/pages/fd4a16d56b83c1bc\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"比typeof运算符更准确的类型判断\",\"date\":\"2020-04-13 15:56:54\",\"capture\":\"不同数据类型的`Object.prototype.toString`方法返回值如下。\\n- 数值：返回`[object Number]`。\\n- 字符串：返回`[object String]`。\\n- 布尔值：返回`[object Boolean]`。\\n- undefined：返回`[object Undefined]`。\\n- null：返回`[object Null]`。\\n- 数组：返回`[object Array]`。\\n- arguments 对象：返回`[object Arguments]`。\\n- 函数：返回`[object Function]`。\\n- Error 对象：返回`[object \"},{\"url\":\"/01.前端/25.JavaScript文章/11.JS获取和修改url参数.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/11.JS获取和修改url参数.html\",\"frontmatter\":{\"title\":\"JS获取和修改url参数\",\"date\":\"2020-03-05 12:45:37\",\"permalink\":\"/pages/7a91be2d502346ce\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"JS获取和修改url参数\",\"date\":\"2020-03-05 12:45:37\",\"capture\":\"获取url参数\\n```js\\n/**\\n * 获取url里的参数\\n * @param arg 参数名\\n * @returns\\n */\\nfunction getURLString(arg) {\\n    var reg = new RegExp(\\\"(^|&)\\\" + arg + \\\"=([^&]*)(&|$)\\\", \\\"i\\\");\\n    var r = window.location.search.substr(1).match(reg);\\n    if (r != null)\\n        return unescape(r[2]);\\n    return null;\\n}\\n```\\n 修改url参数\\n```\"},{\"url\":\"/01.前端/25.JavaScript文章/10.防抖与节流函数.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/10.防抖与节流函数.html\",\"frontmatter\":{\"title\":\"防抖与节流函数\",\"date\":\"2020-02-29 15:07:47\",\"permalink\":\"/pages/0f6a0ac99b62ede5\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"防抖与节流函数\",\"date\":\"2020-02-29 15:07:47\",\"excerpt\":\"<h1 id=\\\"防抖与节流函数\\\" tabindex=\\\"-1\\\">防抖与节流函数 <a class=\\\"header-anchor\\\" href=\\\"#防抖与节流函数\\\" aria-label=\\\"Permalink to &quot;防抖与节流函数&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>防抖和节流的作用都是在高频事件中防止函数被多次调用，是一种性能优化的方案。</p>\\n<p>区别在于，防抖函数只会在高频事件结束后n毫秒调用一次函数，节流函数会在高频事件触发过程当中每隔n毫秒调用一次函数。</p>\\n\",\"capture\":\"防抖和节流的作用都是在高频事件中防止函数被多次调用，是一种性能优化的方案。\\n区别在于，防抖函数只会在高频事件结束后n毫秒调用一次函数，节流函数会在高频事件触发过程当中每隔n毫秒调用一次函数。\\n 防抖函数\\n触发高频事件后一段时间（wait）只会执行一次函数，如果指定时间（wait）内高频事件再次被触发，则重新计算时间。\\n 封装\\n```js\\n// 防抖函数\\nfunction debounce(func, wait) {\\n    let timeout = null;\\n    return function () {\\n        let context = this;\\n        let a\"},{\"url\":\"/01.前端/25.JavaScript文章/09.将一维数组按指定长度转为二维数组.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/09.将一维数组按指定长度转为二维数组.html\",\"frontmatter\":{\"title\":\"将一维数组按指定长度转为二维数组\",\"date\":\"2020-02-23 13:49:31\",\"permalink\":\"/pages/f1acb712033ac8da\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"将一维数组按指定长度转为二维数组\",\"date\":\"2020-02-23 13:49:31\",\"capture\":\"将一维数组按指定长度转为二维数组\\n```js\\nfunction pages(arr, len) {\\n    const pages = []\\n    arr.forEach((item, index) =\\n        const page = Math.floor(index / len)\\n        if (!pages[page]) {\\n            pages[page] = []\\n        }\\n        pages[page].push(item)\\n    })\\n    return pages\\n}\\n// 使用\\nconst arr = [1, 2, 3, \"},{\"url\":\"/01.前端/25.JavaScript文章/03.ES5面向对象.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/03.ES5面向对象.html\",\"frontmatter\":{\"title\":\"ES5面向对象\",\"date\":\"2020-02-22 10:35:43\",\"permalink\":\"/pages/b1af5cb8996363c5\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"ES5面向对象\",\"date\":\"2020-02-22 10:35:43\",\"capture\":\"```js\\n//面向对象封装\\nfunction Student(props){ // 构造函数 （构造函数内定于属性。尊从首字母大写的约定）\\n  this.name = props.name || '匿名';  // 默认‘匿名’\\n  this.grade = props.grade || 1;\\n}\\nStudent.prototype.hello = function(){ // 在构造函数的原型上定义方法\\n  console.log('你好,'+ this.name +'同学，你在'+ this.grade+'年级');\\n}\\n//使用\\nfunction createStudent(props\"},{\"url\":\"/01.前端/25.JavaScript文章/07.js随机打乱数组.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/07.js随机打乱数组.html\",\"frontmatter\":{\"title\":\"JS随机打乱数组\",\"date\":\"2020-02-08 17:42:03\",\"permalink\":\"/pages/40b4db2d38ba85f2\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"JS随机打乱数组\",\"date\":\"2020-02-08 17:42:03\",\"capture\":\"```js\\nfunction shuffle(arr) { // 随机打乱数组\\n  let _arr = arr.slice() // 调用数组副本，不改变原数组\\n  for (let i = 0; i &lt; _arr.length; i++) {\\n    let j = getRandomInt(0, i)\\n    let t = _arr[i]\\n    _arr[i] = _arr[j]\\n    _arr[j] = t\\n  }\\n  return _arr\\n}\\nfunction getRandomInt(min, max) { // 获取min到max的一个随机数，包含min和max本身\"},{\"url\":\"/01.前端/25.JavaScript文章/08.判断是否为移动端浏览器.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/08.判断是否为移动端浏览器.html\",\"frontmatter\":{\"title\":\"判断是否为移动端浏览器\",\"date\":\"2020-01-04 15:25:11\",\"permalink\":\"/pages/40f623be692cf8bc\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"判断是否为移动端浏览器\",\"date\":\"2020-01-04 15:25:11\",\"capture\":\"```js\\nconst flag = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);\\nif(flag){\\n    // 移动端\\n} else {\\n    // PC端\\n}\\n```\"},{\"url\":\"/01.前端/25.JavaScript文章/02.new命令原理.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/02.new命令原理.html\",\"frontmatter\":{\"title\":\"new命令原理\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/8143cc480faf9a11\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"new命令原理\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"new命令原理\\\" tabindex=\\\"-1\\\">new命令原理 <a class=\\\"header-anchor\\\" href=\\\"#new命令原理\\\" aria-label=\\\"Permalink to &quot;new命令原理&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>使用new命令时，它后面的函数依次执行下面的步骤：</p>\\n<ol>\\n<li>创建一个空对象，作为将要返回的实例对象。</li>\\n<li>将这个空对象的原型，指向构造函数的prototype属性。</li>\\n<li>将这个空对象赋值给函数内部的this关键字。</li>\\n<li>开始执行构造函数内部的代码。</li>\\n<li>如果构造函数内有返回值且为对象类型，则返回该对象，否则返回上面创建的实例对象。</li>\\n</ol>\\n\",\"capture\":\"使用new命令时，它后面的函数依次执行下面的步骤：\\n1. 创建一个空对象，作为将要返回的实例对象。\\n2. 将这个空对象的原型，指向构造函数的prototype属性。\\n3. 将这个空对象赋值给函数内部的this关键字。\\n4. 开始执行构造函数内部的代码。\\n5. 如果构造函数内有返回值且为对象类型，则返回该对象，否则返回上面创建的实例对象。\\n```js\\n// 构造函数\\nfunction Person(name,age){\\n    this.name = name\\n    this.age = age\\n}\\n// 自定义_new\\nfunction _new() {\\n  // 将 arguments 对\"},{\"url\":\"/01.前端/25.JavaScript文章/04.ES6面向对象.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/04.ES6面向对象.html\",\"frontmatter\":{\"title\":\"ES6面向对象\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/1f4123be6f45abcd\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"ES6面向对象\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```js\\n//面向对象封装\\nclass Student{ //定义类 (尊从首字母大写的约定)\\n    constructor(props){  // 构造函数 （构造函数内定于属性）\\n        this.name = props.name || '匿名'; // 默认'匿名'\\n      this.grade = props.grade || 1;\\n    }\\n    hello(){ // 在构造函数的原型上定义方法\\n        console.log(`你好,${this.name}同学，你在${this.grade}年级`);\\n    }\\n}\\n//使用\\nfunction c\"},{\"url\":\"/01.前端/25.JavaScript文章/06.多种数组去重性能对比.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/06.多种数组去重性能对比.html\",\"frontmatter\":{\"title\":\"多种数组去重性能对比\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/e808fba1fa8fbab2\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"多种数组去重性能对比\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"测试模板\\n```js\\n// 创建一个 1 ~ 10w 的数组，Array.from为ES6语法\\nlet arr1 = Array.from(new Array(1000000), (x, index) =\\n  return index\\n})\\nlet arr2 = Array.from(new Array(500000), (x, index) =&gt; {\\n  return index + index\\n})\\nlet start = new Date().getTime()\\nconsole.log('开始数组去重')\\n// 数组去重\\nfunction distinct(a, b) {\\n  le\"}],\"页面\":[{\"url\":\"/02.页面/20.CSS/16.css calc()使用.html\",\"relativePath\":\"/02.页面/20.CSS/16.css calc()使用.html\",\"frontmatter\":{\"title\":\"css calc()使用\",\"date\":\"2023-09-08 11:40:43\",\"permalink\":\"/pages/2ecc26/\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"css calc()使用\",\"date\":\"2023-09-08 11:40:43\",\"capture\":\"1.什么是 CSS calc() 函数？\\ncalc() 函数允许在指定 CSS 属性值时执行计算。它对于计算 length、 percentage、 time、 numbers、integers、frequencies 和 angles 等特别有用。 CSS calc() 函数的一个强大功能是能够组合不同的单位。这个函数可以执行预处理器不能执行的数学计算。\\nCSS 中的预处理器只能组合具有固定关系的单位，如角度单位、时间单位、频率单位、分辨率单位和特定长度单位。\\ncalc( Expression)\\ncalc() 函数接受一个表达式作为参数。然后将表达式的结果用作值。它可以采用任何形式并使用以下\"},{\"url\":\"/02.页面/20.CSS/15.CSS给table的tbody添加滚动条.html\",\"relativePath\":\"/02.页面/20.CSS/15.CSS给table的tbody添加滚动条.html\",\"frontmatter\":{\"title\":\"CSS给table的tbody添加滚动条\",\"date\":\"2022-06-29 09:34:23\",\"permalink\":\"/pages/55f894/\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"CSS给table的tbody添加滚动条\",\"date\":\"2022-06-29 09:34:23\",\"capture\":\"```css\\ntable tbody {\\n  height: 200px;\\n  overflow-y: auto;\\n  display: block;\\n}\\ntable thead,\\ntbody tr {\\n  display: table;\\n  width: 100%;\\n}\\n```\"},{\"url\":\"/02.页面/20.CSS/00.CSS教程和技巧收藏.html\",\"relativePath\":\"/02.页面/20.CSS/00.CSS教程和技巧收藏.html\",\"frontmatter\":{\"title\":\"CSS教程和技巧收藏\",\"date\":\"2020-08-11 17:13:52\",\"permalink\":\"/pages/c8f128/\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"CSS教程和技巧收藏\",\"date\":\"2020-08-11 17:13:52\",\"capture\":\"Flex 布局教程：语法篇\\n&lt;http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\\n CSS Grid 网格布局教程\\n&lt;http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html&gt;\\n 只要一行代码，实现五种 CSS 经典布局\\n&lt;http://www.ruanyifeng.com/blog/2020/08/five-css-layouts-in-one-line.html&gt;\\n* 空间居中布局\\n  &gt; 不管容器的大小，项目总是占据中心\"},{\"url\":\"/02.页面/20.CSS/14.CSS-function汇总.html\",\"relativePath\":\"/02.页面/20.CSS/14.CSS-function汇总.html\",\"frontmatter\":{\"title\":\"CSS-function汇总\",\"date\":\"2020-05-12 09:36:44\",\"permalink\":\"/pages/3da0d7\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"CSS-function汇总\",\"date\":\"2020-05-12 09:36:44\",\"capture\":\"\"},{\"url\":\"/02.页面/20.CSS/13.如何根据系统主题自动响应CSS深色模式.html\",\"relativePath\":\"/02.页面/20.CSS/13.如何根据系统主题自动响应CSS深色模式.html\",\"frontmatter\":{\"title\":\"如何根据系统主题自动响应CSS深色模式\",\"date\":\"2020-03-31 14:06:26\",\"permalink\":\"/pages/5dde351274f1e39d\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[\"css\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"如何根据系统主题自动响应CSS深色模式\",\"date\":\"2020-03-31 14:06:26\",\"excerpt\":\"<h1 id=\\\"如何根据系统主题自动响应css深色模式\\\" tabindex=\\\"-1\\\">如何根据系统主题自动响应CSS深色模式 <a class=\\\"header-anchor\\\" href=\\\"#如何根据系统主题自动响应css深色模式\\\" aria-label=\\\"Permalink to &quot;如何根据系统主题自动响应CSS深色模式&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p align=\\\"center\\\">\\n  <img src=\\\"https://cdn.staticaly.com/gh/xugaoyi/image_store/blog/20200427163531.jpg\\\" width=\\\"500\\\">\\n</p>\\n<p>很多人喜欢选择APP或网站中的深色模式，也许他们更喜欢这样的外观，或者他们想让自己的眼睛免受疲劳。这篇文章将告诉你如何在网站中实现一个自动的CSS深色模式，根据访客的系统主题来自动响应。</p>\\n\",\"capture\":\"如何根据系统主题自动响应CSS深色模式\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"https://cdn.staticaly.com/gh/xugaoyi/image_store/blog/20200427163531.jpg\\\" width=\\\"500\\\"&gt;\\n&lt;/p&gt;\\n很多人喜欢选择APP或网站中的深色模式，也许他们更喜欢这样的外观，或者他们想让自己的眼睛免受疲劳。这篇文章将告诉你如何在网站中实现一个自动的CSS深色模式，根据访客的系统主题来自动响应。\\n CSS 深色模式 (Dark Mode)\\n在`:root`根元素中定义变量来设置主题的颜色。我建\"},{\"url\":\"/02.页面/20.CSS/12.水平垂直居中的几种方式-案例.html\",\"relativePath\":\"/02.页面/20.CSS/12.水平垂直居中的几种方式-案例.html\",\"frontmatter\":{\"title\":\"水平垂直居中的几种方式-案例\",\"date\":\"2020-03-13 16:13:43\",\"permalink\":\"/pages/cb7cb251adba4bf7\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"水平垂直居中的几种方式-案例\",\"date\":\"2020-03-13 16:13:43\",\"capture\":\"&lt;iframe height=\\\"880\\\" style=\\\"width: 100%;\\\" scrolling=\\\"no\\\" title=\\\"水平垂直居中的几种方式\\\" src=\\\"https://codepen.io/xugaoyi/embed/poJLeYv?height=880&theme-id=light&default-tab=result\\\" frameborder=\\\"no\\\" allowtransparency=\\\"true\\\" allowfullscreen=\\\"true\\\"\\n  See the Pen &lt;a href='https://codepen.io/xugaoyi/pen/poJLeY\"},{\"url\":\"/02.页面/20.CSS/11.从box-sizing属性入手，了解盒子模型.html\",\"relativePath\":\"/02.页面/20.CSS/11.从box-sizing属性入手，了解盒子模型.html\",\"frontmatter\":{\"title\":\"从box-sizing属性入手，了解盒子模型\",\"date\":\"2020-02-27 17:08:48\",\"permalink\":\"/pages/20a978023139589d\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"从box-sizing属性入手，了解盒子模型\",\"date\":\"2020-02-27 17:08:48\",\"excerpt\":\"<h1 id=\\\"从box-sizing属性入手-了解盒子模型\\\" tabindex=\\\"-1\\\">从box-sizing属性入手，了解盒子模型 <a class=\\\"header-anchor\\\" href=\\\"#从box-sizing属性入手-了解盒子模型\\\" aria-label=\\\"Permalink to &quot;从box-sizing属性入手，了解盒子模型&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"背景\\\" tabindex=\\\"-1\\\">背景 <a class=\\\"header-anchor\\\" href=\\\"#背景\\\" aria-label=\\\"Permalink to &quot;背景&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>先声明一下运用的场景，假如项目布局使用的是<strong>自适应</strong>的布局方式，div给出的宽度是<strong>百分比</strong>的形式，即占窗口宽度的100%，但边框<code>border</code>和内边距<code>padding</code>是用像素来表示的，此时就会造成一个问题是div总宽度超过窗口宽度。为了避免这种问题，可以使用属性<code>box-sizing:border-box</code>来把 <strong>标准盒模型</strong> 变成 <strong>代替(IE)盒模型</strong> ，从而使div的总宽度依然是100%</p>\\n\",\"capture\":\"背景\\n先声明一下运用的场景，假如项目布局使用的是自适应的布局方式，div给出的宽度是百分比的形式，即占窗口宽度的100%，但边框`border`和内边距`padding`是用像素来表示的，此时就会造成一个问题是div总宽度超过窗口宽度。为了避免这种问题，可以使用属性`box-sizing:border-box`来把 标准盒模型 变成 代替(IE)盒模型 ，从而使div的总宽度依然是100%\\n 什么是CSS 盒模型?\\n页面布局中，一个元素的外边距（margin）、 边框（border）、内边距（padding）、内容（content）组成一个盒模型。盒模型可分为标准盒模型 和 代替（IE）盒模型\"},{\"url\":\"/02.页面/20.CSS/10.文字在一行或多行时超出显示省略号.html\",\"relativePath\":\"/02.页面/20.CSS/10.文字在一行或多行时超出显示省略号.html\",\"frontmatter\":{\"title\":\"文字在一行或多行时超出显示省略号\",\"date\":\"2020-02-23 15:07:08\",\"permalink\":\"/pages/42b66999cc27dc25\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"文字在一行或多行时超出显示省略号\",\"date\":\"2020-02-23 15:07:08\",\"excerpt\":\"<h1 id=\\\"文字在一行或多行时超出显示省略号\\\" tabindex=\\\"-1\\\">文字在一行或多行时超出显示省略号 <a class=\\\"header-anchor\\\" href=\\\"#文字在一行或多行时超出显示省略号\\\" aria-label=\\\"Permalink to &quot;文字在一行或多行时超出显示省略号&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"一行超出显示省略\\\" tabindex=\\\"-1\\\">一行超出显示省略 <a class=\\\"header-anchor\\\" href=\\\"#一行超出显示省略\\\" aria-label=\\\"Permalink to &quot;一行超出显示省略&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<div class=\\\"language-css vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">css</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">overflow: hidden;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">white-space</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">: nowrap;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">text-overflow</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">: ellipsis;</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br></div></div>\",\"capture\":\"一行超出显示省略\\n```css\\noverflow: hidden;\\nwhite-space: nowrap;\\ntext-overflow: ellipsis;\\n```\\n```html\\n&lt;html\\n   &lt;div class=\\\"box-42b6\\\"&gt;演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字&lt;/div&gt;\\n&lt;/html&gt;\\n&lt;style&gt;\\n    .box-42b6{\\n        border: 1px solid 999;\\n        width\"},{\"url\":\"/02.页面/20.CSS/09.「布局技巧」图片未加载前自动撑开元素高度.html\",\"relativePath\":\"/02.页面/20.CSS/09.「布局技巧」图片未加载前自动撑开元素高度.html\",\"frontmatter\":{\"title\":\"「布局技巧」图片未加载前自动撑开元素高度\",\"date\":\"2020-02-22 16:37:10\",\"permalink\":\"/pages/3d52574260725aea\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"「布局技巧」图片未加载前自动撑开元素高度\",\"date\":\"2020-02-22 16:37:10\",\"excerpt\":\"<h1 id=\\\"「布局技巧」图片未加载前自动撑开元素高度\\\" tabindex=\\\"-1\\\">「布局技巧」图片未加载前自动撑开元素高度 <a class=\\\"header-anchor\\\" href=\\\"#「布局技巧」图片未加载前自动撑开元素高度\\\" aria-label=\\\"Permalink to &quot;「布局技巧」图片未加载前自动撑开元素高度&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>在移动端开发中，有一些元素是根据图片高度来自动撑开的 ，高度不能写死（如轮播图的外层元素）。在网络较慢的情况下，图片加载需要一些时间，此时该元素的高度没有被撑开，在网页布局上会有一些不想看到的效果。</p>\\n\",\"capture\":\"在移动端开发中，有一些元素是根据图片高度来自动撑开的 ，高度不能写死（如轮播图的外层元素）。在网络较慢的情况下，图片加载需要一些时间，此时该元素的高度没有被撑开，在网页布局上会有一些不想看到的效果。\\n这种情况我们可以设置如下样式来设置该元素的高度：\\n```stylus\\n.wrapper\\n  overflow hidden\\n  width 100%\\n  height 0\\n  padding-bottom 26.66% // 这个数值是图片的高宽比，即 高/宽\\n  background eee\\n```\\n上面代码中，`padding-bottom` 的取值是图片的高宽比（即，高/宽），它会根据 `w\"},{\"url\":\"/02.页面/10.HTML/10.常用meta整理.html\",\"relativePath\":\"/02.页面/10.HTML/10.常用meta整理.html\",\"frontmatter\":{\"title\":\"常用meta整理\",\"date\":\"2020-02-21 12:20:10\",\"permalink\":\"/pages/8309a5b876fc95e3\",\"categories\":[\"页面\",\"HTML\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"常用meta整理\",\"date\":\"2020-02-21 12:20:10\",\"excerpt\":\"<h1 id=\\\"常用meta整理\\\" tabindex=\\\"-1\\\">常用meta整理 <a class=\\\"header-anchor\\\" href=\\\"#常用meta整理\\\" aria-label=\\\"Permalink to &quot;常用meta整理&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"meta-元素\\\" tabindex=\\\"-1\\\">&lt;meta&gt; 元素 <a class=\\\"header-anchor\\\" href=\\\"#meta-元素\\\" aria-label=\\\"Permalink to &quot;&lt;meta\\\\&gt; 元素&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"概要\\\" tabindex=\\\"-1\\\">概要 <a class=\\\"header-anchor\\\" href=\\\"#概要\\\" aria-label=\\\"Permalink to &quot;概要&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>meta标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。</p>\\n\",\"capture\":\"&lt;meta\\\\\\n 概要\\nmeta标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。\\n必要属性\\n| 属性    | 值        | 描述                                   |\\n| ------- | --------- | -------------------------------------- |\\n| content | some text | 定义与http-equiv或name属性相关的元信息 |\\n可选属性\\n| 属性     \"},{\"url\":\"/02.页面/20.CSS/01.flex布局语法.html\",\"relativePath\":\"/02.页面/20.CSS/01.flex布局语法.html\",\"frontmatter\":{\"title\":\"flex布局语法\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/0a83b083bdf257cb\",\"author\":{\"name\":\"阮一峰\"},\"categories\":[\"页面\",\"CSS\"],\"tags\":[null]},\"author\":{\"name\":\"阮一峰\"},\"title\":\"flex布局语法\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"flex布局语法\\\" tabindex=\\\"-1\\\">flex布局语法 <a class=\\\"header-anchor\\\" href=\\\"#flex布局语法\\\" aria-label=\\\"Permalink to &quot;flex布局语法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"一、flex-布局是什么\\\" tabindex=\\\"-1\\\">一、flex 布局是什么？ <a class=\\\"header-anchor\\\" href=\\\"#一、flex-布局是什么\\\" aria-label=\\\"Permalink to &quot;一、flex 布局是什么？&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>Flex是 Flexible Box 的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性。</p>\\n<p><strong>任何一个容器</strong> 都可以指定为 Flex 布局。</p>\\n\",\"capture\":\"一、flex 布局是什么？\\nFlex是 Flexible Box 的缩写，意为\\\"弹性布局\\\"，用来为盒状模型提供最大的灵活性。\\n任何一个容器 都可以指定为 Flex 布局。\\n```css\\n.box{\\n  display: flex;\\n}\\n```\\n行内元素 也可以使用 Flex 布局。\\n```css\\n.box{\\n  display: inline-flex;\\n}\\n```\\nWebkit 内核的浏览器，必须加上`-webkit`前缀。\\n```css\\n.box{\\n  display: -webkit-flex; /* Safari */\\n  display: flex;\\n}\\n```\\n注意，设为 Flex\"},{\"url\":\"/02.页面/20.CSS/02.flex布局案例-基础.html\",\"relativePath\":\"/02.页面/20.CSS/02.flex布局案例-基础.html\",\"frontmatter\":{\"title\":\"flex布局案例-基础\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/ea6db1530c42ad51\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"flex布局案例-基础\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"``` html\\n&lt;html&gt;\\n  &lt;div class=\\\"box\\\"&gt;\\n    &lt;span&gt;1&lt;/span&gt;\\n    &lt;span&gt;2&lt;/span&gt;\\n    &lt;span&gt;3&lt;/span&gt;\\n    &lt;span&gt;4&lt;/span&gt;\\n    &lt;span&gt;5&lt;/span&gt;\\n    &lt;span&gt;6&lt;/span&gt;\\n    &lt;span&gt;7&lt;/span&gt;\\n  &lt;/div&gt;\\n&lt;/html&gt;\\n&lt;st\"},{\"url\":\"/02.页面/20.CSS/03.flex布局案例-骰子.html\",\"relativePath\":\"/02.页面/20.CSS/03.flex布局案例-骰子.html\",\"frontmatter\":{\"title\":\"flex布局案例-骰子\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/eff61bc8b4f4695d\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"flex布局案例-骰子\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```html\\n&lt;html&gt;\\n  &lt;div class=\\\"box2\\\"&gt;\\n    &lt;div class=\\\"first-face\\\"&gt;\\n      &lt;span class=\\\"pip\\\"&gt;&lt;/span&gt;\\n    &lt;/div&gt;\\n    &lt;div class=\\\"second-face\\\"&gt;\\n      &lt;span class=\\\"pip\\\"&gt;&lt;/span&gt;\\n      &lt;span class=\\\"pip\\\"&gt;&lt;/span&gt;\\n    &lt;/div&gt;\\n    &lt;div cla\"},{\"url\":\"/02.页面/20.CSS/04.flex布局案例-圣杯布局.html\",\"relativePath\":\"/02.页面/20.CSS/04.flex布局案例-圣杯布局.html\",\"frontmatter\":{\"title\":\"flex布局案例-圣杯布局\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/df9e7c7214fa5046\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"flex布局案例-圣杯布局\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```html\\n&lt;html&gt;\\n  &lt;div class=\\\"HolyGrail\\\"&gt;\\n    &lt;header&gt;header&lt;/header&gt;\\n    &lt;div class=\\\"wrap\\\"&gt;\\n      &lt;nav class=\\\"left\\\"&gt;left 宽度固定200px&lt;/nav&gt;\\n      &lt;main class=\\\"content\\\"&gt;center 宽度自适应&lt;/main&gt;\\n      &lt;aside class=\\\"right\\\"&gt;right 宽度固定200px&lt;/aside&gt\"},{\"url\":\"/02.页面/20.CSS/05.flex布局案例-网格布局.html\",\"relativePath\":\"/02.页面/20.CSS/05.flex布局案例-网格布局.html\",\"frontmatter\":{\"title\":\"flex布局案例-网格布局\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/85b5a3fe218a34b7\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"flex布局案例-网格布局\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```html\\n&lt;html&gt;\\n  &lt;div class=\\\"grid\\\"&gt;\\n    &lt;div class=\\\"grid-cell\\\"&gt;1/2&lt;/div&gt;\\n    &lt;div class=\\\"grid-cell\\\"&gt;1/2&lt;/div&gt;\\n  &lt;/div&gt;\\n  &lt;div class=\\\"grid\\\"&gt;\\n    &lt;div class=\\\"grid-cell\\\"&gt;1/3&lt;/div&gt;\\n    &lt;div class=\\\"grid-cell\\\"&gt;1/3&lt;/div&gt;\\n    &lt;div cl\"},{\"url\":\"/02.页面/20.CSS/06.flex布局案例-输入框布局.html\",\"relativePath\":\"/02.页面/20.CSS/06.flex布局案例-输入框布局.html\",\"frontmatter\":{\"title\":\"flex布局案例-输入框布局\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/05cc577fb51c7998\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"flex布局案例-输入框布局\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```html\\n&lt;html&gt;\\n  &lt;div class=\\\"InputAddOn\\\"&gt;\\n    &lt;span class=\\\"InputAddOn-item\\\"&gt;icon&lt;/span&gt;\\n    &lt;input class=\\\"InputAddOn-field\\\" placeholder=\\\"input宽度自适应\\\"&gt;\\n    &lt;button class=\\\"InputAddOn-item\\\"&gt;提交&lt;/button&gt;\\n  &lt;/div&gt;\\n  &lt;br/&gt;\\n  &lt;div class=\\\"Media\\\"&gt;\\n   \"},{\"url\":\"/02.页面/20.CSS/07.CSS3之transition过渡.html\",\"relativePath\":\"/02.页面/20.CSS/07.CSS3之transition过渡.html\",\"frontmatter\":{\"title\":\"CSS3之transition过渡\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/02d7f59d98d87409\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"CSS3之transition过渡\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"html结构\\n```html\\n&lt;div class=\\\"box1\\\"\\n  &lt;div class=\\\"div1\\\"&gt;&lt;/div&gt;\\n  &lt;div class=\\\"div2\\\"&gt;&lt;/div&gt;\\n  &lt;div class=\\\"div3\\\"&gt;&lt;/div&gt;\\n&lt;/div&gt;\\n```\\n先给元素设置transition过渡，指定样式和时间，这里设置all全部样式都采用0.3s的过渡\\n```css\\n.box1&gt;div{\\n  /* 给元素所有变化都添加过渡动画, 也可以指定唯一的过渡样式属性*/\\n  transition: all .3s;\"},{\"url\":\"/02.页面/20.CSS/08.CSS3之animation动画.html\",\"relativePath\":\"/02.页面/20.CSS/08.CSS3之animation动画.html\",\"frontmatter\":{\"title\":\"CSS3之animation动画\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/c2c0432138f6e042\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"CSS3之animation动画\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```html\\n&lt;html&gt;\\n  &lt;div class=\\\"animationBox\\\"&gt;\\n    &lt;div class=\\\"rotate\\\"&gt;旋转动画1&lt;/div&gt;\\n    &lt;div class=\\\"play\\\"&gt;\\n      &lt;div class=\\\"img\\\"&gt;旋转动画2&lt;/div&gt;\\n      &lt;span&gt;&lt;p class=\\\"p2\\\"&gt;&lt;/p&gt;&lt;/span&gt;\\n      &lt;span&gt;&lt;p&gt;&lt;/p&gt;&lt;/span&gt;\\n      &\"}],\"CSS\":[{\"url\":\"/02.页面/20.CSS/16.css calc()使用.html\",\"relativePath\":\"/02.页面/20.CSS/16.css calc()使用.html\",\"frontmatter\":{\"title\":\"css calc()使用\",\"date\":\"2023-09-08 11:40:43\",\"permalink\":\"/pages/2ecc26/\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"css calc()使用\",\"date\":\"2023-09-08 11:40:43\",\"capture\":\"1.什么是 CSS calc() 函数？\\ncalc() 函数允许在指定 CSS 属性值时执行计算。它对于计算 length、 percentage、 time、 numbers、integers、frequencies 和 angles 等特别有用。 CSS calc() 函数的一个强大功能是能够组合不同的单位。这个函数可以执行预处理器不能执行的数学计算。\\nCSS 中的预处理器只能组合具有固定关系的单位，如角度单位、时间单位、频率单位、分辨率单位和特定长度单位。\\ncalc( Expression)\\ncalc() 函数接受一个表达式作为参数。然后将表达式的结果用作值。它可以采用任何形式并使用以下\"},{\"url\":\"/02.页面/20.CSS/15.CSS给table的tbody添加滚动条.html\",\"relativePath\":\"/02.页面/20.CSS/15.CSS给table的tbody添加滚动条.html\",\"frontmatter\":{\"title\":\"CSS给table的tbody添加滚动条\",\"date\":\"2022-06-29 09:34:23\",\"permalink\":\"/pages/55f894/\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"CSS给table的tbody添加滚动条\",\"date\":\"2022-06-29 09:34:23\",\"capture\":\"```css\\ntable tbody {\\n  height: 200px;\\n  overflow-y: auto;\\n  display: block;\\n}\\ntable thead,\\ntbody tr {\\n  display: table;\\n  width: 100%;\\n}\\n```\"},{\"url\":\"/02.页面/20.CSS/00.CSS教程和技巧收藏.html\",\"relativePath\":\"/02.页面/20.CSS/00.CSS教程和技巧收藏.html\",\"frontmatter\":{\"title\":\"CSS教程和技巧收藏\",\"date\":\"2020-08-11 17:13:52\",\"permalink\":\"/pages/c8f128/\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"CSS教程和技巧收藏\",\"date\":\"2020-08-11 17:13:52\",\"capture\":\"Flex 布局教程：语法篇\\n&lt;http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\\n CSS Grid 网格布局教程\\n&lt;http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html&gt;\\n 只要一行代码，实现五种 CSS 经典布局\\n&lt;http://www.ruanyifeng.com/blog/2020/08/five-css-layouts-in-one-line.html&gt;\\n* 空间居中布局\\n  &gt; 不管容器的大小，项目总是占据中心\"},{\"url\":\"/02.页面/20.CSS/14.CSS-function汇总.html\",\"relativePath\":\"/02.页面/20.CSS/14.CSS-function汇总.html\",\"frontmatter\":{\"title\":\"CSS-function汇总\",\"date\":\"2020-05-12 09:36:44\",\"permalink\":\"/pages/3da0d7\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"CSS-function汇总\",\"date\":\"2020-05-12 09:36:44\",\"capture\":\"\"},{\"url\":\"/02.页面/20.CSS/13.如何根据系统主题自动响应CSS深色模式.html\",\"relativePath\":\"/02.页面/20.CSS/13.如何根据系统主题自动响应CSS深色模式.html\",\"frontmatter\":{\"title\":\"如何根据系统主题自动响应CSS深色模式\",\"date\":\"2020-03-31 14:06:26\",\"permalink\":\"/pages/5dde351274f1e39d\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[\"css\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"如何根据系统主题自动响应CSS深色模式\",\"date\":\"2020-03-31 14:06:26\",\"excerpt\":\"<h1 id=\\\"如何根据系统主题自动响应css深色模式\\\" tabindex=\\\"-1\\\">如何根据系统主题自动响应CSS深色模式 <a class=\\\"header-anchor\\\" href=\\\"#如何根据系统主题自动响应css深色模式\\\" aria-label=\\\"Permalink to &quot;如何根据系统主题自动响应CSS深色模式&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p align=\\\"center\\\">\\n  <img src=\\\"https://cdn.staticaly.com/gh/xugaoyi/image_store/blog/20200427163531.jpg\\\" width=\\\"500\\\">\\n</p>\\n<p>很多人喜欢选择APP或网站中的深色模式，也许他们更喜欢这样的外观，或者他们想让自己的眼睛免受疲劳。这篇文章将告诉你如何在网站中实现一个自动的CSS深色模式，根据访客的系统主题来自动响应。</p>\\n\",\"capture\":\"如何根据系统主题自动响应CSS深色模式\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"https://cdn.staticaly.com/gh/xugaoyi/image_store/blog/20200427163531.jpg\\\" width=\\\"500\\\"&gt;\\n&lt;/p&gt;\\n很多人喜欢选择APP或网站中的深色模式，也许他们更喜欢这样的外观，或者他们想让自己的眼睛免受疲劳。这篇文章将告诉你如何在网站中实现一个自动的CSS深色模式，根据访客的系统主题来自动响应。\\n CSS 深色模式 (Dark Mode)\\n在`:root`根元素中定义变量来设置主题的颜色。我建\"},{\"url\":\"/02.页面/20.CSS/12.水平垂直居中的几种方式-案例.html\",\"relativePath\":\"/02.页面/20.CSS/12.水平垂直居中的几种方式-案例.html\",\"frontmatter\":{\"title\":\"水平垂直居中的几种方式-案例\",\"date\":\"2020-03-13 16:13:43\",\"permalink\":\"/pages/cb7cb251adba4bf7\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"水平垂直居中的几种方式-案例\",\"date\":\"2020-03-13 16:13:43\",\"capture\":\"&lt;iframe height=\\\"880\\\" style=\\\"width: 100%;\\\" scrolling=\\\"no\\\" title=\\\"水平垂直居中的几种方式\\\" src=\\\"https://codepen.io/xugaoyi/embed/poJLeYv?height=880&theme-id=light&default-tab=result\\\" frameborder=\\\"no\\\" allowtransparency=\\\"true\\\" allowfullscreen=\\\"true\\\"\\n  See the Pen &lt;a href='https://codepen.io/xugaoyi/pen/poJLeY\"},{\"url\":\"/02.页面/20.CSS/11.从box-sizing属性入手，了解盒子模型.html\",\"relativePath\":\"/02.页面/20.CSS/11.从box-sizing属性入手，了解盒子模型.html\",\"frontmatter\":{\"title\":\"从box-sizing属性入手，了解盒子模型\",\"date\":\"2020-02-27 17:08:48\",\"permalink\":\"/pages/20a978023139589d\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"从box-sizing属性入手，了解盒子模型\",\"date\":\"2020-02-27 17:08:48\",\"excerpt\":\"<h1 id=\\\"从box-sizing属性入手-了解盒子模型\\\" tabindex=\\\"-1\\\">从box-sizing属性入手，了解盒子模型 <a class=\\\"header-anchor\\\" href=\\\"#从box-sizing属性入手-了解盒子模型\\\" aria-label=\\\"Permalink to &quot;从box-sizing属性入手，了解盒子模型&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"背景\\\" tabindex=\\\"-1\\\">背景 <a class=\\\"header-anchor\\\" href=\\\"#背景\\\" aria-label=\\\"Permalink to &quot;背景&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>先声明一下运用的场景，假如项目布局使用的是<strong>自适应</strong>的布局方式，div给出的宽度是<strong>百分比</strong>的形式，即占窗口宽度的100%，但边框<code>border</code>和内边距<code>padding</code>是用像素来表示的，此时就会造成一个问题是div总宽度超过窗口宽度。为了避免这种问题，可以使用属性<code>box-sizing:border-box</code>来把 <strong>标准盒模型</strong> 变成 <strong>代替(IE)盒模型</strong> ，从而使div的总宽度依然是100%</p>\\n\",\"capture\":\"背景\\n先声明一下运用的场景，假如项目布局使用的是自适应的布局方式，div给出的宽度是百分比的形式，即占窗口宽度的100%，但边框`border`和内边距`padding`是用像素来表示的，此时就会造成一个问题是div总宽度超过窗口宽度。为了避免这种问题，可以使用属性`box-sizing:border-box`来把 标准盒模型 变成 代替(IE)盒模型 ，从而使div的总宽度依然是100%\\n 什么是CSS 盒模型?\\n页面布局中，一个元素的外边距（margin）、 边框（border）、内边距（padding）、内容（content）组成一个盒模型。盒模型可分为标准盒模型 和 代替（IE）盒模型\"},{\"url\":\"/02.页面/20.CSS/10.文字在一行或多行时超出显示省略号.html\",\"relativePath\":\"/02.页面/20.CSS/10.文字在一行或多行时超出显示省略号.html\",\"frontmatter\":{\"title\":\"文字在一行或多行时超出显示省略号\",\"date\":\"2020-02-23 15:07:08\",\"permalink\":\"/pages/42b66999cc27dc25\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"文字在一行或多行时超出显示省略号\",\"date\":\"2020-02-23 15:07:08\",\"excerpt\":\"<h1 id=\\\"文字在一行或多行时超出显示省略号\\\" tabindex=\\\"-1\\\">文字在一行或多行时超出显示省略号 <a class=\\\"header-anchor\\\" href=\\\"#文字在一行或多行时超出显示省略号\\\" aria-label=\\\"Permalink to &quot;文字在一行或多行时超出显示省略号&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"一行超出显示省略\\\" tabindex=\\\"-1\\\">一行超出显示省略 <a class=\\\"header-anchor\\\" href=\\\"#一行超出显示省略\\\" aria-label=\\\"Permalink to &quot;一行超出显示省略&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<div class=\\\"language-css vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">css</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">overflow: hidden;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">white-space</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">: nowrap;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">text-overflow</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">: ellipsis;</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br></div></div>\",\"capture\":\"一行超出显示省略\\n```css\\noverflow: hidden;\\nwhite-space: nowrap;\\ntext-overflow: ellipsis;\\n```\\n```html\\n&lt;html\\n   &lt;div class=\\\"box-42b6\\\"&gt;演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字&lt;/div&gt;\\n&lt;/html&gt;\\n&lt;style&gt;\\n    .box-42b6{\\n        border: 1px solid 999;\\n        width\"},{\"url\":\"/02.页面/20.CSS/09.「布局技巧」图片未加载前自动撑开元素高度.html\",\"relativePath\":\"/02.页面/20.CSS/09.「布局技巧」图片未加载前自动撑开元素高度.html\",\"frontmatter\":{\"title\":\"「布局技巧」图片未加载前自动撑开元素高度\",\"date\":\"2020-02-22 16:37:10\",\"permalink\":\"/pages/3d52574260725aea\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"「布局技巧」图片未加载前自动撑开元素高度\",\"date\":\"2020-02-22 16:37:10\",\"excerpt\":\"<h1 id=\\\"「布局技巧」图片未加载前自动撑开元素高度\\\" tabindex=\\\"-1\\\">「布局技巧」图片未加载前自动撑开元素高度 <a class=\\\"header-anchor\\\" href=\\\"#「布局技巧」图片未加载前自动撑开元素高度\\\" aria-label=\\\"Permalink to &quot;「布局技巧」图片未加载前自动撑开元素高度&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>在移动端开发中，有一些元素是根据图片高度来自动撑开的 ，高度不能写死（如轮播图的外层元素）。在网络较慢的情况下，图片加载需要一些时间，此时该元素的高度没有被撑开，在网页布局上会有一些不想看到的效果。</p>\\n\",\"capture\":\"在移动端开发中，有一些元素是根据图片高度来自动撑开的 ，高度不能写死（如轮播图的外层元素）。在网络较慢的情况下，图片加载需要一些时间，此时该元素的高度没有被撑开，在网页布局上会有一些不想看到的效果。\\n这种情况我们可以设置如下样式来设置该元素的高度：\\n```stylus\\n.wrapper\\n  overflow hidden\\n  width 100%\\n  height 0\\n  padding-bottom 26.66% // 这个数值是图片的高宽比，即 高/宽\\n  background eee\\n```\\n上面代码中，`padding-bottom` 的取值是图片的高宽比（即，高/宽），它会根据 `w\"},{\"url\":\"/02.页面/20.CSS/01.flex布局语法.html\",\"relativePath\":\"/02.页面/20.CSS/01.flex布局语法.html\",\"frontmatter\":{\"title\":\"flex布局语法\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/0a83b083bdf257cb\",\"author\":{\"name\":\"阮一峰\"},\"categories\":[\"页面\",\"CSS\"],\"tags\":[null]},\"author\":{\"name\":\"阮一峰\"},\"title\":\"flex布局语法\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"flex布局语法\\\" tabindex=\\\"-1\\\">flex布局语法 <a class=\\\"header-anchor\\\" href=\\\"#flex布局语法\\\" aria-label=\\\"Permalink to &quot;flex布局语法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"一、flex-布局是什么\\\" tabindex=\\\"-1\\\">一、flex 布局是什么？ <a class=\\\"header-anchor\\\" href=\\\"#一、flex-布局是什么\\\" aria-label=\\\"Permalink to &quot;一、flex 布局是什么？&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>Flex是 Flexible Box 的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性。</p>\\n<p><strong>任何一个容器</strong> 都可以指定为 Flex 布局。</p>\\n\",\"capture\":\"一、flex 布局是什么？\\nFlex是 Flexible Box 的缩写，意为\\\"弹性布局\\\"，用来为盒状模型提供最大的灵活性。\\n任何一个容器 都可以指定为 Flex 布局。\\n```css\\n.box{\\n  display: flex;\\n}\\n```\\n行内元素 也可以使用 Flex 布局。\\n```css\\n.box{\\n  display: inline-flex;\\n}\\n```\\nWebkit 内核的浏览器，必须加上`-webkit`前缀。\\n```css\\n.box{\\n  display: -webkit-flex; /* Safari */\\n  display: flex;\\n}\\n```\\n注意，设为 Flex\"},{\"url\":\"/02.页面/20.CSS/02.flex布局案例-基础.html\",\"relativePath\":\"/02.页面/20.CSS/02.flex布局案例-基础.html\",\"frontmatter\":{\"title\":\"flex布局案例-基础\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/ea6db1530c42ad51\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"flex布局案例-基础\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"``` html\\n&lt;html&gt;\\n  &lt;div class=\\\"box\\\"&gt;\\n    &lt;span&gt;1&lt;/span&gt;\\n    &lt;span&gt;2&lt;/span&gt;\\n    &lt;span&gt;3&lt;/span&gt;\\n    &lt;span&gt;4&lt;/span&gt;\\n    &lt;span&gt;5&lt;/span&gt;\\n    &lt;span&gt;6&lt;/span&gt;\\n    &lt;span&gt;7&lt;/span&gt;\\n  &lt;/div&gt;\\n&lt;/html&gt;\\n&lt;st\"},{\"url\":\"/02.页面/20.CSS/03.flex布局案例-骰子.html\",\"relativePath\":\"/02.页面/20.CSS/03.flex布局案例-骰子.html\",\"frontmatter\":{\"title\":\"flex布局案例-骰子\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/eff61bc8b4f4695d\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"flex布局案例-骰子\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```html\\n&lt;html&gt;\\n  &lt;div class=\\\"box2\\\"&gt;\\n    &lt;div class=\\\"first-face\\\"&gt;\\n      &lt;span class=\\\"pip\\\"&gt;&lt;/span&gt;\\n    &lt;/div&gt;\\n    &lt;div class=\\\"second-face\\\"&gt;\\n      &lt;span class=\\\"pip\\\"&gt;&lt;/span&gt;\\n      &lt;span class=\\\"pip\\\"&gt;&lt;/span&gt;\\n    &lt;/div&gt;\\n    &lt;div cla\"},{\"url\":\"/02.页面/20.CSS/04.flex布局案例-圣杯布局.html\",\"relativePath\":\"/02.页面/20.CSS/04.flex布局案例-圣杯布局.html\",\"frontmatter\":{\"title\":\"flex布局案例-圣杯布局\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/df9e7c7214fa5046\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"flex布局案例-圣杯布局\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```html\\n&lt;html&gt;\\n  &lt;div class=\\\"HolyGrail\\\"&gt;\\n    &lt;header&gt;header&lt;/header&gt;\\n    &lt;div class=\\\"wrap\\\"&gt;\\n      &lt;nav class=\\\"left\\\"&gt;left 宽度固定200px&lt;/nav&gt;\\n      &lt;main class=\\\"content\\\"&gt;center 宽度自适应&lt;/main&gt;\\n      &lt;aside class=\\\"right\\\"&gt;right 宽度固定200px&lt;/aside&gt\"},{\"url\":\"/02.页面/20.CSS/05.flex布局案例-网格布局.html\",\"relativePath\":\"/02.页面/20.CSS/05.flex布局案例-网格布局.html\",\"frontmatter\":{\"title\":\"flex布局案例-网格布局\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/85b5a3fe218a34b7\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"flex布局案例-网格布局\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```html\\n&lt;html&gt;\\n  &lt;div class=\\\"grid\\\"&gt;\\n    &lt;div class=\\\"grid-cell\\\"&gt;1/2&lt;/div&gt;\\n    &lt;div class=\\\"grid-cell\\\"&gt;1/2&lt;/div&gt;\\n  &lt;/div&gt;\\n  &lt;div class=\\\"grid\\\"&gt;\\n    &lt;div class=\\\"grid-cell\\\"&gt;1/3&lt;/div&gt;\\n    &lt;div class=\\\"grid-cell\\\"&gt;1/3&lt;/div&gt;\\n    &lt;div cl\"},{\"url\":\"/02.页面/20.CSS/06.flex布局案例-输入框布局.html\",\"relativePath\":\"/02.页面/20.CSS/06.flex布局案例-输入框布局.html\",\"frontmatter\":{\"title\":\"flex布局案例-输入框布局\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/05cc577fb51c7998\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"flex布局案例-输入框布局\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```html\\n&lt;html&gt;\\n  &lt;div class=\\\"InputAddOn\\\"&gt;\\n    &lt;span class=\\\"InputAddOn-item\\\"&gt;icon&lt;/span&gt;\\n    &lt;input class=\\\"InputAddOn-field\\\" placeholder=\\\"input宽度自适应\\\"&gt;\\n    &lt;button class=\\\"InputAddOn-item\\\"&gt;提交&lt;/button&gt;\\n  &lt;/div&gt;\\n  &lt;br/&gt;\\n  &lt;div class=\\\"Media\\\"&gt;\\n   \"},{\"url\":\"/02.页面/20.CSS/07.CSS3之transition过渡.html\",\"relativePath\":\"/02.页面/20.CSS/07.CSS3之transition过渡.html\",\"frontmatter\":{\"title\":\"CSS3之transition过渡\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/02d7f59d98d87409\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"CSS3之transition过渡\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"html结构\\n```html\\n&lt;div class=\\\"box1\\\"\\n  &lt;div class=\\\"div1\\\"&gt;&lt;/div&gt;\\n  &lt;div class=\\\"div2\\\"&gt;&lt;/div&gt;\\n  &lt;div class=\\\"div3\\\"&gt;&lt;/div&gt;\\n&lt;/div&gt;\\n```\\n先给元素设置transition过渡，指定样式和时间，这里设置all全部样式都采用0.3s的过渡\\n```css\\n.box1&gt;div{\\n  /* 给元素所有变化都添加过渡动画, 也可以指定唯一的过渡样式属性*/\\n  transition: all .3s;\"},{\"url\":\"/02.页面/20.CSS/08.CSS3之animation动画.html\",\"relativePath\":\"/02.页面/20.CSS/08.CSS3之animation动画.html\",\"frontmatter\":{\"title\":\"CSS3之animation动画\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/c2c0432138f6e042\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"CSS3之animation动画\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"```html\\n&lt;html&gt;\\n  &lt;div class=\\\"animationBox\\\"&gt;\\n    &lt;div class=\\\"rotate\\\"&gt;旋转动画1&lt;/div&gt;\\n    &lt;div class=\\\"play\\\"&gt;\\n      &lt;div class=\\\"img\\\"&gt;旋转动画2&lt;/div&gt;\\n      &lt;span&gt;&lt;p class=\\\"p2\\\"&gt;&lt;/p&gt;&lt;/span&gt;\\n      &lt;span&gt;&lt;p&gt;&lt;/p&gt;&lt;/span&gt;\\n      &\"}],\"技术\":[{\"url\":\"/03.技术/01.技术文档/20.Git修改分支名.html\",\"relativePath\":\"/03.技术/01.技术文档/20.Git修改分支名.html\",\"frontmatter\":{\"title\":\"Git修改分支名\",\"date\":\"2022-08-11 10:51:18\",\"permalink\":\"/pages/922650/\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git修改分支名\",\"date\":\"2022-08-11 10:51:18\",\"capture\":\"同时修改本地分支名和对应的远程分支名\\n修改前要确保本地分支的代码是最新的，并且修改后不会影响到同事的代码。\\n1. 修改本地分支名\\n```sh\\ngit branch -m oldBranchName newBranchName\\n```\\n2. 删除远程分支\\n```sh\\ngit push origin :oldBranchName\\n 或者 git push origin --delete oldBranchName\\n```\\n3. 改名后的本地分支推送到远程\\n```sh\\ngit push --set-upstream origin newBranchName\\n```\"},{\"url\":\"/03.技术/01.技术文档/10.npm packageJson属性详解.html\",\"relativePath\":\"/03.技术/01.技术文档/10.npm packageJson属性详解.html\",\"frontmatter\":{\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"npm packageJson属性详解\",\"date\":\"2020-04-08 17:16:38\",\"permalink\":\"/pages/dec4f3f00e71a312\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null]},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"npm packageJson属性详解\",\"date\":\"2020-04-08 17:16:38\",\"excerpt\":\"<h1 id=\\\"npm-package-json属性详解\\\" tabindex=\\\"-1\\\">npm package.json属性详解 <a class=\\\"header-anchor\\\" href=\\\"#npm-package-json属性详解\\\" aria-label=\\\"Permalink to &quot;npm package.json属性详解&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<blockquote>\\n<p>本文转自<a href=\\\"https://www.cnblogs.com/tzyy/p/5193811.html\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">https://www.cnblogs.com/tzyy/p/5193811.html</a>，作者：TZYY</p>\\n</blockquote>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p><code>package.json</code>必须是一个严格的json文件，而不仅仅是js里边的一个对象。其中很多属性可以通过<code>npm-config</code>来生成</p>\\n\",\"capture\":\"npm package.json属性详解\\n\\n 概述\\n`package.json`必须是一个严格的json文件，而不仅仅是js里边的一个对象。其中很多属性可以通过`npm-config`来生成\\n name\\n`package.json`中最重要的属性是`name`和`version`两个属性，这两个属性是必须要有的，否则模块就无法被安装，这两个属性一起形成了一个npm模块的唯一标识符。模块中内容变更的同时，模块版本也应该一起变化。\\n`name`属性就是你的模块名称，下面是一些命名规则:\\n- `name`必须小于等于214个字节，包括前缀名称在内（如 xxx/xxxmodule）。\\n- `name`\"},{\"url\":\"/03.技术/03.博客搭建/03.GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床.html\",\"relativePath\":\"/03.技术/03.博客搭建/03.GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床.html\",\"frontmatter\":{\"title\":\"GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床\",\"date\":\"2020-01-03 12:55:43\",\"permalink\":\"/pages/a5f73af5185fdf0a\",\"categories\":[\"技术\",\"博客搭建\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床\",\"date\":\"2020-01-03 12:55:43\",\"excerpt\":\"<h1 id=\\\"github-jsdelivr-tinypng-picgo-打造稳定快速、高效免费图床\\\" tabindex=\\\"-1\\\">GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床 <a class=\\\"header-anchor\\\" href=\\\"#github-jsdelivr-tinypng-picgo-打造稳定快速、高效免费图床\\\" aria-label=\\\"Permalink to &quot;GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"前言\\\" tabindex=\\\"-1\\\">前言 <a class=\\\"header-anchor\\\" href=\\\"#前言\\\" aria-label=\\\"Permalink to &quot;前言&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p><strong>Q：为什么要使用图床呢？什么是图床？</strong></p>\\n<p>A：写博客文章时，图片的上传和存放是一个问题，有的朋友可能会把图片放到和博客同一个仓库当中，使用相对路径来引用，这样后期维护起来会比较麻烦。还有的朋友会在不同的平台发布同一篇文章，这样一来每个平台都要上传图片，为了解决这些问题，比较推荐的做法是把图片统一上传到一个在线的第三方静态资源库中，我们把这个资源库称为图床，其返回一个图片的URL，使用<code>markdown+图片url</code>的方式写作文章，一次编写，到处使用~</p>\\n\",\"capture\":\"前言\\nQ：为什么要使用图床呢？什么是图床？\\nA：写博客文章时，图片的上传和存放是一个问题，有的朋友可能会把图片放到和博客同一个仓库当中，使用相对路径来引用，这样后期维护起来会比较麻烦。还有的朋友会在不同的平台发布同一篇文章，这样一来每个平台都要上传图片，为了解决这些问题，比较推荐的做法是把图片统一上传到一个在线的第三方静态资源库中，我们把这个资源库称为图床，其返回一个图片的URL，使用`markdown+图片url`的方式写作文章，一次编写，到处使用~\\n以下内容是比较旧的，现在我发现一个更好用，配置更方便的图床工具：&lt;https://picx.xpoet.cn/\\n使用方法看一下他网站的使\"},{\"url\":\"/03.技术/02.Nodejs/01.nodejs递归读取所有文件.html\",\"relativePath\":\"/03.技术/02.Nodejs/01.nodejs递归读取所有文件.html\",\"frontmatter\":{\"title\":\"nodejs递归读取所有文件\",\"date\":\"2019-12-26 15:57:32\",\"permalink\":\"/pages/117708e0af7f0bd9\",\"categories\":[\"技术\",\"Nodejs\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"nodejs递归读取所有文件\",\"date\":\"2019-12-26 15:57:32\",\"capture\":\"```js\\nvar fs = require('fs');\\nvar path = require('path');\\n \\nfunction readFileList(dir, filesList = []) {\\n    const files = fs.readdirSync(dir);\\n    console.log(files);\\n    files.forEach((item, index) =\\n        var fullPath = path.join(dir, item);\\n        const stat = fs.statSync(fullPath);\\n        i\"},{\"url\":\"/03.技术/01.技术文档/01.Git使用手册.html\",\"relativePath\":\"/03.技术/01.技术文档/01.Git使用手册.html\",\"frontmatter\":{\"title\":\"Git使用手册\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/9a7ee40fc232253e\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git使用手册\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"git使用手册\\\" tabindex=\\\"-1\\\">Git使用手册 <a class=\\\"header-anchor\\\" href=\\\"#git使用手册\\\" aria-label=\\\"Permalink to &quot;Git使用手册&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"安装\\\" tabindex=\\\"-1\\\">安装 <a class=\\\"header-anchor\\\" href=\\\"#安装\\\" aria-label=\\\"Permalink to &quot;安装&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>官网下载：<a href=\\\"https://git-scm.com/downloads\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">https://git-scm.com/downloads</a> 下载完成后使用默认进行安装。</p>\\n<p>安装完成后，在开始菜单里找到 <code>Git</code> -&gt; <code>Git Bash</code>，蹦出一个类似命令行窗口的东西，就说明Git安装成功！\\n还需要最后一步设置，在命令行输入：</p>\\n<div class=\\\"language-bash vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">bash</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">git</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> config</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> --global</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> user.name</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> \\\"Your Name\\\"</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">git</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> config</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> --global</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> user.email</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> \\\"email@example.com\\\"</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br></div></div><p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。</p>\\n\",\"capture\":\"Git使用手册\\n 安装\\n官网下载：&lt;https://git-scm.com/downloads\\n安装完成后，在开始菜单里找到 `Git` -&gt; `Git Bash`，蹦出一个类似命令行窗口的东西，就说明Git安装成功！\\n还需要最后一步设置，在命令行输入：\\n```bash\\ngit config --global user.name \\\"Your Name\\\"\\ngit config --global user.email \\\"email@example.com\\\"\\n```\\n因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。\\n 创建版本库（仓库）\\n```ba\"},{\"url\":\"/03.技术/01.技术文档/02.Markdown使用教程.html\",\"relativePath\":\"/03.技术/01.技术文档/02.Markdown使用教程.html\",\"frontmatter\":{\"title\":\"Markdown使用教程\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/ad247c4332211551\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Markdown使用教程\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"markdown使用教程\\\" tabindex=\\\"-1\\\">Markdown使用教程 <a class=\\\"header-anchor\\\" href=\\\"#markdown使用教程\\\" aria-label=\\\"Permalink to &quot;Markdown使用教程&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"一、markdown\\\" tabindex=\\\"-1\\\">一、Markdown <a class=\\\"header-anchor\\\" href=\\\"#一、markdown\\\" aria-label=\\\"Permalink to &quot;一、Markdown&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p><img src=\\\"https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/md_logo.png\\\" alt=\\\"logo\\\"></p>\\n<p><code>Markdown</code> 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>\\n\",\"capture\":\"一、Markdown\\n 简介\\n`Markdown` 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。\\n  应用\\n当前许多网站都广泛使用 `Markdown` 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、知乎等\\n 编辑器\\n推荐使用`Typora`，官网：&lt;https://typora.io/\\n 二、徽章\\n 什么是徽章\\n徽章是一种小巧精美的小图标，一般配有相关文字进行辅助说明，可对数据进行监控，链接跳转等，富有表现力。\\n常见于`github`项目主页，但其不仅出现于 `github` 项目主页，凡是能够表现图片的地方都可以出现徽章。\\n 徽章的使用\\n* 在\"},{\"url\":\"/03.技术/01.技术文档/03.npm常用命令.html\",\"relativePath\":\"/03.技术/01.技术文档/03.npm常用命令.html\",\"frontmatter\":{\"title\":\"npm常用命令\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/61f2f95fd7da14fd\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"npm常用命令\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"npm常用命令\\\" tabindex=\\\"-1\\\">npm常用命令 <a class=\\\"header-anchor\\\" href=\\\"#npm常用命令\\\" aria-label=\\\"Permalink to &quot;npm常用命令&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>npm是跟随node一起安装的包（模块）管理器。常见的使用场景有以下几种：</p>\\n<ul>\\n<li>允许用户从npm服务器下载别人编写的第三方包到本地使用。</li>\\n<li>允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用。</li>\\n<li>允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。</li>\\n</ul>\\n\",\"capture\":\"简介\\nnpm是跟随node一起安装的包（模块）管理器。常见的使用场景有以下几种：\\n* 允许用户从npm服务器下载别人编写的第三方包到本地使用。\\n* 允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用。\\n* 允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。\\n 常用命令\\n 检测是否安装及版本\\n```sh\\nnpm -v  显示版本号说明已经安装相应的版本\\n```\\n 生成package.json文件\\n```sh\\nnpm init\\n```\\n\\n 安装模块\\n```sh\\nnpm install  安装package.json定义好的模块，简写 npm i\\n 安装包指定模块\\nnpm \"},{\"url\":\"/03.技术/01.技术文档/15.yaml语言教程.html\",\"relativePath\":\"/03.技术/01.技术文档/15.yaml语言教程.html\",\"frontmatter\":{\"title\":\"yaml语言教程\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/4e8444e2d534d14f\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"yaml语言教程\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"yaml语言教程\\\" tabindex=\\\"-1\\\">yaml语言教程 <a class=\\\"header-anchor\\\" href=\\\"#yaml语言教程\\\" aria-label=\\\"Permalink to &quot;yaml语言教程&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>YAML 是 &quot;YAML Ain't a Markup Language&quot;（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：&quot;Yet Another Markup Language&quot;（仍是一种标记语言）。</p>\\n\",\"capture\":\"简介\\nYAML 是 \\\"YAML Ain't a Markup Language\\\"（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：\\\"Yet Another Markup Language\\\"（仍是一种标记语言）。\\nYAML 的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲（例如：许多电子邮件标题格式和YAML非常接近）。\\nYAML 的配置文件后缀为 .yml，如：runoob.yml 。\\n\\n 基本语法\\n- 大小写敏感\\n- 使用缩进\"},{\"url\":\"/03.技术/03.博客搭建/01.解决百度无法收录搭建在GitHub上的个人博客的问题.html\",\"relativePath\":\"/03.技术/03.博客搭建/01.解决百度无法收录搭建在GitHub上的个人博客的问题.html\",\"frontmatter\":{\"title\":\"解决百度无法收录搭建在GitHub上的个人博客的问题\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/41f87d890d0a02af\",\"categories\":[\"技术\",\"博客搭建\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"解决百度无法收录搭建在GitHub上的个人博客的问题\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"解决百度无法收录搭建在github上的静态博客的问题\\\" tabindex=\\\"-1\\\">解决百度无法收录搭建在GitHub上的静态博客的问题 <a class=\\\"header-anchor\\\" href=\\\"#解决百度无法收录搭建在github上的静态博客的问题\\\" aria-label=\\\"Permalink to &quot;解决百度无法收录搭建在GitHub上的静态博客的问题&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<div class=\\\"warning custom-block\\\"><p class=\\\"custom-block-title\\\">WARNING</p>\\n<p>如果你正在寻找本博客的搭建文档，博主建议您查看这个仓库的<a href=\\\"https://github.com/xugaoyi/vuepress-theme-vdoing\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">README</a>。</p>\\n</div>\\n<h2 id=\\\"背景\\\" tabindex=\\\"-1\\\">背景 <a class=\\\"header-anchor\\\" href=\\\"#背景\\\" aria-label=\\\"Permalink to &quot;背景&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>由于GitHub禁止百度爬虫访问，造成托管在GitHub Pages上的博客无法被百度收录。相关问题可以通过百度站长平台的<code>抓取诊断</code>再现，每次都是403 Forbidden的错误。</p>\\n\",\"capture\":\"如果你正在寻找本博客的搭建文档，博主建议您查看这个仓库的README。\\n 背景\\n由于GitHub禁止百度爬虫访问，造成托管在GitHub Pages上的博客无法被百度收录。相关问题可以通过百度站长平台的`抓取诊断`再现，每次都是403 Forbidden的错误。\\n 解决方案\\n同时将博客同时同步托管到GitHub Pages和coding pages上，解决百度不收录问题。最后发现在国内使用coding pages打开速度特别快，而且还会被百度收录，因此我把coding pages的站点作为主站点，原本在github pages的作为分站点。\\n步骤：\\n1、注册coding账号，创建仓库，把代码推\"},{\"url\":\"/03.技术/03.博客搭建/02.使用Gitalk实现静态博客无后台评论系统.html\",\"relativePath\":\"/03.技术/03.博客搭建/02.使用Gitalk实现静态博客无后台评论系统.html\",\"frontmatter\":{\"title\":\"使用Gitalk实现静态博客无后台评论系统\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/1da0bf9a988eafe5\",\"categories\":[\"技术\",\"博客搭建\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"使用Gitalk实现静态博客无后台评论系统\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"使用gitalk实现静态博客无后台评论系统\\\" tabindex=\\\"-1\\\">使用Gitalk实现静态博客无后台评论系统 <a class=\\\"header-anchor\\\" href=\\\"#使用gitalk实现静态博客无后台评论系统\\\" aria-label=\\\"Permalink to &quot;使用Gitalk实现静态博客无后台评论系统&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"前言\\\" tabindex=\\\"-1\\\">前言 <a class=\\\"header-anchor\\\" href=\\\"#前言\\\" aria-label=\\\"Permalink to &quot;前言&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>Gitalk，一个基于 Github Issue 和 Preact 开发的评论插件。</p>\\n<p>下面我们来用它在vuepress搭建的博客中搭建评论区吧</p>\\n\",\"capture\":\"前言\\nGitalk，一个基于 Github Issue 和 Preact 开发的评论插件。\\n下面我们来用它在vuepress搭建的博客中搭建评论区吧\\n 准备\\n使用一个新的东西首先当然是要了解它\\nGitalk demo：&lt;https://gitalk.github.io/\\nGitalk github：&lt;https://github.com/gitalk/gitalk&gt;\\n 实现\\n如何实现？最好的方法我认为是看官方文档，这里我只是记录一下实现的步骤。\\n使用一个别人已经开发好的 vuepress-plugin-comment 插件来帮助我们把Gitalk应用到vuepress搭建的静\"}],\"技术文档\":[{\"url\":\"/03.技术/01.技术文档/20.Git修改分支名.html\",\"relativePath\":\"/03.技术/01.技术文档/20.Git修改分支名.html\",\"frontmatter\":{\"title\":\"Git修改分支名\",\"date\":\"2022-08-11 10:51:18\",\"permalink\":\"/pages/922650/\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git修改分支名\",\"date\":\"2022-08-11 10:51:18\",\"capture\":\"同时修改本地分支名和对应的远程分支名\\n修改前要确保本地分支的代码是最新的，并且修改后不会影响到同事的代码。\\n1. 修改本地分支名\\n```sh\\ngit branch -m oldBranchName newBranchName\\n```\\n2. 删除远程分支\\n```sh\\ngit push origin :oldBranchName\\n 或者 git push origin --delete oldBranchName\\n```\\n3. 改名后的本地分支推送到远程\\n```sh\\ngit push --set-upstream origin newBranchName\\n```\"},{\"url\":\"/03.技术/01.技术文档/10.npm packageJson属性详解.html\",\"relativePath\":\"/03.技术/01.技术文档/10.npm packageJson属性详解.html\",\"frontmatter\":{\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"npm packageJson属性详解\",\"date\":\"2020-04-08 17:16:38\",\"permalink\":\"/pages/dec4f3f00e71a312\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null]},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"npm packageJson属性详解\",\"date\":\"2020-04-08 17:16:38\",\"excerpt\":\"<h1 id=\\\"npm-package-json属性详解\\\" tabindex=\\\"-1\\\">npm package.json属性详解 <a class=\\\"header-anchor\\\" href=\\\"#npm-package-json属性详解\\\" aria-label=\\\"Permalink to &quot;npm package.json属性详解&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<blockquote>\\n<p>本文转自<a href=\\\"https://www.cnblogs.com/tzyy/p/5193811.html\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">https://www.cnblogs.com/tzyy/p/5193811.html</a>，作者：TZYY</p>\\n</blockquote>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p><code>package.json</code>必须是一个严格的json文件，而不仅仅是js里边的一个对象。其中很多属性可以通过<code>npm-config</code>来生成</p>\\n\",\"capture\":\"npm package.json属性详解\\n\\n 概述\\n`package.json`必须是一个严格的json文件，而不仅仅是js里边的一个对象。其中很多属性可以通过`npm-config`来生成\\n name\\n`package.json`中最重要的属性是`name`和`version`两个属性，这两个属性是必须要有的，否则模块就无法被安装，这两个属性一起形成了一个npm模块的唯一标识符。模块中内容变更的同时，模块版本也应该一起变化。\\n`name`属性就是你的模块名称，下面是一些命名规则:\\n- `name`必须小于等于214个字节，包括前缀名称在内（如 xxx/xxxmodule）。\\n- `name`\"},{\"url\":\"/03.技术/01.技术文档/01.Git使用手册.html\",\"relativePath\":\"/03.技术/01.技术文档/01.Git使用手册.html\",\"frontmatter\":{\"title\":\"Git使用手册\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/9a7ee40fc232253e\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git使用手册\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"git使用手册\\\" tabindex=\\\"-1\\\">Git使用手册 <a class=\\\"header-anchor\\\" href=\\\"#git使用手册\\\" aria-label=\\\"Permalink to &quot;Git使用手册&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"安装\\\" tabindex=\\\"-1\\\">安装 <a class=\\\"header-anchor\\\" href=\\\"#安装\\\" aria-label=\\\"Permalink to &quot;安装&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>官网下载：<a href=\\\"https://git-scm.com/downloads\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">https://git-scm.com/downloads</a> 下载完成后使用默认进行安装。</p>\\n<p>安装完成后，在开始菜单里找到 <code>Git</code> -&gt; <code>Git Bash</code>，蹦出一个类似命令行窗口的东西，就说明Git安装成功！\\n还需要最后一步设置，在命令行输入：</p>\\n<div class=\\\"language-bash vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">bash</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">git</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> config</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> --global</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> user.name</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> \\\"Your Name\\\"</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">git</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> config</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> --global</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> user.email</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> \\\"email@example.com\\\"</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br></div></div><p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。</p>\\n\",\"capture\":\"Git使用手册\\n 安装\\n官网下载：&lt;https://git-scm.com/downloads\\n安装完成后，在开始菜单里找到 `Git` -&gt; `Git Bash`，蹦出一个类似命令行窗口的东西，就说明Git安装成功！\\n还需要最后一步设置，在命令行输入：\\n```bash\\ngit config --global user.name \\\"Your Name\\\"\\ngit config --global user.email \\\"email@example.com\\\"\\n```\\n因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。\\n 创建版本库（仓库）\\n```ba\"},{\"url\":\"/03.技术/01.技术文档/02.Markdown使用教程.html\",\"relativePath\":\"/03.技术/01.技术文档/02.Markdown使用教程.html\",\"frontmatter\":{\"title\":\"Markdown使用教程\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/ad247c4332211551\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Markdown使用教程\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"markdown使用教程\\\" tabindex=\\\"-1\\\">Markdown使用教程 <a class=\\\"header-anchor\\\" href=\\\"#markdown使用教程\\\" aria-label=\\\"Permalink to &quot;Markdown使用教程&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"一、markdown\\\" tabindex=\\\"-1\\\">一、Markdown <a class=\\\"header-anchor\\\" href=\\\"#一、markdown\\\" aria-label=\\\"Permalink to &quot;一、Markdown&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p><img src=\\\"https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/md_logo.png\\\" alt=\\\"logo\\\"></p>\\n<p><code>Markdown</code> 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>\\n\",\"capture\":\"一、Markdown\\n 简介\\n`Markdown` 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。\\n  应用\\n当前许多网站都广泛使用 `Markdown` 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、知乎等\\n 编辑器\\n推荐使用`Typora`，官网：&lt;https://typora.io/\\n 二、徽章\\n 什么是徽章\\n徽章是一种小巧精美的小图标，一般配有相关文字进行辅助说明，可对数据进行监控，链接跳转等，富有表现力。\\n常见于`github`项目主页，但其不仅出现于 `github` 项目主页，凡是能够表现图片的地方都可以出现徽章。\\n 徽章的使用\\n* 在\"},{\"url\":\"/03.技术/01.技术文档/03.npm常用命令.html\",\"relativePath\":\"/03.技术/01.技术文档/03.npm常用命令.html\",\"frontmatter\":{\"title\":\"npm常用命令\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/61f2f95fd7da14fd\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"npm常用命令\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"npm常用命令\\\" tabindex=\\\"-1\\\">npm常用命令 <a class=\\\"header-anchor\\\" href=\\\"#npm常用命令\\\" aria-label=\\\"Permalink to &quot;npm常用命令&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>npm是跟随node一起安装的包（模块）管理器。常见的使用场景有以下几种：</p>\\n<ul>\\n<li>允许用户从npm服务器下载别人编写的第三方包到本地使用。</li>\\n<li>允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用。</li>\\n<li>允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。</li>\\n</ul>\\n\",\"capture\":\"简介\\nnpm是跟随node一起安装的包（模块）管理器。常见的使用场景有以下几种：\\n* 允许用户从npm服务器下载别人编写的第三方包到本地使用。\\n* 允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用。\\n* 允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。\\n 常用命令\\n 检测是否安装及版本\\n```sh\\nnpm -v  显示版本号说明已经安装相应的版本\\n```\\n 生成package.json文件\\n```sh\\nnpm init\\n```\\n\\n 安装模块\\n```sh\\nnpm install  安装package.json定义好的模块，简写 npm i\\n 安装包指定模块\\nnpm \"},{\"url\":\"/03.技术/01.技术文档/15.yaml语言教程.html\",\"relativePath\":\"/03.技术/01.技术文档/15.yaml语言教程.html\",\"frontmatter\":{\"title\":\"yaml语言教程\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/4e8444e2d534d14f\",\"categories\":[\"技术\",\"技术文档\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"yaml语言教程\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"yaml语言教程\\\" tabindex=\\\"-1\\\">yaml语言教程 <a class=\\\"header-anchor\\\" href=\\\"#yaml语言教程\\\" aria-label=\\\"Permalink to &quot;yaml语言教程&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>YAML 是 &quot;YAML Ain't a Markup Language&quot;（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：&quot;Yet Another Markup Language&quot;（仍是一种标记语言）。</p>\\n\",\"capture\":\"简介\\nYAML 是 \\\"YAML Ain't a Markup Language\\\"（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：\\\"Yet Another Markup Language\\\"（仍是一种标记语言）。\\nYAML 的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲（例如：许多电子邮件标题格式和YAML非常接近）。\\nYAML 的配置文件后缀为 .yml，如：runoob.yml 。\\n\\n 基本语法\\n- 大小写敏感\\n- 使用缩进\"}],\"学习笔记\":[{\"url\":\"/01.前端/40.学习笔记/50.JS设计模式总结笔记.html\",\"relativePath\":\"/01.前端/40.学习笔记/50.JS设计模式总结笔记.html\",\"frontmatter\":{\"title\":\"JS设计模式总结笔记\",\"date\":\"2021-02-27 20:01:18\",\"permalink\":\"/pages/4643cd/\",\"categories\":[\"前端\",\"学习笔记\"],\"tags\":[\"设计模式\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"JS设计模式总结笔记\",\"date\":\"2021-02-27 20:01:18\",\"capture\":\"开篇：前端工程师的成长论\\n能够决定一个前端工程师的本质的，不是那些瞬息万变的技术点，而是那些不变的东西。\\n所谓“不变的东西”，就是驾驭技术的能力。\\n具体来说，它分为以下三个层次：\\n- 能用健壮的代码去解决具体的问题；\\n- 能用抽象的思维去应对复杂的系统；\\n- 能用工程化的思想去规划更大规模的业务。\\n\\n 设计模式之“道”\\n- 设计模式是“拿来主义”。如使用数学公式，不会从头推导一个公式。\\n  核心思想\\n- 设计模式的核心思想——封装变化\\n- 保证可维护性、可扩展性。\\n- 将变与不变分离，确保变化的部分灵活，不变的部分稳定。——这就是所谓的“健壮”的代码。\\n 设计模式之“术”\\n即最经典的23种设计\"},{\"url\":\"/01.前端/40.学习笔记/35.TypeScript笔记.html\",\"relativePath\":\"/01.前端/40.学习笔记/35.TypeScript笔记.html\",\"frontmatter\":{\"title\":\"TypeScript笔记\",\"date\":\"2020-10-08 13:02:48\",\"permalink\":\"/pages/51afd6/\",\"categories\":[\"前端\",\"学习笔记\"],\"tags\":[\"TypeScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"TypeScript笔记\",\"date\":\"2020-10-08 13:02:48\",\"capture\":\"TypeScript 的类型校验是给程序员看的，在编译后不会存在TS代码。\\n 类型注解\\n```typescript\\nfunction fn(person: string):void{ // 参数类型是字符串，没有返回值\\n    ///...\\n}\\nfn('str') // 如传递参数非字符串，vscode编辑器中或在编译时将给出错误提示\\nconst test:number = 1\\n```\\n 有哪些基础类型注解？\\n```typescript\\n// 基础类型\\n:string\\n:number\\n:boolean\\n:null  // 只能是null值\\n:undefined // 只能是undefined值\"},{\"url\":\"/01.前端/40.学习笔记/40.小程序笔记.html\",\"relativePath\":\"/01.前端/40.学习笔记/40.小程序笔记.html\",\"frontmatter\":{\"title\":\"小程序笔记\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/note/wx-miniprogram/\",\"tags\":[\"小程序\"],\"categories\":[\"前端\",\"学习笔记\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"小程序笔记\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"小程序笔记\\n 基础课程部分\\n 微信公众平台\\n&lt;https://mp.weixin.qq.com/\\n注册时可选择类型：订阅号、服务号、小程序、企业微信\\n每个邮箱仅能注册一个小程序。\\n个人类型小程序：无法使用微信支付、无法使用卡包功能\\n 小程序文档API\\n小程序开发文档\\n 微信开放社区\\n微信开发社区\\n 目录说明\\n默认目录\\npages-----------------------页面相关\\n​\\tindex  ----------------- 首页文件夹\\n​\\t\\tindex.js ------------首页js\\n​\\t\\tindex.json---------首页配置\\n​\\t\\tindex.wxml--\"}],\"三级目录\":[{\"url\":\"/01.前端/25.JavaScript文章/1110.三级目录/00.四级文件.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/1110.三级目录/00.四级文件.html\",\"frontmatter\":{\"title\":\"四级文件(测试)\",\"date\":\"2020-12-11 11:15:53\",\"permalink\":\"/pages/8481d1/\",\"categories\":[\"前端\",\"JavaScript文章\",\"三级目录\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"四级文件(测试)\",\"date\":\"2020-12-11 11:15:53\",\"capture\":\"测试文件\\nTest Test\\n&lt;code-group\\n  &lt;code-block title=\\\"YARN\\\" active&gt;\\n  ```bash\\n  yarn create vuepress-site [optionalDirectoryName]\\n   OR npx create-vuepress-site [optionalDirectoryName]\\n  ```\\n  &lt;/code-block&gt;\\n  &lt;code-block title=\\\"NPM\\\"&gt;\\n  ```bash\\n  npx create-vuepress-site [optionalDirec\"}],\"Vuex\":[{\"url\":\"/《Vue》笔记/10.Vuex/01.Vuex.html\",\"relativePath\":\"/《Vue》笔记/10.Vuex/01.Vuex.html\",\"frontmatter\":{\"title\":\"Vuex\",\"date\":\"2020-08-08 10:38:33\",\"permalink\":\"/pages/b30620/\",\"categories\":[\"《Vue》笔记\",\"Vuex\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Vuex\",\"date\":\"2020-08-08 10:38:33\",\"capture\":\"Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。\\n Vuex使用过程演示\\n以`vue-cli3`新创建出来的项目为例，演示Vuex的使用过程。\\n创建项目:\\n```sh\\nvue create vuex-test\\ncd vuex-test\\nnpm run serve\\n```\\n安装`vuex`:\\n```bash\\nnpm i vuex -S\\n```\\n进入项目的`src/`下新建一个文件`store/index.js`，并写入：\\n```js\\n// store/index.js\\nimport Vue from 'vue'\\nimport Vuex from 'vuex'\\nVue.use(Vu\"}],\"学习\":[{\"url\":\"/04.更多/01.学习/00.费曼学习法.html\",\"relativePath\":\"/04.更多/01.学习/00.费曼学习法.html\",\"frontmatter\":{\"title\":\"费曼学习法\",\"date\":\"2020-07-16 10:04:14\",\"permalink\":\"/pages/f2a556/\",\"categories\":[\"更多\",\"学习\"],\"tags\":[\"学习方法\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"费曼学习法\",\"date\":\"2020-07-16 10:04:14\",\"capture\":\"步骤\\n费曼学习法分为4个步骤:\\n1. 确定学习目标\\n你想学习的概念、内容、主题是什么。\\n2. 模拟教学学习法\\n你要模拟自己是一位老师，面对完全不懂这个领域的人，用自己的话，尽可能具体形象地讲诉。这样的讲诉有助于你活学活用，触类旁通，联系生活具体情境。\\n3. 回顾\\n反思第2步遇到的问题，哪些地方卡壳了，哪些地方对方没有真正听懂。找出问题的要害，把握关键环节。\\n4. 简化\\n把这些遇到问题的地方，重新梳理理解，尽可能了解更多背景和相关知识，再用尽可能简化的方式重新表达，设法看穿本质。然后，返回第2步。\\n\\n&gt; \\n&gt; 《费曼学习法：为何被称为史上最牛的学习法，它的本质究竟是什么？》\\n&gt;\"},{\"url\":\"/04.更多/01.学习/10.搜索引擎使用技巧.html\",\"relativePath\":\"/04.更多/01.学习/10.搜索引擎使用技巧.html\",\"frontmatter\":{\"title\":\"搜索引擎使用技巧\",\"date\":\"2020-05-24 11:44:19\",\"permalink\":\"/pages/ce818a\",\"categories\":[\"更多\",\"学习\"],\"tags\":[\"搜索技巧\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"搜索引擎使用技巧\",\"date\":\"2020-05-24 11:44:19\",\"capture\":\"搜索引擎相信大家经常在使用，但是有时候想搜某个信息时却搜出来一大堆不相关的（百度：你们都在看我干什么？）。下面我们来介绍几种搜索技巧，可以提升搜索效率，助你快速查资料，妈妈再也不担心我的学习了（'妈~我真的是在找学习资料'）\\n 技巧1：排除干扰项\\n方式：关键词1+空格+减号+关键词2，即 `关键词1 -关键词2`\\n功能：排除一些不想要的关键词\\n示例：\\n```\\n锤子 -锤子手机\\n```\\n示例中将在搜索结果排除与`锤子手机`相关的，只显示`锤子`本来的样子。\\n\\n 技巧2：精确搜索\\n方式：给关键词加双引号，`\\\"关键词\\\"`\\n功能：只搜索引号里的字，少一个字或者把字拆开都不行\\n示例：\\n```\\n\\\"达拉不崩\"},{\"url\":\"/04.更多/01.学习/03.提高记忆的技巧.html\",\"relativePath\":\"/04.更多/01.学习/03.提高记忆的技巧.html\",\"frontmatter\":{\"title\":\"提高记忆的技巧\",\"date\":\"2020-01-03 14:34:48\",\"permalink\":\"/pages/996822b2a2ca6e3b\",\"categories\":[\"更多\",\"学习\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"提高记忆的技巧\",\"date\":\"2020-01-03 14:34:48\",\"excerpt\":\"<h1 id=\\\"提高记忆的技巧\\\" tabindex=\\\"-1\\\">提高记忆的技巧 <a class=\\\"header-anchor\\\" href=\\\"#提高记忆的技巧\\\" aria-label=\\\"Permalink to &quot;提高记忆的技巧&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<ol>\\n<li><strong>多个感官并用</strong>\\n记忆时调用一切感官。没人的话可以大声阅读，有人的话可以默念，轻微摇晃手指等，有助于保持专注。</li>\\n</ol>\\n\",\"capture\":\"1. 多个感官并用\\n   记忆时调用一切感官。没人的话可以大声阅读，有人的话可以默念，轻微摇晃手指等，有助于保持专注。\\n   \\n2. 重复记忆\\n   每天留出半个到一个小时，梳理总结今天所学的内容。每一章复习完成后做系统的知识整理。\\n   \\n3. 建立关联\\n   把你所学的新知识与已有的认知建立联系，对于记忆事半功倍。\\n   \\n4. 场景记忆\\n   把知识具象化为一个场景，想象自己在何时何地能用这些知识，与自身发生联系。\\n   \\n5. 提出问题\\n   每学习一个知识点，试着提问，然后给出答案。用了就记住了。\"}],\"笔记\":[{\"url\":\"/01.前端/40.学习笔记/05.《JavaScript高级程序设计》笔记.html\",\"relativePath\":\"/01.前端/40.学习笔记/05.《JavaScript高级程序设计》笔记.html\",\"frontmatter\":{\"title\":\"《JavaScript高级程序设计》笔记\",\"date\":\"2020-06-12 12:39:01\",\"permalink\":\"/note/js/\",\"categories\":[\"笔记\"],\"tags\":[\"笔记\",\"红宝书\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"《JavaScript高级程序设计》笔记\",\"date\":\"2020-06-12 12:39:01\",\"capture\":\"第1章  JavaScript简介\\n* JavaScript诞生于1995年\\n* 一个完整的JavaScript由这三部分组成：\\n  * ECMAScript (核心)\\n  * DOM (文档对象模型)\\n  * BOM (浏览器对象模型)\\n* ECMAScript的 宿主环境 包含 ：\\n  * 浏览器\\n  * Node\\n  * flash\\n* ECMAScript大致规定了下列组成部分：\\n  * 语法\\n  * 类型\\n  * 语句\\n  * 关键字\\n  * 保留字\\n  * 操作符\\n  * 对象\\n 第2章 在HTML中使用JavaScript\\n* `&lt;script\\n  * async 表示立即\"}],\"HTML\":[{\"url\":\"/02.页面/10.HTML/10.常用meta整理.html\",\"relativePath\":\"/02.页面/10.HTML/10.常用meta整理.html\",\"frontmatter\":{\"title\":\"常用meta整理\",\"date\":\"2020-02-21 12:20:10\",\"permalink\":\"/pages/8309a5b876fc95e3\",\"categories\":[\"页面\",\"HTML\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"常用meta整理\",\"date\":\"2020-02-21 12:20:10\",\"excerpt\":\"<h1 id=\\\"常用meta整理\\\" tabindex=\\\"-1\\\">常用meta整理 <a class=\\\"header-anchor\\\" href=\\\"#常用meta整理\\\" aria-label=\\\"Permalink to &quot;常用meta整理&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"meta-元素\\\" tabindex=\\\"-1\\\">&lt;meta&gt; 元素 <a class=\\\"header-anchor\\\" href=\\\"#meta-元素\\\" aria-label=\\\"Permalink to &quot;&lt;meta\\\\&gt; 元素&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"概要\\\" tabindex=\\\"-1\\\">概要 <a class=\\\"header-anchor\\\" href=\\\"#概要\\\" aria-label=\\\"Permalink to &quot;概要&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>meta标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。</p>\\n\",\"capture\":\"&lt;meta\\\\\\n 概要\\nmeta标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。\\n必要属性\\n| 属性    | 值        | 描述                                   |\\n| ------- | --------- | -------------------------------------- |\\n| content | some text | 定义与http-equiv或name属性相关的元信息 |\\n可选属性\\n| 属性     \"}],\"工具\":[{\"url\":\"/《Vue》笔记/05.工具/10.Vue CLi v3 创建项目使用记录.html\",\"relativePath\":\"/《Vue》笔记/05.工具/10.Vue CLi v3 创建项目使用记录.html\",\"frontmatter\":{\"title\":\"Vue CLi v3 创建项目使用记录\",\"date\":\"2020-02-20 17:24:29\",\"permalink\":\"/pages/d00311f8174119b2\",\"categories\":[\"《Vue》笔记\",\"工具\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Vue CLi v3 创建项目使用记录\",\"date\":\"2020-02-20 17:24:29\",\"capture\":\"官方文档\\n以下使用的CLi版本是 v3.11.0\\n vue create\\n1. 运行以下命令来创建一个新项目\\n```sh\\nvue create hello-world\\n```\\n2. 你会被提示选取一个 preset (预设)。你可以选默认的包含了基本的 Babel + ESLint 设置的 preset，也可以选“手动选择特性”来选取需要的特性。\\n```sh\\nVue CLI v3.11.0\\n? Please pick a preset: (Use arrow keys)\\n\\n  Manually select features (手动选择特性)\\n```\\n默认预设只包含Babel + ESLint\"}],\"可复用性&组合\":[{\"url\":\"/《Vue》笔记/04.可复用性&组合/01.Mixin混入.html\",\"relativePath\":\"/《Vue》笔记/04.可复用性&组合/01.Mixin混入.html\",\"frontmatter\":{\"title\":\"Mixin混入\",\"date\":\"2020-02-19 15:22:41\",\"permalink\":\"/pages/bd36a3c1bc3e0821\",\"categories\":[\"《Vue》笔记\",\"可复用性&组合\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Mixin混入\",\"date\":\"2020-02-19 15:22:41\",\"excerpt\":\"<h1 id=\\\"mixin混入\\\" tabindex=\\\"-1\\\">Mixin混入 <a class=\\\"header-anchor\\\" href=\\\"#mixin混入\\\" aria-label=\\\"Permalink to &quot;Mixin混入&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"基础\\\" tabindex=\\\"-1\\\">基础 <a class=\\\"header-anchor\\\" href=\\\"#基础\\\" aria-label=\\\"Permalink to &quot;基础&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。</p>\\n\",\"capture\":\"基础\\n混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。\\n\\n&gt;\\n&gt; 可通过 `this.$options` 查看选项\\n例子：\\n```js\\n// 定义一个混入对象\\nvar myMixin = {\\n  created: function () {\\n    this.hello()\\n  },\\n  methods: {\\n    hello: function () {\\n      console.log('hello from mixin!')\\n  \"}],\"组件\":[{\"url\":\"/《Vue》笔记/02.组件/90.vue父子组件的生命周期顺序.html\",\"relativePath\":\"/《Vue》笔记/02.组件/90.vue父子组件的生命周期顺序.html\",\"frontmatter\":{\"title\":\"vue父子组件的生命周期顺序\",\"date\":\"2020-02-18 16:39:33\",\"permalink\":\"/pages/e6cec47efa42d7f1\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"vue父子组件的生命周期顺序\",\"date\":\"2020-02-18 16:39:33\",\"capture\":\"加载渲染过程\\n```\\n父beforeCreate -\\n```\\n父组件会先执行到beforeMount，接着会执行子组件钩子到挂载结束，再挂载父组件。\\n 子组件更新过程\\n```\\n父beforeUpdate -&gt; 子beforeUpdate -&gt; 子updated -&gt; 父updated\\n```\\n 父组件更新过程\\n```\\n父beforeUpdate -&gt; 父updated\\n```\\n 销毁过程\\n```\\n父beforeDestroy -&gt; 子beforeDestroy -&gt; 子destroyed -&gt; 父destroyed\\n```\"},{\"url\":\"/《Vue》笔记/02.组件/80.动态组件与 v-once 指令.html\",\"relativePath\":\"/《Vue》笔记/02.组件/80.动态组件与 v-once 指令.html\",\"frontmatter\":{\"title\":\"动态组件与 v-once 指令\",\"date\":\"2020-02-16 15:52:19\",\"permalink\":\"/pages/636ca33122e9a64b\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"动态组件与 v-once 指令\",\"date\":\"2020-02-16 15:52:19\",\"capture\":\"动态组件\\n```html\\n&lt;div id=\\\"root\\\"\\n\\t&lt;component :is=\\\"type\\\"&gt;&lt;/component&gt; &lt;!--其效果如同下面两行被注释的代码--&gt;\\n\\t&lt;!-- &lt;child-one v-if=\\\"type === 'child-one'\\\"&gt;&lt;/child-one&gt;\\n\\t    &lt;child-two v-if=\\\"type === 'child-two'\\\"&gt;&lt;/child-two&gt; --&gt;\\n\\t&lt;button @click=\\\"handleClick\\\"&gt;change&\"},{\"url\":\"/《Vue》笔记/02.组件/75.插槽slot.html\",\"relativePath\":\"/《Vue》笔记/02.组件/75.插槽slot.html\",\"frontmatter\":{\"title\":\"插槽slot\",\"date\":\"2020-02-16 11:46:27\",\"permalink\":\"/pages/055ecee9a4325386\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"插槽slot\",\"date\":\"2020-02-16 11:46:27\",\"capture\":\"API\\n 插槽\\n```html\\n&lt;div id=\\\"root\\\"\\n    &lt;child&gt; &lt;!-- 组件标签 --&gt;\\n        &lt;h1&gt;hello&lt;/h1&gt;\\n    &lt;/child&gt;\\n&lt;/div&gt;\\n&lt;script type=\\\"text/javascript\\\"&gt;\\n    Vue.component('child', { // 子组件\\n        template: '&lt;div&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;'\\n    })\\n    var vm \"},{\"url\":\"/《Vue》笔记/02.组件/65.非父子组件传值.html\",\"relativePath\":\"/《Vue》笔记/02.组件/65.非父子组件传值.html\",\"frontmatter\":{\"title\":\"非父子组件传值\",\"date\":\"2020-02-15 14:55:03\",\"permalink\":\"/pages/d408e64f666f146d\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"非父子组件传值\",\"date\":\"2020-02-15 14:55:03\",\"excerpt\":\"<h1 id=\\\"非父子组件间传值\\\" tabindex=\\\"-1\\\">非父子组件间传值 <a class=\\\"header-anchor\\\" href=\\\"#非父子组件间传值\\\" aria-label=\\\"Permalink to &quot;非父子组件间传值&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>当组件的嵌套多时，非父子组件间传值就显得复杂，除了使用<a href=\\\"https://vuex.vuejs.org/zh/\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">vuex</a>实现之外，还可以通过Bus（或者叫 总线/发布订阅模式/观察者模式）的方式实现非父子组件间传值。</p>\\n\",\"capture\":\"当组件的嵌套多时，非父子组件间传值就显得复杂，除了使用vuex实现之外，还可以通过Bus（或者叫 总线/发布订阅模式/观察者模式）的方式实现非父子组件间传值。\\n&lt;div id=\\\"root\\\"\\n\\t\\t&lt;child1 content=\\\"组件1：点我传出值\\\"&gt;&lt;/child1&gt;\\n\\t\\t&lt;child2 content=\\\"组件2\\\"&gt;&lt;/child2&gt;\\n\\t&lt;/div&gt;\\n```html\\n&lt;div id=\\\"root\\\"&gt;\\n    &lt;child1 content=\\\"组件1：点我传出值\\\"&gt;&lt;/child1&gt;\\n    &l\"},{\"url\":\"/《Vue》笔记/02.组件/55.自定义事件.html\",\"relativePath\":\"/《Vue》笔记/02.组件/55.自定义事件.html\",\"frontmatter\":{\"title\":\"自定义事件\",\"date\":\"2020-02-15 11:27:45\",\"permalink\":\"/pages/9651417d08d1779d\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"自定义事件\",\"date\":\"2020-02-15 11:27:45\",\"capture\":\"API\\n 在组件标签v-on绑定的事件是自定义事件\\n```html\\n&lt;div id=\\\"root\\\"\\n    &lt;child @click=\\\"handleClick\\\"&gt;&lt;/child&gt; &lt;!--这里click是自定义事件--&gt;\\n&lt;/div&gt;\\n&lt;script type=\\\"text/javascript\\\"&gt;\\n    Vue.component('child', {\\n        template: '&lt;button&gt;Child&lt;/button&gt;',\\n    })\\n    var vm = new Vue({\\n  \"},{\"url\":\"/《Vue》笔记/02.组件/52.Prop 验证 与 非 Prop 的 Attribute.html\",\"relativePath\":\"/《Vue》笔记/02.组件/52.Prop 验证 与 非 Prop 的 Attribute.html\",\"frontmatter\":{\"title\":\"Prop 验证 与 非 Prop 的 Attribute\",\"date\":\"2020-02-15 10:49:04\",\"permalink\":\"/pages/a3080f60f6596eb4\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Prop 验证 与 非 Prop 的 Attribute\",\"date\":\"2020-02-15 10:49:04\",\"capture\":\"Prop 验证\\nAPI\\n子组件对父组件传递来的参数进行校验\\n```js\\nVue.component('my-component', {\\n  props: {\\n    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)\\n    propA: Number,\\n    // 多个可能的类型\\n    propB: [String, Number],\\n    // 必填的字符串\\n    propC: {\\n      type: String,\\n      required: true\\n    },\\n    // 带有默认值的数字\\n    propD: {\\n      \"},{\"url\":\"/《Vue》笔记/02.组件/36.使用组件的细节点.html\",\"relativePath\":\"/《Vue》笔记/02.组件/36.使用组件的细节点.html\",\"frontmatter\":{\"title\":\"使用组件的细节点\",\"date\":\"2020-02-13 13:26:20\",\"permalink\":\"/pages/83a1ab785e7fd70c\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"使用组件的细节点\",\"date\":\"2020-02-13 13:26:20\",\"capture\":\"解析 DOM 模板时的注意事项\\n```html\\n&lt;div id=\\\"root\\\"\\n    &lt;table&gt;\\n        &lt;tbody&gt;\\n            &lt;row&gt;&lt;/row&gt;\\n            &lt;row&gt;&lt;/row&gt;\\n            &lt;row&gt;&lt;/row&gt;\\n        &lt;/tbody&gt;\\n    &lt;/table&gt;\\n&lt;/div&gt;\\n&lt;script type=\\\"text/javascript\\\"&gt;\\n    Vue.component\"},{\"url\":\"/《Vue》笔记/02.组件/70.父组件调用子组件方法并传入值.html\",\"relativePath\":\"/《Vue》笔记/02.组件/70.父组件调用子组件方法并传入值.html\",\"frontmatter\":{\"title\":\"父组件调用子组件方法并传入值\",\"date\":\"2020-02-04 13:06:37\",\"permalink\":\"/pages/2e24dab728769e0c\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"父组件调用子组件方法并传入值\",\"date\":\"2020-02-04 13:06:37\",\"capture\":\"通过`ref`引用调用子组件内的方法并传入参数\\n父组件：\\n```js\\n&lt;子组件标签  ref=\\\"refName\\\"\\nmethods: {\\n    fnX(x) {\\n      this.$refs.refName.fnY(x) // 调用子组件方法并传入值\\n    }\\n}\\n```\\n子组件：\\n```js\\nmethods: {\\n    fnY(x) {\\n      this.x = x\\n    }\\n  }\\n}\\n```\"},{\"url\":\"/《Vue》笔记/02.组件/60.兄弟组件传值.html\",\"relativePath\":\"/《Vue》笔记/02.组件/60.兄弟组件传值.html\",\"frontmatter\":{\"title\":\"兄弟组件传值\",\"date\":\"2020-02-04 13:04:32\",\"permalink\":\"/pages/809f4582d9ca9552\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"兄弟组件传值\",\"date\":\"2020-02-04 13:04:32\",\"capture\":\"子组件1中把值传到父组件,父组件获取值传入子组件2\\n父组件：\\n```js\\n&lt;子组件1 @方法名x=\\\"方法名y\\\"\\n&lt;子组件2 :值名称x=\\\"值x\\\"&gt;&lt;/子组件2 &gt;\\ndata() {\\n\\treturn {\\n\\t 值x: ''\\n\\t}\\n},\\nmethods: {\\n\\t方法名y(值) {\\n\\t\\tthis.值x = 值\\n\\t}\\n}\\n```\\n子组件1：\\n```js\\nthis.$emit('方法名x', 值) // 传出值\\n```\\n子组件2：\\n```js\\nprops: {\\n    值名称x: { // 接收父组件传入值\\n        type: String,\\n        defa\"},{\"url\":\"/《Vue》笔记/02.组件/50.子组件派发事件和值给父组件.html\",\"relativePath\":\"/《Vue》笔记/02.组件/50.子组件派发事件和值给父组件.html\",\"frontmatter\":{\"title\":\"子组件派发事件和值给父组件\",\"date\":\"2020-02-04 12:56:51\",\"permalink\":\"/pages/0f19a1bcac14fd41\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"子组件派发事件和值给父组件\",\"date\":\"2020-02-04 12:56:51\",\"excerpt\":\"<h1 id=\\\"子组件派发事件和值给父组件\\\" tabindex=\\\"-1\\\">子组件派发事件和值给父组件 <a class=\\\"header-anchor\\\" href=\\\"#子组件派发事件和值给父组件\\\" aria-label=\\\"Permalink to &quot;子组件派发事件和值给父组件&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/components.html#%E7%9B%91%E5%90%AC%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">API</a></p>\\n<p>子组件通过<code>$emit</code>派发事件和值给父组件（值可以有多个）</p>\\n<div class=\\\"language-js vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">js</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">this</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">$emit</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'fnX'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, value)</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br></div></div>\",\"capture\":\"API\\n子组件通过`$emit`派发事件和值给父组件（值可以有多个）\\n```js\\nthis.$emit('fnX', value)\\n```\\n父组件通过`v-on`绑定子组件派发的事件，并触发一个新的事件，新的事件内可以接收传来的值\\n```js\\n&lt;ComponentName @fnX=\\\"fnY\\\"\\nmethods: {\\n\\tfnY(value) {\\n\\t\\tconsole.log(value)\\n\\t}\\n}\\n```\\n 父子组件间传递数据 demo\\n&lt;p class=\\\"codepen\\\" data-height=\\\"400\\\" data-theme-id=\\\"light\\\" data-default-tab\"},{\"url\":\"/《Vue》笔记/02.组件/40.父组件给子组件传值.html\",\"relativePath\":\"/《Vue》笔记/02.组件/40.父组件给子组件传值.html\",\"frontmatter\":{\"title\":\"父组件给子组件传值\",\"date\":\"2020-02-04 12:45:30\",\"permalink\":\"/pages/07b384c2e6232e07\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"父组件给子组件传值\",\"date\":\"2020-02-04 12:45:30\",\"excerpt\":\"<h1 id=\\\"父组件给子组件传值\\\" tabindex=\\\"-1\\\">父组件给子组件传值 <a class=\\\"header-anchor\\\" href=\\\"#父组件给子组件传值\\\" aria-label=\\\"Permalink to &quot;父组件给子组件传值&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>父组件中，通过给子组件标签v-bind绑定属性的方式传入值</p>\\n<div class=\\\"language-html vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">html</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">&#x3C;</span><span style=\\\"--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic\\\">ComponentName</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> v-bind:name</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"value\\\"</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">>&#x3C;/</span><span style=\\\"--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic\\\">ComponentName</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">></span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br></div></div><blockquote>\\n<p>如果不使用v-bind传入的值为字符串，使用v-bind绑定传入的值为表达式。</p>\\n</blockquote>\\n\",\"capture\":\"父组件中，通过给子组件标签v-bind绑定属性的方式传入值\\n```html\\n&lt;ComponentName v-bind:name=\\\"value\\\"\\n```\\n&gt; 如果不使用v-bind传入的值为字符串，使用v-bind绑定传入的值为表达式。\\n子组件中，通过props对象接收值\\n```js\\n props: {\\n    name: { // 接收父组件传入值\\n        type: String || ...,\\n        default: ''\\n    }\\n }\\n```\\n 单向数据流\\n所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向\"}],\"过渡&动画\":[{\"url\":\"/《Vue》笔记/03.过渡&动画/112.使用animate库.html\",\"relativePath\":\"/《Vue》笔记/03.过渡&动画/112.使用animate库.html\",\"frontmatter\":{\"title\":\"使用animate库\",\"date\":\"2020-02-17 16:05:52\",\"permalink\":\"/pages/3b0a20e70805fcea\",\"categories\":[\"《Vue》笔记\",\"过渡&动画\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"使用animate库\",\"date\":\"2020-02-17 16:05:52\",\"excerpt\":\"<h1 id=\\\"vue中使用animate-css库\\\" tabindex=\\\"-1\\\">vue中使用Animate.css库 <a class=\\\"header-anchor\\\" href=\\\"#vue中使用animate-css库\\\" aria-label=\\\"Permalink to &quot;vue中使用Animate.css库&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"自定义过渡类名\\\" tabindex=\\\"-1\\\">自定义过渡类名 <a class=\\\"header-anchor\\\" href=\\\"#自定义过渡类名\\\" aria-label=\\\"Permalink to &quot;自定义过渡类名&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>我们可以通过以下 attribute 来自定义过渡类名：</p>\\n<ul>\\n<li><code>enter-class</code></li>\\n<li><code>enter-active-class</code></li>\\n<li><code>enter-to-class</code> (2.1.8+)</li>\\n<li><code>leave-class</code></li>\\n<li><code>leave-active-class</code></li>\\n<li><code>leave-to-class</code> (2.1.8+)</li>\\n</ul>\\n\",\"capture\":\"自定义过渡类名\\n我们可以通过以下 attribute 来自定义过渡类名：\\n- `enter-class`\\n- `enter-active-class`\\n- `enter-to-class` (2.1.8+)\\n- `leave-class`\\n- `leave-active-class`\\n- `leave-to-class` (2.1.8+)\\n他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 Animate.css结合使用十分有用。\\n 使用Animate.css库\\n```html\\n&lt;transition\\n            name=\\\"custom-\"},{\"url\":\"/《Vue》笔记/03.过渡&动画/120.transition-group列表过渡.html\",\"relativePath\":\"/《Vue》笔记/03.过渡&动画/120.transition-group列表过渡.html\",\"frontmatter\":{\"title\":\"transition-group列表过渡\",\"date\":\"2020-02-04 13:17:42\",\"permalink\":\"/pages/0aa92922ace6bb5e\",\"categories\":[\"《Vue》笔记\",\"过渡&动画\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"transition-group列表过渡\",\"date\":\"2020-02-04 13:17:42\",\"excerpt\":\"<h1 id=\\\"transition-group列表过渡\\\" tabindex=\\\"-1\\\">transition-group列表过渡 <a class=\\\"header-anchor\\\" href=\\\"#transition-group列表过渡\\\" aria-label=\\\"Permalink to &quot;transition-group列表过渡&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"列表的进入-离开过渡\\\" tabindex=\\\"-1\\\">列表的进入/离开过渡 <a class=\\\"header-anchor\\\" href=\\\"#列表的进入-离开过渡\\\" aria-label=\\\"Permalink to &quot;列表的进入/离开过渡&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<div class=\\\"language-html vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">html</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">&#x3C;</span><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">transition-group</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> tag</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"ul\\\"</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">> </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">&#x3C;!--tag转为ul--></span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">    &#x3C;</span><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">li</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> v-for</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"item in list\\\"</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> :key</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"item\\\"</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">>{{item}}&#x3C;/</span><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">li</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">> </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">&#x3C;!--子元素要有key--></span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">&#x3C;/</span><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">transition-group</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">></span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br></div></div><p><strong>注意</strong>：列表元素一定要有<code>key</code></p>\\n\",\"capture\":\"列表的进入/离开过渡\\n```html\\n&lt;transition-group tag=\\\"ul\\\"\\n    &lt;li v-for=\\\"item in list\\\" :key=\\\"item\\\"&gt;{{item}}&lt;/li&gt; &lt;!--子元素要有key--&gt;\\n&lt;/transition-group&gt;\\n```\\n注意：列表元素一定要有`key`\\n```css\\n.v-enter,.v-leave-to{\\n  opacity: 0;\\n  transform: translateX(30px);\\n}\\n.v-enter-active,.v-leave-active{\\n  tran\"},{\"url\":\"/《Vue》笔记/03.过渡&动画/110.transition过渡&动画.html\",\"relativePath\":\"/《Vue》笔记/03.过渡&动画/110.transition过渡&动画.html\",\"frontmatter\":{\"title\":\"transition过渡&动画\",\"date\":\"2020-02-04 13:16:19\",\"permalink\":\"/pages/184a96b493a97078\",\"categories\":[\"《Vue》笔记\",\"过渡&动画\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"transition过渡&动画\",\"date\":\"2020-02-04 13:16:19\",\"excerpt\":\"<h1 id=\\\"transition过渡-动画\\\" tabindex=\\\"-1\\\">transition过渡&amp;动画 <a class=\\\"header-anchor\\\" href=\\\"#transition过渡-动画\\\" aria-label=\\\"Permalink to &quot;transition过渡&amp;动画&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/transitions.html\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">API</a></p>\\n<h2 id=\\\"使用\\\" tabindex=\\\"-1\\\">使用 <a class=\\\"header-anchor\\\" href=\\\"#使用\\\" aria-label=\\\"Permalink to &quot;使用&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>需要设置动画的元素或组件要在外边包裹一个<code>&lt;transition&gt;</code>标签，设置自定义的<code>name</code>，vue会根据元素的切换（进入/离开）过程添加相应的css类名，你可以<strong>自由地使用css类名来设置css过渡&amp;动画</strong>。</p>\\n\",\"capture\":\"API\\n 使用\\n需要设置动画的元素或组件要在外边包裹一个`&lt;transition\\n 过渡的类名\\n在进入/离开的过渡中，会有 6 个 class 切换。\\n各类名的生命周期\\n* 进入\\n  * `v-enter` 只存在于第一帧\\n  * `v-enter-active` 第一帧到最后一帧，结束后移除\\n  * `v-enter-to` 第二帧到最后一帧，结束后移除\\n* 离开\\n  * `v-leave` 只存在于第一帧\\n  * `v-leave-active` 第一帧到最后一帧，结束后移除\\n  * `v-leave-to` 第二帧到最后一帧，结束后移除\\n如果你使用一个没有`name`的`&lt;t\"}],\"基础\":[{\"url\":\"/《Vue》笔记/01.基础/35.列表渲染之数组、对象更新检测.html\",\"relativePath\":\"/《Vue》笔记/01.基础/35.列表渲染之数组、对象更新检测.html\",\"frontmatter\":{\"title\":\"列表渲染之数组、对象更新检测\",\"date\":\"2020-02-05 13:09:06\",\"permalink\":\"/pages/04783a6691cc9d06\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"列表渲染之数组、对象更新检测\",\"date\":\"2020-02-05 13:09:06\",\"excerpt\":\"<h1 id=\\\"列表渲染之数组、对象更新检测\\\" tabindex=\\\"-1\\\">列表渲染之数组、对象更新检测 <a class=\\\"header-anchor\\\" href=\\\"#列表渲染之数组、对象更新检测\\\" aria-label=\\\"Permalink to &quot;列表渲染之数组、对象更新检测&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/list.html#%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">数组更新检测API</a> <a href=\\\"https://cn.vuejs.org/v2/guide/list.html#%E5%AF%B9%E8%B1%A1%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">对象更新检测API</a></p>\\n<h2 id=\\\"数组更新检测\\\" tabindex=\\\"-1\\\">数组更新检测 <a class=\\\"header-anchor\\\" href=\\\"#数组更新检测\\\" aria-label=\\\"Permalink to &quot;数组更新检测&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h4 id=\\\"变异方法-mutation-method\\\" tabindex=\\\"-1\\\">变异方法 (mutation method) <a class=\\\"header-anchor\\\" href=\\\"#变异方法-mutation-method\\\" aria-label=\\\"Permalink to &quot;变异方法 (mutation method)&quot;\\\">&ZeroWidthSpace;</a></h4>\\n<p>Vue 将被侦听的数组的变异方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：</p>\\n\",\"capture\":\"数组更新检测API 对象更新检测API\\n 数组更新检测\\n 变异方法 (mutation method)\\nVue 将被侦听的数组的变异方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：\\n- `push()`末尾添加\\n- `pop()`末尾删除\\n- `shift()` 首位删除\\n- `unshift() ` 首位添加\\n- `splice()` 拼合\\n- `sort()` 排序\\n- `reverse()` 反转\\n数组实例方法\\n 替换数组\\n变异方法，顾名思义，会改变调用了这些方法的原始数组。相比之下，也有非变异 (non-mutating method) 方法，例如 `filter(\"},{\"url\":\"/《Vue》笔记/01.基础/30.v-if vs v-show.html\",\"relativePath\":\"/《Vue》笔记/01.基础/30.v-if vs v-show.html\",\"frontmatter\":{\"title\":\"v-if vs v-show\",\"date\":\"2020-02-04 17:32:23\",\"permalink\":\"/pages/73e4064340277b05\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"v-if vs v-show\",\"date\":\"2020-02-04 17:32:23\",\"excerpt\":\"<h1 id=\\\"v-if-vs-v-show\\\" tabindex=\\\"-1\\\">v-if vs v-show <a class=\\\"header-anchor\\\" href=\\\"#v-if-vs-v-show\\\" aria-label=\\\"Permalink to &quot;v-if vs v-show&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/conditional.html#v-if-vs-v-show\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">API</a></p>\\n<p><code>v-if</code> 根据渲染条件决定是否把元素渲染到DOM页面，而<code>v-show</code>不管渲染条件是什么，都会把元素渲染到DOM页面，只是简单的切换CSS的显示隐藏。</p>\\n\",\"capture\":\"API\\n`v-if` 根据渲染条件决定是否把元素渲染到DOM页面，而`v-show`不管渲染条件是什么，都会把元素渲染到DOM页面，只是简单的切换CSS的显示隐藏。\\n如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好。\"},{\"url\":\"/《Vue》笔记/01.基础/20.计算属性 vs 方法 vs 侦听属性.html\",\"relativePath\":\"/《Vue》笔记/01.基础/20.计算属性 vs 方法 vs 侦听属性.html\",\"frontmatter\":{\"title\":\"计算属性 vs 方法 vs 侦听属性\",\"date\":\"2020-02-04 16:37:51\",\"permalink\":\"/pages/351f72ecd9c41129\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"计算属性 vs 方法 vs 侦听属性\",\"date\":\"2020-02-04 16:37:51\",\"excerpt\":\"<h1 id=\\\"计算属性-vs-方法-vs-侦听属性\\\" tabindex=\\\"-1\\\">计算属性 vs 方法 vs 侦听属性 <a class=\\\"header-anchor\\\" href=\\\"#计算属性-vs-方法-vs-侦听属性\\\" aria-label=\\\"Permalink to &quot;计算属性 vs 方法 vs 侦听属性&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/computed.html#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%BC%93%E5%AD%98-vs-%E6%96%B9%E6%B3%95\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">API</a></p>\\n<p>如果一个功能同时可以使用计算属性(computed)、方法(methods)、侦听属性(watch)来实现的时候推荐使用计算属性。</p>\\n\",\"capture\":\"API\\n如果一个功能同时可以使用计算属性(computed)、方法(methods)、侦听属性(watch)来实现的时候推荐使用计算属性。\\n| 计算属性                                 | 方法                                               | 侦听属性                                     |\\n| ---------------------------------------- | --------------------------------------------------\"},{\"url\":\"/《Vue》笔记/01.基础/10.生命周期.html\",\"relativePath\":\"/《Vue》笔记/01.基础/10.生命周期.html\",\"frontmatter\":{\"title\":\"生命周期\",\"date\":\"2020-02-04 15:06:59\",\"permalink\":\"/pages/176808a1b5f843b8\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"生命周期\",\"date\":\"2020-02-04 15:06:59\",\"excerpt\":\"<h1 id=\\\"实例生命周期钩子\\\" tabindex=\\\"-1\\\">实例生命周期钩子 <a class=\\\"header-anchor\\\" href=\\\"#实例生命周期钩子\\\" aria-label=\\\"Permalink to &quot;实例生命周期钩子&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/instance.html#%E5%AE%9E%E4%BE%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">实例生命周期钩子API</a></p>\\n<p>简单理解，生命周期钩子函数就是vue实例在某一个时间点会自动执行的函数。</p>\\n\",\"capture\":\"实例生命周期钩子API\\n简单理解，生命周期钩子函数就是vue实例在某一个时间点会自动执行的函数。\\n```html\\n&lt;div id=\\\"app\\\"\\n&lt;script src=\\\"https://cdn.bootcss.com/vue/2.4.2/vue.js\\\"&gt;&lt;/script&gt;\\n&lt;script&gt;\\n  var vm = new Vue({\\n    el: 'app',\\n    data: {\\n      msg: 'Vue的生命周期'\\n    },\\n    beforeCreate: function() {\\n      console.group('-----\"},{\"url\":\"/《Vue》笔记/01.基础/00.MVVM模式.html\",\"relativePath\":\"/《Vue》笔记/01.基础/00.MVVM模式.html\",\"frontmatter\":{\"title\":\"MVVM模式\",\"date\":\"2020-02-04 12:19:00\",\"permalink\":\"/pages/114158caa9e96df0\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"MVVM模式\",\"date\":\"2020-02-04 12:19:00\",\"excerpt\":\"<div class=\\\"tip custom-block\\\"><p class=\\\"custom-block-title\\\">TIP</p>\\n<p>说明：本章内容是博主的Vue学习笔记，以<a href=\\\"https://cn.vuejs.org/v2/guide/\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">官方文档</a>为准。</p>\\n</div>\\n<h1 id=\\\"mvvm模式\\\" tabindex=\\\"-1\\\">MVVM模式 <a class=\\\"header-anchor\\\" href=\\\"#mvvm模式\\\" aria-label=\\\"Permalink to &quot;MVVM模式&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>MVVM模式，<code>M</code>即 model，数据模型；<code>V</code>即 view，视图；<code>VM</code>即 view-model，视图模型。</p>\\n\",\"capture\":\"说明：本章内容是博主的Vue学习笔记，以官方文档为准。\\n MVVM模式\\nMVVM模式，`M`即 model，数据模型；`V`即 view，视图；`VM`即 view-model，视图模型。\\n理解\\n首先，数据Model通过Data Bindings把数据绑定在View视图上，\\n当View视图有交互（有改变）的时候，Dom listeners会自动监听，然后更新数据Model。\\nQ：什么是MVVM模式？\\nA：MVVM模式，第一个M代表数据模型，V代表视图，VM代表视图模型；\\n它的实际操作原理是：后台数据通过视图模型来渲染视图，就是页面。当用户在页面上进行操作的时候，\\n视图模型会自动监听到用户的操作\"}],\"规模化\":[{\"url\":\"/《Vue》笔记/06.规模化/140.路由懒加载.html\",\"relativePath\":\"/《Vue》笔记/06.规模化/140.路由懒加载.html\",\"frontmatter\":{\"title\":\"路由懒加载\",\"date\":\"2020-02-04 13:20:20\",\"permalink\":\"/pages/38ecac9a9b92f037\",\"categories\":[\"《Vue》笔记\",\"规模化\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"路由懒加载\",\"date\":\"2020-02-04 13:20:20\",\"capture\":\"```js\\n// 路由同步加载\\n// import Recommend from '@/components/recommend/recommend'\\n// import Singer from '@/components/singer/singer'\\n// import Rank from '@/components/rank/rank'\\n// import Search from '@/components/search/search'\\n// import SingerDetail from '@/components/singer-detail/singer-detail'\\n// imp\"},{\"url\":\"/《Vue》笔记/06.规模化/100.vuex操作相关.html\",\"relativePath\":\"/《Vue》笔记/06.规模化/100.vuex操作相关.html\",\"frontmatter\":{\"title\":\"vuex操作相关\",\"date\":\"2020-02-04 13:15:19\",\"permalink\":\"/pages/d9d62d6ab8ff99a6\",\"categories\":[\"《Vue》笔记\",\"规模化\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"vuex操作相关\",\"date\":\"2020-02-04 13:15:19\",\"capture\":\"```js\\nimport { mapActions, mapMutations, mapGetters } from 'vuex'\\ncomputed: {\\n    ...mapGetters([ // 获取数据，内部为数组\\n        'searchHistory' // 相当于在data插入searchHistory和获取到的数据\\n    ])\\n},\\nmethods: {\\n\\t某方法(){\\n\\t  this.saveSearchHistory(传入值)\\n\\t},\\n\\t...mapActions([ // 提交actions修改数据，内部为数组 因为actions文件已对方法进行了封装所有是数组类\"}],\"博客搭建\":[{\"url\":\"/03.技术/03.博客搭建/03.GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床.html\",\"relativePath\":\"/03.技术/03.博客搭建/03.GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床.html\",\"frontmatter\":{\"title\":\"GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床\",\"date\":\"2020-01-03 12:55:43\",\"permalink\":\"/pages/a5f73af5185fdf0a\",\"categories\":[\"技术\",\"博客搭建\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床\",\"date\":\"2020-01-03 12:55:43\",\"excerpt\":\"<h1 id=\\\"github-jsdelivr-tinypng-picgo-打造稳定快速、高效免费图床\\\" tabindex=\\\"-1\\\">GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床 <a class=\\\"header-anchor\\\" href=\\\"#github-jsdelivr-tinypng-picgo-打造稳定快速、高效免费图床\\\" aria-label=\\\"Permalink to &quot;GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"前言\\\" tabindex=\\\"-1\\\">前言 <a class=\\\"header-anchor\\\" href=\\\"#前言\\\" aria-label=\\\"Permalink to &quot;前言&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p><strong>Q：为什么要使用图床呢？什么是图床？</strong></p>\\n<p>A：写博客文章时，图片的上传和存放是一个问题，有的朋友可能会把图片放到和博客同一个仓库当中，使用相对路径来引用，这样后期维护起来会比较麻烦。还有的朋友会在不同的平台发布同一篇文章，这样一来每个平台都要上传图片，为了解决这些问题，比较推荐的做法是把图片统一上传到一个在线的第三方静态资源库中，我们把这个资源库称为图床，其返回一个图片的URL，使用<code>markdown+图片url</code>的方式写作文章，一次编写，到处使用~</p>\\n\",\"capture\":\"前言\\nQ：为什么要使用图床呢？什么是图床？\\nA：写博客文章时，图片的上传和存放是一个问题，有的朋友可能会把图片放到和博客同一个仓库当中，使用相对路径来引用，这样后期维护起来会比较麻烦。还有的朋友会在不同的平台发布同一篇文章，这样一来每个平台都要上传图片，为了解决这些问题，比较推荐的做法是把图片统一上传到一个在线的第三方静态资源库中，我们把这个资源库称为图床，其返回一个图片的URL，使用`markdown+图片url`的方式写作文章，一次编写，到处使用~\\n以下内容是比较旧的，现在我发现一个更好用，配置更方便的图床工具：&lt;https://picx.xpoet.cn/\\n使用方法看一下他网站的使\"},{\"url\":\"/03.技术/03.博客搭建/01.解决百度无法收录搭建在GitHub上的个人博客的问题.html\",\"relativePath\":\"/03.技术/03.博客搭建/01.解决百度无法收录搭建在GitHub上的个人博客的问题.html\",\"frontmatter\":{\"title\":\"解决百度无法收录搭建在GitHub上的个人博客的问题\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/41f87d890d0a02af\",\"categories\":[\"技术\",\"博客搭建\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"解决百度无法收录搭建在GitHub上的个人博客的问题\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"解决百度无法收录搭建在github上的静态博客的问题\\\" tabindex=\\\"-1\\\">解决百度无法收录搭建在GitHub上的静态博客的问题 <a class=\\\"header-anchor\\\" href=\\\"#解决百度无法收录搭建在github上的静态博客的问题\\\" aria-label=\\\"Permalink to &quot;解决百度无法收录搭建在GitHub上的静态博客的问题&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<div class=\\\"warning custom-block\\\"><p class=\\\"custom-block-title\\\">WARNING</p>\\n<p>如果你正在寻找本博客的搭建文档，博主建议您查看这个仓库的<a href=\\\"https://github.com/xugaoyi/vuepress-theme-vdoing\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">README</a>。</p>\\n</div>\\n<h2 id=\\\"背景\\\" tabindex=\\\"-1\\\">背景 <a class=\\\"header-anchor\\\" href=\\\"#背景\\\" aria-label=\\\"Permalink to &quot;背景&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>由于GitHub禁止百度爬虫访问，造成托管在GitHub Pages上的博客无法被百度收录。相关问题可以通过百度站长平台的<code>抓取诊断</code>再现，每次都是403 Forbidden的错误。</p>\\n\",\"capture\":\"如果你正在寻找本博客的搭建文档，博主建议您查看这个仓库的README。\\n 背景\\n由于GitHub禁止百度爬虫访问，造成托管在GitHub Pages上的博客无法被百度收录。相关问题可以通过百度站长平台的`抓取诊断`再现，每次都是403 Forbidden的错误。\\n 解决方案\\n同时将博客同时同步托管到GitHub Pages和coding pages上，解决百度不收录问题。最后发现在国内使用coding pages打开速度特别快，而且还会被百度收录，因此我把coding pages的站点作为主站点，原本在github pages的作为分站点。\\n步骤：\\n1、注册coding账号，创建仓库，把代码推\"},{\"url\":\"/03.技术/03.博客搭建/02.使用Gitalk实现静态博客无后台评论系统.html\",\"relativePath\":\"/03.技术/03.博客搭建/02.使用Gitalk实现静态博客无后台评论系统.html\",\"frontmatter\":{\"title\":\"使用Gitalk实现静态博客无后台评论系统\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/1da0bf9a988eafe5\",\"categories\":[\"技术\",\"博客搭建\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"使用Gitalk实现静态博客无后台评论系统\",\"date\":\"2019-12-25 14:27:01\",\"excerpt\":\"<h1 id=\\\"使用gitalk实现静态博客无后台评论系统\\\" tabindex=\\\"-1\\\">使用Gitalk实现静态博客无后台评论系统 <a class=\\\"header-anchor\\\" href=\\\"#使用gitalk实现静态博客无后台评论系统\\\" aria-label=\\\"Permalink to &quot;使用Gitalk实现静态博客无后台评论系统&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"前言\\\" tabindex=\\\"-1\\\">前言 <a class=\\\"header-anchor\\\" href=\\\"#前言\\\" aria-label=\\\"Permalink to &quot;前言&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>Gitalk，一个基于 Github Issue 和 Preact 开发的评论插件。</p>\\n<p>下面我们来用它在vuepress搭建的博客中搭建评论区吧</p>\\n\",\"capture\":\"前言\\nGitalk，一个基于 Github Issue 和 Preact 开发的评论插件。\\n下面我们来用它在vuepress搭建的博客中搭建评论区吧\\n 准备\\n使用一个新的东西首先当然是要了解它\\nGitalk demo：&lt;https://gitalk.github.io/\\nGitalk github：&lt;https://github.com/gitalk/gitalk&gt;\\n 实现\\n如何实现？最好的方法我认为是看官方文档，这里我只是记录一下实现的步骤。\\n使用一个别人已经开发好的 vuepress-plugin-comment 插件来帮助我们把Gitalk应用到vuepress搭建的静\"}],\"Nodejs\":[{\"url\":\"/03.技术/02.Nodejs/01.nodejs递归读取所有文件.html\",\"relativePath\":\"/03.技术/02.Nodejs/01.nodejs递归读取所有文件.html\",\"frontmatter\":{\"title\":\"nodejs递归读取所有文件\",\"date\":\"2019-12-26 15:57:32\",\"permalink\":\"/pages/117708e0af7f0bd9\",\"categories\":[\"技术\",\"Nodejs\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"nodejs递归读取所有文件\",\"date\":\"2019-12-26 15:57:32\",\"capture\":\"```js\\nvar fs = require('fs');\\nvar path = require('path');\\n \\nfunction readFileList(dir, filesList = []) {\\n    const files = fs.readdirSync(dir);\\n    console.log(files);\\n    files.forEach((item, index) =\\n        var fullPath = path.join(dir, item);\\n        const stat = fs.statSync(fullPath);\\n        i\"}],\"面试\":[{\"url\":\"/04.更多/03.面试/01.面试问题集锦.html\",\"relativePath\":\"/04.更多/03.面试/01.面试问题集锦.html\",\"frontmatter\":{\"title\":\"面试问题集锦\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/pages/aea6571b7a8bae86\",\"categories\":[\"更多\",\"面试\"],\"tags\":[null],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"面试问题集锦\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"请做一下自我介绍\\n回答提示： 一般人回答这个问题过于平常，只说姓名、年龄、工作经验，这些在简历上都有。其实，企业最希望知道的是求职者能否胜任工作，包括：最强的技能、最深入研究的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，要突出积极的个性和做事的能力，说的合情合理企业才会相信。\\n 你最大的优点是什么？\\n回答提示： 沉着冷静、条理清楚、立场坚定、乐于助人等，加上例子如：我在XX经过一到两年的培训及项目实战，加上实习工作，我想我适合这份工作。\\n 说说你最大的缺点？\\n回答提示： 这个问题企业问的概率很大，通常不希望听到直接回答的缺点是什么等，如果求职者说自己小心眼、非常懒、工作效率低\"}]},\"tags\":{\"AI\":[{\"url\":\"/04.更多/05.AI随笔/01.当珍妮机学会了写代码.html\",\"relativePath\":\"/04.更多/05.AI随笔/01.当珍妮机学会了写代码.html\",\"frontmatter\":{\"title\":\"当珍妮机学会了写代码\",\"date\":\"2026-02-26 20:00:00\",\"permalink\":\"/pages/ai-coding-revolution/\",\"categories\":[\"更多\",\"AI随笔\"],\"tags\":[\"AI\",\"思考\",\"编程\"],\"author\":{\"name\":\"刘志伟;AI\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟;AI\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"当珍妮机学会了写代码\",\"date\":\"2026-02-26 20:00:00\",\"capture\":\"当珍妮机学会了写代码\\n\\n 一、从一台纺纱机说起\\n1764 年的某个夜晚，英国兰开夏郡的织工詹姆斯·哈格里夫斯看着妻子的纺车被踢倒后仍在旋转，灵光一闪——如果把纱锭竖起来，一个轮子就能同时驱动八个纱锭。\\n珍妮纺纱机就这样诞生了。一个人能干八个人的活，效率提升 800%。\\n262 年后的 2026 年，我坐在屏幕前，让一个叫 Claude 的 AI 帮我重构整个博客系统。它用 Three.js 写了一个极光 Shader 背景，用 Vue 3 搭了全屏滚动首页，让它设计了五套可切换的艺术风格主题——赛博朋克、梵高、水墨、古典雕塑、现代。它还帮我写了一篇博客，就是现在你正在看的这篇。\\n如果哈格里夫斯\"}],\"思考\":[{\"url\":\"/04.更多/05.AI随笔/01.当珍妮机学会了写代码.html\",\"relativePath\":\"/04.更多/05.AI随笔/01.当珍妮机学会了写代码.html\",\"frontmatter\":{\"title\":\"当珍妮机学会了写代码\",\"date\":\"2026-02-26 20:00:00\",\"permalink\":\"/pages/ai-coding-revolution/\",\"categories\":[\"更多\",\"AI随笔\"],\"tags\":[\"AI\",\"思考\",\"编程\"],\"author\":{\"name\":\"刘志伟;AI\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟;AI\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"当珍妮机学会了写代码\",\"date\":\"2026-02-26 20:00:00\",\"capture\":\"当珍妮机学会了写代码\\n\\n 一、从一台纺纱机说起\\n1764 年的某个夜晚，英国兰开夏郡的织工詹姆斯·哈格里夫斯看着妻子的纺车被踢倒后仍在旋转，灵光一闪——如果把纱锭竖起来，一个轮子就能同时驱动八个纱锭。\\n珍妮纺纱机就这样诞生了。一个人能干八个人的活，效率提升 800%。\\n262 年后的 2026 年，我坐在屏幕前，让一个叫 Claude 的 AI 帮我重构整个博客系统。它用 Three.js 写了一个极光 Shader 背景，用 Vue 3 搭了全屏滚动首页，让它设计了五套可切换的艺术风格主题——赛博朋克、梵高、水墨、古典雕塑、现代。它还帮我写了一篇博客，就是现在你正在看的这篇。\\n如果哈格里夫斯\"}],\"编程\":[{\"url\":\"/04.更多/05.AI随笔/01.当珍妮机学会了写代码.html\",\"relativePath\":\"/04.更多/05.AI随笔/01.当珍妮机学会了写代码.html\",\"frontmatter\":{\"title\":\"当珍妮机学会了写代码\",\"date\":\"2026-02-26 20:00:00\",\"permalink\":\"/pages/ai-coding-revolution/\",\"categories\":[\"更多\",\"AI随笔\"],\"tags\":[\"AI\",\"思考\",\"编程\"],\"author\":{\"name\":\"刘志伟;AI\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟;AI\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"当珍妮机学会了写代码\",\"date\":\"2026-02-26 20:00:00\",\"capture\":\"当珍妮机学会了写代码\\n\\n 一、从一台纺纱机说起\\n1764 年的某个夜晚，英国兰开夏郡的织工詹姆斯·哈格里夫斯看着妻子的纺车被踢倒后仍在旋转，灵光一闪——如果把纱锭竖起来，一个轮子就能同时驱动八个纱锭。\\n珍妮纺纱机就这样诞生了。一个人能干八个人的活，效率提升 800%。\\n262 年后的 2026 年，我坐在屏幕前，让一个叫 Claude 的 AI 帮我重构整个博客系统。它用 Three.js 写了一个极光 Shader 背景，用 Vue 3 搭了全屏滚动首页，让它设计了五套可切换的艺术风格主题——赛博朋克、梵高、水墨、古典雕塑、现代。它还帮我写了一篇博客，就是现在你正在看的这篇。\\n如果哈格里夫斯\"}],\"electron\":[{\"url\":\"/《Electron》笔记/01.electron记录.html\",\"relativePath\":\"/《Electron》笔记/01.electron记录.html\",\"frontmatter\":{\"title\":\"electron记录\",\"date\":\"2023-09-09 14:23:20\",\"permalink\":\"/pages/8e9a16/\",\"categories\":[\"《Electron》笔记\"],\"tags\":[\"electron\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"electron记录\",\"date\":\"2023-09-09 14:23:20\",\"capture\":\"事件周期\\n electron常用事件统计\\n主进程常用事件可以分为以下几类：\\n1. 应用程序生命周期事件：\\n    - `ready`: 当 Electron 应用程序初始化完成且准备好显示窗口时触发。\\n    - `window-all-closed`: 当所有窗口都关闭后触发，在 macOS 上通常不会退出应用程序。\\n    - `activate`: 在 macOS 上，当用户点击应用程序的 Dock 图标并且没有其他窗口打开时触发，用于重新创建新窗口。\\n2. 窗口相关事件：\\n    - `closed`: 窗口关闭时触发。\\n    - `dom-ready`: 窗口加载完毕并且 DOM \"}],\"JavaScript\":[{\"url\":\"/01.前端/25.JavaScript文章/01.33个非常实用的JavaScript一行代码.html\",\"relativePath\":\"/01.前端/25.JavaScript文章/01.33个非常实用的JavaScript一行代码.html\",\"frontmatter\":{\"title\":\"33个非常实用的JavaScript一行代码\",\"date\":\"2021-11-02 09:51:37\",\"permalink\":\"/pages/a61298/\",\"categories\":[\"前端\",\"JavaScript文章\"],\"tags\":[\"JavaScript\"],\"author\":\"CUGGZ\"},\"author\":\"CUGGZ\",\"title\":\"33个非常实用的JavaScript一行代码\",\"date\":\"2021-11-02 09:51:37\",\"capture\":\"一、日期处理\\n 1. 检察日期是否有效\\n该方法用于检测给出的日期是否有效：\\n```javascript\\nconst isDateValid = (...val) =\\nisDateValid(\\\"December 17, 1995 03:24:00\\\");  // true\\n复制代码\\n```\\n 2. 计算两个日期之间的间隔\\n该方法用于计算两个日期之间的间隔时间：\\n```javascript\\nconst dayDif = (date1, date2) =&gt; Math.ceil(Math.abs(date1.getTime() - date2.getTime()) / 86400000)\\ndayD\"},{\"url\":\"/《JavaScript教程》笔记/01.基础.html\",\"relativePath\":\"/《JavaScript教程》笔记/01.基础.html\",\"frontmatter\":{\"title\":\"基础\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/0796ba76b4b55368\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"基础\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"基础篇\\n 一、JS的一些名词概念\\n 什么是作用域？\\n变量存在的范围。\\n可分为全局作用域和函数作用域，ES6新增块级作用域。\\n 什么是闭包？\\n闭包就是能够读取其他函数内部变量的函数。\\n* 闭包的形式：函数内部定义函数\\n* 本质上闭包就是将函数内部和外部连接起来的一座桥梁\\n闭包的作用：\\n* 可以读取函数内部变量\\n* 让这些变量始终保持在内存中，即闭包可以使得它诞生的环境一直存在。\\n*  封装对象的私有属性和私有方法\\n 什么是构造函数？\\n用于构造(生成)实例的一个函数，使实例拥有构造函数内定于的属性和方法。\\n 什么是实例对象？\\n实例对象就是通过new 构造函数生成的，拥有构造函数内定于的属性和方法的\"},{\"url\":\"/《JavaScript教程》笔记/02.内置对象.html\",\"relativePath\":\"/《JavaScript教程》笔记/02.内置对象.html\",\"frontmatter\":{\"title\":\"内置对象\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/74d2ab3fbfeaaa68\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"内置对象\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"内置对象篇\\n 一、Object对象\\n 1、概述\\nJavaScript 原生提供`Object`对象（注意起首的`O`是大写），本章介绍该对象原生的各种方法。\\nJavaScript 的所有其他对象都继承自`Object`对象，即那些对象都是`Object`的实例。\\n`Object`对象的原生方法分成两类：`Object`本身的方法与`Object`的实例方法。\\n（1）Object对象本身的方法\\n所谓“本身的方法”就是直接定义在`Object`对象的方法。\\n```js\\nObject.print = function (o) { console.log(o) };\\n```\\n上面代码中，`print`\"},{\"url\":\"/《JavaScript教程》笔记/03.面向对象.html\",\"relativePath\":\"/《JavaScript教程》笔记/03.面向对象.html\",\"frontmatter\":{\"title\":\"面向对象\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/659b5af5e2e704e0\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"面向对象\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"面向对象编程\\n 一、实例对象与new命令\\n 1、对象是什么\\n面向对象编程（Object Oriented Programming，缩写为 OOP）是目前主流的编程范式。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。\\n每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务。对象可以复用，通过继承机制还可以定制。因此，面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程（procedural programming），更适合多人合作的大型软件项目。\\n那么，“对象”\"},{\"url\":\"/《JavaScript教程》笔记/04.异步操作.html\",\"relativePath\":\"/《JavaScript教程》笔记/04.异步操作.html\",\"frontmatter\":{\"title\":\"异步操作\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/d61b1cb4cdac1f63\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"异步操作\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"异步操作\\n 一、异步操作概述\\n 1、单线程模型\\n单线程模型指的是，JavaScript 只在一个线程上运行。也就是说，JavaScript 同时只能执行一个任务，其他任务都必须在后面排队等待。\\n注意，JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合。\\nJavaScript 之所以采用单线程，而不是多线程，跟历史有关系。JavaScript 从诞生起就是单线程，原因是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对\"},{\"url\":\"/《JavaScript教程》笔记/05.DOM.html\",\"relativePath\":\"/《JavaScript教程》笔记/05.DOM.html\",\"frontmatter\":{\"title\":\"DOM\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/7d961b8030c6099e\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"DOM\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"DOM\\n 一、概述\\n 1、DOM\\nDOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。\\n浏览器会根据 DOM 模型，将结构化文档（比如 HTML 和 XML）解析成一系列的节点，再由这些节点组成一个树状结构（DOM Tree）。所有的节点和最终的树状结构，都有规范的对外接口。\\nDOM 只是一个接口规范，可以用各种语言实现。所以严格地说，DOM 不是 JavaScript 语法的一部分，但是 DOM 操作是 JavaScript 最\"},{\"url\":\"/《JavaScript教程》笔记/06.事件.html\",\"relativePath\":\"/《JavaScript教程》笔记/06.事件.html\",\"frontmatter\":{\"title\":\"事件\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/10b2761db5a8e089\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"事件\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"事件\\n 一、EventTarget 接口\\n 事件的本质是程序各个组成部分之间的一种通信方式，也是异步编程的一种实现。DOM 支持大量的事件，本章开始介绍 DOM 的事件编程。\\n 1、概述\\nDOM 的事件操作（监听和触发），都定义在`EventTarget`接口。所有节点对象都部署了这个接口，其他一些需要事件通信的浏览器内置对象（比如，`XMLHttpRequest`、`AudioNode`、`AudioContext`）也部署了这个接口。\\n该接口主要提供三个实例方法。\\n- `addEventListener`：绑定事件的监听函数\\n- `removeEventListener`：移除事件的监听函\"},{\"url\":\"/《JavaScript教程》笔记/07.浏览器模型.html\",\"relativePath\":\"/《JavaScript教程》笔记/07.浏览器模型.html\",\"frontmatter\":{\"title\":\"浏览器模型\",\"date\":\"2020-01-12 11:49:16\",\"permalink\":\"/pages/bab4930124ad2c10\",\"categories\":[\"《JavaScript教程》笔记\"],\"tags\":[\"JavaScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"浏览器模型\",\"date\":\"2020-01-12 11:49:16\",\"capture\":\"一、浏览器环境概述\\nJavaScript 是浏览器的内置脚本语言。也就是说，浏览器内置了 JavaScript 引擎，并且提供各种接口，让 JavaScript 脚本可以控制浏览器的各种功能。一旦网页内嵌了 JavaScript 脚本，浏览器加载网页，就会去执行脚本，从而达到操作浏览器的目的，实现网页的各种动态效果。\\n本章开始介绍浏览器提供的各种 JavaScript 接口。首先，介绍 JavaScript 代码嵌入网页的方法。\\n 1、代码嵌入网页的方法\\n网页中嵌入 JavaScript 代码，主要有三种方法。\\n- `  &lt;script\\n- `  &lt;script&gt;  `标签加\"}],\"设计模式\":[{\"url\":\"/01.前端/40.学习笔记/50.JS设计模式总结笔记.html\",\"relativePath\":\"/01.前端/40.学习笔记/50.JS设计模式总结笔记.html\",\"frontmatter\":{\"title\":\"JS设计模式总结笔记\",\"date\":\"2021-02-27 20:01:18\",\"permalink\":\"/pages/4643cd/\",\"categories\":[\"前端\",\"学习笔记\"],\"tags\":[\"设计模式\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"JS设计模式总结笔记\",\"date\":\"2021-02-27 20:01:18\",\"capture\":\"开篇：前端工程师的成长论\\n能够决定一个前端工程师的本质的，不是那些瞬息万变的技术点，而是那些不变的东西。\\n所谓“不变的东西”，就是驾驭技术的能力。\\n具体来说，它分为以下三个层次：\\n- 能用健壮的代码去解决具体的问题；\\n- 能用抽象的思维去应对复杂的系统；\\n- 能用工程化的思想去规划更大规模的业务。\\n\\n 设计模式之“道”\\n- 设计模式是“拿来主义”。如使用数学公式，不会从头推导一个公式。\\n  核心思想\\n- 设计模式的核心思想——封装变化\\n- 保证可维护性、可扩展性。\\n- 将变与不变分离，确保变化的部分灵活，不变的部分稳定。——这就是所谓的“健壮”的代码。\\n 设计模式之“术”\\n即最经典的23种设计\"}],\"Git\":[{\"url\":\"/《Git》学习笔记/10.手册/00.常用Git命令清单.html\",\"relativePath\":\"/《Git》学习笔记/10.手册/00.常用Git命令清单.html\",\"frontmatter\":{\"title\":\"常用Git命令清单\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/8292d8/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"常用Git命令清单\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。\\n下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。\\n\\n&gt; - Index / Stage：暂存区\\n&gt; - Repository：仓库区（或本地仓库）\\n&gt; - Remote：远程仓库\\n 一、新建代码库\\n```bash\\n 在当前目录新建一个Git代码库\\n$ git init\\n 新建一个目录，将其初始化为Git代码库\\n$ git init [project-name]\\n 下载一个项目和它的整个代码历史\\n$ git clone [url]\\n```\\n 二、配置\\nGit的设置文件为\"},{\"url\":\"/《Git》学习笔记/10.手册/01.Git变基合并.html\",\"relativePath\":\"/《Git》学习笔记/10.手册/01.Git变基合并.html\",\"frontmatter\":{\"title\":\"Git变基合并\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/c10281/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git变基合并\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"说明\\n以下 `v2` 是某个需求的开发分支， `dev`是总的开发分支，`v2` 是基于`dev`分支签出的。\\n当完成`v2`的开发后，需要把代码合并到`dev`，我们可以使用`rebase`进行合并：\\n```sh\\n 首先将 v2 push到远程仓库\\ngit add .\\ngit commit -m 'xxx'\\ngit push origin v2\\n 切换到 dev 拉取最新代码\\ngit checkout dev\\ngit pull origin dev\\n 切换到 v2\\ngit checkout v2\\ngit rebase dev  将 v2 的所有[commit] 变基到(应用到) dev\\n 切\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/10.Git基础与命令.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/10.Git基础与命令.html\",\"frontmatter\":{\"title\":\"Git基础与命令\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/635088/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git基础与命令\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"官方文档（中文）：https://git-scm.com/book/zh/v2\\n\\n Git基础\\n 全局配置\\n```bash\\ngit config --global user.name 'your name'\\ngit config --global user.email 'xxx@xx.com'\\n```\\n自报家门\\n 检查配置信息\\n```sh\\ngit config --list\\n```\\n 获取帮助\\n```sh\\n 获取全局帮助手册\\ngit help\\n 获取特定命令的详细版帮助手册 (两个命令是等价的)\\ngit help &lt;某个命令&gt;\\ngit &lt;某个命令&gt; --help  两个\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/100.Git工具-重写历史.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/100.Git工具-重写历史.html\",\"frontmatter\":{\"title\":\"Git工具-重写历史\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/1832fe/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git工具-重写历史\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"许多时候，在使用 Git 时，你可能想要修订提交历史。 Git 很棒的一点是它允许你在最后时刻做决定。 你可以在将暂存区内容提交前决定哪些文件进入提交，可以通过 `git stash` 来决定不与某些内容工作， 也可以重写已经发生的提交就像它们以另一种方式发生的一样。 这可能涉及改变提交的顺序，改变提交中的信息或修改文件，将提交压缩或是拆分， 或完全地移除提交——在将你的工作成果与他人共享之前。\\n在本节中，你可以学到如何完成这些工作，这样在与他人分享你的工作成果时你的提交历史将如你所愿地展示出来。\\n| Note | 在满意之前不要推送你的工作Git 的基本原则之一是，由于克隆中有很多工作是本地\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/110.Git工具-重置揭密.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/110.Git工具-重置揭密.html\",\"frontmatter\":{\"title\":\"Git工具-重置揭密\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/d9e9c6/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git工具-重置揭密\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"在继续了解更专业的工具前，我们先探讨一下 Git 的 `reset` 和 `checkout` 命令。 在初遇的 Git 命令中，这两个是最让人困惑的。 它们能做很多事情，所以看起来我们很难真正地理解并恰当地运用它们。 针对这一点，我们先来做一个简单的比喻。\\n 三棵树\\n理解 `reset` 和 `checkout` 的最简方法，就是以 Git 的思维框架（将其作为内容管理器）来管理三棵不同的树。 “树” 在我们这里的实际意思是 “文件的集合”，而不是指特定的数据结构。 （在某些情况下索引看起来并不像一棵树，不过我们现在的目的是用简单的方式思考它。）\\nGit 作为一个系统，是以它的一般操作来管理\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/20.Git分支-分支原理.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/20.Git分支-分支原理.html\",\"frontmatter\":{\"title\":\"Git分支-分支原理\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/4bef1a/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支-分支原理\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。\\n 首次提交\\n在进行提交操作时，Git 会保存一个提交对象（commit object）。\\n假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 暂存操作会为每一个文件计算校验和（使用 SHA-1 哈希算法），然后会把当前版本的文件快照保存到 Git 仓库中 （Git 使用 *blob* 对象来保存它们），最终将校验和加入到暂存区域等待提交：\\n```sh\\n$ git\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/30.Git分支的新建与合并-分支操作.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/30.Git分支的新建与合并-分支操作.html\",\"frontmatter\":{\"title\":\"Git分支的新建与合并-分支操作\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/ea5a8c/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支的新建与合并-分支操作\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"文档：Git 分支 - 分支的新建与合并\\n 创建分支并切换\\n此时有一个需求需要在新的分支`iss53`上工作：\\n```sh\\n$ git checkout -b iss53   b表示branch\\n```\\n它是下面两条命令的简写：\\n```sh\\n$ git branch iss53\\n$ git checkout iss53\\n```\\n 切换分支\\n突然有一个紧急问题要解决，需要在原来的`master`分支进行修复：\\n```sh\\n$ git checkout master\\n```\\n在切换到`master`之前，需要`iss53`分支保持好一个干净的状态（修改都已提交）。\\n注意：切换分支Git 会重置你的\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/40.Git分支管理-查看分支.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/40.Git分支管理-查看分支.html\",\"frontmatter\":{\"title\":\"Git分支管理-查看分支\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/a399b3/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支管理-查看分支\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"查看分支\\n```sh\\n$ git branch\\n  iss53\\n* master   带星号*表示当前所在分支\\n  testing\\n```\\n`git branch` 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表。\\n 查看每个分支的最后提交\\n```sh\\n$ git branch -v\\n  iss53   93b412c fix javascript issue\\n* master  7a98805 Merge branch 'iss53'\\n  testing 782fd34 test\\n```\\n 查看已(未)合并的分支\\n`--merged` 与 `--no-m\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/50.Git分支开发工作流.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/50.Git分支开发工作流.html\",\"frontmatter\":{\"title\":\"Git分支开发工作流\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/49ee30/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支开发工作流\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"文档：Git分支开发工作流\\n 长期分支\\n因为 Git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。 也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些主题分支合并入其他分支中。\\n许多使用 Git 的开发者都喜欢使用这种方式来工作，比如只在 `master` 分支上保留完全稳定的代码，开发过程在`dev`分支，开发完成后并入`test`分支进行测试，通过测试的稳定代码才并入`master`分支中。\\n`dev`和`test`分支不需要保持绝对稳定，但在`test`通过测试达到稳定状态，就可以被合并入`mast\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/60.Git分支-远程分支.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/60.Git分支-远程分支.html\",\"frontmatter\":{\"title\":\"Git分支-远程分支\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/574d62/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支-远程分支\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"远程引用是对远程仓库的引用（指针），包括分支、标签等等。\\n\\n 查看远程引用列表与信息\\n```sh\\ngit ls-remote &lt;remote&gt;  远程引用的完整列表\\ngit remote show &lt;remote&gt;  远程分支的更多信息\\n```\\n上面两行命令比较少用，更常见的做法是利用远程跟踪分支。\\n 远程跟踪分支\\n远程跟踪分支是远程分支状态的引用。它们是你无法移动的本地引用。一旦你进行了网络通信， Git 就会为你移动它们以精确反映远程仓库的状态。请将它们看做书签， 这样可以提醒你该分支在远程仓库中的位置就是你最后一次连接到它们的位置。\\n它们以 `&lt;remote\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/70.Git分支-变基.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/70.Git分支-变基.html\",\"frontmatter\":{\"title\":\"Git分支-变基\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/3a3247/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git分支-变基\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"在 Git 中整合来自不同分支的修改主要有两种方法：`merge` 以及 `rebase`。 在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。\\n 变基的基本操作\\n请回顾之前在 分支的合并 中的一个例子，你会看到开发任务分叉到两个不同分支，又各自提交了更新。\\n&lt;p align=\\\"center\\\"\\n之前介绍过，整合分支最容易的方法是 `merge` 命令。 它会把两个分支的最新快照（`C3` 和 `C4`）以及二者最近的共同祖先（`C2`）进行三方合并，合并的结果是生成一个新的快照（并提交）。\\n &lt;p align=\\\"cen\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/80.Git工具-查看修订版本.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/80.Git工具-查看修订版本.html\",\"frontmatter\":{\"title\":\"Git工具-查看修订版本\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/c984d1/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git工具-查看修订版本\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"Git 能够以多种方式来指定单个提交、一组提交、或者一定范围内的提交。 了解它们并不是必需的，但是了解一下总没坏处。\\n修订版本指的是：提交\\n 单个修订版本\\n你可以通过任意一个提交的 40 个字符的完整 SHA-1 散列值来指定它， 不过还有很多更人性化的方式来做同样的事情。本节将会介绍获取单个提交的多种方法。\\n 简短的 SHA-1\\nGit 十分智能，你只需要提供 SHA-1 的前几个字符就可以获得对应的那次提交， 当然你提供的 SHA-1 字符数量不得少于 4 个，并且没有歧义——也就是说， 当前对象数据库中没有其它对象以这段 SHA-1 开头。\\n例如，要查看你知道其中添加了某个功能的提交，首\"},{\"url\":\"/《Git》学习笔记/20.文档笔记/90.Git工具-交互式暂存.html\",\"relativePath\":\"/《Git》学习笔记/20.文档笔记/90.Git工具-交互式暂存.html\",\"frontmatter\":{\"title\":\"Git工具-交互式暂存\",\"date\":\"2020-11-18 17:43:57\",\"permalink\":\"/pages/76d859/\",\"categories\":[\"《Git》学习笔记\"],\"tags\":[\"Git\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Git工具-交互式暂存\",\"date\":\"2020-11-18 17:43:57\",\"capture\":\"本节中的几个交互式 Git 命令可以帮助你将文件的特定部分组合成提交。 当你在修改了大量文件后，希望这些改动能拆分为若干提交而不是混杂在一起成为一个提交时，这几个工具会非常有用。 通过这种方式，可以确保提交是逻辑上独立的变更集，同时也会使其他开发者在与你工作时很容易地审核。 如果运行 `git add` 时使用 `-i` 或者 `--interactive` 选项，Git 将会进入一个交互式终端模式，显示类似下面的东西：\\n```sh\\n$ git add -i\\n           staged     unstaged path\\n  1:    unchanged        +0/-1 T\"}],\"TypeScript\":[{\"url\":\"/01.前端/40.学习笔记/35.TypeScript笔记.html\",\"relativePath\":\"/01.前端/40.学习笔记/35.TypeScript笔记.html\",\"frontmatter\":{\"title\":\"TypeScript笔记\",\"date\":\"2020-10-08 13:02:48\",\"permalink\":\"/pages/51afd6/\",\"categories\":[\"前端\",\"学习笔记\"],\"tags\":[\"TypeScript\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"TypeScript笔记\",\"date\":\"2020-10-08 13:02:48\",\"capture\":\"TypeScript 的类型校验是给程序员看的，在编译后不会存在TS代码。\\n 类型注解\\n```typescript\\nfunction fn(person: string):void{ // 参数类型是字符串，没有返回值\\n    ///...\\n}\\nfn('str') // 如传递参数非字符串，vscode编辑器中或在编译时将给出错误提示\\nconst test:number = 1\\n```\\n 有哪些基础类型注解？\\n```typescript\\n// 基础类型\\n:string\\n:number\\n:boolean\\n:null  // 只能是null值\\n:undefined // 只能是undefined值\"}],\"学习方法\":[{\"url\":\"/04.更多/01.学习/00.费曼学习法.html\",\"relativePath\":\"/04.更多/01.学习/00.费曼学习法.html\",\"frontmatter\":{\"title\":\"费曼学习法\",\"date\":\"2020-07-16 10:04:14\",\"permalink\":\"/pages/f2a556/\",\"categories\":[\"更多\",\"学习\"],\"tags\":[\"学习方法\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"费曼学习法\",\"date\":\"2020-07-16 10:04:14\",\"capture\":\"步骤\\n费曼学习法分为4个步骤:\\n1. 确定学习目标\\n你想学习的概念、内容、主题是什么。\\n2. 模拟教学学习法\\n你要模拟自己是一位老师，面对完全不懂这个领域的人，用自己的话，尽可能具体形象地讲诉。这样的讲诉有助于你活学活用，触类旁通，联系生活具体情境。\\n3. 回顾\\n反思第2步遇到的问题，哪些地方卡壳了，哪些地方对方没有真正听懂。找出问题的要害，把握关键环节。\\n4. 简化\\n把这些遇到问题的地方，重新梳理理解，尽可能了解更多背景和相关知识，再用尽可能简化的方式重新表达，设法看穿本质。然后，返回第2步。\\n\\n&gt; \\n&gt; 《费曼学习法：为何被称为史上最牛的学习法，它的本质究竟是什么？》\\n&gt;\"}],\"笔记\":[{\"url\":\"/01.前端/40.学习笔记/05.《JavaScript高级程序设计》笔记.html\",\"relativePath\":\"/01.前端/40.学习笔记/05.《JavaScript高级程序设计》笔记.html\",\"frontmatter\":{\"title\":\"《JavaScript高级程序设计》笔记\",\"date\":\"2020-06-12 12:39:01\",\"permalink\":\"/note/js/\",\"categories\":[\"笔记\"],\"tags\":[\"笔记\",\"红宝书\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"《JavaScript高级程序设计》笔记\",\"date\":\"2020-06-12 12:39:01\",\"capture\":\"第1章  JavaScript简介\\n* JavaScript诞生于1995年\\n* 一个完整的JavaScript由这三部分组成：\\n  * ECMAScript (核心)\\n  * DOM (文档对象模型)\\n  * BOM (浏览器对象模型)\\n* ECMAScript的 宿主环境 包含 ：\\n  * 浏览器\\n  * Node\\n  * flash\\n* ECMAScript大致规定了下列组成部分：\\n  * 语法\\n  * 类型\\n  * 语句\\n  * 关键字\\n  * 保留字\\n  * 操作符\\n  * 对象\\n 第2章 在HTML中使用JavaScript\\n* `&lt;script\\n  * async 表示立即\"}],\"红宝书\":[{\"url\":\"/01.前端/40.学习笔记/05.《JavaScript高级程序设计》笔记.html\",\"relativePath\":\"/01.前端/40.学习笔记/05.《JavaScript高级程序设计》笔记.html\",\"frontmatter\":{\"title\":\"《JavaScript高级程序设计》笔记\",\"date\":\"2020-06-12 12:39:01\",\"permalink\":\"/note/js/\",\"categories\":[\"笔记\"],\"tags\":[\"笔记\",\"红宝书\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"《JavaScript高级程序设计》笔记\",\"date\":\"2020-06-12 12:39:01\",\"capture\":\"第1章  JavaScript简介\\n* JavaScript诞生于1995年\\n* 一个完整的JavaScript由这三部分组成：\\n  * ECMAScript (核心)\\n  * DOM (文档对象模型)\\n  * BOM (浏览器对象模型)\\n* ECMAScript的 宿主环境 包含 ：\\n  * 浏览器\\n  * Node\\n  * flash\\n* ECMAScript大致规定了下列组成部分：\\n  * 语法\\n  * 类型\\n  * 语句\\n  * 关键字\\n  * 保留字\\n  * 操作符\\n  * 对象\\n 第2章 在HTML中使用JavaScript\\n* `&lt;script\\n  * async 表示立即\"}],\"搜索技巧\":[{\"url\":\"/04.更多/01.学习/10.搜索引擎使用技巧.html\",\"relativePath\":\"/04.更多/01.学习/10.搜索引擎使用技巧.html\",\"frontmatter\":{\"title\":\"搜索引擎使用技巧\",\"date\":\"2020-05-24 11:44:19\",\"permalink\":\"/pages/ce818a\",\"categories\":[\"更多\",\"学习\"],\"tags\":[\"搜索技巧\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"搜索引擎使用技巧\",\"date\":\"2020-05-24 11:44:19\",\"capture\":\"搜索引擎相信大家经常在使用，但是有时候想搜某个信息时却搜出来一大堆不相关的（百度：你们都在看我干什么？）。下面我们来介绍几种搜索技巧，可以提升搜索效率，助你快速查资料，妈妈再也不担心我的学习了（'妈~我真的是在找学习资料'）\\n 技巧1：排除干扰项\\n方式：关键词1+空格+减号+关键词2，即 `关键词1 -关键词2`\\n功能：排除一些不想要的关键词\\n示例：\\n```\\n锤子 -锤子手机\\n```\\n示例中将在搜索结果排除与`锤子手机`相关的，只显示`锤子`本来的样子。\\n\\n 技巧2：精确搜索\\n方式：给关键词加双引号，`\\\"关键词\\\"`\\n功能：只搜索引号里的字，少一个字或者把字拆开都不行\\n示例：\\n```\\n\\\"达拉不崩\"}],\"css\":[{\"url\":\"/02.页面/20.CSS/13.如何根据系统主题自动响应CSS深色模式.html\",\"relativePath\":\"/02.页面/20.CSS/13.如何根据系统主题自动响应CSS深色模式.html\",\"frontmatter\":{\"title\":\"如何根据系统主题自动响应CSS深色模式\",\"date\":\"2020-03-31 14:06:26\",\"permalink\":\"/pages/5dde351274f1e39d\",\"categories\":[\"页面\",\"CSS\"],\"tags\":[\"css\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"如何根据系统主题自动响应CSS深色模式\",\"date\":\"2020-03-31 14:06:26\",\"excerpt\":\"<h1 id=\\\"如何根据系统主题自动响应css深色模式\\\" tabindex=\\\"-1\\\">如何根据系统主题自动响应CSS深色模式 <a class=\\\"header-anchor\\\" href=\\\"#如何根据系统主题自动响应css深色模式\\\" aria-label=\\\"Permalink to &quot;如何根据系统主题自动响应CSS深色模式&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p align=\\\"center\\\">\\n  <img src=\\\"https://cdn.staticaly.com/gh/xugaoyi/image_store/blog/20200427163531.jpg\\\" width=\\\"500\\\">\\n</p>\\n<p>很多人喜欢选择APP或网站中的深色模式，也许他们更喜欢这样的外观，或者他们想让自己的眼睛免受疲劳。这篇文章将告诉你如何在网站中实现一个自动的CSS深色模式，根据访客的系统主题来自动响应。</p>\\n\",\"capture\":\"如何根据系统主题自动响应CSS深色模式\\n&lt;p align=\\\"center\\\"\\n  &lt;img src=\\\"https://cdn.staticaly.com/gh/xugaoyi/image_store/blog/20200427163531.jpg\\\" width=\\\"500\\\"&gt;\\n&lt;/p&gt;\\n很多人喜欢选择APP或网站中的深色模式，也许他们更喜欢这样的外观，或者他们想让自己的眼睛免受疲劳。这篇文章将告诉你如何在网站中实现一个自动的CSS深色模式，根据访客的系统主题来自动响应。\\n CSS 深色模式 (Dark Mode)\\n在`:root`根元素中定义变量来设置主题的颜色。我建\"}],\"Vue\":[{\"url\":\"/《Vue》笔记/05.工具/10.Vue CLi v3 创建项目使用记录.html\",\"relativePath\":\"/《Vue》笔记/05.工具/10.Vue CLi v3 创建项目使用记录.html\",\"frontmatter\":{\"title\":\"Vue CLi v3 创建项目使用记录\",\"date\":\"2020-02-20 17:24:29\",\"permalink\":\"/pages/d00311f8174119b2\",\"categories\":[\"《Vue》笔记\",\"工具\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Vue CLi v3 创建项目使用记录\",\"date\":\"2020-02-20 17:24:29\",\"capture\":\"官方文档\\n以下使用的CLi版本是 v3.11.0\\n vue create\\n1. 运行以下命令来创建一个新项目\\n```sh\\nvue create hello-world\\n```\\n2. 你会被提示选取一个 preset (预设)。你可以选默认的包含了基本的 Babel + ESLint 设置的 preset，也可以选“手动选择特性”来选取需要的特性。\\n```sh\\nVue CLI v3.11.0\\n? Please pick a preset: (Use arrow keys)\\n\\n  Manually select features (手动选择特性)\\n```\\n默认预设只包含Babel + ESLint\"},{\"url\":\"/《Vue》笔记/04.可复用性&组合/01.Mixin混入.html\",\"relativePath\":\"/《Vue》笔记/04.可复用性&组合/01.Mixin混入.html\",\"frontmatter\":{\"title\":\"Mixin混入\",\"date\":\"2020-02-19 15:22:41\",\"permalink\":\"/pages/bd36a3c1bc3e0821\",\"categories\":[\"《Vue》笔记\",\"可复用性&组合\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Mixin混入\",\"date\":\"2020-02-19 15:22:41\",\"excerpt\":\"<h1 id=\\\"mixin混入\\\" tabindex=\\\"-1\\\">Mixin混入 <a class=\\\"header-anchor\\\" href=\\\"#mixin混入\\\" aria-label=\\\"Permalink to &quot;Mixin混入&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"基础\\\" tabindex=\\\"-1\\\">基础 <a class=\\\"header-anchor\\\" href=\\\"#基础\\\" aria-label=\\\"Permalink to &quot;基础&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。</p>\\n\",\"capture\":\"基础\\n混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。\\n\\n&gt;\\n&gt; 可通过 `this.$options` 查看选项\\n例子：\\n```js\\n// 定义一个混入对象\\nvar myMixin = {\\n  created: function () {\\n    this.hello()\\n  },\\n  methods: {\\n    hello: function () {\\n      console.log('hello from mixin!')\\n  \"},{\"url\":\"/《Vue》笔记/02.组件/90.vue父子组件的生命周期顺序.html\",\"relativePath\":\"/《Vue》笔记/02.组件/90.vue父子组件的生命周期顺序.html\",\"frontmatter\":{\"title\":\"vue父子组件的生命周期顺序\",\"date\":\"2020-02-18 16:39:33\",\"permalink\":\"/pages/e6cec47efa42d7f1\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"vue父子组件的生命周期顺序\",\"date\":\"2020-02-18 16:39:33\",\"capture\":\"加载渲染过程\\n```\\n父beforeCreate -\\n```\\n父组件会先执行到beforeMount，接着会执行子组件钩子到挂载结束，再挂载父组件。\\n 子组件更新过程\\n```\\n父beforeUpdate -&gt; 子beforeUpdate -&gt; 子updated -&gt; 父updated\\n```\\n 父组件更新过程\\n```\\n父beforeUpdate -&gt; 父updated\\n```\\n 销毁过程\\n```\\n父beforeDestroy -&gt; 子beforeDestroy -&gt; 子destroyed -&gt; 父destroyed\\n```\"},{\"url\":\"/《Vue》笔记/03.过渡&动画/112.使用animate库.html\",\"relativePath\":\"/《Vue》笔记/03.过渡&动画/112.使用animate库.html\",\"frontmatter\":{\"title\":\"使用animate库\",\"date\":\"2020-02-17 16:05:52\",\"permalink\":\"/pages/3b0a20e70805fcea\",\"categories\":[\"《Vue》笔记\",\"过渡&动画\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"使用animate库\",\"date\":\"2020-02-17 16:05:52\",\"excerpt\":\"<h1 id=\\\"vue中使用animate-css库\\\" tabindex=\\\"-1\\\">vue中使用Animate.css库 <a class=\\\"header-anchor\\\" href=\\\"#vue中使用animate-css库\\\" aria-label=\\\"Permalink to &quot;vue中使用Animate.css库&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"自定义过渡类名\\\" tabindex=\\\"-1\\\">自定义过渡类名 <a class=\\\"header-anchor\\\" href=\\\"#自定义过渡类名\\\" aria-label=\\\"Permalink to &quot;自定义过渡类名&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>我们可以通过以下 attribute 来自定义过渡类名：</p>\\n<ul>\\n<li><code>enter-class</code></li>\\n<li><code>enter-active-class</code></li>\\n<li><code>enter-to-class</code> (2.1.8+)</li>\\n<li><code>leave-class</code></li>\\n<li><code>leave-active-class</code></li>\\n<li><code>leave-to-class</code> (2.1.8+)</li>\\n</ul>\\n\",\"capture\":\"自定义过渡类名\\n我们可以通过以下 attribute 来自定义过渡类名：\\n- `enter-class`\\n- `enter-active-class`\\n- `enter-to-class` (2.1.8+)\\n- `leave-class`\\n- `leave-active-class`\\n- `leave-to-class` (2.1.8+)\\n他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 Animate.css结合使用十分有用。\\n 使用Animate.css库\\n```html\\n&lt;transition\\n            name=\\\"custom-\"},{\"url\":\"/《Vue》笔记/02.组件/80.动态组件与 v-once 指令.html\",\"relativePath\":\"/《Vue》笔记/02.组件/80.动态组件与 v-once 指令.html\",\"frontmatter\":{\"title\":\"动态组件与 v-once 指令\",\"date\":\"2020-02-16 15:52:19\",\"permalink\":\"/pages/636ca33122e9a64b\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"动态组件与 v-once 指令\",\"date\":\"2020-02-16 15:52:19\",\"capture\":\"动态组件\\n```html\\n&lt;div id=\\\"root\\\"\\n\\t&lt;component :is=\\\"type\\\"&gt;&lt;/component&gt; &lt;!--其效果如同下面两行被注释的代码--&gt;\\n\\t&lt;!-- &lt;child-one v-if=\\\"type === 'child-one'\\\"&gt;&lt;/child-one&gt;\\n\\t    &lt;child-two v-if=\\\"type === 'child-two'\\\"&gt;&lt;/child-two&gt; --&gt;\\n\\t&lt;button @click=\\\"handleClick\\\"&gt;change&\"},{\"url\":\"/《Vue》笔记/02.组件/75.插槽slot.html\",\"relativePath\":\"/《Vue》笔记/02.组件/75.插槽slot.html\",\"frontmatter\":{\"title\":\"插槽slot\",\"date\":\"2020-02-16 11:46:27\",\"permalink\":\"/pages/055ecee9a4325386\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"插槽slot\",\"date\":\"2020-02-16 11:46:27\",\"capture\":\"API\\n 插槽\\n```html\\n&lt;div id=\\\"root\\\"\\n    &lt;child&gt; &lt;!-- 组件标签 --&gt;\\n        &lt;h1&gt;hello&lt;/h1&gt;\\n    &lt;/child&gt;\\n&lt;/div&gt;\\n&lt;script type=\\\"text/javascript\\\"&gt;\\n    Vue.component('child', { // 子组件\\n        template: '&lt;div&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;'\\n    })\\n    var vm \"},{\"url\":\"/《Vue》笔记/02.组件/65.非父子组件传值.html\",\"relativePath\":\"/《Vue》笔记/02.组件/65.非父子组件传值.html\",\"frontmatter\":{\"title\":\"非父子组件传值\",\"date\":\"2020-02-15 14:55:03\",\"permalink\":\"/pages/d408e64f666f146d\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"非父子组件传值\",\"date\":\"2020-02-15 14:55:03\",\"excerpt\":\"<h1 id=\\\"非父子组件间传值\\\" tabindex=\\\"-1\\\">非父子组件间传值 <a class=\\\"header-anchor\\\" href=\\\"#非父子组件间传值\\\" aria-label=\\\"Permalink to &quot;非父子组件间传值&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>当组件的嵌套多时，非父子组件间传值就显得复杂，除了使用<a href=\\\"https://vuex.vuejs.org/zh/\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">vuex</a>实现之外，还可以通过Bus（或者叫 总线/发布订阅模式/观察者模式）的方式实现非父子组件间传值。</p>\\n\",\"capture\":\"当组件的嵌套多时，非父子组件间传值就显得复杂，除了使用vuex实现之外，还可以通过Bus（或者叫 总线/发布订阅模式/观察者模式）的方式实现非父子组件间传值。\\n&lt;div id=\\\"root\\\"\\n\\t\\t&lt;child1 content=\\\"组件1：点我传出值\\\"&gt;&lt;/child1&gt;\\n\\t\\t&lt;child2 content=\\\"组件2\\\"&gt;&lt;/child2&gt;\\n\\t&lt;/div&gt;\\n```html\\n&lt;div id=\\\"root\\\"&gt;\\n    &lt;child1 content=\\\"组件1：点我传出值\\\"&gt;&lt;/child1&gt;\\n    &l\"},{\"url\":\"/《Vue》笔记/02.组件/55.自定义事件.html\",\"relativePath\":\"/《Vue》笔记/02.组件/55.自定义事件.html\",\"frontmatter\":{\"title\":\"自定义事件\",\"date\":\"2020-02-15 11:27:45\",\"permalink\":\"/pages/9651417d08d1779d\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"自定义事件\",\"date\":\"2020-02-15 11:27:45\",\"capture\":\"API\\n 在组件标签v-on绑定的事件是自定义事件\\n```html\\n&lt;div id=\\\"root\\\"\\n    &lt;child @click=\\\"handleClick\\\"&gt;&lt;/child&gt; &lt;!--这里click是自定义事件--&gt;\\n&lt;/div&gt;\\n&lt;script type=\\\"text/javascript\\\"&gt;\\n    Vue.component('child', {\\n        template: '&lt;button&gt;Child&lt;/button&gt;',\\n    })\\n    var vm = new Vue({\\n  \"},{\"url\":\"/《Vue》笔记/02.组件/52.Prop 验证 与 非 Prop 的 Attribute.html\",\"relativePath\":\"/《Vue》笔记/02.组件/52.Prop 验证 与 非 Prop 的 Attribute.html\",\"frontmatter\":{\"title\":\"Prop 验证 与 非 Prop 的 Attribute\",\"date\":\"2020-02-15 10:49:04\",\"permalink\":\"/pages/a3080f60f6596eb4\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Prop 验证 与 非 Prop 的 Attribute\",\"date\":\"2020-02-15 10:49:04\",\"capture\":\"Prop 验证\\nAPI\\n子组件对父组件传递来的参数进行校验\\n```js\\nVue.component('my-component', {\\n  props: {\\n    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)\\n    propA: Number,\\n    // 多个可能的类型\\n    propB: [String, Number],\\n    // 必填的字符串\\n    propC: {\\n      type: String,\\n      required: true\\n    },\\n    // 带有默认值的数字\\n    propD: {\\n      \"},{\"url\":\"/《Vue》笔记/02.组件/36.使用组件的细节点.html\",\"relativePath\":\"/《Vue》笔记/02.组件/36.使用组件的细节点.html\",\"frontmatter\":{\"title\":\"使用组件的细节点\",\"date\":\"2020-02-13 13:26:20\",\"permalink\":\"/pages/83a1ab785e7fd70c\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"使用组件的细节点\",\"date\":\"2020-02-13 13:26:20\",\"capture\":\"解析 DOM 模板时的注意事项\\n```html\\n&lt;div id=\\\"root\\\"\\n    &lt;table&gt;\\n        &lt;tbody&gt;\\n            &lt;row&gt;&lt;/row&gt;\\n            &lt;row&gt;&lt;/row&gt;\\n            &lt;row&gt;&lt;/row&gt;\\n        &lt;/tbody&gt;\\n    &lt;/table&gt;\\n&lt;/div&gt;\\n&lt;script type=\\\"text/javascript\\\"&gt;\\n    Vue.component\"},{\"url\":\"/《Vue》笔记/01.基础/35.列表渲染之数组、对象更新检测.html\",\"relativePath\":\"/《Vue》笔记/01.基础/35.列表渲染之数组、对象更新检测.html\",\"frontmatter\":{\"title\":\"列表渲染之数组、对象更新检测\",\"date\":\"2020-02-05 13:09:06\",\"permalink\":\"/pages/04783a6691cc9d06\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"列表渲染之数组、对象更新检测\",\"date\":\"2020-02-05 13:09:06\",\"excerpt\":\"<h1 id=\\\"列表渲染之数组、对象更新检测\\\" tabindex=\\\"-1\\\">列表渲染之数组、对象更新检测 <a class=\\\"header-anchor\\\" href=\\\"#列表渲染之数组、对象更新检测\\\" aria-label=\\\"Permalink to &quot;列表渲染之数组、对象更新检测&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/list.html#%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">数组更新检测API</a> <a href=\\\"https://cn.vuejs.org/v2/guide/list.html#%E5%AF%B9%E8%B1%A1%E5%8F%98%E6%9B%B4%E6%A3%80%E6%B5%8B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">对象更新检测API</a></p>\\n<h2 id=\\\"数组更新检测\\\" tabindex=\\\"-1\\\">数组更新检测 <a class=\\\"header-anchor\\\" href=\\\"#数组更新检测\\\" aria-label=\\\"Permalink to &quot;数组更新检测&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h4 id=\\\"变异方法-mutation-method\\\" tabindex=\\\"-1\\\">变异方法 (mutation method) <a class=\\\"header-anchor\\\" href=\\\"#变异方法-mutation-method\\\" aria-label=\\\"Permalink to &quot;变异方法 (mutation method)&quot;\\\">&ZeroWidthSpace;</a></h4>\\n<p>Vue 将被侦听的数组的变异方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：</p>\\n\",\"capture\":\"数组更新检测API 对象更新检测API\\n 数组更新检测\\n 变异方法 (mutation method)\\nVue 将被侦听的数组的变异方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：\\n- `push()`末尾添加\\n- `pop()`末尾删除\\n- `shift()` 首位删除\\n- `unshift() ` 首位添加\\n- `splice()` 拼合\\n- `sort()` 排序\\n- `reverse()` 反转\\n数组实例方法\\n 替换数组\\n变异方法，顾名思义，会改变调用了这些方法的原始数组。相比之下，也有非变异 (non-mutating method) 方法，例如 `filter(\"},{\"url\":\"/《Vue》笔记/01.基础/30.v-if vs v-show.html\",\"relativePath\":\"/《Vue》笔记/01.基础/30.v-if vs v-show.html\",\"frontmatter\":{\"title\":\"v-if vs v-show\",\"date\":\"2020-02-04 17:32:23\",\"permalink\":\"/pages/73e4064340277b05\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"v-if vs v-show\",\"date\":\"2020-02-04 17:32:23\",\"excerpt\":\"<h1 id=\\\"v-if-vs-v-show\\\" tabindex=\\\"-1\\\">v-if vs v-show <a class=\\\"header-anchor\\\" href=\\\"#v-if-vs-v-show\\\" aria-label=\\\"Permalink to &quot;v-if vs v-show&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/conditional.html#v-if-vs-v-show\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">API</a></p>\\n<p><code>v-if</code> 根据渲染条件决定是否把元素渲染到DOM页面，而<code>v-show</code>不管渲染条件是什么，都会把元素渲染到DOM页面，只是简单的切换CSS的显示隐藏。</p>\\n\",\"capture\":\"API\\n`v-if` 根据渲染条件决定是否把元素渲染到DOM页面，而`v-show`不管渲染条件是什么，都会把元素渲染到DOM页面，只是简单的切换CSS的显示隐藏。\\n如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好。\"},{\"url\":\"/《Vue》笔记/01.基础/20.计算属性 vs 方法 vs 侦听属性.html\",\"relativePath\":\"/《Vue》笔记/01.基础/20.计算属性 vs 方法 vs 侦听属性.html\",\"frontmatter\":{\"title\":\"计算属性 vs 方法 vs 侦听属性\",\"date\":\"2020-02-04 16:37:51\",\"permalink\":\"/pages/351f72ecd9c41129\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"计算属性 vs 方法 vs 侦听属性\",\"date\":\"2020-02-04 16:37:51\",\"excerpt\":\"<h1 id=\\\"计算属性-vs-方法-vs-侦听属性\\\" tabindex=\\\"-1\\\">计算属性 vs 方法 vs 侦听属性 <a class=\\\"header-anchor\\\" href=\\\"#计算属性-vs-方法-vs-侦听属性\\\" aria-label=\\\"Permalink to &quot;计算属性 vs 方法 vs 侦听属性&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/computed.html#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%BC%93%E5%AD%98-vs-%E6%96%B9%E6%B3%95\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">API</a></p>\\n<p>如果一个功能同时可以使用计算属性(computed)、方法(methods)、侦听属性(watch)来实现的时候推荐使用计算属性。</p>\\n\",\"capture\":\"API\\n如果一个功能同时可以使用计算属性(computed)、方法(methods)、侦听属性(watch)来实现的时候推荐使用计算属性。\\n| 计算属性                                 | 方法                                               | 侦听属性                                     |\\n| ---------------------------------------- | --------------------------------------------------\"},{\"url\":\"/《Vue》笔记/01.基础/10.生命周期.html\",\"relativePath\":\"/《Vue》笔记/01.基础/10.生命周期.html\",\"frontmatter\":{\"title\":\"生命周期\",\"date\":\"2020-02-04 15:06:59\",\"permalink\":\"/pages/176808a1b5f843b8\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"生命周期\",\"date\":\"2020-02-04 15:06:59\",\"excerpt\":\"<h1 id=\\\"实例生命周期钩子\\\" tabindex=\\\"-1\\\">实例生命周期钩子 <a class=\\\"header-anchor\\\" href=\\\"#实例生命周期钩子\\\" aria-label=\\\"Permalink to &quot;实例生命周期钩子&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/instance.html#%E5%AE%9E%E4%BE%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">实例生命周期钩子API</a></p>\\n<p>简单理解，生命周期钩子函数就是vue实例在某一个时间点会自动执行的函数。</p>\\n\",\"capture\":\"实例生命周期钩子API\\n简单理解，生命周期钩子函数就是vue实例在某一个时间点会自动执行的函数。\\n```html\\n&lt;div id=\\\"app\\\"\\n&lt;script src=\\\"https://cdn.bootcss.com/vue/2.4.2/vue.js\\\"&gt;&lt;/script&gt;\\n&lt;script&gt;\\n  var vm = new Vue({\\n    el: 'app',\\n    data: {\\n      msg: 'Vue的生命周期'\\n    },\\n    beforeCreate: function() {\\n      console.group('-----\"},{\"url\":\"/《Vue》笔记/06.规模化/140.路由懒加载.html\",\"relativePath\":\"/《Vue》笔记/06.规模化/140.路由懒加载.html\",\"frontmatter\":{\"title\":\"路由懒加载\",\"date\":\"2020-02-04 13:20:20\",\"permalink\":\"/pages/38ecac9a9b92f037\",\"categories\":[\"《Vue》笔记\",\"规模化\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"路由懒加载\",\"date\":\"2020-02-04 13:20:20\",\"capture\":\"```js\\n// 路由同步加载\\n// import Recommend from '@/components/recommend/recommend'\\n// import Singer from '@/components/singer/singer'\\n// import Rank from '@/components/rank/rank'\\n// import Search from '@/components/search/search'\\n// import SingerDetail from '@/components/singer-detail/singer-detail'\\n// imp\"},{\"url\":\"/《Vue》笔记/03.过渡&动画/120.transition-group列表过渡.html\",\"relativePath\":\"/《Vue》笔记/03.过渡&动画/120.transition-group列表过渡.html\",\"frontmatter\":{\"title\":\"transition-group列表过渡\",\"date\":\"2020-02-04 13:17:42\",\"permalink\":\"/pages/0aa92922ace6bb5e\",\"categories\":[\"《Vue》笔记\",\"过渡&动画\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"transition-group列表过渡\",\"date\":\"2020-02-04 13:17:42\",\"excerpt\":\"<h1 id=\\\"transition-group列表过渡\\\" tabindex=\\\"-1\\\">transition-group列表过渡 <a class=\\\"header-anchor\\\" href=\\\"#transition-group列表过渡\\\" aria-label=\\\"Permalink to &quot;transition-group列表过渡&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"列表的进入-离开过渡\\\" tabindex=\\\"-1\\\">列表的进入/离开过渡 <a class=\\\"header-anchor\\\" href=\\\"#列表的进入-离开过渡\\\" aria-label=\\\"Permalink to &quot;列表的进入/离开过渡&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<div class=\\\"language-html vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">html</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">&#x3C;</span><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">transition-group</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> tag</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"ul\\\"</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">> </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">&#x3C;!--tag转为ul--></span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">    &#x3C;</span><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">li</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> v-for</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"item in list\\\"</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> :key</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"item\\\"</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">>{{item}}&#x3C;/</span><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">li</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">> </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">&#x3C;!--子元素要有key--></span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">&#x3C;/</span><span style=\\\"--shiki-light:#22863A;--shiki-dark:#85E89D\\\">transition-group</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">></span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br></div></div><p><strong>注意</strong>：列表元素一定要有<code>key</code></p>\\n\",\"capture\":\"列表的进入/离开过渡\\n```html\\n&lt;transition-group tag=\\\"ul\\\"\\n    &lt;li v-for=\\\"item in list\\\" :key=\\\"item\\\"&gt;{{item}}&lt;/li&gt; &lt;!--子元素要有key--&gt;\\n&lt;/transition-group&gt;\\n```\\n注意：列表元素一定要有`key`\\n```css\\n.v-enter,.v-leave-to{\\n  opacity: 0;\\n  transform: translateX(30px);\\n}\\n.v-enter-active,.v-leave-active{\\n  tran\"},{\"url\":\"/《Vue》笔记/03.过渡&动画/110.transition过渡&动画.html\",\"relativePath\":\"/《Vue》笔记/03.过渡&动画/110.transition过渡&动画.html\",\"frontmatter\":{\"title\":\"transition过渡&动画\",\"date\":\"2020-02-04 13:16:19\",\"permalink\":\"/pages/184a96b493a97078\",\"categories\":[\"《Vue》笔记\",\"过渡&动画\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"transition过渡&动画\",\"date\":\"2020-02-04 13:16:19\",\"excerpt\":\"<h1 id=\\\"transition过渡-动画\\\" tabindex=\\\"-1\\\">transition过渡&amp;动画 <a class=\\\"header-anchor\\\" href=\\\"#transition过渡-动画\\\" aria-label=\\\"Permalink to &quot;transition过渡&amp;动画&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/transitions.html\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">API</a></p>\\n<h2 id=\\\"使用\\\" tabindex=\\\"-1\\\">使用 <a class=\\\"header-anchor\\\" href=\\\"#使用\\\" aria-label=\\\"Permalink to &quot;使用&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>需要设置动画的元素或组件要在外边包裹一个<code>&lt;transition&gt;</code>标签，设置自定义的<code>name</code>，vue会根据元素的切换（进入/离开）过程添加相应的css类名，你可以<strong>自由地使用css类名来设置css过渡&amp;动画</strong>。</p>\\n\",\"capture\":\"API\\n 使用\\n需要设置动画的元素或组件要在外边包裹一个`&lt;transition\\n 过渡的类名\\n在进入/离开的过渡中，会有 6 个 class 切换。\\n各类名的生命周期\\n* 进入\\n  * `v-enter` 只存在于第一帧\\n  * `v-enter-active` 第一帧到最后一帧，结束后移除\\n  * `v-enter-to` 第二帧到最后一帧，结束后移除\\n* 离开\\n  * `v-leave` 只存在于第一帧\\n  * `v-leave-active` 第一帧到最后一帧，结束后移除\\n  * `v-leave-to` 第二帧到最后一帧，结束后移除\\n如果你使用一个没有`name`的`&lt;t\"},{\"url\":\"/《Vue》笔记/06.规模化/100.vuex操作相关.html\",\"relativePath\":\"/《Vue》笔记/06.规模化/100.vuex操作相关.html\",\"frontmatter\":{\"title\":\"vuex操作相关\",\"date\":\"2020-02-04 13:15:19\",\"permalink\":\"/pages/d9d62d6ab8ff99a6\",\"categories\":[\"《Vue》笔记\",\"规模化\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"vuex操作相关\",\"date\":\"2020-02-04 13:15:19\",\"capture\":\"```js\\nimport { mapActions, mapMutations, mapGetters } from 'vuex'\\ncomputed: {\\n    ...mapGetters([ // 获取数据，内部为数组\\n        'searchHistory' // 相当于在data插入searchHistory和获取到的数据\\n    ])\\n},\\nmethods: {\\n\\t某方法(){\\n\\t  this.saveSearchHistory(传入值)\\n\\t},\\n\\t...mapActions([ // 提交actions修改数据，内部为数组 因为actions文件已对方法进行了封装所有是数组类\"},{\"url\":\"/《Vue》笔记/99.其他/90.操作本地缓存.html\",\"relativePath\":\"/《Vue》笔记/99.其他/90.操作本地缓存.html\",\"frontmatter\":{\"title\":\"操作本地缓存\",\"date\":\"2020-02-04 13:14:19\",\"permalink\":\"/pages/30a94dbe96873b33\",\"categories\":[\"《Vue》笔记\",\"其他\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"操作本地缓存\",\"date\":\"2020-02-04 13:14:19\",\"capture\":\"&lt;https://github.com/ustbhuangyi/storage\\n操作 sessionStorage 和 localStorage 。\"},{\"url\":\"/《Vue》笔记/99.其他/80.Vue中的防抖函数封装和使用.html\",\"relativePath\":\"/《Vue》笔记/99.其他/80.Vue中的防抖函数封装和使用.html\",\"frontmatter\":{\"title\":\"Vue中的防抖函数封装和使用\",\"date\":\"2020-02-04 13:10:19\",\"permalink\":\"/pages/fb08e252dfd8fdfd\",\"categories\":[\"《Vue》笔记\",\"其他\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"Vue中的防抖函数封装和使用\",\"date\":\"2020-02-04 13:10:19\",\"capture\":\"Vue中的防抖函数封装和使用\\n如搜索框中，每改变一个数值就请求一次搜索接口，当快速的改变数值时并不需要多次请求接口，这就需要一个防抖函数：\\n```js\\n// 防抖函数\\nexport function debounce(func, delay) { // func 函数 delay间隔时间\\n  let timer\\n  return function (...args) {\\n    if (timer) {\\n      clearTimeout(timer)\\n    }\\n    timer = setTimeout(() =\\n      func.apply(this, args)\\n    }, \"},{\"url\":\"/《Vue》笔记/02.组件/70.父组件调用子组件方法并传入值.html\",\"relativePath\":\"/《Vue》笔记/02.组件/70.父组件调用子组件方法并传入值.html\",\"frontmatter\":{\"title\":\"父组件调用子组件方法并传入值\",\"date\":\"2020-02-04 13:06:37\",\"permalink\":\"/pages/2e24dab728769e0c\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"父组件调用子组件方法并传入值\",\"date\":\"2020-02-04 13:06:37\",\"capture\":\"通过`ref`引用调用子组件内的方法并传入参数\\n父组件：\\n```js\\n&lt;子组件标签  ref=\\\"refName\\\"\\nmethods: {\\n    fnX(x) {\\n      this.$refs.refName.fnY(x) // 调用子组件方法并传入值\\n    }\\n}\\n```\\n子组件：\\n```js\\nmethods: {\\n    fnY(x) {\\n      this.x = x\\n    }\\n  }\\n}\\n```\"},{\"url\":\"/《Vue》笔记/02.组件/60.兄弟组件传值.html\",\"relativePath\":\"/《Vue》笔记/02.组件/60.兄弟组件传值.html\",\"frontmatter\":{\"title\":\"兄弟组件传值\",\"date\":\"2020-02-04 13:04:32\",\"permalink\":\"/pages/809f4582d9ca9552\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"兄弟组件传值\",\"date\":\"2020-02-04 13:04:32\",\"capture\":\"子组件1中把值传到父组件,父组件获取值传入子组件2\\n父组件：\\n```js\\n&lt;子组件1 @方法名x=\\\"方法名y\\\"\\n&lt;子组件2 :值名称x=\\\"值x\\\"&gt;&lt;/子组件2 &gt;\\ndata() {\\n\\treturn {\\n\\t 值x: ''\\n\\t}\\n},\\nmethods: {\\n\\t方法名y(值) {\\n\\t\\tthis.值x = 值\\n\\t}\\n}\\n```\\n子组件1：\\n```js\\nthis.$emit('方法名x', 值) // 传出值\\n```\\n子组件2：\\n```js\\nprops: {\\n    值名称x: { // 接收父组件传入值\\n        type: String,\\n        defa\"},{\"url\":\"/《Vue》笔记/02.组件/50.子组件派发事件和值给父组件.html\",\"relativePath\":\"/《Vue》笔记/02.组件/50.子组件派发事件和值给父组件.html\",\"frontmatter\":{\"title\":\"子组件派发事件和值给父组件\",\"date\":\"2020-02-04 12:56:51\",\"permalink\":\"/pages/0f19a1bcac14fd41\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"子组件派发事件和值给父组件\",\"date\":\"2020-02-04 12:56:51\",\"excerpt\":\"<h1 id=\\\"子组件派发事件和值给父组件\\\" tabindex=\\\"-1\\\">子组件派发事件和值给父组件 <a class=\\\"header-anchor\\\" href=\\\"#子组件派发事件和值给父组件\\\" aria-label=\\\"Permalink to &quot;子组件派发事件和值给父组件&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><a href=\\\"https://cn.vuejs.org/v2/guide/components.html#%E7%9B%91%E5%90%AC%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">API</a></p>\\n<p>子组件通过<code>$emit</code>派发事件和值给父组件（值可以有多个）</p>\\n<div class=\\\"language-js vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">js</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">this</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">$emit</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'fnX'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, value)</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br></div></div>\",\"capture\":\"API\\n子组件通过`$emit`派发事件和值给父组件（值可以有多个）\\n```js\\nthis.$emit('fnX', value)\\n```\\n父组件通过`v-on`绑定子组件派发的事件，并触发一个新的事件，新的事件内可以接收传来的值\\n```js\\n&lt;ComponentName @fnX=\\\"fnY\\\"\\nmethods: {\\n\\tfnY(value) {\\n\\t\\tconsole.log(value)\\n\\t}\\n}\\n```\\n 父子组件间传递数据 demo\\n&lt;p class=\\\"codepen\\\" data-height=\\\"400\\\" data-theme-id=\\\"light\\\" data-default-tab\"},{\"url\":\"/《Vue》笔记/02.组件/40.父组件给子组件传值.html\",\"relativePath\":\"/《Vue》笔记/02.组件/40.父组件给子组件传值.html\",\"frontmatter\":{\"title\":\"父组件给子组件传值\",\"date\":\"2020-02-04 12:45:30\",\"permalink\":\"/pages/07b384c2e6232e07\",\"categories\":[\"《Vue》笔记\",\"组件\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"父组件给子组件传值\",\"date\":\"2020-02-04 12:45:30\",\"excerpt\":\"<h1 id=\\\"父组件给子组件传值\\\" tabindex=\\\"-1\\\">父组件给子组件传值 <a class=\\\"header-anchor\\\" href=\\\"#父组件给子组件传值\\\" aria-label=\\\"Permalink to &quot;父组件给子组件传值&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>父组件中，通过给子组件标签v-bind绑定属性的方式传入值</p>\\n<div class=\\\"language-html vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">html</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">&#x3C;</span><span style=\\\"--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic\\\">ComponentName</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> v-bind:name</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"value\\\"</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">>&#x3C;/</span><span style=\\\"--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic\\\">ComponentName</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">></span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br></div></div><blockquote>\\n<p>如果不使用v-bind传入的值为字符串，使用v-bind绑定传入的值为表达式。</p>\\n</blockquote>\\n\",\"capture\":\"父组件中，通过给子组件标签v-bind绑定属性的方式传入值\\n```html\\n&lt;ComponentName v-bind:name=\\\"value\\\"\\n```\\n&gt; 如果不使用v-bind传入的值为字符串，使用v-bind绑定传入的值为表达式。\\n子组件中，通过props对象接收值\\n```js\\n props: {\\n    name: { // 接收父组件传入值\\n        type: String || ...,\\n        default: ''\\n    }\\n }\\n```\\n 单向数据流\\n所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向\"},{\"url\":\"/《Vue》笔记/01.基础/00.MVVM模式.html\",\"relativePath\":\"/《Vue》笔记/01.基础/00.MVVM模式.html\",\"frontmatter\":{\"title\":\"MVVM模式\",\"date\":\"2020-02-04 12:19:00\",\"permalink\":\"/pages/114158caa9e96df0\",\"categories\":[\"《Vue》笔记\",\"基础\"],\"tags\":[\"Vue\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"MVVM模式\",\"date\":\"2020-02-04 12:19:00\",\"excerpt\":\"<div class=\\\"tip custom-block\\\"><p class=\\\"custom-block-title\\\">TIP</p>\\n<p>说明：本章内容是博主的Vue学习笔记，以<a href=\\\"https://cn.vuejs.org/v2/guide/\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">官方文档</a>为准。</p>\\n</div>\\n<h1 id=\\\"mvvm模式\\\" tabindex=\\\"-1\\\">MVVM模式 <a class=\\\"header-anchor\\\" href=\\\"#mvvm模式\\\" aria-label=\\\"Permalink to &quot;MVVM模式&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>MVVM模式，<code>M</code>即 model，数据模型；<code>V</code>即 view，视图；<code>VM</code>即 view-model，视图模型。</p>\\n\",\"capture\":\"说明：本章内容是博主的Vue学习笔记，以官方文档为准。\\n MVVM模式\\nMVVM模式，`M`即 model，数据模型；`V`即 view，视图；`VM`即 view-model，视图模型。\\n理解\\n首先，数据Model通过Data Bindings把数据绑定在View视图上，\\n当View视图有交互（有改变）的时候，Dom listeners会自动监听，然后更新数据Model。\\nQ：什么是MVVM模式？\\nA：MVVM模式，第一个M代表数据模型，V代表视图，VM代表视图模型；\\n它的实际操作原理是：后台数据通过视图模型来渲染视图，就是页面。当用户在页面上进行操作的时候，\\n视图模型会自动监听到用户的操作\"}],\"ES6\":[{\"url\":\"/《ES6 教程》笔记/29.最新提案.html\",\"relativePath\":\"/《ES6 教程》笔记/29.最新提案.html\",\"frontmatter\":{\"title\":\"最新提案\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/7188882b8d65af1b\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"最新提案\",\"date\":\"2020-02-09 16:00:30\",\"excerpt\":\"<h1 id=\\\"最新提案\\\" tabindex=\\\"-1\\\">最新提案 <a class=\\\"header-anchor\\\" href=\\\"#最新提案\\\" aria-label=\\\"Permalink to &quot;最新提案&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>本章介绍一些尚未进入标准、但很有希望的最新提案。</p>\\n<h2 id=\\\"do-表达式\\\" tabindex=\\\"-1\\\">do 表达式 <a class=\\\"header-anchor\\\" href=\\\"#do-表达式\\\" aria-label=\\\"Permalink to &quot;do 表达式&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">{</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">  let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> t </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> f</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">();</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">  t </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> t </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">*</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> t </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">+</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br></div></div>\",\"capture\":\"本章介绍一些尚未进入标准、但很有希望的最新提案。\\n do 表达式\\n本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。\\n```javascript\\n{\\n  let t = f();\\n  t = t * t + 1;\\n}\\n```\\n上面代码中，块级作用域将两个语句封装在一起。但是，在块级作用域以外，没有办法得到`t`的值，因为块级作用域不返回值，除非`t`是全局变量。\\n现在有一个提案，使得块级作用域可以变为表达式，也就是说可以返回值，办法就是在块级作用域之前加上`do`，使它变为`do`表达式，然后就会返回内部最后执行的表达式的值。\\n```javascript\\nlet x = do {\"},{\"url\":\"/《ES6 教程》笔记/30.装饰器.html\",\"relativePath\":\"/《ES6 教程》笔记/30.装饰器.html\",\"frontmatter\":{\"title\":\"装饰器\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/e97bc1e5626b082c\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"装饰器\",\"date\":\"2020-02-09 16:00:30\",\"excerpt\":\"<h1 id=\\\"装饰器\\\" tabindex=\\\"-1\\\">装饰器 <a class=\\\"header-anchor\\\" href=\\\"#装饰器\\\" aria-label=\\\"Permalink to &quot;装饰器&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>[说明] Decorator 提案经过了大幅修改，目前还没有定案，不知道语法会不会再变。下面的内容完全依据以前的提案，已经有点过时了。等待定案以后，需要完全重写。</p>\\n<p>装饰器（Decorator）是一种与类（class）相关的语法，用来注释或修改类和类方法。许多面向对象的语言都有这项功能，目前有一个<a href=\\\"https://github.com/tc39/proposal-decorators\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">提案</a>将其引入了 ECMAScript。</p>\\n\",\"capture\":\"[说明] Decorator 提案经过了大幅修改，目前还没有定案，不知道语法会不会再变。下面的内容完全依据以前的提案，已经有点过时了。等待定案以后，需要完全重写。\\n装饰器（Decorator）是一种与类（class）相关的语法，用来注释或修改类和类方法。许多面向对象的语言都有这项功能，目前有一个提案将其引入了 ECMAScript。\\n装饰器是一种函数，写成`@ + 函数名`。它可以放在类和类方法的定义前面。\\n```javascript\\n@frozen class Foo {\\n  @configurable(false)\\n  @enumerable(true)\\n  method() {}\\n  @\"},{\"url\":\"/《ES6 教程》笔记/31.函数式编程.html\",\"relativePath\":\"/《ES6 教程》笔记/31.函数式编程.html\",\"frontmatter\":{\"title\":\"函数式编程\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/1cf50330655efc69\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"函数式编程\",\"date\":\"2020-02-09 16:00:30\",\"excerpt\":\"<h1 id=\\\"函数式编程\\\" tabindex=\\\"-1\\\">函数式编程 <a class=\\\"header-anchor\\\" href=\\\"#函数式编程\\\" aria-label=\\\"Permalink to &quot;函数式编程&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>JavaScript 语言从一诞生，就具有函数式编程的烙印。它将函数作为一种独立的数据类型，与其他数据类型处于完全平等的地位。在 JavaScript 语言中，你可以采用面向对象编程，也可以采用函数式编程。有人甚至说，JavaScript 是有史以来第一种被大规模采用的函数式编程语言。</p>\\n\",\"capture\":\"JavaScript 语言从一诞生，就具有函数式编程的烙印。它将函数作为一种独立的数据类型，与其他数据类型处于完全平等的地位。在 JavaScript 语言中，你可以采用面向对象编程，也可以采用函数式编程。有人甚至说，JavaScript 是有史以来第一种被大规模采用的函数式编程语言。\\nES6 的种种新增功能，使得函数式编程变得更方便、更强大。本章介绍 ES6 如何进行函数式编程。\\n 柯里化\\n柯里化（currying）指的是将一个多参数的函数拆分成一系列函数，每个拆分后的函数都只接受一个参数（unary）。\\n```javascript\\nfunction add (a, b) {\\n  retur\"},{\"url\":\"/《ES6 教程》笔记/32.Mixin.html\",\"relativePath\":\"/《ES6 教程》笔记/32.Mixin.html\",\"frontmatter\":{\"title\":\"Mixin\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/6a8e2dc558da1b39\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Mixin\",\"date\":\"2020-02-09 16:00:30\",\"excerpt\":\"<h1 id=\\\"mixin\\\" tabindex=\\\"-1\\\">Mixin <a class=\\\"header-anchor\\\" href=\\\"#mixin\\\" aria-label=\\\"Permalink to &quot;Mixin&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>JavaScript 语言的设计是单一继承，即子类只能继承一个父类，不允许继承多个父类。这种设计保证了对象继承的层次结构是树状的，而不是复杂的<a href=\\\"https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">网状结构</a>。</p>\\n\",\"capture\":\"JavaScript 语言的设计是单一继承，即子类只能继承一个父类，不允许继承多个父类。这种设计保证了对象继承的层次结构是树状的，而不是复杂的网状结构。\\n但是，这大大降低了编程的灵活性。因为实际开发中，有时不可避免，子类需要继承多个父类。举例来说，“猫”可以继承“哺乳类动物”，也可以继承“宠物”。\\n各种单一继承的编程语言，有不同的多重继承解决方案。比如，Java 语言也是子类只能继承一个父类，但是还允许继承多个界面（interface），这样就间接实现了多重继承。Interface 与父类一样，也是一个类，只不过它只定义接口（method signature），不定义实现，因此又被称为“抽象类\"},{\"url\":\"/《ES6 教程》笔记/33.SIMD.html\",\"relativePath\":\"/《ES6 教程》笔记/33.SIMD.html\",\"frontmatter\":{\"title\":\"SIMD\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/8e8f80f69b775a56\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"SIMD\",\"date\":\"2020-02-09 16:00:30\",\"excerpt\":\"<h1 id=\\\"simd\\\" tabindex=\\\"-1\\\">SIMD <a class=\\\"header-anchor\\\" href=\\\"#simd\\\" aria-label=\\\"Permalink to &quot;SIMD&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>SIMD（发音<code>/sim-dee/</code>）是“Single Instruction/Multiple Data”的缩写，意为“单指令，多数据”。它是 JavaScript 操作 CPU 对应指令的接口，你可以看做这是一种不同的运算执行模式。与它相对的是 SISD（“Single Instruction/Single Data”），即“单指令，单数据”。</p>\\n\",\"capture\":\"概述\\nSIMD（发音`/sim-dee/`）是“Single Instruction/Multiple Data”的缩写，意为“单指令，多数据”。它是 JavaScript 操作 CPU 对应指令的接口，你可以看做这是一种不同的运算执行模式。与它相对的是 SISD（“Single Instruction/Single Data”），即“单指令，单数据”。\\nSIMD 的含义是使用一个指令，完成多个数据的运算；SISD 的含义是使用一个指令，完成单个数据的运算，这是 JavaScript 的默认运算模式。显而易见，SIMD 的执行效率要高于 SISD，所以被广泛用于 3D 图形运算、物理模拟等运算\"},{\"url\":\"/《ES6 教程》笔记/34.参考链接.html\",\"relativePath\":\"/《ES6 教程》笔记/34.参考链接.html\",\"frontmatter\":{\"title\":\"参考链接\",\"date\":\"2020-02-09 16:00:30\",\"permalink\":\"/pages/ea6f3b870f6dab69\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"参考链接\",\"date\":\"2020-02-09 16:00:30\",\"capture\":\"官方文件\\n- ECMAScript® 2015 Language Specification: ECMAScript 2015 规格\\n- ECMAScript® 2016 Language Specification: ECMAScript 2016 规格\\n- ECMAScript® 2017 Language Specification：ECMAScript 2017 规格（草案）\\n- ECMAScript Current Proposals: ECMAScript 当前的所有提案\\n- ECMAScript Active Proposals: 已经进入正式流程的提案\\n- ECMAScript\"},{\"url\":\"/《ES6 教程》笔记/02.let 和 const 命令.html\",\"relativePath\":\"/《ES6 教程》笔记/02.let 和 const 命令.html\",\"frontmatter\":{\"title\":\"let 和 const 命令\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/c1edd70a6b7c7872\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"let 和 const 命令\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"let-和-const-命令\\\" tabindex=\\\"-1\\\">let 和 const 命令 <a class=\\\"header-anchor\\\" href=\\\"#let-和-const-命令\\\" aria-label=\\\"Permalink to &quot;let 和 const 命令&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"let-命令\\\" tabindex=\\\"-1\\\">let 命令 <a class=\\\"header-anchor\\\" href=\\\"#let-命令\\\" aria-label=\\\"Permalink to &quot;let 命令&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"基本用法\\\" tabindex=\\\"-1\\\">基本用法 <a class=\\\"header-anchor\\\" href=\\\"#基本用法\\\" aria-label=\\\"Permalink to &quot;基本用法&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>ES6 新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code>，但是所声明的变量，<strong>只在<code>let</code>命令所在的代码块内有效(块级作用域)</strong>。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">{</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">  let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> a </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 10</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">  var</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> b </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">a </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// ReferenceError: a is not defined.</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">b </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// 1</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br></div></div>\",\"capture\":\"let 命令\\n 基本用法\\nES6 新增了`let`命令，用来声明变量。它的用法类似于`var`，但是所声明的变量，只在`let`命令所在的代码块内有效(块级作用域)。\\n```javascript\\n{\\n  let a = 10;\\n  var b = 1;\\n}\\na // ReferenceError: a is not defined.\\nb // 1\\n```\\n上面代码在代码块之中，分别用`let`和`var`声明了两个变量。然后在代码块之外调用这两个变量，结果`let`声明的变量报错，`var`声明的变量返回了正确的值。这表明，`let`声明的变量只在它所在的代码块有效。\\n`for`循环的计数器，\"},{\"url\":\"/《ES6 教程》笔记/03.变量的解构赋值.html\",\"relativePath\":\"/《ES6 教程》笔记/03.变量的解构赋值.html\",\"frontmatter\":{\"title\":\"变量的解构赋值\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/b1ab10a62f7564da\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"变量的解构赋值\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"变量的解构赋值\\\" tabindex=\\\"-1\\\">变量的解构赋值 <a class=\\\"header-anchor\\\" href=\\\"#变量的解构赋值\\\" aria-label=\\\"Permalink to &quot;变量的解构赋值&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"数组的解构赋值\\\" tabindex=\\\"-1\\\">数组的解构赋值 <a class=\\\"header-anchor\\\" href=\\\"#数组的解构赋值\\\" aria-label=\\\"Permalink to &quot;数组的解构赋值&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"基本用法\\\" tabindex=\\\"-1\\\">基本用法 <a class=\\\"header-anchor\\\" href=\\\"#基本用法\\\" aria-label=\\\"Permalink to &quot;基本用法&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>ES6 允许按照一定模式，<strong>从数组和对象中提取值，对变量进行赋值，这被称为解构</strong>（Destructuring）。</p>\\n<p>以前，为变量赋值，只能直接指定值。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> a </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> b </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> c </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 3</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br></div></div>\",\"capture\":\"数组的解构赋值\\n 基本用法\\nES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。\\n以前，为变量赋值，只能直接指定值。\\n```javascript\\nlet a = 1;\\nlet b = 2;\\nlet c = 3;\\n```\\nES6 允许写成下面这样。\\n```javascript\\nlet [a, b, c] = [1, 2, 3];\\n```\\n上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。\\n本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。\\n```javas\"},{\"url\":\"/《ES6 教程》笔记/04.字符串的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/04.字符串的扩展.html\",\"frontmatter\":{\"title\":\"字符串的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/ca89eca8adeba5f4\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"字符串的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"字符串的扩展\\\" tabindex=\\\"-1\\\">字符串的扩展 <a class=\\\"header-anchor\\\" href=\\\"#字符串的扩展\\\" aria-label=\\\"Permalink to &quot;字符串的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>本章介绍 ES6 对字符串的改造和增强，下一章介绍字符串对象的新增方法。</p>\\n<h2 id=\\\"字符的-unicode-表示法\\\" tabindex=\\\"-1\\\">字符的 Unicode 表示法 <a class=\\\"header-anchor\\\" href=\\\"#字符的-unicode-表示法\\\" aria-label=\\\"Permalink to &quot;字符的 Unicode 表示法&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES6 加强了对 Unicode 的支持，允许采用<code>\\\\uxxxx</code>形式表示一个字符，其中<code>xxxx</code>表示字符的 Unicode 码点。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">\\\\u0061</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">\\\"</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// \\\"a\\\"</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br></div></div>\",\"capture\":\"本章介绍 ES6 对字符串的改造和增强，下一章介绍字符串对象的新增方法。\\n 字符的 Unicode 表示法\\nES6 加强了对 Unicode 的支持，允许采用`\\\\uxxxx`形式表示一个字符，其中`xxxx`表示字符的 Unicode 码点。\\n```javascript\\n\\\"\\\\u0061\\\"\\n// \\\"a\\\"\\n```\\n但是，这种表示法只限于码点在`\\\\u0000`~`\\\\uFFFF`之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。\\n```javascript\\n\\\"\\\\uD842\\\\uDFB7\\\"\\n// \\\"𠮷\\\"\\n\\\"\\\\u20BB7\\\"\\n// \\\" 7\\\"\\n```\\n上面代码表示，如果直接在`\\\\u`后面跟上超过`\"},{\"url\":\"/《ES6 教程》笔记/05.字符串的新增方法.html\",\"relativePath\":\"/《ES6 教程》笔记/05.字符串的新增方法.html\",\"frontmatter\":{\"title\":\"字符串的新增方法\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/a650b4a0ebfc9350\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"字符串的新增方法\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"字符串的新增方法\\\" tabindex=\\\"-1\\\">字符串的新增方法 <a class=\\\"header-anchor\\\" href=\\\"#字符串的新增方法\\\" aria-label=\\\"Permalink to &quot;字符串的新增方法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>本章介绍字符串对象的新增方法。</p>\\n<h2 id=\\\"string-fromcodepoint\\\" tabindex=\\\"-1\\\">String.fromCodePoint() <a class=\\\"header-anchor\\\" href=\\\"#string-fromcodepoint\\\" aria-label=\\\"Permalink to &quot;String.fromCodePoint()&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES5 提供<code>String.fromCharCode()</code>方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于<code>0xFFFF</code>的字符。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">String.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">fromCharCode</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">0x20BB7</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">)</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// \\\"ஷ\\\"</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br></div></div>\",\"capture\":\"本章介绍字符串对象的新增方法。\\n String.fromCodePoint()\\nES5 提供`String.fromCharCode()`方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于`0xFFFF`的字符。\\n```javascript\\nString.fromCharCode(0x20BB7)\\n// \\\"ஷ\\\"\\n```\\n上面代码中，`String.fromCharCode()`不能识别大于`0xFFFF`的码点，所以`0x20BB7`就发生了溢出，最高位`2`被舍弃了，最后返回码点`U+0BB7`对应的字符，而不是码点`U+20BB7`对应的字符。\\nES6 提供了`S\"},{\"url\":\"/《ES6 教程》笔记/06.正则的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/06.正则的扩展.html\",\"frontmatter\":{\"title\":\"正则的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/0473261a6ab0ee8c\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"正则的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"正则的扩展\\\" tabindex=\\\"-1\\\">正则的扩展 <a class=\\\"header-anchor\\\" href=\\\"#正则的扩展\\\" aria-label=\\\"Permalink to &quot;正则的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"regexp-构造函数\\\" tabindex=\\\"-1\\\">RegExp 构造函数 <a class=\\\"header-anchor\\\" href=\\\"#regexp-构造函数\\\" aria-label=\\\"Permalink to &quot;RegExp 构造函数&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>在 ES5 中，<code>RegExp</code>构造函数的参数有两种情况。</p>\\n<p>第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">var</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> regex </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> new</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> RegExp</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'xyz'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'i'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">);</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// 等价于</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">var</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> regex </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> /</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#DBEDFF\\\">xyz</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">/</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">i</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br></div></div>\",\"capture\":\"RegExp 构造函数\\n在 ES5 中，`RegExp`构造函数的参数有两种情况。\\n第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。\\n```javascript\\nvar regex = new RegExp('xyz', 'i');\\n// 等价于\\nvar regex = /xyz/i;\\n```\\n第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。\\n```javascript\\nvar regex = new RegExp(/xyz/i);\\n// 等价于\\nvar regex = /xyz/i;\\n```\\n但是，ES5 不允许此时使用第二个参数添加修饰\"},{\"url\":\"/《ES6 教程》笔记/07.数值的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/07.数值的扩展.html\",\"frontmatter\":{\"title\":\"数值的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/5dfea9a0f2d1a392\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"数值的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"数值的扩展\\\" tabindex=\\\"-1\\\">数值的扩展 <a class=\\\"header-anchor\\\" href=\\\"#数值的扩展\\\" aria-label=\\\"Permalink to &quot;数值的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"二进制和八进制表示法\\\" tabindex=\\\"-1\\\">二进制和八进制表示法 <a class=\\\"header-anchor\\\" href=\\\"#二进制和八进制表示法\\\" aria-label=\\\"Permalink to &quot;二进制和八进制表示法&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES6 提供了二进制和八进制数值的新的写法，分别用前缀<code>0b</code>（或<code>0B</code>）和<code>0o</code>（或<code>0O</code>）表示。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">0b111110111</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> ===</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 503</span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\"> // true</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">0o767</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> ===</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> 503</span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\"> // true</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br></div></div>\",\"capture\":\"二进制和八进制表示法\\nES6 提供了二进制和八进制数值的新的写法，分别用前缀`0b`（或`0B`）和`0o`（或`0O`）表示。\\n```javascript\\n0b111110111 === 503 // true\\n0o767 === 503 // true\\n```\\n从 ES5 开始，在严格模式之中，八进制就不再允许使用前缀`0`表示，ES6 进一步明确，要使用前缀`0o`表示。\\n```javascript\\n// 非严格模式\\n(function(){\\n  console.log(0o11 === 011);\\n})() // true\\n// 严格模式\\n(function(){\\n  'use str\"},{\"url\":\"/《ES6 教程》笔记/08.函数的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/08.函数的扩展.html\",\"frontmatter\":{\"title\":\"函数的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/8ed309d668b20264\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"函数的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"函数的扩展\\\" tabindex=\\\"-1\\\">函数的扩展 <a class=\\\"header-anchor\\\" href=\\\"#函数的扩展\\\" aria-label=\\\"Permalink to &quot;函数的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"函数参数的默认值\\\" tabindex=\\\"-1\\\">函数参数的默认值 <a class=\\\"header-anchor\\\" href=\\\"#函数参数的默认值\\\" aria-label=\\\"Permalink to &quot;函数参数的默认值&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"基本用法\\\" tabindex=\\\"-1\\\">基本用法 <a class=\\\"header-anchor\\\" href=\\\"#基本用法\\\" aria-label=\\\"Permalink to &quot;基本用法&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">function</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#E36209;--shiki-dark:#FFAB70\\\">x</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#E36209;--shiki-dark:#FFAB70\\\">y</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">) {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">  y </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> y </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">||</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> 'World'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">  console.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(x, y);</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'Hello'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">) </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// Hello World</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'Hello'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'China'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">) </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// Hello China</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'Hello'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">''</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">) </span><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// Hello World</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br><span class=\\\"line-number\\\">8</span><br></div></div>\",\"capture\":\"函数参数的默认值\\n 基本用法\\nES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。\\n```javascript\\nfunction log(x, y) {\\n  y = y || 'World';\\n  console.log(x, y);\\n}\\nlog('Hello') // Hello World\\nlog('Hello', 'China') // Hello China\\nlog('Hello', '') // Hello World\\n```\\n上面代码检查函数`log`的参数`y`有没有赋值，如果没有，则指定默认值为`World`。这种写法的缺点在于，如果参数`y`赋值了，但是对应的布\"},{\"url\":\"/《ES6 教程》笔记/09.数组的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/09.数组的扩展.html\",\"frontmatter\":{\"title\":\"数组的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/e34009d60d8bc4b2\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"数组的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"数组的扩展\\\" tabindex=\\\"-1\\\">数组的扩展 <a class=\\\"header-anchor\\\" href=\\\"#数组的扩展\\\" aria-label=\\\"Permalink to &quot;数组的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"扩展运算符\\\" tabindex=\\\"-1\\\">扩展运算符 <a class=\\\"header-anchor\\\" href=\\\"#扩展运算符\\\" aria-label=\\\"Permalink to &quot;扩展运算符&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"含义\\\" tabindex=\\\"-1\\\">含义 <a class=\\\"header-anchor\\\" href=\\\"#含义\\\" aria-label=\\\"Permalink to &quot;含义&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>扩展运算符（spread）是三个点（<code>...</code>）。它好比 rest 参数的逆运算，<strong>将一个数组转为用逗号分隔的参数序列</strong>。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">console.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">...</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">[</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">3</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">])</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// 1 2 3</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">console.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">...</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">[</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">3</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">4</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">], </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">5</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">)</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// 1 2 3 4 5</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">[</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">...</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">document.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">querySelectorAll</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\">'div'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">)]</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// [&#x3C;div>, &#x3C;div>, &#x3C;div>]</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br><span class=\\\"line-number\\\">8</span><br></div></div>\",\"capture\":\"扩展运算符\\n 含义\\n扩展运算符（spread）是三个点（`...`）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。\\n```javascript\\nconsole.log(...[1, 2, 3])\\n// 1 2 3\\nconsole.log(1, ...[2, 3, 4], 5)\\n// 1 2 3 4 5\\n[...document.querySelectorAll('div')]\\n// [&lt;div\\n```\\n该运算符主要用于函数调用。\\n```javascript\\nfunction push(array, ...items) {\\n  array.push(...items\"},{\"url\":\"/《ES6 教程》笔记/10.对象的扩展.html\",\"relativePath\":\"/《ES6 教程》笔记/10.对象的扩展.html\",\"frontmatter\":{\"title\":\"对象的扩展\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/b5e3e0a0ff6e9c25\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"对象的扩展\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"对象的扩展\\\" tabindex=\\\"-1\\\">对象的扩展 <a class=\\\"header-anchor\\\" href=\\\"#对象的扩展\\\" aria-label=\\\"Permalink to &quot;对象的扩展&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>对象（object）是 JavaScript 最重要的数据结构。ES6 对它进行了重大升级，本章介绍数据结构本身的改变，下一章介绍<code>Object</code>对象的新增方法。</p>\\n\",\"capture\":\"对象（object）是 JavaScript 最重要的数据结构。ES6 对它进行了重大升级，本章介绍数据结构本身的改变，下一章介绍`Object`对象的新增方法。\\n 属性的简洁表示法\\nES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。\\n```javascript\\nconst foo = 'bar';\\nconst baz = {foo};\\nbaz // {foo: \\\"bar\\\"}\\n// 等同于\\nconst baz = {foo: foo};\\n```\\n上面代码中，变量`foo`直接写在大括号里面。这时，属性名就是变量名, 属性值就是变量值。下面是另一个例子。\\n`\"},{\"url\":\"/《ES6 教程》笔记/11.对象的新增方法.html\",\"relativePath\":\"/《ES6 教程》笔记/11.对象的新增方法.html\",\"frontmatter\":{\"title\":\"对象的新增方法\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/e85e68947502cf90\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"对象的新增方法\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"对象的新增方法\\\" tabindex=\\\"-1\\\">对象的新增方法 <a class=\\\"header-anchor\\\" href=\\\"#对象的新增方法\\\" aria-label=\\\"Permalink to &quot;对象的新增方法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>本章介绍 Object 对象的新增方法。</p>\\n<h2 id=\\\"object-is\\\" tabindex=\\\"-1\\\">Object.is() <a class=\\\"header-anchor\\\" href=\\\"#object-is\\\" aria-label=\\\"Permalink to &quot;Object.is()&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES5 比较两个值是否相等，只有两个运算符：相等运算符（<code>==</code>）和严格相等运算符（<code>===</code>）。它们都有缺点，前者会自动转换数据类型，后者的<code>NaN</code>不等于自身，以及<code>+0</code>等于<code>-0</code>。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</p>\\n<p>ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。<code>Object.is</code>就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</p>\\n\",\"capture\":\"本章介绍 Object 对象的新增方法。\\n Object.is()\\nES5 比较两个值是否相等，只有两个运算符：相等运算符（`==`）和严格相等运算符（`===`）。它们都有缺点，前者会自动转换数据类型，后者的`NaN`不等于自身，以及`+0`等于`-0`。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。\\nES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。`Object.is`就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。\\n```javascript\\nObject.\"},{\"url\":\"/《ES6 教程》笔记/12.Symbol.html\",\"relativePath\":\"/《ES6 教程》笔记/12.Symbol.html\",\"frontmatter\":{\"title\":\"Symbol\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/02c86eb2792f3262\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Symbol\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"symbol\\\" tabindex=\\\"-1\\\">Symbol <a class=\\\"header-anchor\\\" href=\\\"#symbol\\\" aria-label=\\\"Permalink to &quot;Symbol&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，<strong>保证每个属性的名字都是独一无二</strong>的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入<code>Symbol</code>的原因。</p>\\n\",\"capture\":\"概述\\nES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入`Symbol`的原因。\\nES6 引入了一种新的原始数据类型`Symbol`，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：`undefined`、`null`、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。\\nSymbol 值\"},{\"url\":\"/《ES6 教程》笔记/13.Set 和 Map 数据结构.html\",\"relativePath\":\"/《ES6 教程》笔记/13.Set 和 Map 数据结构.html\",\"frontmatter\":{\"title\":\"Set 和 Map 数据结构\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/0c21dae358fca16b\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Set 和 Map 数据结构\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"set-和-map-数据结构\\\" tabindex=\\\"-1\\\">Set 和 Map 数据结构 <a class=\\\"header-anchor\\\" href=\\\"#set-和-map-数据结构\\\" aria-label=\\\"Permalink to &quot;Set 和 Map 数据结构&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"set\\\" tabindex=\\\"-1\\\">Set <a class=\\\"header-anchor\\\" href=\\\"#set\\\" aria-label=\\\"Permalink to &quot;Set&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"基本用法\\\" tabindex=\\\"-1\\\">基本用法 <a class=\\\"header-anchor\\\" href=\\\"#基本用法\\\" aria-label=\\\"Permalink to &quot;基本用法&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>ES6 提供了新的数据结构 Set。它<strong>类似于数组，但是成员的值都是唯一的，没有重复的值</strong>。</p>\\n<p><strong><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构</strong>。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">const</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> s</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> =</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> new</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> Set</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">();</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">[</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">3</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">5</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">4</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">5</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">].</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">forEach</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#E36209;--shiki-dark:#FFAB70\\\">x</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> =></span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> s.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">add</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(x));</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">for</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> (</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">let</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> i </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">of</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> s) {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">  console.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">log</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(i);</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#6A737D;--shiki-dark:#6A737D\\\">// 2 3 5 4</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br><span class=\\\"line-number\\\">8</span><br></div></div>\",\"capture\":\"Set\\n 基本用法\\nES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。\\n`Set`本身是一个构造函数，用来生成 Set 数据结构。\\n```javascript\\nconst s = new Set();\\n[2, 3, 5, 4, 5, 2, 2].forEach(x =\\nfor (let i of s) {\\n  console.log(i);\\n}\\n// 2 3 5 4\\n```\\n上面代码通过`add()`方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。\\n`Set`函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参\"},{\"url\":\"/《ES6 教程》笔记/14.Proxy.html\",\"relativePath\":\"/《ES6 教程》笔记/14.Proxy.html\",\"frontmatter\":{\"title\":\"Proxy\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/f56ec2ab97d60483\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Proxy\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"proxy\\\" tabindex=\\\"-1\\\">Proxy <a class=\\\"header-anchor\\\" href=\\\"#proxy\\\" aria-label=\\\"Permalink to &quot;Proxy&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“<strong>元编程</strong>”（meta programming），即<strong>对编程语言进行编程</strong>。</p>\\n<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，<strong>外界对该对象的访问，都必须先通过这层拦截</strong>，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>\\n\",\"capture\":\"概述\\nProxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。\\nProxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。\\n```javascript\\nvar obj = new Proxy({}, {\\n  get: function (target, propKey, receiver) {\\n    console.log(\"},{\"url\":\"/《ES6 教程》笔记/15.Reflect.html\",\"relativePath\":\"/《ES6 教程》笔记/15.Reflect.html\",\"frontmatter\":{\"title\":\"Reflect\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/74de3e45e4491e95\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Reflect\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"reflect\\\" tabindex=\\\"-1\\\">Reflect <a class=\\\"header-anchor\\\" href=\\\"#reflect\\\" aria-label=\\\"Permalink to &quot;Reflect&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p><code>Reflect</code>对象与<code>Proxy</code>对象一样，也是 ES6 为了操作对象而提供的新 API。<code>Reflect</code>对象的设计目的有这样几个。</p>\\n<p>（1） **将<code>Object</code>对象的一些明显属于语言内部的方法（比如<code>Object.defineProperty</code>），放到<code>Reflect</code>对象上。**现阶段，某些方法同时在<code>Object</code>和<code>Reflect</code>对象上部署，未来的新方法将只部署在<code>Reflect</code>对象上。也就是说，从<code>Reflect</code>对象上可以拿到语言内部的方法。</p>\\n\",\"capture\":\"概述\\n`Reflect`对象与`Proxy`对象一样，也是 ES6 为了操作对象而提供的新 API。`Reflect`对象的设计目的有这样几个。\\n（1） 将`Object`对象的一些明显属于语言内部的方法（比如`Object.defineProperty`），放到`Reflect`对象上。现阶段，某些方法同时在`Object`和`Reflect`对象上部署，未来的新方法将只部署在`Reflect`对象上。也就是说，从`Reflect`对象上可以拿到语言内部的方法。\\n（2） 修改某些`Object`方法的返回结果，让其变得更合理。比如，`Object.defineProperty(obj, na\"},{\"url\":\"/《ES6 教程》笔记/16.Promise 对象.html\",\"relativePath\":\"/《ES6 教程》笔记/16.Promise 对象.html\",\"frontmatter\":{\"title\":\"Promise 对象\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/2810ae8985e9bd52\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Promise 对象\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"promise-对象\\\" tabindex=\\\"-1\\\">Promise 对象 <a class=\\\"header-anchor\\\" href=\\\"#promise-对象\\\" aria-label=\\\"Permalink to &quot;Promise 对象&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"promise-的含义\\\" tabindex=\\\"-1\\\">Promise 的含义 <a class=\\\"header-anchor\\\" href=\\\"#promise-的含义\\\" aria-label=\\\"Permalink to &quot;Promise 的含义&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了<code>Promise</code>对象。</p>\\n\",\"capture\":\"Promise 的含义\\nPromise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了`Promise`对象。\\n所谓`Promise`，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。\\n`Promise`对象有以下两个特点。\\n（1）对象的状态不受外界影响。`Promise`对象代表一个异步操作，有三种状态：`pe\"},{\"url\":\"/《ES6 教程》笔记/17.Iterator 和 for-of 循环.html\",\"relativePath\":\"/《ES6 教程》笔记/17.Iterator 和 for-of 循环.html\",\"frontmatter\":{\"title\":\"Iterator 和 for-of 循环\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/48df907ad3570f3d\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Iterator 和 for-of 循环\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"iterator-和-for-of-循环\\\" tabindex=\\\"-1\\\">Iterator 和 for...of 循环 <a class=\\\"header-anchor\\\" href=\\\"#iterator-和-for-of-循环\\\" aria-label=\\\"Permalink to &quot;Iterator 和 for...of 循环&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"iterator-遍历器-的概念\\\" tabindex=\\\"-1\\\">Iterator（遍历器）的概念 <a class=\\\"header-anchor\\\" href=\\\"#iterator-遍历器-的概念\\\" aria-label=\\\"Permalink to &quot;Iterator（遍历器）的概念&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>JavaScript 原有的表示“集合”的数据结构，主要是数组（<code>Array</code>）和对象（<code>Object</code>），ES6 又添加了<code>Map</code>和<code>Set</code>。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是<code>Map</code>，<code>Map</code>的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。</p>\\n\",\"capture\":\"Iterator（遍历器）的概念\\nJavaScript 原有的表示“集合”的数据结构，主要是数组（`Array`）和对象（`Object`），ES6 又添加了`Map`和`Set`。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是`Map`，`Map`的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。\\n遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。\\nIterator 的作用有三个：一是为各\"},{\"url\":\"/《ES6 教程》笔记/18.Generator 函数的语法.html\",\"relativePath\":\"/《ES6 教程》笔记/18.Generator 函数的语法.html\",\"frontmatter\":{\"title\":\"Generator 函数的语法\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/718b48ed9ce0adce\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Generator 函数的语法\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"generator-函数的语法\\\" tabindex=\\\"-1\\\">Generator 函数的语法 <a class=\\\"header-anchor\\\" href=\\\"#generator-函数的语法\\\" aria-label=\\\"Permalink to &quot;Generator 函数的语法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"基本概念\\\" tabindex=\\\"-1\\\">基本概念 <a class=\\\"header-anchor\\\" href=\\\"#基本概念\\\" aria-label=\\\"Permalink to &quot;基本概念&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>Generator 函数是 ES6 提供的一种<strong>异步编程解决方案</strong>，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《Generator 函数的异步应用》一章。</p>\\n\",\"capture\":\"简介\\n 基本概念\\nGenerator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《Generator 函数的异步应用》一章。\\nGenerator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。\\n执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。\\n形式上，Generator 函数是一个\"},{\"url\":\"/《ES6 教程》笔记/19.Generator 函数的异步应用.html\",\"relativePath\":\"/《ES6 教程》笔记/19.Generator 函数的异步应用.html\",\"frontmatter\":{\"title\":\"Generator 函数的异步应用\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/75af7031eb66847b\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Generator 函数的异步应用\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"generator-函数的异步应用\\\" tabindex=\\\"-1\\\">Generator 函数的异步应用 <a class=\\\"header-anchor\\\" href=\\\"#generator-函数的异步应用\\\" aria-label=\\\"Permalink to &quot;Generator 函数的异步应用&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>异步编程对 JavaScript 语言太重要。JavaScript 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。本章主要介绍 Generator 函数如何完成异步操作。</p>\\n\",\"capture\":\"异步编程对 JavaScript 语言太重要。JavaScript 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。本章主要介绍 Generator 函数如何完成异步操作。\\n 传统方法\\nES6 诞生以前，异步编程的方法，大概有下面四种。\\n- 回调函数\\n- 事件监听\\n- 发布/订阅\\n- Promise 对象\\nGenerator 函数将 JavaScript 异步编程带入了一个全新的阶段。\\n 基本概念\\n 异步\\n所谓\\\"异步\\\"，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。\\n比如，有一个任\"},{\"url\":\"/《ES6 教程》笔记/20.async 函数.html\",\"relativePath\":\"/《ES6 教程》笔记/20.async 函数.html\",\"frontmatter\":{\"title\":\"async 函数\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/3777253e65bac487\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"async 函数\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"async-函数\\\" tabindex=\\\"-1\\\">async 函数 <a class=\\\"header-anchor\\\" href=\\\"#async-函数\\\" aria-label=\\\"Permalink to &quot;async 函数&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"含义\\\" tabindex=\\\"-1\\\">含义 <a class=\\\"header-anchor\\\" href=\\\"#含义\\\" aria-label=\\\"Permalink to &quot;含义&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p>\\n<p>async 函数是什么？一句话，它就<strong>是 Generator 函数的语法糖</strong>。</p>\\n<p>前文有一个 Generator 函数，依次读取两个文件。</p>\\n\",\"capture\":\"含义\\nES2017 标准引入了 async 函数，使得异步操作变得更加方便。\\nasync 函数是什么？一句话，它就是 Generator 函数的语法糖。\\n前文有一个 Generator 函数，依次读取两个文件。\\n```javascript\\nconst fs = require('fs');\\nconst readFile = function (fileName) {\\n  return new Promise(function (resolve, reject) {\\n    fs.readFile(fileName, function(error, data) {\\n      if (error\"},{\"url\":\"/《ES6 教程》笔记/21.Class 的基本语法.html\",\"relativePath\":\"/《ES6 教程》笔记/21.Class 的基本语法.html\",\"frontmatter\":{\"title\":\"Class 的基本语法\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/e831e1593c82bbe0\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Class 的基本语法\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"class-的基本语法\\\" tabindex=\\\"-1\\\">Class 的基本语法 <a class=\\\"header-anchor\\\" href=\\\"#class-的基本语法\\\" aria-label=\\\"Permalink to &quot;Class 的基本语法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<h3 id=\\\"类的由来\\\" tabindex=\\\"-1\\\">类的由来 <a class=\\\"header-anchor\\\" href=\\\"#类的由来\\\" aria-label=\\\"Permalink to &quot;类的由来&quot;\\\">&ZeroWidthSpace;</a></h3>\\n<p>JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">function</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> Point</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#E36209;--shiki-dark:#FFAB70\\\">x</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#E36209;--shiki-dark:#FFAB70\\\">y</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">) {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">  this</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.x </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> x;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">  this</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.y </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> y;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">Point</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">prototype</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\">toString</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> =</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> function</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> () {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">  return</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> '('</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> +</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> this</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.x </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">+</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> ', '</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> +</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\"> this</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">.y </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">+</span><span style=\\\"--shiki-light:#032F62;--shiki-dark:#9ECBFF\\\"> ')'</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">;</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">};</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">var</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> p </span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">=</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> new</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> Point</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">(</span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">1</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">, </span><span style=\\\"--shiki-light:#005CC5;--shiki-dark:#79B8FF\\\">2</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">);</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br><span class=\\\"line-number\\\">6</span><br><span class=\\\"line-number\\\">7</span><br><span class=\\\"line-number\\\">8</span><br><span class=\\\"line-number\\\">9</span><br><span class=\\\"line-number\\\">10</span><br></div></div>\",\"capture\":\"简介\\n 类的由来\\nJavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。\\n```javascript\\nfunction Point(x, y) {\\n  this.x = x;\\n  this.y = y;\\n}\\nPoint.prototype.toString = function () {\\n  return '(' + this.x + ', ' + this.y + ')';\\n};\\nvar p = new Point(1, 2);\\n```\\n上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。\\nES6 提供\"},{\"url\":\"/《ES6 教程》笔记/22.Class 的继承.html\",\"relativePath\":\"/《ES6 教程》笔记/22.Class 的继承.html\",\"frontmatter\":{\"title\":\"Class 的继承\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/83f8c3a0cd87dd83\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Class 的继承\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"class-的继承\\\" tabindex=\\\"-1\\\">Class 的继承 <a class=\\\"header-anchor\\\" href=\\\"#class-的继承\\\" aria-label=\\\"Permalink to &quot;Class 的继承&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"简介\\\" tabindex=\\\"-1\\\">简介 <a class=\\\"header-anchor\\\" href=\\\"#简介\\\" aria-label=\\\"Permalink to &quot;简介&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>Class 可以通过<code>extends</code>关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p>\\n<div class=\\\"language-javascript vp-adaptive-theme line-numbers-mode\\\"><button title=\\\"Copy Code\\\" class=\\\"copy\\\"></button><span class=\\\"lang\\\">javascript</span><pre class=\\\"shiki shiki-themes github-light github-dark vp-code\\\" tabindex=\\\"0\\\" v-pre=\\\"\\\"><code><span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">class</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> Point</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span>\\n<span class=\\\"line\\\"></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\">class</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> ColorPoint</span><span style=\\\"--shiki-light:#D73A49;--shiki-dark:#F97583\\\"> extends</span><span style=\\\"--shiki-light:#6F42C1;--shiki-dark:#B392F0\\\"> Point</span><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\"> {</span></span>\\n<span class=\\\"line\\\"><span style=\\\"--shiki-light:#24292E;--shiki-dark:#E1E4E8\\\">}</span></span></code></pre>\\n<div class=\\\"line-numbers-wrapper\\\" aria-hidden=\\\"true\\\"><span class=\\\"line-number\\\">1</span><br><span class=\\\"line-number\\\">2</span><br><span class=\\\"line-number\\\">3</span><br><span class=\\\"line-number\\\">4</span><br><span class=\\\"line-number\\\">5</span><br></div></div>\",\"capture\":\"简介\\nClass 可以通过`extends`关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。\\n```javascript\\nclass Point {\\n}\\nclass ColorPoint extends Point {\\n}\\n```\\n上面代码定义了一个`ColorPoint`类，该类通过`extends`关键字，继承了`Point`类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个`Point`类。下面，我们在`ColorPoint`内部加上代码。\\n```javascript\\nclass ColorPoint extends Point \"},{\"url\":\"/《ES6 教程》笔记/23.Module 的语法.html\",\"relativePath\":\"/《ES6 教程》笔记/23.Module 的语法.html\",\"frontmatter\":{\"title\":\"Module 的语法\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/efe2fb04eb8ac5fb\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Module 的语法\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"module-的语法\\\" tabindex=\\\"-1\\\">Module 的语法 <a class=\\\"header-anchor\\\" href=\\\"#module-的语法\\\" aria-label=\\\"Permalink to &quot;Module 的语法&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的<code>require</code>、Python 的<code>import</code>，甚至就连 CSS 都有<code>@import</code>，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p>\\n\",\"capture\":\"概述\\n历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的`require`、Python 的`import`，甚至就连 CSS 都有`@import`，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。\\n在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD \"},{\"url\":\"/《ES6 教程》笔记/24.Module 的加载实现.html\",\"relativePath\":\"/《ES6 教程》笔记/24.Module 的加载实现.html\",\"frontmatter\":{\"title\":\"Module 的加载实现\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/a79ca2e64ceae213\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"Module 的加载实现\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"module-的加载实现\\\" tabindex=\\\"-1\\\">Module 的加载实现 <a class=\\\"header-anchor\\\" href=\\\"#module-的加载实现\\\" aria-label=\\\"Permalink to &quot;Module 的加载实现&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>上一章介绍了模块的语法，本章介绍如何在浏览器和 Node.js 之中加载 ES6 模块，以及实际开发中经常遇到的一些问题（比如循环加载）。</p>\\n\",\"capture\":\"上一章介绍了模块的语法，本章介绍如何在浏览器和 Node.js 之中加载 ES6 模块，以及实际开发中经常遇到的一些问题（比如循环加载）。\\n 浏览器加载\\n 传统方法\\nHTML 网页中，浏览器通过`&lt;script\\n```html\\n&lt;!-- 页面内嵌的脚本 --&gt;\\n&lt;script type=\\\"application/javascript\\\"&gt;\\n  // module code\\n&lt;/script&gt;\\n&lt;!-- 外部脚本 --&gt;\\n&lt;script type=\\\"application/javascript\\\" src=\\\"path/to/myModule\"},{\"url\":\"/《ES6 教程》笔记/25.编程风格.html\",\"relativePath\":\"/《ES6 教程》笔记/25.编程风格.html\",\"frontmatter\":{\"title\":\"编程风格\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/984bf549204bb266\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"编程风格\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"编程风格\\\" tabindex=\\\"-1\\\">编程风格 <a class=\\\"header-anchor\\\" href=\\\"#编程风格\\\" aria-label=\\\"Permalink to &quot;编程风格&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>本章探讨如何将 ES6 的新语法，运用到编码实践之中，与传统的 JavaScript 语法结合在一起，写出合理的、易于阅读和维护的代码。</p>\\n<p>多家公司和组织已经公开了它们的风格规范，下面的内容主要参考了 <a href=\\\"https://github.com/airbnb/javascript\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">Airbnb</a> 公司的 JavaScript 风格规范。</p>\\n\",\"capture\":\"本章探讨如何将 ES6 的新语法，运用到编码实践之中，与传统的 JavaScript 语法结合在一起，写出合理的、易于阅读和维护的代码。\\n多家公司和组织已经公开了它们的风格规范，下面的内容主要参考了 Airbnb 公司的 JavaScript 风格规范。\\n 块级作用域\\n（1）let 取代 var\\nES6 提出了两个新的声明变量的命令：`let`和`const`。其中，`let`完全可以取代`var`，因为两者语义相同，而且`let`没有副作用。\\n```javascript\\n'use strict';\\nif (true) {\\n  let x = 'hello';\\n}\\nfor (let i = 0\"},{\"url\":\"/《ES6 教程》笔记/26.读懂 ECMAScript 规格.html\",\"relativePath\":\"/《ES6 教程》笔记/26.读懂 ECMAScript 规格.html\",\"frontmatter\":{\"title\":\"读懂 ECMAScript 规格\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/32c35f7651d6e58e\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"读懂 ECMAScript 规格\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"读懂-ecmascript-规格\\\" tabindex=\\\"-1\\\">读懂 ECMAScript 规格 <a class=\\\"header-anchor\\\" href=\\\"#读懂-ecmascript-规格\\\" aria-label=\\\"Permalink to &quot;读懂 ECMAScript 规格&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"概述\\\" tabindex=\\\"-1\\\">概述 <a class=\\\"header-anchor\\\" href=\\\"#概述\\\" aria-label=\\\"Permalink to &quot;概述&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>规格文件是计算机语言的官方标准，详细描述语法规则和实现方法。</p>\\n<p>一般来说，没有必要阅读规格，除非你要写编译器。因为规格写得非常抽象和精炼，又缺乏实例，不容易理解，而且对于解决实际的应用问题，帮助不大。但是，如果你遇到疑难的语法问题，实在找不到答案，这时可以去查看规格文件，了解语言标准是怎么说的。规格是解决问题的“最后一招”。</p>\\n\",\"capture\":\"概述\\n规格文件是计算机语言的官方标准，详细描述语法规则和实现方法。\\n一般来说，没有必要阅读规格，除非你要写编译器。因为规格写得非常抽象和精炼，又缺乏实例，不容易理解，而且对于解决实际的应用问题，帮助不大。但是，如果你遇到疑难的语法问题，实在找不到答案，这时可以去查看规格文件，了解语言标准是怎么说的。规格是解决问题的“最后一招”。\\n这对 JavaScript 语言很有必要。因为它的使用场景复杂，语法规则不统一，例外很多，各种运行环境的行为不一致，导致奇怪的语法问题层出不穷，任何语法书都不可能囊括所有情况。查看规格，不失为一种解决语法问题的最可靠、最权威的终极方法。\\n本章介绍如何读懂 ECMASc\"},{\"url\":\"/《ES6 教程》笔记/27.异步遍历器.html\",\"relativePath\":\"/《ES6 教程》笔记/27.异步遍历器.html\",\"frontmatter\":{\"title\":\"异步遍历器\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/16121351be68691b\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"异步遍历器\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"异步遍历器\\\" tabindex=\\\"-1\\\">异步遍历器 <a class=\\\"header-anchor\\\" href=\\\"#异步遍历器\\\" aria-label=\\\"Permalink to &quot;异步遍历器&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<h2 id=\\\"同步遍历器的问题\\\" tabindex=\\\"-1\\\">同步遍历器的问题 <a class=\\\"header-anchor\\\" href=\\\"#同步遍历器的问题\\\" aria-label=\\\"Permalink to &quot;同步遍历器的问题&quot;\\\">&ZeroWidthSpace;</a></h2>\\n<p>《遍历器》一章说过，Iterator 接口是一种数据遍历的协议，只要调用遍历器对象的<code>next</code>方法，就会得到一个对象，表示当前遍历指针所在的那个位置的信息。<code>next</code>方法返回的对象的结构是<code>{value, done}</code>，其中<code>value</code>表示当前的数据的值，<code>done</code>是一个布尔值，表示遍历是否结束。</p>\\n\",\"capture\":\"同步遍历器的问题\\n《遍历器》一章说过，Iterator 接口是一种数据遍历的协议，只要调用遍历器对象的`next`方法，就会得到一个对象，表示当前遍历指针所在的那个位置的信息。`next`方法返回的对象的结构是`{value, done}`，其中`value`表示当前的数据的值，`done`是一个布尔值，表示遍历是否结束。\\n```javascript\\nfunction idMaker() {\\n  let index = 0;\\n  return {\\n    next: function() {\\n      return { value: index++, done: false };\\n    }\"},{\"url\":\"/《ES6 教程》笔记/28.ArrayBuffer.html\",\"relativePath\":\"/《ES6 教程》笔记/28.ArrayBuffer.html\",\"frontmatter\":{\"title\":\"ArrayBuffer\",\"date\":\"2020-02-09 16:00:29\",\"permalink\":\"/pages/a2ba314746bfdbdd\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"ArrayBuffer\",\"date\":\"2020-02-09 16:00:29\",\"excerpt\":\"<h1 id=\\\"arraybuffer\\\" tabindex=\\\"-1\\\">ArrayBuffer <a class=\\\"header-anchor\\\" href=\\\"#arraybuffer\\\" aria-label=\\\"Permalink to &quot;ArrayBuffer&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p><code>ArrayBuffer</code>对象、<code>TypedArray</code>视图和<code>DataView</code>视图是 JavaScript 操作二进制数据的一个接口。这些对象早就存在，属于独立的规格（2011 年 2 月发布），ES6 将它们纳入了 ECMAScript 规格，并且增加了新的方法。它们都是以数组的语法处理二进制数据，所以统称为二进制数组。</p>\\n\",\"capture\":\"`ArrayBuffer`对象、`TypedArray`视图和`DataView`视图是 JavaScript 操作二进制数据的一个接口。这些对象早就存在，属于独立的规格（2011 年 2 月发布），ES6 将它们纳入了 ECMAScript 规格，并且增加了新的方法。它们都是以数组的语法处理二进制数据，所以统称为二进制数组。\\n这个接口的原始设计目的，与 WebGL 项目有关。所谓 WebGL，就是指浏览器与显卡之间的通信接口，为了满足 JavaScript 与显卡之间大量的、实时的数据交换，它们之间的数据通信必须是二进制的，而不能是传统的文本格式。文本格式传递一个 32 位整数，两端的 Ja\"},{\"url\":\"/《ES6 教程》笔记/01.ECMAScript 6 简介.html\",\"relativePath\":\"/《ES6 教程》笔记/01.ECMAScript 6 简介.html\",\"frontmatter\":{\"title\":\"ECMAScript 6 简介\",\"date\":\"2020-01-12 15:45:35\",\"permalink\":\"/pages/f344d070a1031ef7\",\"author\":\"阮一峰\",\"categories\":[\"《ES6 教程》笔记\"],\"tags\":[\"ES6\"]},\"author\":\"阮一峰\",\"title\":\"ECMAScript 6 简介\",\"date\":\"2020-01-12 15:45:35\",\"excerpt\":\"<blockquote>\\n<p>说明：本章内容为博主在原教程基础上添加自己的学习笔记，来源<a href=\\\"http://es6.ruanyifeng.com/\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">http://es6.ruanyifeng.com/</a>，教程版权归原作者所有。</p>\\n</blockquote>\\n<h1 id=\\\"ecmascript-6-简介\\\" tabindex=\\\"-1\\\">ECMAScript 6 简介 <a class=\\\"header-anchor\\\" href=\\\"#ecmascript-6-简介\\\" aria-label=\\\"Permalink to &quot;ECMAScript 6 简介&quot;\\\">&ZeroWidthSpace;</a></h1>\\n<p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p>\\n\",\"capture\":\"ECMAScript 6 简介\\nECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。\\n ECMAScript 和 JavaScript 的关系\\n一个常见的问题是，ECMAScript 和 JavaScript 到底是什么关系？\\n要讲清楚这个问题，需要回顾历史。1996 年 11 月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给标准化组织 ECMA，希望这种语言能够成为国际标\"}],\"小程序\":[{\"url\":\"/01.前端/40.学习笔记/40.小程序笔记.html\",\"relativePath\":\"/01.前端/40.学习笔记/40.小程序笔记.html\",\"frontmatter\":{\"title\":\"小程序笔记\",\"date\":\"2019-12-25 14:27:01\",\"permalink\":\"/note/wx-miniprogram/\",\"tags\":[\"小程序\"],\"categories\":[\"前端\",\"学习笔记\"],\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"}},\"author\":{\"name\":\"刘志伟\",\"link\":\"https://github.com/2019-02-18\"},\"title\":\"小程序笔记\",\"date\":\"2019-12-25 14:27:01\",\"capture\":\"小程序笔记\\n 基础课程部分\\n 微信公众平台\\n&lt;https://mp.weixin.qq.com/\\n注册时可选择类型：订阅号、服务号、小程序、企业微信\\n每个邮箱仅能注册一个小程序。\\n个人类型小程序：无法使用微信支付、无法使用卡包功能\\n 小程序文档API\\n小程序开发文档\\n 微信开放社区\\n微信开发社区\\n 目录说明\\n默认目录\\npages-----------------------页面相关\\n​\\tindex  ----------------- 首页文件夹\\n​\\t\\tindex.js ------------首页js\\n​\\t\\tindex.json---------首页配置\\n​\\t\\tindex.wxml--\"}]}},\"groupCards\":{\"categories\":[{\"name\":\"更多\",\"length\":6},{\"name\":\"AI随笔\",\"length\":1},{\"name\":\"《JavaScript教程》笔记\",\"length\":14},{\"name\":\"《Git》学习笔记\",\"length\":14},{\"name\":\"《uniapp》笔记\",\"length\":1},{\"name\":\"《Vue》笔记\",\"length\":28},{\"name\":\"其他\",\"length\":4},{\"name\":\"《Electron》笔记\",\"length\":2},{\"name\":\"《ES6 教程》笔记\",\"length\":35},{\"name\":\"前端\",\"length\":18},{\"name\":\"JavaScript文章\",\"length\":15},{\"name\":\"页面\",\"length\":18},{\"name\":\"CSS\",\"length\":17},{\"name\":\"技术\",\"length\":10},{\"name\":\"技术文档\",\"length\":6},{\"name\":\"学习笔记\",\"length\":3},{\"name\":\"三级目录\",\"length\":1},{\"name\":\"Vuex\",\"length\":1},{\"name\":\"学习\",\"length\":3},{\"name\":\"笔记\",\"length\":1},{\"name\":\"HTML\",\"length\":1},{\"name\":\"工具\",\"length\":1},{\"name\":\"可复用性&组合\",\"length\":1},{\"name\":\"组件\",\"length\":11},{\"name\":\"过渡&动画\",\"length\":3},{\"name\":\"基础\",\"length\":5},{\"name\":\"规模化\",\"length\":2},{\"name\":\"博客搭建\",\"length\":3},{\"name\":\"Nodejs\",\"length\":1},{\"name\":\"面试\",\"length\":1}],\"tags\":[{\"name\":\"AI\",\"length\":1},{\"name\":\"思考\",\"length\":1},{\"name\":\"编程\",\"length\":1},{\"name\":\"electron\",\"length\":1},{\"name\":\"JavaScript\",\"length\":8},{\"name\":\"设计模式\",\"length\":1},{\"name\":\"Git\",\"length\":13},{\"name\":\"TypeScript\",\"length\":1},{\"name\":\"学习方法\",\"length\":1},{\"name\":\"笔记\",\"length\":1},{\"name\":\"红宝书\",\"length\":1},{\"name\":\"搜索技巧\",\"length\":1},{\"name\":\"css\",\"length\":1},{\"name\":\"Vue\",\"length\":25},{\"name\":\"ES6\",\"length\":34},{\"name\":\"小程序\",\"length\":1}]}}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");